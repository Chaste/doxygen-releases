<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Chaste: Todo List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="todo">Todo List </a></h1><a class="anchor" name="_todo000047"></a> <dl>
<dt>Member <a class="el" href="classAbstractBidomainSolver.html#1e7706fc4a50566ee314066451597818">AbstractBidomainSolver::InitialiseForSolve</a> (Vec initialSolution) </dt>
<dd>: block preconditioners only make sense in Bidomain... Add some warning/error message </dd>
</dl>
<p>
<a class="anchor" name="_todo000047"></a> <dl>
<dt>Member <a class="el" href="classAbstractBidomainSolver.html#1e7706fc4a50566ee314066451597818">AbstractBidomainSolver::InitialiseForSolve</a> (Vec initialSolution) </dt>
<dd>: #1082 only works if you know about the whole mesh. </dd>
</dl>
<p>
<a class="anchor" name="_todo000049"></a> <dl>
<dt>Member <a class="el" href="classAbstractBidomainSolver.html#4152bba2f016574802cd0ec3d7712cde">AbstractBidomainSolver::CheckCompatibilityCondition</a> () </dt>
<dd>#1327 This could be a collective MPI-like operation </dd>
</dl>
<p>
<a class="anchor" name="_todo000050"></a> <dl>
<dt>Member <a class="el" href="classAbstractBidomainSolver.html#7f9bdc5fac4cd98659fb871d75e4ce76">AbstractBidomainSolver::FinaliseForBath</a> (bool computeMatrix, bool computeVector) </dt>
<dd>: #1215 #1328 this seems not to be an issue anymore. Document and remove code. </dd>
</dl>
<p>
<a class="anchor" name="_todo000050"></a> <dl>
<dt>Member <a class="el" href="classAbstractBidomainSolver.html#7f9bdc5fac4cd98659fb871d75e4ce76">AbstractBidomainSolver::FinaliseForBath</a> (bool computeMatrix, bool computeVector) </dt>
<dd>#1328 This code may no longer be needed since all the operations in the following loop may apply only to local elements. MatSetValue and VecSetValue are not collective... </dd>
</dl>
<p>
<a class="anchor" name="_todo000018"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#b996d7a4e8fde84b2bd5767487b8e864">AbstractCardiacProblem::save</a> (Archive &amp;archive, const unsigned int version) const  </dt>
<dd>#1317 code for saving/loading mSolution is PROBLEM_DIM specific, move it into the save/load methods fo Mono and <a class="el" href="classBidomainProblem.html">BidomainProblem</a> </dd>
</dl>
<p>
<a class="anchor" name="_todo000018"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#b996d7a4e8fde84b2bd5767487b8e864">AbstractCardiacProblem::save</a> (Archive &amp;archive, const unsigned int version) const  </dt>
<dd>#1369 </dd>
</dl>
<p>
<a class="anchor" name="_todo000020"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#0738e85a4897d8fd5962911c42594511">AbstractCardiacProblem::load</a> (Archive &amp;archive, const unsigned int version) </dt>
<dd>#1317 code for saving/loading mSolution is PROBLEM_DIM specific, move it into the save/load methods fo Mono and <a class="el" href="classBidomainProblem.html">BidomainProblem</a> </dd>
</dl>
<p>
<a class="anchor" name="_todo000020"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#0738e85a4897d8fd5962911c42594511">AbstractCardiacProblem::load</a> (Archive &amp;archive, const unsigned int version) </dt>
<dd>#1317 is there a reason we can't use PETSc's load/save vector functionality? </dd>
</dl>
<p>
<a class="anchor" name="_todo000015"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#7a72dc8f2ed3834792e92675130f7952">AbstractCardiacProblem::Solve</a> () </dt>
<dd>#1318 the following line will deadlock if not every process throws in the Solve call </dd>
</dl>
<p>
<a class="anchor" name="_todo000016"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#bf2f17740646016bcc7f796d16ac7de1">AbstractCardiacProblem::InitialiseWriter</a> () </dt>
<dd>1242 </dd>
</dl>
<p>
<a class="anchor" name="_todo000017"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#fda9434b87c4d2af11859f006b1bb29e">AbstractCardiacProblem::LoadExtraArchive</a> (Archive &amp;archive, unsigned version) </dt>
<dd>#1159 sanity check that the contents of p_bcc and mpBoundaryConditionsContainer match. </dd>
</dl>
<p>
<a class="anchor" name="_todo000052"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacTissue.html#aa8864a4217eccc8f2f7c50cbf43baf4">AbstractCardiacTissue::CreateIntracellularConductivityTensor</a> () </dt>
<dd>#1316 Create a class defining constant tensors to be used when no fibre orientation is provided. </dd>
</dl>
<p>
<a class="anchor" name="_todo000054"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacTissue.html#b0735358503cce2cb7e7af3761d17e4d">AbstractCardiacTissue::LoadCardiacCells</a> (Archive &amp;archive, const unsigned int version, std::vector&lt; AbstractCardiacCell * &gt; &amp;rCells, AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; *pMesh) </dt>
<dd>#1199 test this </dd>
</dl>
<p>
<a class="anchor" name="_todo000185"></a> <dl>
<dt>Member <a class="el" href="classAbstractCellPopulation.html#7038cf93612af5652a59a2168d58f7b8">AbstractCellPopulation::AbstractCellPopulation</a> (std::vector&lt; CellPtr &gt; &amp;rCells, const std::vector&lt; unsigned &gt; locationIndices=stdvector&lt; unsigned &gt;()) </dt>
<dd>remove explicit use of NUM_CELL_PROLIFERATIVE_TYPES and NUM_CELL_CYCLE_PHASES as these may eventually differ between simulations (see #1285) </dd>
</dl>
<p>
<a class="anchor" name="_todo000001"></a> <dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#25a3b5da1f940794918b6abb47f7fb79">AbstractConvergenceTester::Converge</a> (std::string nameOfTest) </dt>
<dd>This is a scarily long method; could do with some parts extracted? </dd>
</dl>
<p>
<a class="anchor" name="_todo000001"></a> <dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#25a3b5da1f940794918b6abb47f7fb79">AbstractConvergenceTester::Converge</a> (std::string nameOfTest) </dt>
<dd>consider reducing all stimuli to match this one. </dd>
</dl>
<p>
<a class="anchor" name="_todo000001"></a> <dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#25a3b5da1f940794918b6abb47f7fb79">AbstractConvergenceTester::Converge</a> (std::string nameOfTest) </dt>
<dd>Cover this </dd>
</dl>
<p>
<a class="anchor" name="_todo000004"></a> <dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#8ec5fb24c1e3606e72dc68a6c1ebce6f">AbstractConvergenceTester::DisplayRun</a> () </dt>
<dd>The UseAbsoluteStimulus is temporary, while we are sorting out 3D stimulus. It is to be removed later (along with StimulusConvergenceTester) </dd>
</dl>
<p>
<a class="anchor" name="_todo000006"></a> <dl>
<dt>Class <a class="el" href="classAbstractCvodeCell.html">AbstractCvodeCell</a>  </dt>
<dd>#890 Add an option to just initialise once, and assume subsequent Solve calls are continuing from where we left off.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000006"></a> <dl>
<dt>Class <a class="el" href="classAbstractCvodeCell.html">AbstractCvodeCell</a>  </dt>
<dd>#889 Integrate this better into the main hierarchy? </dd>
</dl>
<p>
<a class="anchor" name="_todo000005"></a> <dl>
<dt>Member <a class="el" href="classAbstractCvodeCell.html#bcf98ef5ca6f3b8a86d7ffba0c02f2b4">AbstractCvodeCell::SetStateVariables</a> (N_Vector stateVars) </dt>
<dd>#890 re-init CVODE here? </dd>
</dl>
<p>
<a class="anchor" name="_todo000181"></a> <dl>
<dt>Member <a class="el" href="classAbstractFeObjectAssembler.html#a1474347ee3ff3bb96ca68d06445fc3b">AbstractFeObjectAssembler::ComputeTransformedBasisFunctionDerivatives</a> (const ChastePoint&lt; ELEMENT_DIM &gt; &amp;rPoint, const c_matrix&lt; double, ELEMENT_DIM, SPACE_DIM &gt; &amp;rInverseJacobian, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rReturnValue) </dt>
<dd>#1319 Template <a class="el" href="classLinearBasisFunction.html">LinearBasisFunction</a> over SPACE_DIM and remove this method?<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000179"></a> <dl>
<dt>Member <a class="el" href="classAbstractFeObjectAssembler.html#5df14c5633ef13bbb435156b9fe3be98">AbstractFeObjectAssembler::AssembleOnElement</a> (Element&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement, c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;rAElem, c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;rBElem) </dt>
<dd>#1320 This assumes that the Jacobian is constant on an element. This is true for linear basis functions, but not for any other type of basis function. </dd>
</dl>
<p>
<a class="anchor" name="_todo000180"></a> <dl>
<dt>Member <a class="el" href="classAbstractFeObjectAssembler.html#6f46f0d00fb6332619892402136cb277">AbstractFeObjectAssembler::AssembleOnSurfaceElement</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;rBSurfElem) </dt>
<dd>#1321 Improve efficiency of Neumann BC implementation. </dd>
</dl>
<p>
<a class="anchor" name="_todo000156"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#3ba3f6957e2343e39d6304d4cdc2405e">AbstractIsotropicIncompressibleMaterialLaw::Get_dW_dI1</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000157"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#e377687f775dd070cdf29bd60b26efcf">AbstractIsotropicIncompressibleMaterialLaw::Get_dW_dI2</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000158"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#b560e0993f5892ec9524dc035702ba6f">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI1</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000159"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#cbcca2fcf4c5d73484dfeb4c65cb10bb">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI2</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000160"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#cb19d8801f5dcd6085826b2e358efe12">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000091"></a> <dl>
<dt>Member <a class="el" href="classAbstractMesh.html#67018371f9ddeaabec54a2f24ba31eb8">AbstractMesh::CalculateBoundingBox</a> () const  </dt>
<dd>#1322 use a const version of NodeIterator here </dd>
</dl>
<p>
<a class="anchor" name="_todo000149"></a> <dl>
<dt>Member <a class="el" href="classAbstractOdeSystem.html#4dad7892bd5e47262b21b87d77796c96">AbstractOdeSystem::rGetConstStateVariables</a> () const  </dt>
<dd>move to <a class="el" href="classAbstractParameterisedSystem.html">AbstractParameterisedSystem</a>? (1540)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000092"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMesh.html#e95c4b2ff7ecebbe10a26818abd8d4f2">AbstractTetrahedralMesh::save</a> (Archive &amp;archive, const unsigned int version) const  </dt>
<dd>#1200 This is bad for very large meshes. Consider making a symlink and just writing the permutation. Perhaps even copy the permutation file from an earlier checkpoint? </dd>
</dl>
<p>
<a class="anchor" name="_todo000093"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMesh.html#4547ff751d240e232bf7a905e0b9f1eb">AbstractTetrahedralMesh::load</a> (Archive &amp;archive, const unsigned int version) </dt>
<dd>#1199 make this work for everything else... </dd>
</dl>
<p>
<a class="anchor" name="_todo000094"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMesh.html#58117ae299e18890024229126015a377">AbstractTetrahedralMesh::ConstructFromMesh</a> (AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rOtherMesh) </dt>
<dd>Can we make this const? </dd>
</dl>
<p>
<a class="anchor" name="_todo000147"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMeshWriter.html#d732d0dae28b0efd5b528f060d77b4d9">AbstractTetrahedralMeshWriter::WriteFilesUsingMesh</a> (AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMesh, bool keepOriginalElementIndexing=true) </dt>
<dd>#1322 Mesh should really be const! </dd>
</dl>
<p>
<a class="anchor" name="_todo000145"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMeshWriter.html#d732d0dae28b0efd5b528f060d77b4d9">AbstractTetrahedralMeshWriter::WriteFilesUsingMesh</a> (AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMesh, bool keepOriginalElementIndexing=true) </dt>
<dd>#1322 Mesh should be const </dd>
</dl>
<p>
<a class="anchor" name="_todo000145"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMeshWriter.html#d732d0dae28b0efd5b528f060d77b4d9">AbstractTetrahedralMeshWriter::WriteFilesUsingMesh</a> (AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMesh, bool keepOriginalElementIndexing=true) </dt>
<dd>#1322 This should be const too </dd>
</dl>
<p>
<a class="anchor" name="_todo000184"></a> <dl>
<dt>Member <a class="el" href="classAlarcon2004OxygenBasedCellCycleOdeSystem.html#165ef79638ca4da2bc4d8451b4b5827d">Alarcon2004OxygenBasedCellCycleOdeSystem::Alarcon2004OxygenBasedCellCycleOdeSystem</a> (double oxygenConcentration, bool isLabelled, std::vector&lt; double &gt; stateVariables=stdvector&lt; double &gt;()) </dt>
<dd>should this be 0.004?? </dd>
</dl>
<p>
<a class="anchor" name="_todo000022"></a> <dl>
<dt>Member <a class="el" href="classBidomainProblem.html#3cba4f174d15a2e197217e944e066f87">BidomainProblem::AtBeginningOfTimestep</a> (double time) </dt>
<dd>#1159 #1324 <a class="el" href="AbstractCardiacProblem_8hpp-source.html">heart/src/problem/AbstractCardiacProblem.hpp</a>:657 expects both pointing at the same place when unarchiving </dd>
</dl>
<p>
<a class="anchor" name="_todo000023"></a> <dl>
<dt>Member <a class="el" href="classBidomainProblem.html#66e781e2d8200ccaab18a29a6a6577a0">BidomainProblem::LoadExtraArchiveForBidomain</a> (Archive &amp;archive, unsigned version) </dt>
<dd>#1159 sanity check that the contents of p_bcc and mpElectrodes-&gt;GetBoundaryConditionsContainer() match. </dd>
</dl>
<p>
<a class="anchor" name="_todo000152"></a> <dl>
<dt>Class <a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;</a>  </dt>
<dd>#1321 Various operations are currently very inefficient - there is certainly scope for optimisation here! </dd>
</dl>
<p>
<a class="anchor" name="_todo000153"></a> <dl>
<dt>Member <a class="el" href="classBoundaryConditionsContainer.html#7a8ad2d7013bdea0bdef532efb3fa00f">BoundaryConditionsContainer::HasNeumannBoundaryCondition</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; *pSurfaceElement, unsigned indexOfUnknown=0) </dt>
<dd>#1321 This is a horrendously inefficient fix. Perhaps have flag in element object?<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Member <a class="el" href="classCardiacElectroMechanicsProblem.html#6f060578a8380d2aec80d3f9d3c4feb9">CardiacElectroMechanicsProblem::WriteWatchedLocationData</a> (double time, Vec voltage) </dt>
<dd>Improve efficiency of this method? </dd>
</dl>
<p>
<a class="anchor" name="_todo000025"></a> <dl>
<dt>Member <a class="el" href="classCardiacElectroMechanicsProblem.html#24920cefa1bf029e178f837470dedb07">CardiacElectroMechanicsProblem::CardiacElectroMechanicsProblem</a> (ContractionModel contractionModel, <a class="el" href="classTetrahedralMesh.html">TetrahedralMesh&lt; DIM, DIM &gt;</a> *pElectricsMesh, QuadraticMesh&lt; DIM &gt; *pMechanicsMesh, std::vector&lt; unsigned &gt; fixedMechanicsNodes, <a class="el" href="classAbstractCardiacCellFactory.html">AbstractCardiacCellFactory&lt; DIM &gt;</a> *pCellFactory, double endTime, double electricsPdeTimeStep, unsigned numElecTimeStepsPerMechTimestep, double contractionModelOdeTimeStep, std::string outputDirectory) </dt>
<dd>Cover these lines </dd>
</dl>
<p>
<a class="anchor" name="_todo000026"></a> <dl>
<dt>Member <a class="el" href="classCardiacSimulationArchiver.html#f02c88ef857037f9bf109402604fac26">CardiacSimulationArchiver::Save</a> (PROBLEM_CLASS &amp;simulationToArchive, const std::string &amp;rDirectory, bool clearDirectory=true) </dt>
<dd>#1026 get a real version number! </dd>
</dl>
<p>
<a class="anchor" name="_todo000186"></a> <dl>
<dt>Member <a class="el" href="classCell.html#59f24d2d16222cfcbc26198cc9918f54">Cell::GetMutationState</a> () const  </dt>
<dd>allow a cell to have less/more than one mutation state? (#1285) </dd>
</dl>
<p>
<a class="anchor" name="_todo000187"></a> <dl>
<dt>Member <a class="el" href="classCell.html#64e5bb231ebad2c66c884b11289326e4">Cell::AddCellProperty</a> (const boost::shared_ptr&lt; AbstractCellProperty &gt; &amp;rProperty) </dt>
<dd>Be stricter and throw an exception if rProperty is already in mCellPropertyCollection? (#1285) </dd>
</dl>
<p>
<a class="anchor" name="_todo000188"></a> <dl>
<dt>Member <a class="el" href="classCell.html#cc0b8ed433348d0a715cab2c1839b14d">Cell::RemoveCellProperty</a> () </dt>
<dd>Be stricter and throw an exception if cell does not have this property? (#1285) </dd>
</dl>
<p>
<a class="anchor" name="_todo000193"></a> <dl>
<dt>Member <a class="el" href="classCellBasedSimulation.html#68fc5d3a2b0647f863eeb5d9d963c6b6">CellBasedSimulation::CalculateCellDivisionVector</a> (CellPtr pParentCell) </dt>
<dd>Could remove this dynamic_cast by moving the code block below into <a class="el" href="classAbstractCentreBasedCellPopulation.html#2532655c1f42f0a3f688ae0260d009dc">AbstractCentreBasedCellPopulation::AddCell()</a>, allowing it to be overruled by this method when overridden in subclasses. See also comment on #1093. </dd>
</dl>
<p>
<a class="anchor" name="_todo000194"></a> <dl>
<dt>Member <a class="el" href="classCellBasedSimulation.html#8aa6c34938a23f63c215d00912832d62">CellBasedSimulation::OutputSimulationSetup</a> () </dt>
<dd>Loop over cell cycle models (#1453) </dd>
</dl>
<p>
<a class="anchor" name="_todo000195"></a> <dl>
<dt>Member <a class="el" href="classCellBasedSimulationWithPdes.html#1cdf5557c2259b650a16382ec68954d5">CellBasedSimulationWithPdes::PostSolve</a> () </dt>
<dd>Worry about round-off errors </dd>
</dl>
<p>
<a class="anchor" name="_todo000196"></a> <dl>
<dt>Member <a class="el" href="classCellBasedSimulationWithPdes.html#7b2de5c8b4582ae3e3eb42de7b1aeb27">CellBasedSimulationWithPdes::CreateCoarsePdeMesh</a> (double coarseGrainScaleFactor) </dt>
<dd>currently only works in 2D (see #737)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000197"></a> <dl>
<dt>Member <a class="el" href="classCellBasedSimulationWithPdes.html#018f336557e8c1db954a3219e5d46620">CellBasedSimulationWithPdes::SetPdeAndBcCollection</a> (std::vector&lt; PdeAndBoundaryConditions&lt; DIM &gt; * &gt; pdeAndBcCollection) </dt>
<dd>Check if archiving has been implemented yet for PDE classes (#1460)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000189"></a> <dl>
<dt>Class <a class="el" href="classCellCycleModelOdeSolver_3_01CELL__CYCLE__MODEL_00_01BackwardEulerIvpOdeSolver_01_4.html">CellCycleModelOdeSolver&lt; CELL_CYCLE_MODEL, BackwardEulerIvpOdeSolver &gt;</a>  </dt>
<dd>there must be an easier way to deal with this peculiarity (#1427) </dd>
</dl>
<p>
<a class="anchor" name="_todo000148"></a> <dl>
<dt>Member <a class="el" href="classCmguiMeshWriter.html#735cff9aaf10b299909a607afdf263ef">CmguiMeshWriter::WriteFiles</a> () </dt>
<dd>: EXCEPTION maybe... </dd>
</dl>
<p>
<a class="anchor" name="_todo000008"></a> <dl>
<dt>Member <a class="el" href="classCML__noble__varghese__kohl__noble__1998__basic__with__sac.html#eae8f3b9d4804cd948aacd1e5c78f343">CML_noble_varghese_kohl_noble_1998_basic_with_sac::GetIIonic</a> () </dt>
<dd>we need to + Ask JonC to amend PyCml if necessary<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000059"></a> <dl>
<dt>Member <a class="el" href="classColumnDataReader.html#7bae0b42045724d4dfcda58315588bec">ColumnDataReader::mVariablesToColumns</a>  </dt>
<dd>Change int to unsigned? (#991) </dd>
</dl>
<p>
<a class="anchor" name="_todo000198"></a> <dl>
<dt>Class <a class="el" href="classCryptSimulationArchiver.html">CryptSimulationArchiver&lt; DIM, SIM &gt;</a>  </dt>
<dd>reduce code duplication with <a class="el" href="classCellBasedSimulationArchiver.html">CellBasedSimulationArchiver</a> (#1568) </dd>
</dl>
<p>
<a class="anchor" name="_todo000151"></a> <dl>
<dt>Class <a class="el" href="classCvodeAdaptor.html">CvodeAdaptor</a>  </dt>
<dd>Add an option to just initialise once, and assume subsequent Solve calls are continuing from where we left off. </dd>
</dl>
<p>
<a class="anchor" name="_todo000111"></a> <dl>
<dt>Member <a class="el" href="classDistanceMapCalculator.html#967f808107ae372f57c471c631d53700">DistanceMapCalculator::SingleDistance</a> (unsigned sourceNodeIndex, unsigned destinationNodeIndex) </dt>
<dd>#1414 premature termination when we find the correct one (parallel) </dd>
</dl>
<p>
<a class="anchor" name="_todo000096"></a> <dl>
<dt>Member <a class="el" href="classDistributedTetrahedralMesh.html#32a12e026b6fd1c040e865fdaaf5f545">DistributedTetrahedralMesh::ConstructFromMeshReader</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader) </dt>
<dd>#1289 assert the node is not considered both owned and halo-owned. </dd>
</dl>
<p>
<a class="anchor" name="_todo000095"></a> <dl>
<dt>Member <a class="el" href="classDistributedTetrahedralMesh.html#605ae53c176351d862a3ce2bdd6acb0c">DistributedTetrahedralMesh::ComputeMeshPartitioning</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader, std::set&lt; unsigned &gt; &amp;rNodesOwned, std::set&lt; unsigned &gt; &amp;rHaloNodesOwned, std::set&lt; unsigned &gt; &amp;rElementsOwned, std::vector&lt; unsigned &gt; &amp;rProcessorsOffset) </dt>
<dd>#1293 add a timing event for the partitioning </dd>
</dl>
<p>
<a class="anchor" name="_todo000097"></a> <dl>
<dt>Member <a class="el" href="classDistributedTetrahedralMesh.html#9a1aa3570cce8cb554422c49e95dcb6c">DistributedTetrahedralMesh::PetscMatrixPartitioning</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader, std::set&lt; unsigned &gt; &amp;rNodesOwned, std::vector&lt; unsigned &gt; &amp;rProcessorsOffset) </dt>
<dd>change the number 54 below (row nonzero allocation) to be nonmagic </dd>
</dl>
<p>
<a class="anchor" name="_todo000097"></a> <dl>
<dt>Member <a class="el" href="classDistributedTetrahedralMesh.html#9a1aa3570cce8cb554422c49e95dcb6c">DistributedTetrahedralMesh::PetscMatrixPartitioning</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader, std::set&lt; unsigned &gt; &amp;rNodesOwned, std::vector&lt; unsigned &gt; &amp;rProcessorsOffset) </dt>
<dd>: This assembly is likely to generate many communications. Try to interleave other operations by executing them between Begin() and End(). </dd>
</dl>
<p>
<a class="anchor" name="_todo000100"></a> <dl>
<dt>Member <a class="el" href="classElement.html#7659b64d36f88f6adf8545562afbf653">Element::CalculateXi</a> (const <a class="el" href="classChastePoint.html">ChastePoint&lt; SPACE_DIM &gt;</a> &amp;rTestPoint) </dt>
<dd>#1326 This method shouldn't need a new Jacobian inverse for every Xi </dd>
</dl>
<p>
<a class="anchor" name="_todo000056"></a> <dl>
<dt>Class <a class="el" href="classException.html">Exception</a>  </dt>
<dd>Might we want this class to inherit from STL exceptions? </dd>
</dl>
<p>
<a class="anchor" name="_todo000161"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#7fd47d973750491f5d5356143870062a">ExponentialMaterialLaw::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000162"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#4af9764dba9d79966ffc9e0c0c59a416">ExponentialMaterialLaw::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000163"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#291b4a2441a90b0605d41985269d7304">ExponentialMaterialLaw::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000164"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#c008235dc7dec5992da5b0141816e4b0">ExponentialMaterialLaw::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000165"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#b881ef4671b0a67d754c2b798d8d3ce6">ExponentialMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000176"></a> <dl>
<dt>Member <a class="el" href="classFineCoarseMeshPair.html#c368190dce5407deaa2d71fd7a4fe22a">FineCoarseMeshPair::ComputeFineElementAndWeightForGivenPoint</a> (ChastePoint&lt; DIM &gt; &amp;rPoint, bool safeMode, unsigned boxForThisPoint, unsigned index) </dt>
<dd>: could possibly merge with ComputeCoarseElementForGivenPoint(). Difference between the methods are: this uses fine mesh and fine mesh box, computes weights as well (and sets the element and weight in the vec), rather than returning the element, and this method saves information in mStatisticsCounters </dd>
</dl>
<p>
<a class="anchor" name="_todo000177"></a> <dl>
<dt>Member <a class="el" href="classFineCoarseMeshPair.html#8988248b1f9dbd537906aa74d5a03ec0">FineCoarseMeshPair::ComputeCoarseElementForGivenPoint</a> (ChastePoint&lt; DIM &gt; &amp;rPoint, bool safeMode, unsigned boxForThisPoint) </dt>
<dd>: could possibly merge with ComputeFineElementAndWeightForGivenPoint(). Differences between the methods are: the other method uses fine mesh and fine mesh box, computes weights as well (and sets the element and weight in the vec), rather than returning the element, and that method saves information in mStatisticsCounters </dd>
</dl>
<p>
<a class="anchor" name="_todo000027"></a> <dl>
<dt>Member <a class="el" href="classGeneralPlaneStimulusCellFactory.html#468ee9de3791785b366e7dbe496e7b05">GeneralPlaneStimulusCellFactory::GeneralPlaneStimulusCellFactory</a> (unsigned numEleAcross, double meshWidth, bool useMeshWidthAsMag=false, double stimulusMagnitude=-1e7, double stimulusDuration=0.5) </dt>
<dd>The useMeshWidth is temporary, while we are sorting out 3D stimulus. It is to be removed later (along with StimulusConvergenceTester) scale stimulus depending on space_step of elements<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000027"></a> <dl>
<dt>Member <a class="el" href="classGeneralPlaneStimulusCellFactory.html#468ee9de3791785b366e7dbe496e7b05">GeneralPlaneStimulusCellFactory::GeneralPlaneStimulusCellFactory</a> (unsigned numEleAcross, double meshWidth, bool useMeshWidthAsMag=false, double stimulusMagnitude=-1e7, double stimulusDuration=0.5) </dt>
<dd>It looks like the value of the stimulus is specific to 3D<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000062"></a> <dl>
<dt>Class <a class="el" href="classHdf5DataReader.html">Hdf5DataReader</a>  </dt>
<dd>: magic number </dd>
</dl>
<p>
<a class="anchor" name="_todo000063"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataReader.html#afd7eea581b860ca7212b0b4c30c8969">Hdf5DataReader::MAX_DATASET_RANK</a>  </dt>
<dd>: define it once </dd>
</dl>
<p>
<a class="anchor" name="_todo000060"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataReader.html#859ef71cd53870bd08d77abc83e575b5">Hdf5DataReader::GetVariableOverNodes</a> (Vec data, const std::string &amp;rVariableName, unsigned timestep=0) </dt>
<dd>Use <a class="el" href="classDistributedVector.html">DistributedVector</a>? </dd>
</dl>
<p>
<a class="anchor" name="_todo000061"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataReader.html#b53e22d9e173efd32ded2281eea4c971">Hdf5DataReader::Close</a> () </dt>
<dd>: move code to the destructor??? </dd>
</dl>
<p>
<a class="anchor" name="_todo000066"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataWriter.html#3c70b9b18ab0dec566bb5709391bc5ae">Hdf5DataWriter::DATASET_DIMS</a>  </dt>
<dd>: define it once </dd>
</dl>
<p>
<a class="anchor" name="_todo000065"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataWriter.html#e8a160a637a689e142d7a16f8b0d856c">Hdf5DataWriter::PutStripedVector</a> (std::vector&lt; int &gt; variableIDs, Vec petscVector) </dt>
<dd>Use distributed vector functionality here? </dd>
</dl>
<p>
<a class="anchor" name="_todo000064"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataWriter.html#c243765e7b041a9bf3be21c8ec1849cb">Hdf5DataWriter::Hdf5DataWriter</a> (<a class="el" href="classDistributedVectorFactory.html">DistributedVectorFactory</a> &amp;rVectorFactory, const std::string &amp;rDirectory, const std::string &amp;rBaseName, bool cleanDirectory=true, bool extendData=false) </dt>
<dd>1300 We can't set mDataFixedDimensionSize, because the information isn't in the input file. This means that checking the size of input vectors in PutVector and PutStripedVector is impossible. </dd>
</dl>
<p>
<a class="anchor" name="_todo000010"></a> <dl>
<dt>Member <a class="el" href="classHdf5ToCmguiConverter.html#eded7c9d6e8eb249374e97ae7da3bafe">Hdf5ToCmguiConverter::Hdf5ToCmguiConverter</a> (std::string inputDirectory, std::string fileBaseName, AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; *pMesh, bool hasBath=false) </dt>
<dd>What if the mesh has been scaled, translated or rotated? </dd>
</dl>
<p>
<a class="anchor" name="_todo000011"></a> <dl>
<dt>Member <a class="el" href="classHdf5ToMeshalyzerConverter.html#46e395509899004802fedab703b9a25f">Hdf5ToMeshalyzerConverter::Hdf5ToMeshalyzerConverter</a> (std::string inputDirectory, std::string fileBaseName, AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; *pMesh) </dt>
<dd>What if the mesh has been scaled, translated or rotated? </dd>
</dl>
<p>
<a class="anchor" name="_todo000012"></a> <dl>
<dt>Member <a class="el" href="classHdf5ToVtkConverter.html#07acec66c93ddef74015d74fb36e2f08">Hdf5ToVtkConverter::Hdf5ToVtkConverter</a> (std::string inputDirectory, std::string fileBaseName, AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; *pMesh) </dt>
<dd>Can we get this as a std::vector? </dd>
</dl>
<p>
<a class="anchor" name="_todo000012"></a> <dl>
<dt>Member <a class="el" href="classHdf5ToVtkConverter.html#07acec66c93ddef74015d74fb36e2f08">Hdf5ToVtkConverter::Hdf5ToVtkConverter</a> (std::string inputDirectory, std::string fileBaseName, AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; *pMesh) </dt>
<dd>What if the mesh has been scaled, translated or rotated? </dd>
</dl>
<p>
<a class="anchor" name="_todo000029"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#52a6c8732dadbb923dd233dada799e81">HeartConfig::GetIonicModelRegions</a> (std::vector&lt; ChasteCuboid&lt; DIM &gt; &gt; &amp;rDefinedRegions, std::vector&lt; cp::ionic_model_selection_type &gt; &amp;rIonicModels) const  </dt>
<dd>When this is implemented, then we require an example in ChasteParametersFullFormat.xml </dd>
</dl>
<p>
<a class="anchor" name="_todo000034"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#165a75e6d71355cfcea146b578a02969">HeartConfig::SetIonicModelRegions</a> (std::vector&lt; ChasteCuboid&lt; 3 &gt; &gt; &amp;rDefinedRegions, std::vector&lt; cp::ionic_model_selection_type &gt; &amp;rIonicModels) const  </dt>
<dd>will this break if the user parameters don't include an IonicModels element? </dd>
</dl>
<p>
<a class="anchor" name="_todo000037"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#ca214e0a3a7aefaa8694e602a6346dc7">HeartConfig::GetSlabDimensions</a> (c_vector&lt; double, 3 &gt; &amp;slabDimensions) const  </dt>
<dd>IsMeshProvided and GetLoadMesh are subtly different but very similar. Can one of them go? </dd>
</dl>
<p>
<a class="anchor" name="_todo000038"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#3c3b1bebf0e10ae4240c3659be153a88">HeartConfig::GetStimuli</a> (std::vector&lt; boost::shared_ptr&lt; AbstractStimulusFunction &gt; &gt; &amp;rStimuliApplied, std::vector&lt; ChasteCuboid&lt; DIM &gt; &gt; &amp;rStimulatedAreas) const  </dt>
<dd>- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </dd>
</dl>
<p>
<a class="anchor" name="_todo000038"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#3c3b1bebf0e10ae4240c3659be153a88">HeartConfig::GetStimuli</a> (std::vector&lt; boost::shared_ptr&lt; AbstractStimulusFunction &gt; &gt; &amp;rStimuliApplied, std::vector&lt; ChasteCuboid&lt; DIM &gt; &gt; &amp;rStimulatedAreas) const  </dt>
<dd>There is no set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000040"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#05fc7893b156f74ef7b8bba5b7125df0">HeartConfig::GetCellHeterogeneities</a> (std::vector&lt; AbstractChasteRegion&lt; DIM &gt; * &gt; &amp;rCellHeterogeneityRegions, std::vector&lt; double &gt; &amp;rScaleFactorGks, std::vector&lt; double &gt; &amp;rScaleFactorIto, std::vector&lt; double &gt; &amp;rScaleFactorGkr, std::vector&lt; std::map&lt; std::string, double &gt; &gt; *pParameterSettings) </dt>
<dd>- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </dd>
</dl>
<p>
<a class="anchor" name="_todo000040"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#05fc7893b156f74ef7b8bba5b7125df0">HeartConfig::GetCellHeterogeneities</a> (std::vector&lt; AbstractChasteRegion&lt; DIM &gt; * &gt; &amp;rCellHeterogeneityRegions, std::vector&lt; double &gt; &amp;rScaleFactorGks, std::vector&lt; double &gt; &amp;rScaleFactorIto, std::vector&lt; double &gt; &amp;rScaleFactorGkr, std::vector&lt; std::map&lt; std::string, double &gt; &gt; *pParameterSettings) </dt>
<dd>There is no set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000042"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#629c34c3877e3f7ae8745af21322f4fb">HeartConfig::GetConductivityHeterogeneities</a> (std::vector&lt; AbstractChasteRegion&lt; DIM &gt; * &gt; &amp;conductivitiesHeterogeneityAreas, std::vector&lt; c_vector&lt; double, 3 &gt; &gt; &amp;intraConductivities, std::vector&lt; c_vector&lt; double, 3 &gt; &gt; &amp;extraConductivities) const  </dt>
<dd>- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </dd>
</dl>
<p>
<a class="anchor" name="_todo000030"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#629c34c3877e3f7ae8745af21322f4fb">HeartConfig::GetConductivityHeterogeneities</a> (std::vector&lt; AbstractChasteRegion&lt; DIM &gt; * &gt; &amp;conductivitiesHeterogeneityAreas, std::vector&lt; c_vector&lt; double, 3 &gt; &gt; &amp;intraConductivities, std::vector&lt; c_vector&lt; double, 3 &gt; &gt; &amp;extraConductivities) const  </dt>
<dd>When this is implemented, then we require an example in ChasteParametersFullFormat.xml </dd>
</dl>
<p>
<a class="anchor" name="_todo000031"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#34e25b3a25618f0f8721c678e6b12f95">HeartConfig::GetCheckpointSimulation</a> () const  </dt>
<dd>#1160 What code covers this? Should be removed ideally. </dd>
</dl>
<p>
<a class="anchor" name="_todo000032"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#80bb45c8945a0a3b98b5a1151d79143a">HeartConfig::GetCheckpointTimestep</a> () const  </dt>
<dd>#1160 What code covers this? Should be removed ideally. </dd>
</dl>
<p>
<a class="anchor" name="_todo000033"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#d6f5c8169999d795e99f66befb962f0c">HeartConfig::GetMaxCheckpointsOnDisk</a> () const  </dt>
<dd>#1160 What code covers this? Should be removed ideally. </dd>
</dl>
<p>
<a class="anchor" name="_todo000043"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#dc7f04b8d3bdf6a734c45fd57ffbd16d">HeartConfig::SetMeshFileName</a> (std::string meshPrefix, cp::media_type fibreDefinition=cpmedia_type::NoFibreOrientation) </dt>
<dd>There is no Get method </dd>
</dl>
<p>
<a class="anchor" name="_todo000035"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#b4327ce8948dfdc306daaa5b733d8b7a">HeartConfig::SetOutputVariables</a> (const std::vector&lt; std::string &gt; &amp;rOutputVariables) </dt>
<dd>#1596 is this no longer needed? </dd>
</dl>
<p>
<a class="anchor" name="_todo000044"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#994cb2f7b3edc1c45ba43fc967a98a8a">HeartConfig::SetBathConductivity</a> (double bathConductivity) </dt>
<dd>Is this used anywhere? </dd>
</dl>
<p>
<a class="anchor" name="_todo000036"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#eaa1ff9d97c84353beaced74801b0677">HeartConfig::SetAdaptivityParameters</a> (double targetError, double sigma, double maxEdgeLength, double minEdgeLength, double gradation, unsigned maxNodes, unsigned numSweeps) </dt>
<dd>I think you can just do the 'if' clause regardless. </dd>
</dl>
<p>
<a class="anchor" name="_todo000045"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#44efaadc8d2d6d415bac30db41c10604">HeartConfig::SetUpstrokeTimeMaps</a> (std::vector&lt; double &gt; &amp;rUpstrokeTimeMaps) </dt>
<dd>improve the description of threshold) with respect to which the upstroke time maps are calculated. </dd>
</dl>
<p>
<a class="anchor" name="_todo000046"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#16bdac7c8f00948b957b99d4c606bf80">HeartConfig::SetMaxUpstrokeVelocityMaps</a> (std::vector&lt; double &gt; &amp;rMaxUpstrokeVelocityMaps) </dt>
<dd>improve the description of threshold) with respect to which the upstroke velocity maps are calculated. </dd>
</dl>
<p>
<a class="anchor" name="_todo000183"></a> <dl>
<dt>Member <a class="el" href="classIdentifiable.html#3babf1ebefe42ecca9dbc4b446035242">Identifiable::TidyTemplatedExportIdentifier</a> (std::string identifier) const  </dt>
<dd>#1453 - implement the following if needed if (i != identifier.npos) { identifier.replace(i, s_comma.length(), s_dash); } </dd>
</dl>
<p>
<a class="anchor" name="_todo000078"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#5e6afa86b789aba62eba01d8eadeb198">LinearSystem::mOwnershipRangeLo</a>  </dt>
<dd>Verify claim that ownership range for Vec and Mat is same. This should only matter for efficiency if the claim is false. </dd>
</dl>
<p>
<a class="anchor" name="_todo000079"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#cdf8590613ad204cc72dbe6a48f286fd">LinearSystem::mpBlockDiagonalPC</a>  </dt>
<dd>: #1082 Create an abstract class for the preconditioners and use a single pointer </dd>
</dl>
<p>
<a class="anchor" name="_todo000072"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#10c3dac3140195854ab2cd72f7b3a8be">LinearSystem::SetMatrixIsSymmetric</a> (bool isSymmetric=true) </dt>
<dd>: shall we allow modifying the symmetry flag anytime? </dd>
</dl>
<p>
<a class="anchor" name="_todo000080"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#ef72ca135343b273fb352fc7dcc590b0">LinearSystem::SetPcType</a> (const char *pcType, boost::shared_ptr&lt; std::vector&lt; PetscInt &gt; &gt; pBathNodes=boostshared_ptr&lt; std::vector&lt; PetscInt &gt; &gt;()) </dt>
<dd>: #1082 is this the way of defining a null pointer as the default value of pBathNodes? </dd>
</dl>
<p>
<a class="anchor" name="_todo000073"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#ef72ca135343b273fb352fc7dcc590b0">LinearSystem::SetPcType</a> (const char *pcType, boost::shared_ptr&lt; std::vector&lt; PetscInt &gt; &gt; pBathNodes=boostshared_ptr&lt; std::vector&lt; PetscInt &gt; &gt;()) </dt>
<dd>: #1082 use a single pointer to abstract class </dd>
</dl>
<p>
<a class="anchor" name="_todo000076"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#7cf2cdd65608f5cd83990c96ec8815ea">LinearSystem::Solve</a> (Vec lhsGuess=NULL) </dt>
<dd>never tested in linalg component </dd>
</dl>
<p>
<a class="anchor" name="_todo000076"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#7cf2cdd65608f5cd83990c96ec8815ea">LinearSystem::Solve</a> (Vec lhsGuess=NULL) </dt>
<dd>Should it be compulsory for the caller to supply this and manage the memory? </dd>
</dl>
<p>
<a class="anchor" name="_todo000068"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#f1bfecddfb062c43463efe466fd64aa8">LinearSystem::LinearSystem</a> (PetscInt lhsVectorSize, unsigned rowPreallocation=UINT_MAX) </dt>
<dd>: if we create a linear system object outside a cardiac solver, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </dd>
</dl>
<p>
<a class="anchor" name="_todo000069"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#2dc140320a785f744be5ffdee884158b">LinearSystem::LinearSystem</a> (Vec templateVector, unsigned rowPreallocation) </dt>
<dd>: if we create a linear system object outside a cardiac solver, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </dd>
</dl>
<p>
<a class="anchor" name="_todo000070"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#79b5a1abd9189331236113d48ffde5a9">LinearSystem::LinearSystem</a> (Vec residualVector, Mat jacobianMatrix) </dt>
<dd>: if we create a linear system object outside a cardiac solver, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </dd>
</dl>
<p>
<a class="anchor" name="_todo000071"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#e4aa80d347b07a6377607349eb334819">LinearSystem::~LinearSystem</a> () </dt>
<dd>Never tested in linalg component </dd>
</dl>
<p>
<a class="anchor" name="_todo000190"></a> <dl>
<dt>Member <a class="el" href="classMeshBasedCellPopulation.html#ca7c10a12e4e171865191daaadfc2952">MeshBasedCellPopulation::mpVoronoiTessellation</a>  </dt>
<dd>Make this static/const? (#1075) </dd>
</dl>
<p>
<a class="anchor" name="_todo000166"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#6d55482ffc8a243cd9fd2399d9713035">MooneyRivlinMaterialLaw::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000167"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#84b7f95aed9c199fabcdeefa282f68e5">MooneyRivlinMaterialLaw::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000168"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#16002ef8753f56e75545c07f2a079209">MooneyRivlinMaterialLaw::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000169"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#a8da1807bcbb6d337d55d0e670cdb4e1">MooneyRivlinMaterialLaw::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000170"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#a6ef7d8e0134db35cf1f590358a17890">MooneyRivlinMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000101"></a> <dl>
<dt>Member <a class="el" href="classMutableMesh.html#3a48de933e960d1aa91f6f521347f35e">MutableMesh::CheckIsVoronoi</a> (Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement, double maxPenetration) </dt>
<dd>Should use a set union operation here </dd>
</dl>
<p>
<a class="anchor" name="_todo000103"></a> <dl>
<dt>Member <a class="el" href="classMutableMesh.html#c241ad1e4d5c57f0201a22678d082d51">MutableMesh::RescaleMeshFromBoundaryNode</a> (ChastePoint&lt; 1 &gt; updatedPoint, unsigned boundaryNodeIndex) </dt>
<dd>should unsigned GetNumBoundaryNodes() be overloaded too?? </dd>
</dl>
<p>
<a class="anchor" name="_todo000102"></a> <dl>
<dt>Member <a class="el" href="classMutableMesh.html#3e67b3b6fe1bdd5487a8a2976d810262">MutableMesh::CheckIsVoronoi</a> (double maxPenetration=0.0) </dt>
<dd>use ElementIterator here? </dd>
</dl>
<p>
<a class="anchor" name="_todo000117"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#eecc3fb0677e787592ebe9b81f0e65ac">MutableVertexMesh::DivideElement</a> (VertexElement&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement, unsigned nodeAIndex, unsigned nodeBIndex, bool placeOriginalElementBelow=false) </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000113"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#eecc3fb0677e787592ebe9b81f0e65ac">MutableVertexMesh::DivideElement</a> (VertexElement&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement, unsigned nodeAIndex, unsigned nodeBIndex, bool placeOriginalElementBelow=false) </dt>
<dd>this could be more efficient </dd>
</dl>
<p>
<a class="anchor" name="_todo000118"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#672d5e08c84a23b3766fec49257c13e3">MutableVertexMesh::CheckForT1Swaps</a> (<a class="el" href="classVertexElementMap.html">VertexElementMap</a> &amp;rElementMap) </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000115"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#672d5e08c84a23b3766fec49257c13e3">MutableVertexMesh::CheckForT1Swaps</a> (<a class="el" href="classVertexElementMap.html">VertexElementMap</a> &amp;rElementMap) </dt>
<dd>use iterators to tidy this up </dd>
</dl>
<p>
<a class="anchor" name="_todo000119"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#52a816bda4b8cdf4b93c8ca787082cfd">MutableVertexMesh::CheckForT2Swaps</a> (<a class="el" href="classVertexElementMap.html">VertexElementMap</a> &amp;rElementMap) </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000120"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#6be30ccffd5793dcad87ca591c2dc23a">MutableVertexMesh::CheckForIntersections</a> () </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000121"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#0a2cfac0b3edc146353f97cd05cc5647">MutableVertexMesh::IdentifySwapType</a> (Node&lt; SPACE_DIM &gt; *pNodeA, Node&lt; SPACE_DIM &gt; *pNodeB, <a class="el" href="classVertexElementMap.html">VertexElementMap</a> &amp;rElementMap) </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000122"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#2f8f1877f4f2bf8a2fd24f1437f41356">MutableVertexMesh::PerformT1Swap</a> (Node&lt; SPACE_DIM &gt; *pNodeA, Node&lt; SPACE_DIM &gt; *pNodeB, std::set&lt; unsigned &gt; &amp;rElementsContainingNodes) </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000116"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#2f8f1877f4f2bf8a2fd24f1437f41356">MutableVertexMesh::PerformT1Swap</a> (Node&lt; SPACE_DIM &gt; *pNodeA, Node&lt; SPACE_DIM &gt; *pNodeB, std::set&lt; unsigned &gt; &amp;rElementsContainingNodes) </dt>
<dd>this is a magic number - think of something better </dd>
</dl>
<p>
<a class="anchor" name="_todo000123"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#b78b3bc66ffebb743f398403bf22aeae">MutableVertexMesh::PerformT2Swap</a> (VertexElement&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement) </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000124"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#b2f2c796443a7cc3358b7f87064145b8">MutableVertexMesh::DivideElementAlongShortAxis</a> (VertexElement&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement, bool placeOriginalElementBelow=false) </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000125"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#6f364bc7a3a1771ca544f8b15938cb09">MutableVertexMesh::DivideElementAlongGivenAxis</a> (VertexElement&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement, c_vector&lt; double, SPACE_DIM &gt; axisOfDivision, bool placeOriginalElementBelow=false) </dt>
<dd>This method currently assumes SPACE_DIM = 2 (see #866)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000112"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#6f364bc7a3a1771ca544f8b15938cb09">MutableVertexMesh::DivideElementAlongGivenAxis</a> (VertexElement&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement, c_vector&lt; double, SPACE_DIM &gt; axisOfDivision, bool placeOriginalElementBelow=false) </dt>
<dd>or should we move a and b apart, it may interfere with neighboring edges? (see #1399) </dd>
</dl>
<p>
<a class="anchor" name="_todo000114"></a> <dl>
<dt>Member <a class="el" href="classMutableVertexMesh.html#f4d4012ffd46303c7e7cce923ffb53b8">MutableVertexMesh::ReMesh</a> (<a class="el" href="classVertexElementMap.html">VertexElementMap</a> &amp;rElementMap) </dt>
<dd>put code for remeshing in 3D here - see #866 and the paper doi:10.1016/j.jtbi.2003.10.001 </dd>
</dl>
<p>
<a class="anchor" name="_todo000182"></a> <dl>
<dt>Class <a class="el" href="classNonlinearElasticitySolver.html">NonlinearElasticitySolver&lt; DIM &gt;</a>  </dt>
<dd>: factor out Dof handling? </dd>
</dl>
<p>
<a class="anchor" name="_todo000150"></a> <dl>
<dt>Member <a class="el" href="classOdeSystemInformation.html#290a58619ebad70ded740c148df3ad9d">OdeSystemInformation::mpInstance</a>  </dt>
<dd>see if using weak_ptr would work and give funkier semantics (automatically destroy the singleton when no ODE systems were using it) </dd>
</dl>
<p>
<a class="anchor" name="_todo000055"></a> <dl>
<dt>Class <a class="el" href="structpack_3_01void_07T_08_4.html">pack&lt; void(T)&gt;</a>  </dt>
<dd>Check if we need this on Boost&gt;=1.38. Even if it's not needed there, we might still need it to load earlier archives. </dd>
</dl>
<p>
<a class="anchor" name="_todo000067"></a> <dl>
<dt>Member <a class="el" href="classParallelColumnDataWriter.html#579406de3c0e29243d592ffdf3f6580c">ParallelColumnDataWriter::PutVectorStripe</a> (int variableId, <a class="el" href="classDistributedVector_1_1Stripe.html">DistributedVector::Stripe</a> &amp;rStripe) </dt>
<dd>allow this to be a const-reference </dd>
</dl>
<p>
<a class="anchor" name="_todo000082"></a> <dl>
<dt>Member <a class="el" href="structPCLDUFactorisation_1_1PCLDUFactorisationContext.html#a457cd5770a3fd29b7678718d8dbbb8a">PCLDUFactorisation::PCLDUFactorisationContext::PC_amg_A11</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p>
<a class="anchor" name="_todo000083"></a> <dl>
<dt>Member <a class="el" href="structPCLDUFactorisation_1_1PCLDUFactorisationContext.html#89466aa004f0e1a893e555c238d6ec84">PCLDUFactorisation::PCLDUFactorisationContext::PC_amg_A22</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p>
<a class="anchor" name="_todo000089"></a> <dl>
<dt>Class <a class="el" href="classPCTwoLevelsBlockDiagonal.html">PCTwoLevelsBlockDiagonal</a>  </dt>
<dd>: #1082 update this description </dd>
</dl>
<p>
<a class="anchor" name="_todo000084"></a> <dl>
<dt>Member <a class="el" href="classPCTwoLevelsBlockDiagonal.html#6115871fb1c77b86a91cc9ba9eedaee0">PCTwoLevelsBlockDiagonal::PCTwoLevelsBlockDiagonalCreate</a> (KSP &amp;rKspObject, std::vector&lt; PetscInt &gt; &amp;rBathNodes) </dt>
<dd>: #1082 won't work in parallel </dd>
</dl>
<p>
<a class="anchor" name="_todo000084"></a> <dl>
<dt>Member <a class="el" href="classPCTwoLevelsBlockDiagonal.html#6115871fb1c77b86a91cc9ba9eedaee0">PCTwoLevelsBlockDiagonal::PCTwoLevelsBlockDiagonalCreate</a> (KSP &amp;rKspObject, std::vector&lt; PetscInt &gt; &amp;rBathNodes) </dt>
<dd>: #1082 assert size(x1) = size(x21) + size(x22) </dd>
</dl>
<p>
<a class="anchor" name="_todo000084"></a> <dl>
<dt>Member <a class="el" href="classPCTwoLevelsBlockDiagonal.html#6115871fb1c77b86a91cc9ba9eedaee0">PCTwoLevelsBlockDiagonal::PCTwoLevelsBlockDiagonalCreate</a> (KSP &amp;rKspObject, std::vector&lt; PetscInt &gt; &amp;rBathNodes) </dt>
<dd>: #1082 legacy, no need to use the references </dd>
</dl>
<p>
<a class="anchor" name="_todo000084"></a> <dl>
<dt>Member <a class="el" href="classPCTwoLevelsBlockDiagonal.html#6115871fb1c77b86a91cc9ba9eedaee0">PCTwoLevelsBlockDiagonal::PCTwoLevelsBlockDiagonalCreate</a> (KSP &amp;rKspObject, std::vector&lt; PetscInt &gt; &amp;rBathNodes) </dt>
<dd>: #1082 OK in parallel. Use as an example for the other two blocks </dd>
</dl>
<p>
<a class="anchor" name="_todo000057"></a> <dl>
<dt>Member <a class="el" href="classPetscTools.html#613b2cf28fcb27daa87684d43114e4ef">PetscTools::SetupMat</a> (Mat &amp;rMat, int numRows, int numColumns, unsigned rowPreallocation, int numLocalRows=PETSC_DECIDE, int numLocalColumns=PETSC_DECIDE) </dt>
<dd>#1216 Fix the 1, 0.7 hack </dd>
</dl>
<p>
<a class="anchor" name="_todo000058"></a> <dl>
<dt>Member <a class="el" href="classPetscTools.html#609e4a5a53f9276b13e3d29208160d4d">PetscTools::ReadPetscObject</a> (Mat &amp;rMat, const std::string &amp;rOutputFileFullPath, Vec rParallelLayout=NULL) </dt>
<dd>: #1082 work out appropriate nz allocation. </dd>
</dl>
<p>
<a class="anchor" name="_todo000171"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#8924263fd2f64b16d5c9074d40142669">PolynomialMaterialLaw3d::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000172"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#1aabede19af92507752a4ddcb58311ff">PolynomialMaterialLaw3d::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000173"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#144746018624f7de4def2a1b669100fb">PolynomialMaterialLaw3d::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000174"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#f877b2e196146b36438bfcee79552f87">PolynomialMaterialLaw3d::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000175"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#b8707e90ba8823d0b34ee7aaa9f7b987">PolynomialMaterialLaw3d::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000014"></a> <dl>
<dt>Member <a class="el" href="classPostProcessingWriter.html#bdb67a953b0778e2fac1afb6b5750b40">PostProcessingWriter::WriteAboveThresholdDepolarisationFile</a> (double threshold) </dt>
<dd>This method ought to be private and called by the WritePostProcessingFiles method if the user requests for it. This will be possible after modifying the schema and specifying Get and Set methods in <a class="el" href="classHeartConfig.html">HeartConfig</a> to check whetehr the user wants this file or not<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000106"></a> <dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#381423743a648ba7e155c20d09b3c717">QuadraticMesh::HelperMethod1</a> (unsigned boundaryElemNode0, unsigned boundaryElemNode1, Element&lt; DIM, DIM &gt; *pElement, unsigned node0, unsigned node1, unsigned node2, unsigned &amp;rOffset, bool &amp;rReverse) </dt>
<dd>document these parameters<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000107"></a> <dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#3ef05dfe611ac8d2f84a7d9dc9de2164">QuadraticMesh::HelperMethod2</a> (<a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; DIM-1, DIM &gt; *pBoundaryElement, Element&lt; DIM, DIM &gt; *pElement, unsigned internalNode0, unsigned internalNode1, unsigned internalNode2, unsigned offset, bool reverse) </dt>
<dd>document these parameters<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000154"></a> <dl>
<dt>Member <a class="el" href="classQuadraturePointsGroup.html#401acdf9dbac2e283a13c74b7467c005">QuadraturePointsGroup::Get</a> (unsigned elementIndex, unsigned quadIndex) </dt>
<dd>this method should be renamed rGet() as it returns a reference<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000155"></a> <dl>
<dt>Member <a class="el" href="classQuadraturePointsGroup.html#6a8f637e49dffb46a6a36e24b1e2700c">QuadraturePointsGroup::Get</a> (unsigned i) </dt>
<dd>this method should be renamed rGet() as it returns a reference<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000108"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#df9f933954c2c0c411c3fa548b44c205">TetrahedralMesh::ImportFromMesher</a> (MESHER_IO &amp;mesherOutput, unsigned numberOfElements, int *elementList, unsigned numberOfFaces, int *faceList, int *edgeMarkerList) </dt>
<dd>#1545 ...) </dd>
</dl>
<p>
<a class="anchor" name="_todo000109"></a> <dl>
<dt>Member <a class="el" href="classTrianglesMeshReader.html#869d21887156901cb08629673b3d2123">TrianglesMeshReader::OpenNodeFile</a> () </dt>
<dd>Change name to OpenNodesFile for consistency with OpenElementsFile and OpenFacesFile? (#991) </dd>
</dl>
<p>
<a class="anchor" name="_todo000192"></a> <dl>
<dt>Member <a class="el" href="classVertexBasedCellPopulation.html#1ff3384522009800539eca2da369ea32">VertexBasedCellPopulation::GetLocationOfCellCentre</a> (CellPtr pCell) </dt>
<dd>If required, we could come up with a more clever definition of cell location for a VertexCellPopulation (for example, there is no guarantee of convexity so the centre of mass may lie outside the element)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000191"></a> <dl>
<dt>Member <a class="el" href="classVertexBasedCellPopulation.html#73330725e80fcd776d582fd9dde29dd1">VertexBasedCellPopulation::VertexBasedCellPopulation</a> (<a class="el" href="classMutableVertexMesh.html">MutableVertexMesh&lt; DIM, DIM &gt;</a> &amp;rMesh, std::vector&lt; CellPtr &gt; &amp;rCells, bool deleteMesh=false, bool validate=true, const std::vector&lt; unsigned &gt; locationIndices=stdvector&lt; unsigned &gt;()) </dt>
<dd>we should be able to do this, but mBoundaryNodes is not used in vertex meshes (#1558) </dd>
</dl>
<p>
<a class="anchor" name="_todo000126"></a> <dl>
<dt>Member <a class="el" href="classVertexMesh.html#370e77ce6f980e559fb84c0e94001e4b">VertexMesh::SolveBoundaryElementMapping</a> (unsigned index) const  </dt>
<dd>sort out boundary elements in a vertex mesh (#1263) </dd>
</dl>
<p>
<a class="anchor" name="_todo000127"></a> <dl>
<dt>Member <a class="el" href="classVertexMesh.html#c3b1ef99d19e007c3ba87c816f90605b">VertexMesh::GetCentroidOfElement</a> (unsigned index) </dt>
<dd>Why isn't this just the centre of mass? (#1075) </dd>
</dl>
<p>
<a class="anchor" name="_todo000128"></a> <dl>
<dt>Member <a class="el" href="classVertexMesh.html#8c56892be720dbf33599341c9a126498">VertexMesh::VertexMesh</a> (TetrahedralMesh&lt; 2, 2 &gt; &amp;rMesh, bool isPeriodic=false) </dt>
<dd>Merge with 3D Voronoi constructor? (#1075)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000129"></a> <dl>
<dt>Member <a class="el" href="classVertexMesh.html#95c11e802b7024578eb490d1f7e1a767">VertexMesh::VertexMesh</a> (<a class="el" href="classTetrahedralMesh.html">TetrahedralMesh&lt; 3, 3 &gt;</a> &amp;rMesh) </dt>
<dd>Merge with 2D Voronoi constructor? (#1075)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000130"></a> <dl>
<dt>Class <a class="el" href="classVertexMesh_1_1VertexElementIterator.html">VertexMesh&lt; ELEMENT_DIM, SPACE_DIM &gt;::VertexElementIterator</a>  </dt>
<dd>This is the same as in <a class="el" href="classAbstractTetrahedralMesh.html">AbstractTetrahedralMesh</a> - merge? (#1379) </dd>
</dl>
<p>
<a class="anchor" name="_todo000131"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshReader.html#6ac1f3b48f16070ae291e0a02cf87e19">VertexMeshReader::GetNumFaces</a> () const  </dt>
<dd>Implement this method (#1076) </dd>
</dl>
<p>
<a class="anchor" name="_todo000132"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshReader.html#f5f354ca7f6b4889a66a9e2015b8f471">VertexMeshReader::GetNextFaceData</a> () </dt>
<dd>Implement this method (#1076, #1377) </dd>
</dl>
<p>
<a class="anchor" name="_todo000133"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshReader.html#4caeef6f49a41e4ef230685689c9187c">VertexMeshReader::GetNumEdges</a> () const  </dt>
<dd>Implement this method (#1076) </dd>
</dl>
<p>
<a class="anchor" name="_todo000134"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshReader.html#462a4c94668c6985fa899ff72d80e96e">VertexMeshReader::GetNextElementDataWithFaces</a> () </dt>
<dd>Store face orientations? (#1076/#1377) </dd>
</dl>
<p>
<a class="anchor" name="_todo000143"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#13b36c7341b9c396f7c0bc8534788afb">VertexMeshWriter::mpVtkUnstructedMesh</a>  </dt>
<dd>Merge into <a class="el" href="classVtkMeshWriter.html">VtkMeshWriter</a> (#1076) </dd>
</dl>
<p>
<a class="anchor" name="_todo000144"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#d0255a5990c2ed45d592fabfd86baa3f">VertexMeshWriter::WriteFilesUsingMesh</a> (VertexMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMesh) </dt>
<dd>Mesh should be const (#1076) </dd>
</dl>
<p>
<a class="anchor" name="_todo000139"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#d0255a5990c2ed45d592fabfd86baa3f">VertexMeshWriter::WriteFilesUsingMesh</a> (VertexMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMesh) </dt>
<dd>Mesh should be const (#1076) </dd>
</dl>
<p>
<a class="anchor" name="_todo000137"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#247cf741c443b25a72e7e15fb02e6192">VertexMeshWriter::GetNextElement</a> () </dt>
<dd>Assert this method should only be called in 2D? (#1076/#1377) </dd>
</dl>
<p>
<a class="anchor" name="_todo000137"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#247cf741c443b25a72e7e15fb02e6192">VertexMeshWriter::GetNextElement</a> () </dt>
<dd>: set attribute (#1076) </dd>
</dl>
<p>
<a class="anchor" name="_todo000135"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#bc91e2d1207aae3c1ccd127f06ea1747">VertexMeshWriter::GetNextElementWithFaces</a> () </dt>
<dd>Store face orientations? (#1076/#1377) </dd>
</dl>
<p>
<a class="anchor" name="_todo000135"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#bc91e2d1207aae3c1ccd127f06ea1747">VertexMeshWriter::GetNextElementWithFaces</a> () </dt>
<dd>set attribute (#1076) </dd>
</dl>
<p>
<a class="anchor" name="_todo000140"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#7b70f3e874b4a7111fcb9ba36c26aa3d">VertexMeshWriter::WriteFiles</a> () </dt>
<dd>write element attributes if necessary </dd>
</dl>
<p>
<a class="anchor" name="_todo000140"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#7b70f3e874b4a7111fcb9ba36c26aa3d">VertexMeshWriter::WriteFiles</a> () </dt>
<dd>Store face orientations? (#1076/#1377) </dd>
</dl>
<p>
<a class="anchor" name="_todo000140"></a> <dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#7b70f3e874b4a7111fcb9ba36c26aa3d">VertexMeshWriter::WriteFiles</a> () </dt>
<dd>write element attribute (#1076/#1377) </dd>
</dl>
<p>
<a class="anchor" name="_todo000110"></a> <dl>
<dt>Class <a class="el" href="classVtkMeshReader.html">VtkMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>  </dt>
<dd>Provide &lt;2,2&gt; functionality </dd>
</dl>
<p>
<a class="anchor" name="_todo000009"></a> <dl>
<dt>File <a class="el" href="NobleVargheseKohlNoble1998WithSac_8hpp.html">NobleVargheseKohlNoble1998WithSac.hpp</a>  </dt>
<dd>: do something with this.. </dd>
</dl>
<p>
<a class="anchor" name="_todo000090"></a> <dl>
<dt>Member <a class="el" href="UblasCustomFunctions_8hpp.html#59ca0dd0f118f3996c9df1f946a0740c">CalculateEigenvectorForSmallestNonzeroEigenvalue</a>  </dt>
<dd>Only covered by TestPapillaryFibreCalculator, cover in TestUblasCustomFunctions.hpp </dd>
</dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Nov 1 12:35:28 2010 for Chaste by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
