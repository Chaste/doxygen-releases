<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Chaste: AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt; Class Template Reference</h1><!-- doxytag: class="AbstractNonlinearAssembler" --><!-- doxytag: inherits="AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;" --><code>#include &lt;<a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;:</div>
<div class="dynsection">
<p><center><img src="classAbstractNonlinearAssembler__inherit__graph.png" border="0" usemap="#AbstractNonlinearAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_00_01CONCRETE_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="AbstractNonlinearAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_00_01CONCRETE_01_4__inherit__map">
<area shape="rect" href="classAbstractNonlinearAssembler.html" title="{AbstractNonlinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|# mpSolver\l# mWeAllocatedSolverMemory\l# mUseAnalyticalJacobian\l&#45; mInitialGuess\l|+ AssembleResidual()\l+ AssembleJacobian()\l+ AbstractNonlinearAssembler()\l+ ~AbstractNonlinearAssembler()\l+ SetUseAnalyticalJacobian()\l+ Solve()\l+ SetNonlinearSolver()\l+ CreateConstantInitialGuess()\l+ VerifyJacobian()\l# ApplyDirichletConditions()\l# AssembleJacobianNumerically()\l# AssembleSystem()\l# ProblemIsNonlinear()\l# InitialiseForSolve()\l# StaticSolve()\l}" alt="" coords="5,1474,808,1786"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="117,774,696,1046"><area shape="rect" href="classAbstractAssembler.html" title="{AbstractAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|# mpBoundaryConditions\l|+ AbstractAssembler()\l+ SetBoundaryConditionsContainer()\l+ ~AbstractAssembler()\l+ ResetInterpolatedQuantities()\l+ IncrementInterpolatedQuantities()\l# SetMatrixIsConst()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# PrepareForAssembleSystem()\l# FinaliseAssembleSystem()\l# FinaliseLinearSystem()\l# ApplyDirichletConditions()\l# ProblemIsNonlinear()\l# StaticSolve()\l# InitialiseForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# ApplyNeummanBoundaryConditions()\l}" alt="" coords="264,6,699,390"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="423,440,1057,712"><area shape="rect" href="classSimpleNonlinearEllipticAssembler.html" title="{SimpleNonlinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l&#45; mpNonlinearEllipticPde\l|+ SimpleNonlinearEllipticAssembler()\l&#45; ComputeMatrixTerm()\l&#45; ComputeVectorTerm()\l&#45; ComputeVectorSurfaceTerm()\l}" alt="" coords="199,1839,615,1996"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;:</div>
<div class="dynsection">
<p><center><img src="classAbstractNonlinearAssembler__coll__graph.png" border="0" usemap="#AbstractNonlinearAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_00_01CONCRETE_01_4__coll__map" alt="Collaboration graph"></center>
<map name="AbstractNonlinearAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_00_01CONCRETE_01_4__coll__map">
<area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="764,2414,1343,2686"><area shape="rect" href="classAbstractAssembler.html" title="{AbstractAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|# mpBoundaryConditions\l|+ AbstractAssembler()\l+ SetBoundaryConditionsContainer()\l+ ~AbstractAssembler()\l+ ResetInterpolatedQuantities()\l+ IncrementInterpolatedQuantities()\l# SetMatrixIsConst()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# PrepareForAssembleSystem()\l# FinaliseAssembleSystem()\l# FinaliseLinearSystem()\l# ApplyDirichletConditions()\l# ProblemIsNonlinear()\l# StaticSolve()\l# InitialiseForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# ApplyNeummanBoundaryConditions()\l}" alt="" coords="1015,1426,1449,1810"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="813,2080,1448,2352"><area shape="rect" href="classBoundaryConditionsContainer.html" title="{BoundaryConditionsContainer\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|&#45; mpNeumannMap\l&#45; mLastNeumannCondition\l&#45; mAnyNonZeroNeumannConditionsForUnknown\l&#45; mpZeroBoundaryCondition\l|+ BoundaryConditionsContainer()\l+ ~BoundaryConditionsContainer()\l+ AddDirichletBoundaryCondition()\l+ AddNeumannBoundaryCondition()\l+ DefineZeroDirichletOnMeshBoundary()\l+ DefineConstantDirichletOnMeshBoundary()\l+ DefineZeroNeumannOnMeshBoundary()\l+ ApplyDirichletToLinearProblem()\l+ ApplyDirichletToNonlinearResidual()\l+ ApplyDirichletToNonlinearJacobian()\l+ Validate()\l+ GetNeumannBCValue()\l+ HasNeumannBoundaryCondition()\l+ AnyNonZeroNeumannConditions()\l+ BeginNeumann()\l+ EndNeumann()\l}" alt="" coords="1313,799,1809,1124"><area shape="rect" href="classBoundaryConditionsContainer.html" title="{BoundaryConditionsContainer\&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|&#45; mpNeumannMap\l&#45; mLastNeumannCondition\l&#45; mAnyNonZeroNeumannConditionsForUnknown\l&#45; mpZeroBoundaryCondition\l|+ BoundaryConditionsContainer()\l+ ~BoundaryConditionsContainer()\l+ AddDirichletBoundaryCondition()\l+ AddNeumannBoundaryCondition()\l+ DefineZeroDirichletOnMeshBoundary()\l+ DefineConstantDirichletOnMeshBoundary()\l+ DefineZeroNeumannOnMeshBoundary()\l+ ApplyDirichletToLinearProblem()\l+ ApplyDirichletToNonlinearResidual()\l+ ApplyDirichletToNonlinearJacobian()\l+ Validate()\l+ GetNeumannBCValue()\l+ HasNeumannBoundaryCondition()\l+ AnyNonZeroNeumannConditions()\l+ BeginNeumann()\l+ EndNeumann()\l}" alt="" coords="708,367,1177,692"><area shape="rect" href="classLinearSystem.html" title="{LinearSystem\n|&#45; mLhsMatrix\l&#45; mRhsVector\l&#45; mSize\l&#45; mOwnershipRangeLo\l&#45; mOwnershipRangeHi\l&#45; mMatNullSpace\l&#45; mDestroyMatAndVec\l&#45; mKspSolver\l&#45; mKspIsSetup\l&#45; mNonZerosUsed\l&#45; mMatrixIsConstant\l&#45; mTolerance\l&#45; mUseAbsoluteTolerance\l&#45; mKspType\l&#45; mPcType\l&#45; mDirichletBoundaryConditionsVector\l|+ LinearSystem()\l+ LinearSystem()\l+ LinearSystem()\l+ ~LinearSystem()\l+ SetMatrixElement()\l+ AddToMatrixElement()\l+ AssembleFinalLinearSystem()\l+ AssembleIntermediateLinearSystem()\l+ AssembleFinalLhsMatrix()\l+ AssembleIntermediateLhsMatrix()\l+ AssembleRhsVector()\l+ SetMatrixIsSymmetric()\l+ SetMatrixIsConstant()\l+ SetRelativeTolerance()\l+ SetAbsoluteTolerance()\l+ SetKspType()\l+ SetPcType()\l+ DisplayMatrix()\l+ DisplayRhs()\l+ SetMatrixRow()\l+ ZeroMatrixRow()\l+ ZeroMatrixColumn()\l+ ZeroLhsMatrix()\l+ ZeroRhsVector()\l+ ZeroLinearSystem()\l+ Solve()\l+ SetRhsVectorElement()\l+ AddToRhsVectorElement()\l+ GetSize()\l+ SetNullBasis()\l+ rGetRhsVector()\l+ rGetLhsMatrix()\l+ rGetDirichletBoundaryConditionsVector()\l+ GetOwnershipRange()\l+ GetMatrixElement()\l+ GetRhsVectorElement()\l+ AddLhsMultipleValues()\l+ AddRhsMultipleValues()\l}" alt="" coords="709,1216,976,2019"><area shape="rect" href="classGaussianQuadratureRule.html" title="{GaussianQuadratureRule\&lt; ELEMENT_DIM \&gt;\n|&#45; mNumQuadPoints\l&#45; mWeights\l&#45; mPoints\l|+ GaussianQuadratureRule()\l+ rGetQuadPoint()\l+ GetWeight()\l+ GetNumQuadPoints()\l}" alt="" coords="1809,1546,2092,1690"><area shape="rect" href="classGaussianQuadratureRule.html" title="{GaussianQuadratureRule\&lt; ELEM_DIM \&gt;\n|&#45; mNumQuadPoints\l&#45; mWeights\l&#45; mPoints\l|+ GaussianQuadratureRule()\l+ rGetQuadPoint()\l+ GetWeight()\l+ GetNumQuadPoints()\l}" alt="" coords="2140,890,2396,1034"><area shape="rect" href="classGaussianQuadratureRule.html" title="{GaussianQuadratureRule\&lt; ELEMENT_DIM&#45;1 \&gt;\n|&#45; mNumQuadPoints\l&#45; mWeights\l&#45; mPoints\l|+ GaussianQuadratureRule()\l+ rGetQuadPoint()\l+ GetWeight()\l+ GetNumQuadPoints()\l}" alt="" coords="2116,1546,2409,1690"><area shape="rect" href="classAbstractNonlinearSolver.html" title="{AbstractNonlinearSolver\n||+ Solve()\l+ ~AbstractNonlinearSolver()\l}" alt="" coords="1367,2506,1556,2594"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classAbstractNonlinearAssembler-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PetscErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#e6dac701df0acb44e10565746d82c10b">AssembleResidual</a> (const Vec currentGuess, Vec residualVector)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PetscErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#47d873b5dba04bbcbfc1bac9780947fe">AssembleJacobian</a> (const Vec currentGuess, Mat *pGlobalJacobian)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#68bea9dbdb2d7305051ec22fd0d68165">AbstractNonlinearAssembler</a> (unsigned numQuadPoints=2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#a6a6abb7d8978547b366a70002b6e048">SetUseAnalyticalJacobian</a> (bool useAnalyticalJacobian)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual Vec&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#e7192757acbc554cb04a83bf948d3f28">Solve</a> (Vec initialGuess, bool useAnalyticalJacobian=false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#007f2f13fa4854260cea613d8bfb57d1">SetNonlinearSolver</a> (<a class="el" href="classAbstractNonlinearSolver.html">AbstractNonlinearSolver</a> *pNonlinearSolver)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Vec&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#3bfa7eaa5eb52d56f08f717c665eda2c">CreateConstantInitialGuess</a> (double value)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#38fd96b1b3a48c468cf1f73633bee79b">VerifyJacobian</a> (double tol=1e-4, bool print=false)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#24df26dc705b54b2f626b5114e8c36a9">ApplyDirichletConditions</a> (Vec currentGuess, bool applyToMatrix)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">PetscErrorCode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#85b8386a9b053139cb0ef3d25eeaa575">AssembleJacobianNumerically</a> (const Vec currentGuess, Mat *pJacobian)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#987bf3fd50c7f194f44ba474ce6eb5f9">AssembleSystem</a> (bool assembleVector, bool assembleMatrix, Vec currentGuess=NULL, double currentTime=0.0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#249c069dddfd82fa3bd0429941131c09">ProblemIsNonlinear</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#07c583a147955333eb5a909602973270">InitialiseForSolve</a> (Vec initialGuess)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Vec&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractNonlinearAssembler.html#5645b3fcde13bd8802099837e535e342">StaticSolve</a> (Vec currentSolutionOrGuess=NULL, double currentTime=0.0, bool assembleMatrix=true)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7790b23f9628c6903ae3376b11fa7cd6"></a><!-- doxytag: member="AbstractNonlinearAssembler::mpSolver" ref="7790b23f9628c6903ae3376b11fa7cd6" args="" -->
<a class="el" href="classAbstractNonlinearSolver.html">AbstractNonlinearSolver</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><b>mpSolver</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e9dc519c23e8cf778f01a3ecdf2af2a0"></a><!-- doxytag: member="AbstractNonlinearAssembler::mWeAllocatedSolverMemory" ref="e9dc519c23e8cf778f01a3ecdf2af2a0" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>mWeAllocatedSolverMemory</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="398b2c74c85c2f3e709cecab5635b288"></a><!-- doxytag: member="AbstractNonlinearAssembler::mUseAnalyticalJacobian" ref="398b2c74c85c2f3e709cecab5635b288" args="" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>mUseAnalyticalJacobian</b></td></tr>

<tr><td colspan="2"><br><h2>Private Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6f8221a5cbc975b6649f7454cb809546"></a><!-- doxytag: member="AbstractNonlinearAssembler::BaseClassType" ref="6f8221a5cbc975b6649f7454cb809546" args="" -->
typedef <br>
<a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a><br>
&lt; ELEMENT_DIM, SPACE_DIM, <br>
PROBLEM_DIM, true, CONCRETE &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>BaseClassType</b></td></tr>

<tr><td colspan="2"><br><h2>Private Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4966cc7a2f1625023beb1f0c2043a524"></a><!-- doxytag: member="AbstractNonlinearAssembler::mInitialGuess" ref="4966cc7a2f1625023beb1f0c2043a524" args="" -->
Vec&nbsp;</td><td class="memItemRight" valign="bottom"><b>mInitialGuess</b></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt;<br>
 class AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</h3>

<a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a> 
<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00081">81</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="68bea9dbdb2d7305051ec22fd0d68165"></a><!-- doxytag: member="AbstractNonlinearAssembler::AbstractNonlinearAssembler" ref="68bea9dbdb2d7305051ec22fd0d68165" args="(unsigned numQuadPoints=2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::<a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>numQuadPoints</em> = <code>2</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Constructors just call the base class versions. 
<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00319">319</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="24df26dc705b54b2f626b5114e8c36a9"></a><!-- doxytag: member="AbstractNonlinearAssembler::ApplyDirichletConditions" ref="24df26dc705b54b2f626b5114e8c36a9" args="(Vec currentGuess, bool applyToMatrix)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::ApplyDirichletConditions           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>applyToMatrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply Dirichlet boundary conditions to either the residual or jacobian. 
<p>Implements <a class="el" href="classAbstractAssembler.html#ebd31166fc064a704dca661f259eda03">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00095">95</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="e6dac701df0acb44e10565746d82c10b"></a><!-- doxytag: member="AbstractNonlinearAssembler::AssembleResidual" ref="e6dac701df0acb44e10565746d82c10b" args="(const Vec currentGuess, Vec residualVector)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::AssembleResidual           </td>
          <td>(</td>
          <td class="paramtype">const Vec&nbsp;</td>
          <td class="paramname"> <em>currentGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>residualVector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the residual vector given the current solution guess.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentGuess</em>&nbsp;</td><td>The solution guess for the current iteration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>residualVector</em>&nbsp;</td><td>We fill this with the residual vector. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code if any PETSc routines fail.</dd></dl>
NOTE: this method is called indirectly by the PETSc iterative solvers, so must be public. 
<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00122">122</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00173">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::AssembleJacobianNumerically()</a>.</p>

</div>
</div><p>
<a class="anchor" name="47d873b5dba04bbcbfc1bac9780947fe"></a><!-- doxytag: member="AbstractNonlinearAssembler::AssembleJacobian" ref="47d873b5dba04bbcbfc1bac9780947fe" args="(const Vec currentGuess, Mat *pGlobalJacobian)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::AssembleJacobian           </td>
          <td>(</td>
          <td class="paramtype">const Vec&nbsp;</td>
          <td class="paramname"> <em>currentGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat *&nbsp;</td>
          <td class="paramname"> <em>pGlobalJacobian</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Compute the Jacobian matrix given a current guess at the solution. Choose whether to use a numerical or analytical method based on a flag provided by the user (in <a class="el" href="classAbstractNonlinearAssembler.html#e7192757acbc554cb04a83bf948d3f28">Solve()</a>).<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentGuess</em>&nbsp;</td><td>The solution guess for the current iteration. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pGlobalJacobian</em>&nbsp;</td><td>Pointer to object to fill with the jacobian matrix. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code if any PETSc routines fail.</dd></dl>
NOTE: this method is called indirectly by the PETSc iterative solvers, so must be public. 
<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00146">146</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00411">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::VerifyJacobian()</a>.</p>

</div>
</div><p>
<a class="anchor" name="85b8386a9b053139cb0ef3d25eeaa575"></a><!-- doxytag: member="AbstractNonlinearAssembler::AssembleJacobianNumerically" ref="85b8386a9b053139cb0ef3d25eeaa575" args="(const Vec currentGuess, Mat *pJacobian)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">PetscErrorCode <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::AssembleJacobianNumerically           </td>
          <td>(</td>
          <td class="paramtype">const Vec&nbsp;</td>
          <td class="paramname"> <em>currentGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat *&nbsp;</td>
          <td class="paramname"> <em>pJacobian</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes the Jacobian numerically i.e. an approximation, using numerical partial derivatives.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentGuess</em>&nbsp;</td><td>Independent variable, u in f(u), for example </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pJacobian</em>&nbsp;</td><td>A pointer to the Jacobian matrix</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An error code if any PETSc routines fail. </dd></dl>

<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00173">173</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00146">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::AssembleJacobian()</a>.</p>

</div>
</div><p>
<a class="anchor" name="987bf3fd50c7f194f44ba474ce6eb5f9"></a><!-- doxytag: member="AbstractNonlinearAssembler::AssembleSystem" ref="987bf3fd50c7f194f44ba474ce6eb5f9" args="(bool assembleVector, bool assembleMatrix, Vec currentGuess=NULL, double currentTime=0.0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::AssembleSystem           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
AssembleSystem - the major method for all assemblers<p>
Assemble the linear system for a linear PDE, or the residual or Jacobian for nonlinear PDEs. Loops over each element (and each each surface element if there are non-zero Neumann boundary conditions), calls <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AssembleOnElement()</a> and adds the contribution to the linear system.<p>
Takes in current solution and time if necessary but only used if the problem is a dynamic one. This method uses PROBLEM_DIM and can assemble linear systems for any number of unknown variables.<p>
Called by <a class="el" href="classAbstractNonlinearAssembler.html#e7192757acbc554cb04a83bf948d3f28">Solve()</a> Calls <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AssembleOnElement()</a><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>assembleVector</em>&nbsp;</td><td>Whether to assemble the RHS vector of the linear system (i.e. the residual vector for nonlinear problems). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleMatrix</em>&nbsp;</td><td>Whether to assemble the LHS matrix of the linear system (i.e. the jacobian matrix for nonlinear problems).</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td>The current solution in a linear dynamic problem, or the current guess in a nonlinear problem. Should be NULL for linear static problems.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td>The current time for dynamic problems. Not used in static problems. </td></tr>
  </table>
</dl>

<p>Reimplemented from <a class="el" href="classAbstractStaticAssembler.html#2d524f457086a4fa40c4ae78371538ce">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00258">258</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00146">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::AssembleJacobian()</a>, and <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00122">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::AssembleResidual()</a>.</p>

</div>
</div><p>
<a class="anchor" name="249c069dddfd82fa3bd0429941131c09"></a><!-- doxytag: member="AbstractNonlinearAssembler::ProblemIsNonlinear" ref="249c069dddfd82fa3bd0429941131c09" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::ProblemIsNonlinear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether grad_u should be calculated 
<p>Implements <a class="el" href="classAbstractAssembler.html#7c66cce275f297ad2c13a5f42d597a69">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00266">266</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="07c583a147955333eb5a909602973270"></a><!-- doxytag: member="AbstractNonlinearAssembler::InitialiseForSolve" ref="07c583a147955333eb5a909602973270" args="(Vec initialGuess)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::InitialiseForSolve           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>initialGuess</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
No separate initialisation is needed in the nonlinear case; PrepareForSolve does everything. We just check the size of the initial guess. 
<p>Implements <a class="el" href="classAbstractAssembler.html#5dc3a84b7d6535cf2c1727c0fc00c75f">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00275">275</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00359">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::Solve()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5645b3fcde13bd8802099837e535e342"></a><!-- doxytag: member="AbstractNonlinearAssembler::StaticSolve" ref="5645b3fcde13bd8802099837e535e342" args="(Vec currentSolutionOrGuess=NULL, double currentTime=0.0, bool assembleMatrix=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vec <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::StaticSolve           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform the work of a single solve, but without any initialisation.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td>either the current solution (dynamic problem) or initial guess (static problem). MUST be provided. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td>for a dynamic problem, the current time </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the solution vector </dd></dl>

<p>
<dl compact><dt><b><a class="el" href="todo.html#_todo000080">Todo:</a></b></dt><dd>do something sensible if assembleMatrix is false. </dd></dl>

<p>Implements <a class="el" href="classAbstractAssembler.html#1f4769b876004c784a2d2ec8f845f8e3">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00298">298</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00359">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::Solve()</a>.</p>

</div>
</div><p>
<a class="anchor" name="a6a6abb7d8978547b366a70002b6e048"></a><!-- doxytag: member="AbstractNonlinearAssembler::SetUseAnalyticalJacobian" ref="a6a6abb7d8978547b366a70002b6e048" args="(bool useAnalyticalJacobian)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::SetUseAnalyticalJacobian           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useAnalyticalJacobian</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set whether to use an analytical jacobian. This is provided for use when solving dynamic nonlinear problems; when solving static problems there is an argument to the Solve method which specifies this property, and overrides any user call to this method.<p>
If this method is not called the default is false i.e. numerical jacobian. 
<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00346">346</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00359">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::Solve()</a>.</p>

</div>
</div><p>
<a class="anchor" name="e7192757acbc554cb04a83bf948d3f28"></a><!-- doxytag: member="AbstractNonlinearAssembler::Solve" ref="e7192757acbc554cb04a83bf948d3f28" args="(Vec initialGuess, bool useAnalyticalJacobian=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual Vec <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::Solve           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>initialGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>useAnalyticalJacobian</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Assemble and solve the system for a nonlinear elliptic PDE.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>initialGuess</em>&nbsp;</td><td>An initial guess for the iterative solver </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>useAnalyticalJacobian</em>&nbsp;</td><td>Set to true to use an analytically calculated jacobian matrix rather than a numerically approximated one. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A PETSc vector giving the solution at each mesh node. </dd></dl>

<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00359">359</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="007f2f13fa4854260cea613d8bfb57d1"></a><!-- doxytag: member="AbstractNonlinearAssembler::SetNonlinearSolver" ref="007f2f13fa4854260cea613d8bfb57d1" args="(AbstractNonlinearSolver *pNonlinearSolver)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::SetNonlinearSolver           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAbstractNonlinearSolver.html">AbstractNonlinearSolver</a> *&nbsp;</td>
          <td class="paramname"> <em>pNonlinearSolver</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
SetNonlinearSolver - by default a <a class="el" href="classSimplePetscNonlinearSolver.html">SimplePetscNonlinearSolver</a> is created and used in this class, this method can be called to use a different <a class="el" href="classAbstractNonlinearSolver.html">AbstractNonlinearSolver</a> 
<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00375">375</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="3bfa7eaa5eb52d56f08f717c665eda2c"></a><!-- doxytag: member="AbstractNonlinearAssembler::CreateConstantInitialGuess" ref="3bfa7eaa5eb52d56f08f717c665eda2c" args="(double value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vec <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::CreateConstantInitialGuess           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
A helpful method for creating an initial guess vector 
<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00388">388</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="38fd96b1b3a48c468cf1f73633bee79b"></a><!-- doxytag: member="AbstractNonlinearAssembler::VerifyJacobian" ref="38fd96b1b3a48c468cf1f73633bee79b" args="(double tol=1e-4, bool print=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM, class CONCRETE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classAbstractNonlinearAssembler.html">AbstractNonlinearAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::VerifyJacobian           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>tol</em> = <code>1e-4</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>print</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
VerifyJacobian<p>
A helper method for use when writing concrete assemblers. Once the user has calculated (on paper) the weak form and the form of the ComputeMatrixTerm method, they can check whether the analytic Jacobian matches the numerical Jacobian (which only calls ComputeVectorTerm and ComputeVectorSurfaceTerm) to verify the correctness of the code.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>tol</em>&nbsp;</td><td>A tolerance which defaults to 1e-5 </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>print</em>&nbsp;</td><td>Whether to print the different matrix J_numerical-J_analytical </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the componentwise difference between the matrices is less than the tolerance, false otherwise.</dd></dl>
This method should NOT be run in simulations - it is only to verify the correctness of the concrete assembler code. 
<p>Definition at line <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00411">411</a> of file <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/tmp/release_1/pde/src/solver/common/<a class="el" href="AbstractNonlinearAssembler_8hpp-source.html">AbstractNonlinearAssembler.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Mar 18 12:52:07 2009 for Chaste by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
