<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Chaste: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.2 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">


<h1><a class="anchor" id="todo">Todo List </a></h1><p><a class="anchor" id="_todo000007"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#a360ab25d7146d2878d2c58b88380287f">AbstractCardiacPde::CreateIntracellularConductivityTensor</a> () </dt>
<dd><p class="startdd">#1316 Create a class defining constant tensors to be used when no fibre orientation is provided. </p>
<p class="enddd">#1316 Create a class defining constant tensors to be used when no fibre orientation is provided. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000010"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#aa7c8cac314ae65b46a98ed9ad9e5fe58">AbstractCardiacPde::LoadCardiacCells</a> (Archive &amp;archive, const unsigned int version, std::vector&lt; AbstractCardiacCell * &gt; &amp;rCells, AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; *pMesh) </dt>
<dd>#1199 test this </dd>
</dl>
<p><a class="anchor" id="_todo000009"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#ad24e4472e9dbf10fe275fad09714aed3">AbstractCardiacPde::mDoOneCacheReplication</a>  </dt>
<dd>#1063 maybe we don't want the conventional assembly even in the first time step. </dd>
</dl>
<p><a class="anchor" id="_todo000016"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#a0738e85a4897d8fd5962911c42594511">AbstractCardiacProblem::load</a> (Archive &amp;archive, const unsigned int version) </dt>
<dd><p class="startdd">#1317 code for saving/loading mSolution is PROBLEM_DIM specific, move it into the save/load methods fo Mono and <a class="el" href="classBidomainProblem.html">BidomainProblem</a> </p>
<p class="enddd">#1317 is there a reason we can't use PETSc's load/save vector functionality? </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000014"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#afda9434b87c4d2af11859f006b1bb29e">AbstractCardiacProblem::LoadExtraArchive</a> (Archive &amp;archive, unsigned version) </dt>
<dd>#1159 sanity check that the contents of p_bcc and mpBoundaryConditionsContainer match. </dd>
</dl>
<p><a class="anchor" id="_todo000015"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#ab996d7a4e8fde84b2bd5767487b8e864">AbstractCardiacProblem::save</a> (Archive &amp;archive, const unsigned int version) const  </dt>
<dd>#1317 code for saving/loading mSolution is PROBLEM_DIM specific, move it into the save/load methods fo Mono and <a class="el" href="classBidomainProblem.html">BidomainProblem</a> </dd>
</dl>
<p><a class="anchor" id="_todo000013"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#a7a72dc8f2ed3834792e92675130f7952">AbstractCardiacProblem::Solve</a> () </dt>
<dd>#1318 the following line will deadlock if not every process throws in the Solve call </dd>
</dl>
<p><a class="anchor" id="_todo000001"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#a25a3b5da1f940794918b6abb47f7fb79">AbstractConvergenceTester::Converge</a> (std::string nameOfTest) </dt>
<dd><p class="startdd">This is a scarily long method; could do with some parts extracted? </p>
<p class="enddd">Cover this </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000003"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#a8ec5fb24c1e3606e72dc68a6c1ebce6f">AbstractConvergenceTester::DisplayRun</a> () </dt>
<dd>The UseAbsoluteStimulus is temporary, while we are sorting out 3D stimulus. It is to be removed later (along with StimulusConvergenceTester) </dd>
</dl>
<p><a class="anchor" id="_todo000133"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#ab560e0993f5892ec9524dc035702ba6f">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI1</a> (double I1, double I2)=0 </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000135"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#acb19d8801f5dcd6085826b2e358efe12">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2)=0 </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000134"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#acbcca2fcf4c5d73484dfeb4c65cb10bb">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI2</a> (double I1, double I2)=0 </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000131"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#a3ba3f6957e2343e39d6304d4cdc2405e">AbstractIsotropicIncompressibleMaterialLaw::Get_dW_dI1</a> (double I1, double I2)=0 </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000132"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#ae377687f775dd070cdf29bd60b26efcf">AbstractIsotropicIncompressibleMaterialLaw::Get_dW_dI2</a> (double I1, double I2)=0 </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000080"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractMesh.html#abe215056a72c1b64d0871e37d08dd0f7">AbstractMesh::GetWidthExtremes</a> (const unsigned &amp;rDimension) const  </dt>
<dd>#1322 use a const version of NodeIterator here </dd>
</dl>
<p><a class="anchor" id="_todo000151"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractNonlinearAssembler.html#a5645b3fcde13bd8802099837e535e342">AbstractNonlinearAssembler::StaticSolve</a> (Vec currentSolutionOrGuess=NULL, double currentTime=0.0, bool assembleMatrix=true) </dt>
<dd>do something sensible if assembleMatrix is false. </dd>
</dl>
<p><a class="anchor" id="_todo000152"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractNonlinearAssembler.html#aadc88d30b47c691665fe7c9d7bc7e1c3">AbstractNonlinearAssembler::VerifyJacobian</a> (double tol=1e-4) </dt>
<dd>Get more than one value at a time </dd>
</dl>
<p><a class="anchor" id="_todo000153"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractStaticAssembler.html#a1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler::AssembleOnElement</a> (Element&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement, c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;rAElem, c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;rBElem, bool assembleVector, bool assembleMatrix) </dt>
<dd>#1320 This assumes that the Jacobian is constant on an element. This is true for linear basis functions, but not for any other type of basis function. </dd>
</dl>
<p><a class="anchor" id="_todo000154"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractStaticAssembler.html#ad900feac00b92662daaadd766f26cf78">AbstractStaticAssembler::AssembleOnSurfaceElement</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;rBSurfElem) </dt>
<dd><p class="startdd">: add interpolation of u as well </p>
<p class="enddd">#1321 Improve efficiency of Neumann BC implementation. </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000156"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractStaticAssembler.html#a2fe1f0600bdee65ce27ac191b531b1a5">AbstractStaticAssembler::ComputeTransformedBasisFunctionDerivatives</a> (const ChastePoint&lt; ELEMENT_DIM &gt; &amp;rPoint, const c_matrix&lt; double, ELEMENT_DIM, SPACE_DIM &gt; &amp;rInverseJacobian, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rReturnValue) </dt>
<dd><p class="startdd">#1319 Template <a class="el" href="classLinearBasisFunction.html">LinearBasisFunction</a> over SPACE_DIM and remove this method?</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000082"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMesh.html#a4547ff751d240e232bf7a905e0b9f1eb">AbstractTetrahedralMesh::load</a> (Archive &amp;archive, const unsigned int version) </dt>
<dd>#1199 make this work for everything else... </dd>
</dl>
<p><a class="anchor" id="_todo000081"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMesh.html#ae95c4b2ff7ecebbe10a26818abd8d4f2">AbstractTetrahedralMesh::save</a> (Archive &amp;archive, const unsigned int version) const  </dt>
<dd>#1200 This is bad for very large meshes. Consider making a symlink and just writing the permutation. Perhaps even copy the permutation file from an earlier checkpoint? </dd>
</dl>
<p><a class="anchor" id="_todo000125"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMeshWriter.html#a4f4fb91da4806b39a6afced7d3ba7491">AbstractTetrahedralMeshWriter::WriteFilesUsingMesh</a> (AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMesh) </dt>
<dd><p class="startdd">#1322 Mesh should really be const! </p>
<p>#1322 Mesh should be const </p>
<p class="enddd">#1322 This should be const too </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000162"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractTissue.html#a8bba7630c2ee2dd88b6aa49a69cac2a6">AbstractTissue::AbstractTissue</a> (std::vector&lt; TissueCell &gt; &amp;rCells, const std::vector&lt; unsigned &gt; locationIndices=stdvector&lt; unsigned &gt;()) </dt>
<dd>remove explicit use of NUM_CELL_PROLIFERATIVE_TYPES and NUM_CELL_CYCLE_PHASES as these may eventually differ between simulations (see #1285) </dd>
</dl>
<p><a class="anchor" id="_todo000163"></a> </p>
<dl>
<dt>Member <a class="el" href="classAbstractTissue.html#a18b004f24bd473f1cbbe9e524f8f667a">AbstractTissue::HasMesh</a> () </dt>
<dd><p class="startdd">This method returns true if the tissue is a <a class="el" href="classMeshBasedTissue.html">MeshBasedTissue</a> or a VertexBasedTissue, but is actually used to tell force laws whether the tissue is a <a class="el" href="classMeshBasedTissue.html">MeshBasedTissue</a>. See #1303.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000004"></a> </p>
<dl>
<dt>Member <a class="el" href="classBackwardEulerNobleVargheseKohlNoble1998.html#a40cbfc5da447f1cd37c10edc50f4767d">BackwardEulerNobleVargheseKohlNoble1998::GetIIonic</a> () </dt>
<dd><p class="startdd">we need to + Check this scaling + Ask JonC to amend PyCml if necessary + Check other cell models</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000038"></a> </p>
<dl>
<dt>Member <a class="el" href="classBidomainDg0Assembler.html#ac70ba273a3213755d2e0df72a502e306">BidomainDg0Assembler::CheckCompatibilityCondition</a> () </dt>
<dd>#1327 This could be a collective MPI-like operation </dd>
</dl>
<p><a class="anchor" id="_todo000018"></a> </p>
<dl>
<dt>Member <a class="el" href="classBidomainProblem.html#a3cba4f174d15a2e197217e944e066f87">BidomainProblem::AtBeginningOfTimestep</a> (double time) </dt>
<dd>#1159 #1324 <a class="el" href="AbstractCardiacProblem_8hpp_source.html">heart/src/problem/AbstractCardiacProblem.hpp</a>:657 expects both pointing at the same place when unarchiving </dd>
</dl>
<p><a class="anchor" id="_todo000019"></a> </p>
<dl>
<dt>Member <a class="el" href="classBidomainProblem.html#a66e781e2d8200ccaab18a29a6a6577a0">BidomainProblem::LoadExtraArchiveForBidomain</a> (Archive &amp;archive, unsigned version) </dt>
<dd>#1159 sanity check that the contents of p_bcc and mpElectrodes-&gt;GetBoundaryConditionsContainer() match. </dd>
</dl>
<p><a class="anchor" id="_todo000039"></a> </p>
<dl>
<dt>Member <a class="el" href="classBidomainWithBathAssembler.html#a10ca4cf8f3ff023005825db2c988f56d">BidomainWithBathAssembler::FinaliseLinearSystem</a> (Vec existingSolutionOrGuess, double time, bool assembleVector, bool assembleMatrix) </dt>
<dd><p class="startdd">: #1215 #1328 this seems not to be an issue anymore. Document and remove code. </p>
<p class="enddd">#1328 This code may no longer be needed since all the operations in the following loop may apply only to local elements. MatSetValue and VecSetValue are not collective... </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000041"></a> </p>
<dl>
<dt>Member <a class="el" href="classBidomainWithBathMatrixBasedAssembler.html#aeed8b1047eb7592dd0b0aac486f03c35">BidomainWithBathMatrixBasedAssembler::BidomainWithBathMatrixBasedAssembler</a> (AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; *pMesh, BidomainPde&lt; SPACE_DIM &gt; *pPde, BoundaryConditionsContainer&lt; ELEMENT_DIM, SPACE_DIM, 2 &gt; *pBcc, unsigned numQuadPoints=2) </dt>
<dd>#1063 at this point we'll have a <a class="el" href="classBidomainWithBathRhsMatrixAssembler.html">BidomainWithBathRhsMatrixAssembler</a> object and a <a class="el" href="classBidomainRhsMatrixAssembler.html">BidomainRhsMatrixAssembler</a> object in memory. This is a waste of memory since both construct and store a matrix for RHS assembly. </dd>
</dl>
<p><a class="anchor" id="_todo000043"></a> </p>
<dl>
<dt>Member <a class="el" href="classBidomainWithBathMatrixBasedAssembler.html#afa18f1eb05b51d305c85834443f60fc7">BidomainWithBathMatrixBasedAssembler::mpBidomainWithBathRhsMatrixAssembler</a>  </dt>
<dd>#1063 Once <a class="el" href="classBidomainWithBathRhsMatrixAssembler.html">BidomainWithBathRhsMatrixAssembler</a> inherits from <a class="el" href="classBidomainRhsMatrixAssembler.html">BidomainRhsMatrixAssembler</a> we'll be able to reuse the pointer in <a class="el" href="classBidomainMatrixBasedAssembler.html">BidomainMatrixBasedAssembler</a> </dd>
</dl>
<p><a class="anchor" id="_todo000042"></a> </p>
<dl>
<dt>Class <a class="el" href="classBidomainWithBathRhsMatrixAssembler.html">BidomainWithBathRhsMatrixAssembler&lt; DIM &gt;</a>  </dt>
<dd>#1063 make this class inherit from <a class="el" href="classBidomainRhsMatrixAssembler.html">BidomainRhsMatrixAssembler</a> </dd>
</dl>
<p><a class="anchor" id="_todo000128"></a> </p>
<dl>
<dt>Member <a class="el" href="classBoundaryConditionsContainer.html#a7a8ad2d7013bdea0bdef532efb3fa00f">BoundaryConditionsContainer::HasNeumannBoundaryCondition</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; *pSurfaceElement, unsigned indexOfUnknown=0) </dt>
<dd><p class="startdd">#1321 This is a horrendously inefficient fix. Perhaps have flag in element object?</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000127"></a> </p>
<dl>
<dt>Class <a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;</a>  </dt>
<dd>#1321 Various operations are currently very inefficient - there is certainly scope for optimisation here! </dd>
</dl>
<p><a class="anchor" id="_todo000021"></a> </p>
<dl>
<dt>Member <a class="el" href="classCardiacElectroMechanicsProblem.html#a24920cefa1bf029e178f837470dedb07">CardiacElectroMechanicsProblem::CardiacElectroMechanicsProblem</a> (ContractionModel contractionModel, <a class="el" href="classTetrahedralMesh.html">TetrahedralMesh&lt; DIM, DIM &gt;</a> *pElectricsMesh, QuadraticMesh&lt; DIM &gt; *pMechanicsMesh, std::vector&lt; unsigned &gt; fixedMechanicsNodes, <a class="el" href="classAbstractCardiacCellFactory.html">AbstractCardiacCellFactory&lt; DIM &gt;</a> *pCellFactory, double endTime, double electricsPdeTimeStep, unsigned numElecTimeStepsPerMechTimestep, double contractionModelOdeTimeStep, std::string outputDirectory) </dt>
<dd>Cover these lines </dd>
</dl>
<p><a class="anchor" id="_todo000020"></a> </p>
<dl>
<dt>Member <a class="el" href="classCardiacElectroMechanicsProblem.html#a6f060578a8380d2aec80d3f9d3c4feb9">CardiacElectroMechanicsProblem::WriteWatchedLocationData</a> (double time, Vec voltage) </dt>
<dd>Improve efficiency of this method? </dd>
</dl>
<p><a class="anchor" id="_todo000022"></a> </p>
<dl>
<dt>Member <a class="el" href="classCardiacSimulationArchiver.html#af02c88ef857037f9bf109402604fac26">CardiacSimulationArchiver::Save</a> (PROBLEM_CLASS &amp;simulationToArchive, const std::string &amp;rDirectory, bool clearDirectory=true) </dt>
<dd>#1026 get a real version number! </dd>
</dl>
<p><a class="anchor" id="_todo000011"></a> </p>
<dl>
<dt>Member <a class="el" href="classCellProperties.html#a8a90b8eae0e383fd7df237da487a7859">CellProperties::CalculateActionPotentialDurations</a> (const double percentage) </dt>
<dd>#913 linear interpolation here too? </dd>
</dl>
<p><a class="anchor" id="_todo000005"></a> </p>
<dl>
<dt>Member <a class="el" href="classCML__noble__varghese__kohl__noble__1998__basic.html#a4c33b10ce090258e7db95e614fe86d71">CML_noble_varghese_kohl_noble_1998_basic::GetIIonic</a> () </dt>
<dd><p class="startdd">we need to + Check this scaling + Ask JonC to amend PyCml if necessary + Check other cell models</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000006"></a> </p>
<dl>
<dt>Member <a class="el" href="classCML__noble__varghese__kohl__noble__1998__basic__pe__lut.html#ad96a13d857f9f87de0f6039657b71cd6">CML_noble_varghese_kohl_noble_1998_basic_pe_lut::GetIIonic</a> () </dt>
<dd><p class="startdd">we need to + Check this scaling + Ask JonC to amend PyCml if necessary + Check other cell models</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000047"></a> </p>
<dl>
<dt>Member <a class="el" href="classColumnDataReader.html#a7bae0b42045724d4dfcda58315588bec">ColumnDataReader::mVariablesToColumns</a>  </dt>
<dd>Change int to unsigned? (#991) </dd>
</dl>
<p><a class="anchor" id="_todo000083"></a> </p>
<dl>
<dt>Member <a class="el" href="classDistributedTetrahedralMesh.html#a605ae53c176351d862a3ce2bdd6acb0c">DistributedTetrahedralMesh::ComputeMeshPartitioning</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader, std::set&lt; unsigned &gt; &amp;rNodesOwned, std::set&lt; unsigned &gt; &amp;rHaloNodesOwned, std::set&lt; unsigned &gt; &amp;rElementsOwned, std::vector&lt; unsigned &gt; &amp;rProcessorsOffset) </dt>
<dd>#1293 add a timing event for the partitioning </dd>
</dl>
<p><a class="anchor" id="_todo000084"></a> </p>
<dl>
<dt>Member <a class="el" href="classDistributedTetrahedralMesh.html#a32a12e026b6fd1c040e865fdaaf5f545">DistributedTetrahedralMesh::ConstructFromMeshReader</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader) </dt>
<dd>#1289 assert the node is not considered both owned and halo-owned. </dd>
</dl>
<p><a class="anchor" id="_todo000086"></a> </p>
<dl>
<dt>Member <a class="el" href="classElement.html#abf5c2bc4fb4db48d8108d04625075b21">Element::CalculatePsi</a> (<a class="el" href="classChastePoint.html">ChastePoint&lt; SPACE_DIM &gt;</a> testPoint) </dt>
<dd>#1326 This method shouldn't need a new Jacobian inverse for every Psi </dd>
</dl>
<p><a class="anchor" id="_todo000045"></a> </p>
<dl>
<dt>Class <a class="el" href="classException.html">Exception</a>  </dt>
<dd>Might we want this class to inherit from STL exceptions? </dd>
</dl>
<p><a class="anchor" id="_todo000138"></a> </p>
<dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#a291b4a2441a90b0605d41985269d7304">ExponentialMaterialLaw::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000140"></a> </p>
<dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#ab881ef4671b0a67d754c2b798d8d3ce6">ExponentialMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000139"></a> </p>
<dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#ac008235dc7dec5992da5b0141816e4b0">ExponentialMaterialLaw::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000136"></a> </p>
<dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#a7fd47d973750491f5d5356143870062a">ExponentialMaterialLaw::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000137"></a> </p>
<dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#a4af9764dba9d79966ffc9e0c0c59a416">ExponentialMaterialLaw::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000023"></a> </p>
<dl>
<dt>Member <a class="el" href="classGeneralPlaneStimulusCellFactory.html#a468ee9de3791785b366e7dbe496e7b05">GeneralPlaneStimulusCellFactory::GeneralPlaneStimulusCellFactory</a> (unsigned numEleAcross, double meshWidth, bool useMeshWidthAsMag=false, double stimulusMagnitude=-1e7, double stimulusDuration=0.5) </dt>
<dd><p class="startdd">The useMeshWidth is temporary, while we are sorting out 3D stimulus. It is to be removed later (along with StimulusConvergenceTester) scale stimulus depending on space_step of elements</p>
<p></p>
<p>It looks like the value of the stimulus is specific to 3D</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000050"></a> </p>
<dl>
<dt>Class <a class="el" href="classHdf5DataReader.html">Hdf5DataReader</a>  </dt>
<dd>: magic number </dd>
</dl>
<p><a class="anchor" id="_todo000049"></a> </p>
<dl>
<dt>Member <a class="el" href="classHdf5DataReader.html#ab53e22d9e173efd32ded2281eea4c971">Hdf5DataReader::Close</a> () </dt>
<dd>: move code to the destructor??? </dd>
</dl>
<p><a class="anchor" id="_todo000048"></a> </p>
<dl>
<dt>Member <a class="el" href="classHdf5DataReader.html#a859ef71cd53870bd08d77abc83e575b5">Hdf5DataReader::GetVariableOverNodes</a> (Vec data, const std::string &amp;rVariableName, unsigned timestep=0) </dt>
<dd>Use <a class="el" href="classDistributedVector.html">DistributedVector</a>? </dd>
</dl>
<p><a class="anchor" id="_todo000051"></a> </p>
<dl>
<dt>Member <a class="el" href="classHdf5DataReader.html#aafd7eea581b860ca7212b0b4c30c8969">Hdf5DataReader::MAX_DATASET_RANK</a>  </dt>
<dd>: define it once </dd>
</dl>
<p><a class="anchor" id="_todo000054"></a> </p>
<dl>
<dt>Member <a class="el" href="classHdf5DataWriter.html#a3c70b9b18ab0dec566bb5709391bc5ae">Hdf5DataWriter::DATASET_DIMS</a>  </dt>
<dd>: define it once </dd>
</dl>
<p><a class="anchor" id="_todo000052"></a> </p>
<dl>
<dt>Member <a class="el" href="classHdf5DataWriter.html#ac243765e7b041a9bf3be21c8ec1849cb">Hdf5DataWriter::Hdf5DataWriter</a> (<a class="el" href="classDistributedVectorFactory.html">DistributedVectorFactory</a> &amp;rVectorFactory, const std::string &amp;rDirectory, const std::string &amp;rBaseName, bool cleanDirectory=true, bool extendData=false) </dt>
<dd>1300 We can't set mDataFixedDimensionSize, because the information isn't in the input file. This means that checking the size of input vectors in PutVector and PutStripedVector is impossible. </dd>
</dl>
<p><a class="anchor" id="_todo000053"></a> </p>
<dl>
<dt>Member <a class="el" href="classHdf5DataWriter.html#a9fcd06f1bb1e2d6ef8a17eaec354a636">Hdf5DataWriter::PutStripedVector</a> (int firstVariableID, int secondVariableID, Vec petscVector) </dt>
<dd>Use distributed vector functionality here? </dd>
</dl>
<p><a class="anchor" id="_todo000031"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#a1d87ceebdd23866393deaad3e8ffc1cc">HeartConfig::GetCellHeterogeneities</a> (std::vector&lt; AbstractChasteRegion&lt; DIM &gt; * &gt; &amp;rCellHeterogeneityRegions, std::vector&lt; double &gt; &amp;rScaleFactorGks, std::vector&lt; double &gt; &amp;rScaleFactorIto, std::vector&lt; double &gt; &amp;rScaleFactorGkr) </dt>
<dd><p class="startdd">- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </p>
<p class="enddd">There is no set method </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000033"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#a46798fe1a461e288e8c5a96bc62ee695">HeartConfig::GetConductivityHeterogeneities</a> (std::vector&lt; ChasteCuboid&lt; DIM &gt; &gt; &amp;conductivitiesHeterogeneityAreas, std::vector&lt; c_vector&lt; double, 3 &gt; &gt; &amp;intraConductivities, std::vector&lt; c_vector&lt; double, 3 &gt; &gt; &amp;extraConductivities) const  </dt>
<dd><p class="startdd">- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </p>
<p class="enddd">When this is implemented, then we require an example in ChasteParametersFullFormat.xml </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000025"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#a52a6c8732dadbb923dd233dada799e81">HeartConfig::GetIonicModelRegions</a> (std::vector&lt; ChasteCuboid&lt; DIM &gt; &gt; &amp;rDefinedRegions, std::vector&lt; cp::ionic_model_selection_type &gt; &amp;rIonicModels) const  </dt>
<dd>When this is implemented, then we require an example in ChasteParametersFullFormat.xml </dd>
</dl>
<p><a class="anchor" id="_todo000028"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#aca214e0a3a7aefaa8694e602a6346dc7">HeartConfig::GetSlabDimensions</a> (c_vector&lt; double, 3 &gt; &amp;slabDimensions) const  </dt>
<dd>IsMeshProvided and GetLoadMesh are subtly different but very similar. Can one of them go? </dd>
</dl>
<p><a class="anchor" id="_todo000029"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#a3e7bfaab40d27a13d56a67e0c4c202ae">HeartConfig::GetStimuli</a> (std::vector&lt; boost::shared_ptr&lt; SimpleStimulus &gt; &gt; &amp;rStimuliApplied, std::vector&lt; ChasteCuboid&lt; DIM &gt; &gt; &amp;rStimulatedAreas) const  </dt>
<dd><p class="startdd">- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </p>
<p class="enddd">There is no set method </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000035"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#a994cb2f7b3edc1c45ba43fc967a98a8a">HeartConfig::SetBathConductivity</a> (double bathConductivity) </dt>
<dd>Is this used anywhere? </dd>
</dl>
<p><a class="anchor" id="_todo000027"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#a165a75e6d71355cfcea146b578a02969">HeartConfig::SetIonicModelRegions</a> (std::vector&lt; ChasteCuboid&lt; 3 &gt; &gt; &amp;rDefinedRegions, std::vector&lt; cp::ionic_model_selection_type &gt; &amp;rIonicModels) const  </dt>
<dd>will this break if the user parameters don't include an IonicModels element? </dd>
</dl>
<p><a class="anchor" id="_todo000037"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#a329e1bfc5785247315fdd4459afd4312">HeartConfig::SetMaxUpstrokeVelocityMaps</a> (std::vector&lt; double &gt; &amp;maxUpstrokeVelocityMaps) </dt>
<dd>improve the description of threshold) with respect to which the upstroke velocity maps are calculated. </dd>
</dl>
<p><a class="anchor" id="_todo000034"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#adc7f04b8d3bdf6a734c45fd57ffbd16d">HeartConfig::SetMeshFileName</a> (std::string meshPrefix, cp::media_type fibreDefinition=cpmedia_type::NoFibreOrientation) </dt>
<dd>There is no Get method </dd>
</dl>
<p><a class="anchor" id="_todo000036"></a> </p>
<dl>
<dt>Member <a class="el" href="classHeartConfig.html#abba0cb5ca22b68dcaadc87ac24aab8ba">HeartConfig::SetUpstrokeTimeMaps</a> (std::vector&lt; double &gt; &amp;upstrokeTimeMaps) </dt>
<dd>improve the description of threshold) with respect to which the upstroke time maps are calculated. </dd>
</dl>
<p><a class="anchor" id="_todo000164"></a> </p>
<dl>
<dt>Class <a class="el" href="classLabelledCellMutationState.html">LabelledCellMutationState</a>  </dt>
<dd>Fixing this is part of #1285. </dd>
</dl>
<p><a class="anchor" id="_todo000056"></a> </p>
<dl>
<dt>Member <a class="el" href="classLinearSystem.html#a2af90d2cac0e92fba7c098fc15a8c468">LinearSystem::LinearSystem</a> (PetscInt lhsVectorSize, MatType matType=(MatType) MATMPIAIJ) </dt>
<dd><p class="startdd">: if we create a linear system object outside a cardiac assembler, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </p>
<p>: if we create a linear system object outside a cardiac assembler, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </p>
<p class="enddd">: if we create a linear system object outside a cardiac assembler, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000063"></a> </p>
<dl>
<dt>Member <a class="el" href="classLinearSystem.html#a5e6afa86b789aba62eba01d8eadeb198">LinearSystem::mOwnershipRangeLo</a>  </dt>
<dd>Verify claim that ownership range for Vec and Mat is same. This should only matter for efficiency if the claim is false. </dd>
</dl>
<p><a class="anchor" id="_todo000060"></a> </p>
<dl>
<dt>Member <a class="el" href="classLinearSystem.html#a10c3dac3140195854ab2cd72f7b3a8be">LinearSystem::SetMatrixIsSymmetric</a> (bool isSymmetric=true) </dt>
<dd>: shall we allow modifying the symmetry flag anytime? </dd>
</dl>
<p><a class="anchor" id="_todo000061"></a> </p>
<dl>
<dt>Member <a class="el" href="classLinearSystem.html#a7cf2cdd65608f5cd83990c96ec8815ea">LinearSystem::Solve</a> (Vec lhsGuess=NULL) </dt>
<dd><p class="startdd">never tested in linalg component </p>
<p class="enddd">Should it be compulsory for the caller to supply this and manage the memory? </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000059"></a> </p>
<dl>
<dt>Member <a class="el" href="classLinearSystem.html#ae4aa80d347b07a6377607349eb334819">LinearSystem::~LinearSystem</a> () </dt>
<dd>Never tested in linalg component </dd>
</dl>
<p><a class="anchor" id="_todo000167"></a> </p>
<dl>
<dt>Member <a class="el" href="classMeshBasedTissue.html#a6b13bb7d9ba4d50ee35ef098262f7c00">MeshBasedTissue::SetOutputTissueAreas</a> (bool writeTissueAreas) </dt>
<dd><p class="startdd">Extend this to 3D (possibly rename to SetOutputTissueVolumes?) - see also #738</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000165"></a> </p>
<dl>
<dt>Member <a class="el" href="classMeshBasedTissue.html#a7b5dbd27ed0c94251b0367b971fe38e2">MeshBasedTissue::WriteResultsToFiles</a> () </dt>
<dd><p class="startdd">implement writing of tissue/cell lengths in 1D (see also #738) </p>
<p class="enddd">implement writing of tissue/cell volumes in 3D (see also #738) </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000143"></a> </p>
<dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#a16002ef8753f56e75545c07f2a079209">MooneyRivlinMaterialLaw::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000145"></a> </p>
<dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#aa6ef7d8e0134db35cf1f590358a17890">MooneyRivlinMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000144"></a> </p>
<dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#aa8da1807bcbb6d337d55d0e670cdb4e1">MooneyRivlinMaterialLaw::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000141"></a> </p>
<dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#a6d55482ffc8a243cd9fd2399d9713035">MooneyRivlinMaterialLaw::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000142"></a> </p>
<dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#a84b7f95aed9c199fabcdeefa282f68e5">MooneyRivlinMaterialLaw::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000090"></a> </p>
<dl>
<dt>Member <a class="el" href="classMutableMesh.html#a3e67b3b6fe1bdd5487a8a2976d810262">MutableMesh::CheckIsVoronoi</a> (double maxPenetration=0.0) </dt>
<dd><p class="startdd">use ElementIterator here? </p>
<p class="enddd">Should use a set union operation here </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000087"></a> </p>
<dl>
<dt>Member <a class="el" href="classMutableMesh.html#a20f735bf3837b082929ca010bb2f1a1e">MutableMesh::ReMesh</a> (<a class="el" href="classNodeMap.html">NodeMap</a> &amp;map) </dt>
<dd><p class="startdd">communicate the length first </p>
<p class="enddd">use EXPECT0 here </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000091"></a> </p>
<dl>
<dt>Member <a class="el" href="classMutableMesh.html#ac241ad1e4d5c57f0201a22678d082d51">MutableMesh::RescaleMeshFromBoundaryNode</a> (ChastePoint&lt; 1 &gt; updatedPoint, unsigned boundaryNodeIndex) </dt>
<dd>should unsigned GetNumBoundaryNodes() be overloaded too?? </dd>
</dl>
<p><a class="anchor" id="_todo000157"></a> </p>
<dl>
<dt>Class <a class="el" href="classNonlinearElasticityAssembler.html">NonlinearElasticityAssembler&lt; DIM &gt;</a>  </dt>
<dd>: factor out Dof handling? </dd>
</dl>
<p><a class="anchor" id="_todo000126"></a> </p>
<dl>
<dt>Member <a class="el" href="classOdeSystemInformation.html#a290a58619ebad70ded740c148df3ad9d">OdeSystemInformation::mpInstance</a>  </dt>
<dd>see if using weak_ptr would work and give funkier semantics (automatically destroy the singleton when no ODE systems were using it) </dd>
</dl>
<p><a class="anchor" id="_todo000046"></a> </p>
<dl>
<dt>Member <a class="el" href="classOutputFileHandler.html#a1350bb879fe97e11a9481c008fb97d7b">OutputFileHandler::MakeFoldersAndReturnFullPath</a> (const std::string &amp;rDirectory) </dt>
<dd>Put the Chaste signature file in all folders we have created </dd>
</dl>
<p><a class="anchor" id="_todo000044"></a> </p>
<dl>
<dt>Class <a class="el" href="structpack_3_01void_07T_08_4.html">pack&lt; void(T)&gt;</a>  </dt>
<dd>Check if we need this on Boost&gt;=1.38. Even if it's not needed there, we might still need it to load 1.33.1 archives. </dd>
</dl>
<p><a class="anchor" id="_todo000055"></a> </p>
<dl>
<dt>Member <a class="el" href="classParallelColumnDataWriter.html#a579406de3c0e29243d592ffdf3f6580c">ParallelColumnDataWriter::PutVectorStripe</a> (int variableId, <a class="el" href="classDistributedVector_1_1Stripe.html">DistributedVector::Stripe</a> &amp;rStripe) </dt>
<dd>allow this to be a const-reference </dd>
</dl>
<p><a class="anchor" id="_todo000065"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCBlockDiagonal_1_1PCBlockDiagonalContext.html#a00d0bde63d57499a3be7615afee22e0b">PCBlockDiagonal::PCBlockDiagonalContext::A11_matrix_subblock</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000066"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCBlockDiagonal_1_1PCBlockDiagonalContext.html#a6efafce9e8e1d3f941a1e91094ed61e4">PCBlockDiagonal::PCBlockDiagonalContext::A22_matrix_subblock</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000067"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCBlockDiagonal_1_1PCBlockDiagonalContext.html#ab30e41636edc4227f32664e633811735">PCBlockDiagonal::PCBlockDiagonalContext::PC_amg_A11</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000068"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCBlockDiagonal_1_1PCBlockDiagonalContext.html#a6004045452c8c19a26aedce6e95743dd">PCBlockDiagonal::PCBlockDiagonalContext::PC_amg_A22</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000070"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCLDUFactorisation_1_1PCLDUFactorisationContext.html#a470c1ffe92d057de6e3617cf4cb2c1b9">PCLDUFactorisation::PCLDUFactorisationContext::A11_matrix_subblock</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000071"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCLDUFactorisation_1_1PCLDUFactorisationContext.html#a8a24caeb852f1927a96b13daff80b332">PCLDUFactorisation::PCLDUFactorisationContext::A22_matrix_subblock</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000072"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCLDUFactorisation_1_1PCLDUFactorisationContext.html#ad99e80c57dc7371e2a3805f57751f688">PCLDUFactorisation::PCLDUFactorisationContext::B_matrix_subblock</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000073"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCLDUFactorisation_1_1PCLDUFactorisationContext.html#aa457cd5770a3fd29b7678718d8dbbb8a">PCLDUFactorisation::PCLDUFactorisationContext::PC_amg_A11</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000074"></a> </p>
<dl>
<dt>Member <a class="el" href="structPCLDUFactorisation_1_1PCLDUFactorisationContext.html#a89466aa004f0e1a893e555c238d6ec84">PCLDUFactorisation::PCLDUFactorisationContext::PC_amg_A22</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p><a class="anchor" id="_todo000148"></a> </p>
<dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#a144746018624f7de4def2a1b669100fb">PolynomialMaterialLaw3d::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000150"></a> </p>
<dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#ab8707e90ba8823d0b34ee7aaa9f7b987">PolynomialMaterialLaw3d::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000149"></a> </p>
<dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#af877b2e196146b36438bfcee79552f87">PolynomialMaterialLaw3d::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000146"></a> </p>
<dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#a8924263fd2f64b16d5c9074d40142669">PolynomialMaterialLaw3d::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000147"></a> </p>
<dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#a1aabede19af92507752a4ddcb58311ff">PolynomialMaterialLaw3d::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd><p class="startdd">The name of this method should not include underscores.</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000012"></a> </p>
<dl>
<dt>Member <a class="el" href="classPostProcessingWriter.html#abdb67a953b0778e2fac1afb6b5750b40">PostProcessingWriter::WriteAboveThresholdDepolarisationFile</a> (double threshold) </dt>
<dd><p class="startdd">This method ought to be private and called by the WritePostProcessingFiles method if the user requests for it. This will be possible after modifying the schema and specifying Get and Set methods in <a class="el" href="classHeartConfig.html">HeartConfig</a> to check whetehr the user wants this file or not</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000095"></a> </p>
<dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#a381423743a648ba7e155c20d09b3c717">QuadraticMesh::HelperMethod1</a> (unsigned boundaryElemNode0, unsigned boundaryElemNode1, Element&lt; DIM, DIM &gt; *pElement, unsigned node0, unsigned node1, unsigned node2, unsigned &amp;rOffset, bool &amp;rReverse) </dt>
<dd><p class="startdd">document these parameters</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000096"></a> </p>
<dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#a3ef05dfe611ac8d2f84a7d9dc9de2164">QuadraticMesh::HelperMethod2</a> (<a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; DIM-1, DIM &gt; *pBoundaryElement, Element&lt; DIM, DIM &gt; *pElement, unsigned internalNode0, unsigned internalNode1, unsigned internalNode2, unsigned offset, bool reverse) </dt>
<dd><p class="startdd">document these parameters</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000092"></a> </p>
<dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#a994fe7d9ec5250fdfdbaa7659cc7dc67">QuadraticMesh::RunMesherAndReadMesh</a> (std::string binary, std::string outputDir, std::string fileStem) </dt>
<dd>: Could use the '-nn' flag when calling tetgen and then face file would have containing element info and second false </dd>
</dl>
<p><a class="anchor" id="_todo000130"></a> </p>
<dl>
<dt>Member <a class="el" href="classQuadraturePointsGroup.html#a6a8f637e49dffb46a6a36e24b1e2700c">QuadraturePointsGroup::Get</a> (unsigned i) </dt>
<dd><p class="startdd">this method should be renamed rGet() as it returns a reference</p>
<p></p>
<p>this method should be renamed rGet() as it returns a reference</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000158"></a> </p>
<dl>
<dt>Member <a class="el" href="classSimpleNonlinearEllipticAssembler.html#a3e8a46013b0697b9f9c60597e688171b">SimpleNonlinearEllipticAssembler::ComputeMatrixTerm</a> (c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, <a class="el" href="classChastePoint.html">ChastePoint&lt; SPACE_DIM &gt;</a> &amp;rX, c_vector&lt; double, 1 &gt; &amp;rU, c_matrix&lt; double, 1, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement) </dt>
<dd>#1298 Should these be SPACE_DIM?? </dd>
</dl>
<p><a class="anchor" id="_todo000159"></a> </p>
<dl>
<dt>Class <a class="el" href="classSimpleNonlinearEllipticAssembler.html">SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>  </dt>
<dd>[old todo, maybe not true anymore after refactor(?)] #1298 This class could do with some tidying. More (3D) tests are also needed. It probably needs re-writing to take advantage of parallel machines. </dd>
</dl>
<p><a class="anchor" id="_todo000097"></a> </p>
<dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#a7c9b901ad6fc93772e8d6e854a6adf12">TetrahedralMesh::GetContainingElementIndex</a> (<a class="el" href="classChastePoint.html">ChastePoint&lt; SPACE_DIM &gt;</a> testPoint, bool strict=false, std::set&lt; unsigned &gt; testElements=stdset&lt; unsigned &gt;(), bool onlyTryWithTestElements=false) </dt>
<dd><p class="startdd">#1299 What if the element is deleted? </p>
<p>#1299 Polling every element is unnecessary. We ought to start from a likely place and hill climb </p>
<p class="enddd">#1299 What if the element is deleted? </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000100"></a> </p>
<dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#a61994e0e5e493b1fb28f7b7b3a6b9847">TetrahedralMesh::GetContainingElementIndexWithInitialGuess</a> (<a class="el" href="classChastePoint.html">ChastePoint&lt; SPACE_DIM &gt;</a> testPoint, unsigned startingElementGuess, bool strict=false) </dt>
<dd>#1299 What if the element is deleted? </dd>
</dl>
<p><a class="anchor" id="_todo000104"></a> </p>
<dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#acd338a5d9350f042df2d7bc369b9e9f2">TetrahedralMesh::GetContainingElementIndices</a> (<a class="el" href="classChastePoint.html">ChastePoint&lt; SPACE_DIM &gt;</a> testPoint) </dt>
<dd>#1299 What if the element is deleted? </dd>
</dl>
<p><a class="anchor" id="_todo000101"></a> </p>
<dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#ac4d26bb52e22df8148267eb1f762b30e">TetrahedralMesh::GetNearestElementIndex</a> (<a class="el" href="classChastePoint.html">ChastePoint&lt; SPACE_DIM &gt;</a> testPoint) </dt>
<dd><p class="startdd">#1299 This ought to return a set of all elements that contain the point (if the point is a node in the mesh then it's contained in multiple elements) </p>
<p>#1299 Polling every element is unnecessary. We ought to start from a likely place and hill climb </p>
<p class="enddd">#1299 What if the element is deleted? </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000160"></a> </p>
<dl>
<dt>Member <a class="el" href="classTissueConfig.html#a3886f584363f15eb3450e55b286ca62b">TissueConfig::Reset</a> () </dt>
<dd><p class="startdd">Fix this comment (see also #1294) mMembraneSurfaceEnergyParameter has ? units </p>
<p>Fix this comment (see also #1294) mCellCellAdhesionEnergyParameter has ? units </p>
<p>Fix this comment (see also #1294) mCellBoundaryAdhesionEnergyParameter has ? units </p>
<p>Fix this comment (see also #1294) mWelikyOsterAreaParameter has ? units </p>
<p>Fix this comment (see also #1294) mWelikyOsterPerimeterParameter has ? units </p>
<p class="enddd">Fix this comment (see also #1294) </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000161"></a> </p>
<dl>
<dt>Member <a class="el" href="classTissueSimulation.html#a12c88938bcebace4be1fe6bfd7818115">TissueSimulation::CalculateCellDivisionVector</a> (<a class="el" href="classTissueCell.html">TissueCell</a> &amp;rParentCell) </dt>
<dd>Could remove this dynamic_cast by moving the code block below into <a class="el" href="classAbstractCellCentreBasedTissue.html#a6c2f269dcb30c699889c0bd5a9da339c">AbstractCellCentreBasedTissue::AddCell()</a>, allowing it to be overruled by this method when overridden in subclasses. See also comment on #1093. </dd>
</dl>
<p><a class="anchor" id="_todo000105"></a> </p>
<dl>
<dt>Member <a class="el" href="classTrianglesMeshReader.html#a869d21887156901cb08629673b3d2123">TrianglesMeshReader::OpenNodeFile</a> () </dt>
<dd>Change name to OpenNodesFile for consistency with OpenElementsFile and OpenFacesFile? (#991) </dd>
</dl>
<p><a class="anchor" id="_todo000107"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexElement.html#a598888e0b9abacbfe69ae246c465bc0c">VertexElement::GetNodeLocalIndex</a> (unsigned globalIndex) </dt>
<dd><p class="startdd">This method could be moved to the AbstactElement class (#1304)</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000106"></a> </p>
<dl>
<dt>Class <a class="el" href="classVertexElement_3_011_00_01SPACE__DIM_01_4.html">VertexElement&lt; 1, SPACE_DIM &gt;</a>  </dt>
<dd>Move implementation into .cpp file? (#1304) </dd>
</dl>
<p><a class="anchor" id="_todo000108"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexElement_3_011_00_01SPACE__DIM_01_4.html#a584cec6aacf53641935dcfad73e8fafe">VertexElement&lt; 1, SPACE_DIM &gt;::GetNodeLocalIndex</a> (unsigned globalIndex) </dt>
<dd><p class="startdd">This method could be moved to the AbstactElement class (#1304)</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000113"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMesh.html#a960d5ba4f473f957b16c529bd128fa66">VertexMesh::GetAreaOfFace</a> (<a class="el" href="classVertexElement.html">VertexElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; *pFace) </dt>
<dd>reduce code duplication with GetAreaOfElement() method (see #1283 and #1276) </dd>
</dl>
<p><a class="anchor" id="_todo000111"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMesh.html#ac3b1ef99d19e007c3ba87c816f90605b">VertexMesh::GetCentroidOfElement</a> (unsigned index) </dt>
<dd>Why isn't this just the centre of mass? (#1075) </dd>
</dl>
<p><a class="anchor" id="_todo000109"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMesh.html#aa68094c8ce3b6176406c98afd7ba31b5">VertexMesh::GetEdgeLength</a> (unsigned elementIndex1, unsigned elementIndex2) </dt>
<dd>Move this bit of code into <a class="el" href="classLinearSpringWithVariableSpringConstantsForce.html#a06cf34ce0593d5a1cd4ccc1a37c3b726">LinearSpringWithVariableSpringConstantsForce::VariableSpringConstantMultiplicationFactor()</a> and make use of IsGhostNode() (#1075) </dd>
</dl>
<p><a class="anchor" id="_todo000112"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMesh.html#a345d1535d342c95c5e88db536500cb11">VertexMesh::GetNeighbouringNodeNotAlsoInElement</a> (unsigned nodeIndex, unsigned elemIndex) </dt>
<dd>We should probably assert here that the node is in fact contained in the element (#1305) </dd>
</dl>
<p><a class="anchor" id="_todo000114"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMesh.html#aab3099ea7fe1138f92fd7bac8883f89a">VertexMesh::GetShortAxisOfElement</a> (unsigned index) </dt>
<dd><p class="startdd">This method is only called inside DivideElementAlongShortAxis() - get rid of it and move the code into that method? (#1276)</p>
<p class="enddd"></p>
</dd>
</dl>
<p><a class="anchor" id="_todo000110"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMesh.html#a370e77ce6f980e559fb84c0e94001e4b">VertexMesh::SolveBoundaryElementMapping</a> (unsigned index) const  </dt>
<dd>sort out boundary elements in a vertex mesh (#943) </dd>
</dl>
<p><a class="anchor" id="_todo000115"></a> </p>
<dl>
<dt>Class <a class="el" href="classVertexMesh_1_1VertexElementIterator.html">VertexMesh&lt; ELEMENT_DIM, SPACE_DIM &gt;::VertexElementIterator</a>  </dt>
<dd>This is the same as in <a class="el" href="classAbstractTetrahedralMesh.html">AbstractTetrahedralMesh</a> (#1276) </dd>
</dl>
<p><a class="anchor" id="_todo000117"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMeshReader.html#af5f354ca7f6b4889a66a9e2015b8f471">VertexMeshReader::GetNextFaceData</a> () </dt>
<dd>Implement this method (#1076) </dd>
</dl>
<p><a class="anchor" id="_todo000118"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMeshReader.html#a4caeef6f49a41e4ef230685689c9187c">VertexMeshReader::GetNumEdges</a> () const  </dt>
<dd>Implement this method (#1076) </dd>
</dl>
<p><a class="anchor" id="_todo000116"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMeshReader.html#a6ac1f3b48f16070ae291e0a02cf87e19">VertexMeshReader::GetNumFaces</a> () const  </dt>
<dd>Implement this method (#1076) </dd>
</dl>
<p><a class="anchor" id="_todo000120"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#a7b70f3e874b4a7111fcb9ba36c26aa3d">VertexMeshWriter::WriteFiles</a> () </dt>
<dd>need to think about how best to do this in 3D (#866, #1076) </dd>
</dl>
<p><a class="anchor" id="_todo000121"></a> </p>
<dl>
<dt>Member <a class="el" href="classVertexMeshWriter.html#ad0255a5990c2ed45d592fabfd86baa3f">VertexMeshWriter::WriteFilesUsingMesh</a> (VertexMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMesh) </dt>
<dd><p class="startdd">Mesh should be const (#1076) </p>
<p class="enddd">Mesh should be const (#1076) </p>
</dd>
</dl>
<p><a class="anchor" id="_todo000122"></a> </p>
<dl>
<dt>Member <a class="el" href="classVoronoiTessellation.html#ac8f299bc9ae73972fef79ebf36add4c0">VoronoiTessellation::GetNumFaces</a> () const  </dt>
<dd>If mLocationIndices is not empty, then should this return mLocationIndices.size()? See also #1257. </dd>
</dl>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.2 </small></address>
</body>
</html>
