<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Chaste: AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; Class Template Reference</h1><!-- doxytag: class="AbstractAssembler" --><code>#include &lt;<a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;:</div>
<div class="dynsection">
<p><center><img src="classAbstractAssembler__inherit__graph.png" border="0" usemap="#AbstractAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="AbstractAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_01_4__inherit__map">
<area shape="rect" href="classAbstractDynamicAssemblerMixin.html" title="{AbstractDynamicAssemblerMixin\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|# mTstart\l# mTend\l# mDt\l# mDtInverse\l# mTimesSet\l# mInitialCondition\l# mMatrixIsAssembled\l# mMatrixIsConstant\l# mUseMatrixBasedRhsAssembly\l# mpMatrixForMatrixBasedRhsAssembly\l# mVectorForMatrixBasedRhsAssembly\l|+ AbstractDynamicAssemblerMixin()\l+ SetTimes()\l+ SetInitialCondition()\l+ SetMatrixIsConstant()\l+ SetMatrixIsNotAssembled()\l+ Solve()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l# DoMatrixBasedRhsAssembly()\l}" alt="" coords="639,516,1169,887"><area shape="rect" href="classAbstractDynamicAssemblerMixin.html" title="{AbstractDynamicAssemblerMixin\&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|# mTstart\l# mTend\l# mDt\l# mDtInverse\l# mTimesSet\l# mInitialCondition\l# mMatrixIsAssembled\l# mMatrixIsConstant\l# mUseMatrixBasedRhsAssembly\l# mpMatrixForMatrixBasedRhsAssembly\l# mVectorForMatrixBasedRhsAssembly\l|+ AbstractDynamicAssemblerMixin()\l+ SetTimes()\l+ SetInitialCondition()\l+ SetMatrixIsConstant()\l+ SetMatrixIsNotAssembled()\l+ Solve()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l# DoMatrixBasedRhsAssembly()\l}" alt="" coords="229,954,736,1324"><area shape="rect" href="classAbstractDynamicAssemblerMixin.html" title="{AbstractDynamicAssemblerMixin\&lt; ELEMENT_DIM, SPACE_DIM, 1 \&gt;\n|# mTstart\l# mTend\l# mDt\l# mDtInverse\l# mTimesSet\l# mInitialCondition\l# mMatrixIsAssembled\l# mMatrixIsConstant\l# mUseMatrixBasedRhsAssembly\l# mpMatrixForMatrixBasedRhsAssembly\l# mVectorForMatrixBasedRhsAssembly\l|+ AbstractDynamicAssemblerMixin()\l+ SetTimes()\l+ SetInitialCondition()\l+ SetMatrixIsConstant()\l+ SetMatrixIsNotAssembled()\l+ Solve()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l# DoMatrixBasedRhsAssembly()\l}" alt="" coords="1877,1351,2325,1722"><area shape="rect" href="classAbstractDynamicAssemblerMixin.html" title="{AbstractDynamicAssemblerMixin\&lt; ELEMENT_DIM, SPACE_DIM, 2 \&gt;\n|# mTstart\l# mTend\l# mDt\l# mDtInverse\l# mTimesSet\l# mInitialCondition\l# mMatrixIsAssembled\l# mMatrixIsConstant\l# mUseMatrixBasedRhsAssembly\l# mpMatrixForMatrixBasedRhsAssembly\l# mVectorForMatrixBasedRhsAssembly\l|+ AbstractDynamicAssemblerMixin()\l+ SetTimes()\l+ SetInitialCondition()\l+ SetMatrixIsConstant()\l+ SetMatrixIsNotAssembled()\l+ Solve()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l# DoMatrixBasedRhsAssembly()\l}" alt="" coords="536,1351,984,1722"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="5652,532,6132,871"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler\&lt; ELEM_DIM, SPACE_DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="4695,970,5657,1308"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="9159,970,9751,1308"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="7417,970,8292,1308"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="3228,970,4671,1308"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="1065,970,1996,1308"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="6351,970,7393,1308"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="9775,970,10711,1308"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="2071,970,3204,1308"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ GetLinearSystem()\l+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# ComputeTransformedBasisFunctionDerivatives()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="8316,970,9135,1308"><area shape="rect" href="classSimpleDg0ParabolicAssembler.html" title="{SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l&#45; mpParabolicPde\l|+ SimpleDg0ParabolicAssembler()\l+ PrepareForSolve()\l+ Solve()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l}" alt="" coords="2256,2312,2835,2531"><area shape="rect" href="classSimpleDg0ParabolicAssembler.html" title="{SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, false, MonodomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l&#45; mpParabolicPde\l|+ SimpleDg0ParabolicAssembler()\l+ PrepareForSolve()\l+ Solve()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l}" alt="" coords="2125,2851,2965,3070"><area shape="rect" href="classMonodomainDg0Assembler.html" title="{MonodomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mSourceTerm\l# mpMonodomainPde\l|+ MonodomainDg0Assembler()\l+ ~MonodomainDg0Assembler()\l# ComputeVectorTerm()\l# ResetInterpolatedQuantities()\l# IncrementInterpolatedQuantities()\l# PrepareForAssembleSystem()\l# InitialiseForSolve()\l}" alt="" coords="2345,3248,2745,3502"><area shape="rect" href="classMonodomainMatrixBasedAssembler.html" title="{MonodomainMatrixBasedAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|# mpMonodomainRhsMatrixAssembler\l|+ MonodomainMatrixBasedAssembler()\l+ ~MonodomainMatrixBasedAssembler()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l}" alt="" coords="2320,3552,2771,3670"><area shape="rect" href="classBidomainDg0Assembler.html" title="{BidomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mpBidomainPde\l# mpConfig\l# mIionic\l# mIIntracellularStimulus\l# mIExtracellularStimulus\l# mNullSpaceCreated\l# mFixedExtracellularPotentialNodes\l# mRowForAverageOfPhiZeroed\l|+ BidomainDg0Assembler()\l+ ~BidomainDg0Assembler()\l+ SetFixedExtracellularPotentialNodes()\l+ SetRowForAverageOfPhiZeroed()\l# ResetInterpolatedQuantities()\l# InitialiseForSolve()\l# IncrementInterpolatedQuantities()\l# CheckCompatibilityCondition()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l# PrepareForAssembleSystem()\l# FinaliseAssembleSystem()\l# GenerateNullBasis()\l}" alt="" coords="953,2184,1329,2659"><area shape="rect" href="classBidomainDg0Assembler.html" title="{BidomainDg0Assembler\&lt; DIM, DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mpBidomainPde\l# mpConfig\l# mIionic\l# mIIntracellularStimulus\l# mIExtracellularStimulus\l# mNullSpaceCreated\l# mFixedExtracellularPotentialNodes\l# mRowForAverageOfPhiZeroed\l|+ BidomainDg0Assembler()\l+ ~BidomainDg0Assembler()\l+ SetFixedExtracellularPotentialNodes()\l+ SetRowForAverageOfPhiZeroed()\l# ResetInterpolatedQuantities()\l# InitialiseForSolve()\l# IncrementInterpolatedQuantities()\l# CheckCompatibilityCondition()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l# PrepareForAssembleSystem()\l# FinaliseAssembleSystem()\l# GenerateNullBasis()\l}" alt="" coords="639,2723,913,3198"><area shape="rect" href="classBidomainMatrixBasedAssembler.html" title="{BidomainMatrixBasedAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|# mpBidomainRhsMatrixAssembler\l|+ BidomainMatrixBasedAssembler()\l+ ~BidomainMatrixBasedAssembler()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l}" alt="" coords="1369,2902,1799,3019"><area shape="rect" href="classBidomainWithBathAssembler.html" title="{BidomainWithBathAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n||+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ FinaliseLinearSystem()\l+ BidomainWithBathAssembler()\l}" alt="" coords="937,2894,1345,3027"><area shape="rect" href="classBidomainWithBathMatrixBasedAssembler.html" title="{BidomainWithBathMatrixBasedAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|# mpBidomainWithBathRhsMatrixAssembler\l|+ BidomainWithBathMatrixBasedAssembler()\l+ ~BidomainWithBathMatrixBasedAssembler()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l}" alt="" coords="1069,3316,1555,3434"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="5681,1038,6327,1240"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="7037,1832,7669,2035"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEM_DIM, SPACE_DIM, 1, false, MonodomainRhsMatrixAssembler\&lt; ELEM_DIM, SPACE_DIM \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="4935,1832,5743,2035"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="6033,1832,6943,2035"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="7835,1832,8408,2035"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="3239,1832,4599,2035"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="832,1832,1632,2035"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="2164,1832,3215,2035"><area shape="rect" href="classBidomainWithBathRhsMatrixAssembler.html" title="{BidomainWithBathRhsMatrixAssembler\&lt; DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ BidomainWithBathRhsMatrixAssembler()\l+ ~BidomainWithBathRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="7044,2320,7367,2523"><area shape="rect" href="classBidomainWithBathRhsMatrixAssembler.html" title="{BidomainWithBathRhsMatrixAssembler\&lt; SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ BidomainWithBathRhsMatrixAssembler()\l+ ~BidomainWithBathRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="7120,2859,7491,3062"><area shape="rect" href="classMonodomainRhsMatrixAssembler.html" title="{MonodomainRhsMatrixAssembler\&lt; ELEM_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ MonodomainRhsMatrixAssembler()\l+ ~MonodomainRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="4952,2320,5363,2523"><area shape="rect" href="classMonodomainRhsMatrixAssembler.html" title="{MonodomainRhsMatrixAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ MonodomainRhsMatrixAssembler()\l+ ~MonodomainRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="5061,2859,5496,3062"><area shape="rect" href="classSimpleLinearEllipticAssembler.html" title="{SimpleLinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mpEllipticPde\l|+ SimpleLinearEllipticAssembler()\l+ PrepareForSolve()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l}" alt="" coords="6243,2320,6733,2523"><area shape="rect" href="classBidomainRhsMatrixAssembler.html" title="{BidomainRhsMatrixAssembler\&lt; DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ BidomainRhsMatrixAssembler()\l+ ~BidomainRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="7871,2320,8135,2523"><area shape="rect" href="classBidomainRhsMatrixAssembler.html" title="{BidomainRhsMatrixAssembler\&lt; SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ BidomainRhsMatrixAssembler()\l+ ~BidomainRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="7931,2859,8245,3062"><area shape="rect" href="classAbstractNonlinearAssembler.html" title="{AbstractNonlinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE \&gt;\n|# mpSolver\l# mWeAllocatedSolverMemory\l# mUseAnalyticalJacobian\l&#45; mInitialGuess\l|+ AssembleResidual()\l+ AssembleJacobian()\l+ AbstractNonlinearAssembler()\l+ ~AbstractNonlinearAssembler()\l+ SetUseAnalyticalJacobian()\l+ Solve()\l+ SetNonlinearSolver()\l+ CreateConstantInitialGuess()\l+ VerifyJacobian()\l# ApplyDirichletConditions()\l# AssembleJacobianNumerically()\l# AssembleSystem()\l# ProblemIsNonlinear()\l# InitialiseForSolve()\l# StaticSolve()\l}" alt="" coords="9260,1748,9841,2119"><area shape="rect" href="classAbstractNonlinearAssembler.html" title="{AbstractNonlinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|# mpSolver\l# mWeAllocatedSolverMemory\l# mUseAnalyticalJacobian\l&#45; mInitialGuess\l|+ AssembleResidual()\l+ AssembleJacobian()\l+ AbstractNonlinearAssembler()\l+ ~AbstractNonlinearAssembler()\l+ SetUseAnalyticalJacobian()\l+ Solve()\l+ SetNonlinearSolver()\l+ CreateConstantInitialGuess()\l+ VerifyJacobian()\l# ApplyDirichletConditions()\l# AssembleJacobianNumerically()\l# AssembleSystem()\l# ProblemIsNonlinear()\l# InitialiseForSolve()\l# StaticSolve()\l}" alt="" coords="9467,2236,10309,2607"><area shape="rect" href="classSimpleNonlinearEllipticAssembler.html" title="{SimpleNonlinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l&#45; mpNonlinearEllipticPde\l|+ SimpleNonlinearEllipticAssembler()\l&#45; ComputeMatrixTerm()\l&#45; ComputeVectorTerm()\l&#45; ComputeVectorSurfaceTerm()\l}" alt="" coords="9671,2868,10105,3052"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;:</div>
<div class="dynsection">
<p><center><img src="classAbstractAssembler__coll__graph.png" border="0" usemap="#AbstractAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_01_4__coll__map" alt="Collaboration graph"></center>
<map name="AbstractAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_01_4__coll__map">
<area shape="rect" href="classBoundaryConditionsContainer.html" title="{BoundaryConditionsContainer\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|&#45; mpNeumannMap\l&#45; mLastNeumannCondition\l&#45; mAnyNonZeroNeumannConditionsForUnknown\l&#45; mpZeroBoundaryCondition\l|+ BoundaryConditionsContainer()\l+ ~BoundaryConditionsContainer()\l+ AddDirichletBoundaryCondition()\l+ AddNeumannBoundaryCondition()\l+ DefineZeroDirichletOnMeshBoundary()\l+ DefineConstantDirichletOnMeshBoundary()\l+ DefineZeroNeumannOnMeshBoundary()\l+ ApplyDirichletToLinearProblem()\l+ ApplyDirichletToNonlinearResidual()\l+ ApplyDirichletToNonlinearJacobian()\l+ Validate()\l+ GetNeumannBCValue()\l+ HasNeumannBoundaryCondition()\l+ AnyNonZeroNeumannConditions()\l+ BeginNeumann()\l+ EndNeumann()\l}" alt="" coords="1075,859,1587,1248"><area shape="rect" href="classAbstractBoundaryConditionsContainer.html" title="{AbstractBoundaryConditionsContainer\&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|# mpDirichletMap\l# mDirichIterator\l|+ AbstractBoundaryConditionsContainer()\l+ ~AbstractBoundaryConditionsContainer()\l+ HasDirichletBoundaryConditions()\l+ DeleteDirichletBoundaryConditions()\l+ GetDirichletBCValue()\l+ HasDirichletBoundaryCondition()\l}" alt="" coords="215,155,756,341"><area shape="rect" href="classBoundaryConditionsContainer.html" title="{BoundaryConditionsContainer\&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|&#45; mpNeumannMap\l&#45; mLastNeumannCondition\l&#45; mAnyNonZeroNeumannConditionsForUnknown\l&#45; mpZeroBoundaryCondition\l|+ BoundaryConditionsContainer()\l+ ~BoundaryConditionsContainer()\l+ AddDirichletBoundaryCondition()\l+ AddNeumannBoundaryCondition()\l+ DefineZeroDirichletOnMeshBoundary()\l+ DefineConstantDirichletOnMeshBoundary()\l+ DefineZeroNeumannOnMeshBoundary()\l+ ApplyDirichletToLinearProblem()\l+ ApplyDirichletToNonlinearResidual()\l+ ApplyDirichletToNonlinearJacobian()\l+ Validate()\l+ GetNeumannBCValue()\l+ HasNeumannBoundaryCondition()\l+ AnyNonZeroNeumannConditions()\l+ BeginNeumann()\l+ EndNeumann()\l}" alt="" coords="917,405,1405,795"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classAbstractAssembler-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classLinearSystem.html">LinearSystem</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#10bc9f80f9fcf7efe0989a67d0993d3c">GetLinearSystem</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#9a4a0d466be779b073a73748217e0556">AbstractAssembler</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#d1d376deefa9502c8e39f63866d2423c">SetBoundaryConditionsContainer</a> (<a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; *pBoundaryConditions)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#10834c3e77a4077674e7ad546032edee">~AbstractAssembler</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#7359442e86e4b4c8db20544a0d26cf50">ResetInterpolatedQuantities</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#4a669b99d2442d7ee1057fecb84cddf9">IncrementInterpolatedQuantities</a> (double phiI, const <a class="el" href="classNode.html">Node</a>&lt; SPACE_DIM &gt; *pNode)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#68e46d5f7f836223d025d81351becae0">SetMatrixIsConst</a> (bool matrixIsConstant=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual c_matrix&lt; double, <br>
PROBLEM_DIM *(ELEMENT_DIM+1), <br>
PROBLEM_DIM *(ELEMENT_DIM+1)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#ba0539d41329a6e78843d8a6b8bf038a">ComputeMatrixTerm</a> (c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, <a class="el" href="classChastePoint.html">ChastePoint</a>&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, PROBLEM_DIM &gt; &amp;rU, c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;rGradU, <a class="el" href="classElement.html">Element</a>&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual c_vector&lt; double, <br>
PROBLEM_DIM *(ELEMENT_DIM+1)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#3c148dbd85e5226e9d06beea6f2ea807">ComputeVectorTerm</a> (c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, <a class="el" href="classChastePoint.html">ChastePoint</a>&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, PROBLEM_DIM &gt; &amp;rU, c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;rGradU, <a class="el" href="classElement.html">Element</a>&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual c_vector&lt; double, <br>
PROBLEM_DIM *ELEMENT_DIM &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#0c8d53504e43c0acfc68f9cf98d97c8d">ComputeVectorSurfaceTerm</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, ELEMENT_DIM &gt; &amp;rPhi, <a class="el" href="classChastePoint.html">ChastePoint</a>&lt; SPACE_DIM &gt; &amp;rX)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement</a> (<a class="el" href="classElement.html">Element</a>&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement, c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;rAElem, c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;rBElem, bool assembleVector, bool assembleMatrix)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#c3dee23c12daa3facaecbc13546e247b">AssembleOnSurfaceElement</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;rBSurfElem)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#9ae4f4ce934a931a3be8b776c5191c31">AssembleSystem</a> (bool assembleVector, bool assembleMatrix, Vec currentSolutionOrGuess=NULL, double currentTime=0.0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#c95938dd3454b2f0175269cac4634ffe">PrepareForSolve</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#9b386b36c616c1bf9bda87c56701a7b1">PrepareForAssembleSystem</a> (Vec currentSolutionOrGuess, double currentTime)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#ee1ca595e6a96c333f5526a04a398b71">FinaliseAssembleSystem</a> (Vec currentSolutionOrGuess, double currentTime)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#6639e3911c942536ec17af7aa90db92d">FinaliseLinearSystem</a> (Vec currentSolutionOrGuess, double currentTime, bool assembleVector, bool assembleMatrix)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#ebd31166fc064a704dca661f259eda03">ApplyDirichletConditions</a> (Vec currentSolutionOrGuess, bool applyToMatrix)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#7c66cce275f297ad2c13a5f42d597a69">ProblemIsNonlinear</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual Vec&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#1f4769b876004c784a2d2ec8f845f8e3">StaticSolve</a> (Vec currentSolutionOrGuess=NULL, double currentTime=0.0, bool assembleMatrix=true)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#5dc3a84b7d6535cf2c1727c0fc00c75f">InitialiseForSolve</a> (Vec initialGuess)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classReplicatableVector.html">ReplicatableVector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#b16b05fe3ba5b32d72f114ad587900ef">rGetCurrentSolutionOrGuess</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#2affb9cf8a934b9fe2f3e15d7361151e">ApplyNeummanBoundaryConditions</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a><br>
&lt; ELEMENT_DIM, SPACE_DIM, <br>
PROBLEM_DIM &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#eb85a48384f748109cb169d7b45c0b62">mpBoundaryConditions</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt;<br>
 class AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;</h3>

<a class="el" href="classAbstractAssembler.html">AbstractAssembler</a><p>
Base class from which all solvers for linear and nonlinear PDEs inherit. Templated over the PROBLEM_DIM so also handles problems with more than one unknown variable (ie those of the form u_xx + v = 0, v_xx + 2u = 1, where PROBLEM_DIM is equal to 2)<p>
It defines a common interface for AssembleSystem, AssembleOnElement and AssembleOnSurfaceElement. Each of these work for any PROBLEM_DIM&gt;=1. Each of these methods work in both the dynamic case (when there is a current solution available) and the static case. The same code is used for the nonlinear and linear cases. Default code is defined in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a><p>
user calls:<p>
Solve(). In the linear case Solve() calls <a class="el" href="classAbstractAssembler.html#9ae4f4ce934a931a3be8b776c5191c31">AssembleSystem()</a> directly, in the nonlinear case Solve() calls the PETSc nonlinear solver which then calls AssembleResidual or AssembleJacobian, both of which call <a class="el" href="classAbstractAssembler.html#9ae4f4ce934a931a3be8b776c5191c31">AssembleSystem()</a>:<p>
<a class="el" href="classAbstractAssembler.html#9ae4f4ce934a931a3be8b776c5191c31">AssembleSystem()</a>. (implemented in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a>, loops over elements and adds to the linear system or residual vector or jacobian matrix) <a class="el" href="classAbstractAssembler.html#9ae4f4ce934a931a3be8b776c5191c31">AssembleSystem()</a> calls:<p>
<a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a> and <a class="el" href="classAbstractAssembler.html#c3dee23c12daa3facaecbc13546e247b">AssembleOnSurfaceElement()</a>. (implemented in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a>. These loop over gauss points and create the element stiffness matrix and vector in the linear case ). They call:<p>
<a class="el" href="classAbstractAssembler.html#ba0539d41329a6e78843d8a6b8bf038a">ComputeMatrixTerm()</a>, <a class="el" href="classAbstractAssembler.html#3c148dbd85e5226e9d06beea6f2ea807">ComputeVectorTerm()</a>, <a class="el" href="classAbstractAssembler.html#0c8d53504e43c0acfc68f9cf98d97c8d">ComputeVectorSurfaceTerm()</a> (implemented in the concrete assembler class (eg <a class="el" href="classSimpleDg0ParabolicAssembler.html">SimpleDg0ParabolicAssembler</a>), which tells this assembler exactly what function of bases, position, pde constants etc to add to the element stiffness matrix/vector). 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00077">77</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="9a4a0d466be779b073a73748217e0556"></a><!-- doxytag: member="AbstractAssembler::AbstractAssembler" ref="9a4a0d466be779b073a73748217e0556" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::<a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00412">412</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="10834c3e77a4077674e7ad546032edee"></a><!-- doxytag: member="AbstractAssembler::~AbstractAssembler" ref="10834c3e77a4077674e7ad546032edee" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::~<a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete any memory allocated by this class. 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00350">350</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="68e46d5f7f836223d025d81351becae0"></a><!-- doxytag: member="AbstractAssembler::SetMatrixIsConst" ref="68e46d5f7f836223d025d81351becae0" args="(bool matrixIsConstant=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::SetMatrixIsConst           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>matrixIsConstant</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hack for dynamic mixin.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matrixIsConstant</em>&nbsp;</td><td>defaults to true </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEM_DIM, SPACE_DIM, 1, false, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, and <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00090">90</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00238">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::SetMatrixIsConstant()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ba0539d41329a6e78843d8a6b8bf038a"></a><!-- doxytag: member="AbstractAssembler::ComputeMatrixTerm" ref="ba0539d41329a6e78843d8a6b8bf038a" args="(c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, PROBLEM_DIM &gt; &amp;rU, c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual c_matrix&lt;double,PROBLEM_DIM*(ELEMENT_DIM+1),PROBLEM_DIM*(ELEMENT_DIM+1)&gt; <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ComputeMatrixTerm           </td>
          <td>(</td>
          <td class="paramtype">c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rGradPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classChastePoint.html">ChastePoint</a>&lt; SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, PROBLEM_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rGradU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classElement.html">Element</a>&lt; ELEMENT_DIM, SPACE_DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>pElement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the matrix to be added to element stiffness matrix for a given gauss point. The arguments are the bases, bases gradients, x and current solution computed at the Gauss point. The returned matrix will be multiplied by the gauss weight and jacobian determinent and added to the element stiffness matrix (see <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a>).<p>
--This method has to be implemented in the concrete class--<p>
NOTE: for linear problems rGradU is NOT set up correctly because it should not be needed<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rPhi</em>&nbsp;</td><td>The basis functions, rPhi(i) = phi_i, i=1..numBases. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rGradPhi</em>&nbsp;</td><td>Basis gradients, rGradPhi(i,j) = d(phi_j)/d(X_i). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rX</em>&nbsp;</td><td>The point in space. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rU</em>&nbsp;</td><td>The unknown as a vector, u(i) = u_i. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rGradU</em>&nbsp;</td><td>The gradient of the unknown as a matrix, rGradU(i,j) = d(u_i)/d(X_j). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pElement</em>&nbsp;</td><td>Pointer to the element. </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00305">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleOnElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="3c148dbd85e5226e9d06beea6f2ea807"></a><!-- doxytag: member="AbstractAssembler::ComputeVectorTerm" ref="3c148dbd85e5226e9d06beea6f2ea807" args="(c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, PROBLEM_DIM &gt; &amp;rU, c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual c_vector&lt;double,PROBLEM_DIM*(ELEMENT_DIM+1)&gt; <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ComputeVectorTerm           </td>
          <td>(</td>
          <td class="paramtype">c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rGradPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classChastePoint.html">ChastePoint</a>&lt; SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, PROBLEM_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rGradU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classElement.html">Element</a>&lt; ELEMENT_DIM, SPACE_DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>pElement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the vector to be added to element stiffness vector for a given gauss point. The arguments are the bases, x and current solution computed at the Gauss point. The returned vector will be multiplied by the gauss weight and jacobian determinent and added to the element stiffness matrix (see <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a>).<p>
--This method has to be implemented in the concrete class--<p>
NOTE: for linear problems rGradPhi and rGradU are NOT set up correctly because they should not be needed<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rPhi</em>&nbsp;</td><td>The basis functions, rPhi(i) = phi_i, i=1..numBases </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rGradPhi</em>&nbsp;</td><td>Basis gradients, rGradPhi(i,j) = d(phi_j)/d(X_i) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rX</em>&nbsp;</td><td>The point in space </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rU</em>&nbsp;</td><td>The unknown as a vector, u(i) = u_i </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rGradU</em>&nbsp;</td><td>The gradient of the unknown as a matrix, rGradU(i,j) = d(u_i)/d(X_j) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pElement</em>&nbsp;</td><td>Pointer to the element </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00305">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleOnElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0c8d53504e43c0acfc68f9cf98d97c8d"></a><!-- doxytag: member="AbstractAssembler::ComputeVectorSurfaceTerm" ref="0c8d53504e43c0acfc68f9cf98d97c8d" args="(const BoundaryElement&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, ELEMENT_DIM &gt; &amp;rPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual c_vector&lt;double, PROBLEM_DIM*ELEMENT_DIM&gt; <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ComputeVectorSurfaceTerm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rSurfaceElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, ELEMENT_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classChastePoint.html">ChastePoint</a>&lt; SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rX</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the vector to be added to element stiffness vector for a given gauss point in <a class="el" href="classBoundaryElement.html">BoundaryElement</a>. The arguments are the bases, x and current solution computed at the Gauss point. The returned vector will be multiplied by the gauss weight and jacobian determinent and added to the element stiffness matrix (see <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a>).<p>
--This method has to be implemented in the concrete class--<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rSurfaceElement</em>&nbsp;</td><td>the element which is being considered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rPhi</em>&nbsp;</td><td>The basis functions, rPhi(i) = phi_i, i=1..numBases </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rX</em>&nbsp;</td><td>The point in space </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classBidomainDg0Assembler.html#8226b0e6346ab15ddb650455555da158">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classSimpleDg0ParabolicAssembler.html#519a422263b39f56d8b0881aa31fc83a">SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classSimpleLinearEllipticAssembler.html#e0a2e11ebdab2474833d6637fa89d94d">SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt;</a>, <a class="el" href="classSimpleNonlinearEllipticAssembler.html#bda2f839ec3fd6573fb1dd34d2a954ea">SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classBidomainDg0Assembler.html#8226b0e6346ab15ddb650455555da158">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>, and <a class="el" href="classSimpleDg0ParabolicAssembler.html#519a422263b39f56d8b0881aa31fc83a">SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, false, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00438">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleOnSurfaceElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4b3c3db59a7f16a894a6a2a273566cd1"></a><!-- doxytag: member="AbstractAssembler::AssembleOnElement" ref="4b3c3db59a7f16a894a6a2a273566cd1" args="(Element&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement, c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;rAElem, c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;rBElem, bool assembleVector, bool assembleMatrix)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AssembleOnElement           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classElement.html">Element</a>&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rAElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rBElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the contribution of a single element to the linear system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rElement</em>&nbsp;</td><td>The element to assemble on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rAElem</em>&nbsp;</td><td>The element's contribution to the LHS matrix is returned in this n by n matrix, where n is the no. of nodes in this element. There is no need to zero this matrix before calling. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rBElem</em>&nbsp;</td><td>The element's contribution to the RHS vector is returned in this vector of length n, the no. of nodes in this element. There is no need to zero this vector before calling. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleVector</em>&nbsp;</td><td>a bool stating whether to assemble the load vector (in the linear case) or the residual vector (in the nonlinear case) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleMatrix</em>&nbsp;</td><td>a bool stating whether to assemble the stiffness matrix (in the linear case) or the Jacobian matrix (in the nonlinear case)</td></tr>
  </table>
</dl>
Called by <a class="el" href="classAbstractAssembler.html#9ae4f4ce934a931a3be8b776c5191c31">AssembleSystem()</a> Calls <a class="el" href="classAbstractAssembler.html#ba0539d41329a6e78843d8a6b8bf038a">ComputeMatrixTerm()</a> etc<p>
Implemented in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a> 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="c3dee23c12daa3facaecbc13546e247b"></a><!-- doxytag: member="AbstractAssembler::AssembleOnSurfaceElement" ref="c3dee23c12daa3facaecbc13546e247b" args="(const BoundaryElement&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;rBSurfElem)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AssembleOnSurfaceElement           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rSurfaceElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rBSurfElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the contribution of a single surface element with Neumann boundary condition to the linear system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rSurfaceElement</em>&nbsp;</td><td>The element to assemble on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rBSurfElem</em>&nbsp;</td><td>The element's contribution to the RHS vector is returned in this vector of length n, the no. of nodes in this element. There is no need to zero this vector before calling.</td></tr>
  </table>
</dl>
Implemented in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a> 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractAssembler_8hpp-source.html#l00385">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyNeummanBoundaryConditions()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9ae4f4ce934a931a3be8b776c5191c31"></a><!-- doxytag: member="AbstractAssembler::AssembleSystem" ref="9ae4f4ce934a931a3be8b776c5191c31" args="(bool assembleVector, bool assembleMatrix, Vec currentSolutionOrGuess=NULL, double currentTime=0.0)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AssembleSystem           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em> = <code>0.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
AssembleSystem - the major method for all assemblers<p>
Assemble the linear system for a linear PDE, or the residual or Jacobian for nonlinear PDEs. Loops over each element (and each each surface element if there are non-zero Neumann boundary conditions), calls <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a> and adds the contribution to the linear system.<p>
Takes in current solution and time if necessary but only used if the problem is a dynamic one. This method uses PROBLEM_DIM and can assemble linear systems for any number of unknown variables.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>assembleVector</em>&nbsp;</td><td>Whether to assemble the RHS vector of the linear system (i.e. the residual vector for nonlinear problems). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleMatrix</em>&nbsp;</td><td>Whether to assemble the LHS matrix of the linear system (i.e. the jacobian matrix for nonlinear problems). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td>The current solution in a linear dynamic problem, or the current guess in a nonlinear problem. Should be NULL for linear static problems. Defaults to NULL. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td>The current time for dynamic problems. Not used in static problems. Defaults to 0.0. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classAbstractNonlinearAssembler.html#ac6d2ce488e7ab20afa85cb01599b4b3">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#ac6d2ce488e7ab20afa85cb01599b4b3">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#9e775a635389bbe08e4d0402af29d895">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="c95938dd3454b2f0175269cac4634ffe"></a><!-- doxytag: member="AbstractAssembler::PrepareForSolve" ref="c95938dd3454b2f0175269cac4634ffe" args="()=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::PrepareForSolve           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called at the beginning of Solve(). Subclass assemblers can use it to check everything has been set up correctly 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classSimpleDg0ParabolicAssembler.html#76448713284f5b88b93dfdb33fe8127f">SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classSimpleLinearEllipticAssembler.html#c49e09ea2d2a790aa84ce375d1dda388">SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#ce4e80b47d5271b43d5705712421e701">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classSimpleDg0ParabolicAssembler.html#76448713284f5b88b93dfdb33fe8127f">SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, false, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00251">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::Solve()</a>.</p>

</div>
</div><p>
<a class="anchor" name="9b386b36c616c1bf9bda87c56701a7b1"></a><!-- doxytag: member="AbstractAssembler::PrepareForAssembleSystem" ref="9b386b36c616c1bf9bda87c56701a7b1" args="(Vec currentSolutionOrGuess, double currentTime)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::PrepareForAssembleSystem           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called at the beginning of <a class="el" href="classAbstractAssembler.html#9ae4f4ce934a931a3be8b776c5191c31">AssembleSystem()</a> and should be overloaded in the concrete assembler class if there is any work to be done before assembling, for example integrating ODEs such as in the Monodomain assembler.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classBidomainDg0Assembler.html#dce74259ebc2627cfb4dbea600fdad32">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classMonodomainDg0Assembler.html#f1f7b5a798fbcfac468e7b1ef507693b">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#dce74259ebc2627cfb4dbea600fdad32">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00247">247</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00493">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleSystem()</a>, and <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00165">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::DoMatrixBasedRhsAssembly()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ee1ca595e6a96c333f5526a04a398b71"></a><!-- doxytag: member="AbstractAssembler::FinaliseAssembleSystem" ref="ee1ca595e6a96c333f5526a04a398b71" args="(Vec currentSolutionOrGuess, double currentTime)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::FinaliseAssembleSystem           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called at the end of <a class="el" href="classAbstractAssembler.html#9ae4f4ce934a931a3be8b776c5191c31">AssembleSystem()</a> and should be overloaded in the concrete assembler class if there is any further work to be done.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classBidomainDg0Assembler.html#41e01b008979a1bbf5cc74914995c38c">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#41e01b008979a1bbf5cc74914995c38c">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00257">257</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00493">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleSystem()</a>, and <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00165">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::DoMatrixBasedRhsAssembly()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6639e3911c942536ec17af7aa90db92d"></a><!-- doxytag: member="AbstractAssembler::FinaliseLinearSystem" ref="6639e3911c942536ec17af7aa90db92d" args="(Vec currentSolutionOrGuess, double currentTime, bool assembleVector, bool assembleMatrix)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::FinaliseLinearSystem           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Can be overloaded if the user needs to edit the linear system after the boundary conditions have been added but before it is solved.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleVector</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleMatrix</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classBidomainWithBathAssembler.html#10ca4cf8f3ff023005825db2c988f56d">BidomainWithBathAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00269">269</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00493">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleSystem()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ebd31166fc064a704dca661f259eda03"></a><!-- doxytag: member="AbstractAssembler::ApplyDirichletConditions" ref="ebd31166fc064a704dca661f259eda03" args="(Vec currentSolutionOrGuess, bool applyToMatrix)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyDirichletConditions           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>applyToMatrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called by AssembleSystem to apply Dirichlet conditions to the system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>applyToMatrix</em>&nbsp;</td><td></td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classAbstractLinearAssembler.html#d44d2388a9c42235ac5aa4164fdd9e92">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#24df26dc705b54b2f626b5114e8c36a9">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#d44d2388a9c42235ac5aa4164fdd9e92">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#d44d2388a9c42235ac5aa4164fdd9e92">AbstractLinearAssembler&lt; ELEM_DIM, SPACE_DIM, 1, false, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#d44d2388a9c42235ac5aa4164fdd9e92">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#d44d2388a9c42235ac5aa4164fdd9e92">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#d44d2388a9c42235ac5aa4164fdd9e92">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#d44d2388a9c42235ac5aa4164fdd9e92">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#d44d2388a9c42235ac5aa4164fdd9e92">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractNonlinearAssembler.html#24df26dc705b54b2f626b5114e8c36a9">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00493">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleSystem()</a>, and <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00165">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::DoMatrixBasedRhsAssembly()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7c66cce275f297ad2c13a5f42d597a69"></a><!-- doxytag: member="AbstractAssembler::ProblemIsNonlinear" ref="7c66cce275f297ad2c13a5f42d597a69" args="()=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ProblemIsNonlinear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether grad_u should be calculated 
<p>Implemented in <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#249c069dddfd82fa3bd0429941131c09">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEM_DIM, SPACE_DIM, 1, false, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractNonlinearAssembler.html#249c069dddfd82fa3bd0429941131c09">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00305">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleOnElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1f4769b876004c784a2d2ec8f845f8e3"></a><!-- doxytag: member="AbstractAssembler::StaticSolve" ref="1f4769b876004c784a2d2ec8f845f8e3" args="(Vec currentSolutionOrGuess=NULL, double currentTime=0.0, bool assembleMatrix=true)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual Vec <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::StaticSolve           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform the work of a single solve, but without any initialisation. Static assemblers must implement this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td>either the current solution (dynamic problem) or initial guess (static problem); optional in some cases </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td>for a dynamic problem, the current time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleMatrix</em>&nbsp;</td><td>whether to assemble the matrix (it may have been done by a previous call) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the solution vector </dd></dl>

<p>Implemented in <a class="el" href="classAbstractLinearAssembler.html#a518884e9d443bc171fcd5c29cd06ab6">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#5645b3fcde13bd8802099837e535e342">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#a518884e9d443bc171fcd5c29cd06ab6">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#a518884e9d443bc171fcd5c29cd06ab6">AbstractLinearAssembler&lt; ELEM_DIM, SPACE_DIM, 1, false, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#a518884e9d443bc171fcd5c29cd06ab6">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#a518884e9d443bc171fcd5c29cd06ab6">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#a518884e9d443bc171fcd5c29cd06ab6">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#a518884e9d443bc171fcd5c29cd06ab6">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#a518884e9d443bc171fcd5c29cd06ab6">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractNonlinearAssembler.html#5645b3fcde13bd8802099837e535e342">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00251">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::Solve()</a>.</p>

</div>
</div><p>
<a class="anchor" name="5dc3a84b7d6535cf2c1727c0fc00c75f"></a><!-- doxytag: member="AbstractAssembler::InitialiseForSolve" ref="5dc3a84b7d6535cf2c1727c0fc00c75f" args="(Vec initialGuess)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::InitialiseForSolve           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>initialGuess</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform any initialisation needed before a sequence of StaticSolve calls.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>initialGuess</em>&nbsp;</td><td>an initial guess </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classBidomainDg0Assembler.html#2020a53a83bc9a5cd93ac5b4c3c28e39">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classMonodomainDg0Assembler.html#5f9582fc6f0db41b2de406d56af94383">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#21c2206dc33de48108c4c8ab7307cb22">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#07c583a147955333eb5a909602973270">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classBidomainDg0Assembler.html#2020a53a83bc9a5cd93ac5b4c3c28e39">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#21c2206dc33de48108c4c8ab7307cb22">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#21c2206dc33de48108c4c8ab7307cb22">AbstractLinearAssembler&lt; ELEM_DIM, SPACE_DIM, 1, false, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#21c2206dc33de48108c4c8ab7307cb22">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#21c2206dc33de48108c4c8ab7307cb22">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#21c2206dc33de48108c4c8ab7307cb22">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#21c2206dc33de48108c4c8ab7307cb22">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#21c2206dc33de48108c4c8ab7307cb22">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractNonlinearAssembler.html#07c583a147955333eb5a909602973270">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00251">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::Solve()</a>.</p>

</div>
</div><p>
<a class="anchor" name="10bc9f80f9fcf7efe0989a67d0993d3c"></a><!-- doxytag: member="AbstractAssembler::GetLinearSystem" ref="10bc9f80f9fcf7efe0989a67d0993d3c" args="()=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearSystem.html">LinearSystem</a>** <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::GetLinearSystem           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor method that subclasses can use to get to useful data. 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#a0953adda86755ced66c8ef097ed5d96">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractAssembler_8hpp-source.html#l00385">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyNeummanBoundaryConditions()</a>, <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00165">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::DoMatrixBasedRhsAssembly()</a>, <a class="el" href="BidomainWithBathAssembler_8cpp-source.html#l00118">BidomainWithBathAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::FinaliseLinearSystem()</a>, <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00251">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::Solve()</a>, and <a class="el" href="AbstractCardiacProblem_8cpp-source.html#l00357">AbstractCardiacProblem&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM &gt;::Solve()</a>.</p>

</div>
</div><p>
<a class="anchor" name="b16b05fe3ba5b32d72f114ad587900ef"></a><!-- doxytag: member="AbstractAssembler::rGetCurrentSolutionOrGuess" ref="b16b05fe3ba5b32d72f114ad587900ef" args="()=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classReplicatableVector.html">ReplicatableVector</a>&amp; <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::rGetCurrentSolutionOrGuess           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor method that subclasses can use to get to useful data. 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#4d6532a839b659e41ac143cc430aef6e">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="2affb9cf8a934b9fe2f3e15d7361151e"></a><!-- doxytag: member="AbstractAssembler::ApplyNeummanBoundaryConditions" ref="2affb9cf8a934b9fe2f3e15d7361151e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyNeummanBoundaryConditions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply Neumann boundary conditions to the RHS vector by looping over surface elements (though actually looping over the boundary condition objects).<p>
Note for PROBLEM_DIM&gt;1. We assume that if an element has a boundary condition on any unknown there is a boundary condition on unknown 0. This can be so for any problem by adding zero constant conditions where required although this is a bit inefficient. Proper solution involves changing BCC to have a map of arrays boundary conditions rather than an array of maps. 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00385">385</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>References <a class="el" href="BoundaryConditionsContainerImplementation_8hpp-source.html#l00422">BoundaryConditionsContainer&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AnyNonZeroNeumannConditions()</a>, <a class="el" href="classAbstractAssembler.html#c3dee23c12daa3facaecbc13546e247b">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AssembleOnSurfaceElement()</a>, <a class="el" href="GenericEventHandler_8hpp-source.html#l00120">GenericEventHandler&lt; 11, HeartEventHandler &gt;::BeginEvent()</a>, <a class="el" href="BoundaryConditionsContainerImplementation_8hpp-source.html#l00436">BoundaryConditionsContainer&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM &gt;::BeginNeumann()</a>, <a class="el" href="GenericEventHandler_8hpp-source.html#l00158">GenericEventHandler&lt; 11, HeartEventHandler &gt;::EndEvent()</a>, <a class="el" href="BoundaryConditionsContainerImplementation_8hpp-source.html#l00443">BoundaryConditionsContainer&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM &gt;::EndNeumann()</a>, <a class="el" href="classAbstractAssembler.html#10bc9f80f9fcf7efe0989a67d0993d3c">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::GetLinearSystem()</a>, <a class="el" href="AbstractTetrahedralElement_8cpp-source.html#l00211">AbstractTetrahedralElement&lt; ELEMENT_DIM, SPACE_DIM &gt;::GetStiffnessMatrixGlobalIndices()</a>, and <a class="el" href="AbstractAssembler_8hpp-source.html#l00082">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::mpBoundaryConditions</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00493">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleSystem()</a>, and <a class="el" href="AbstractDynamicAssemblerMixin_8hpp-source.html#l00165">AbstractDynamicAssemblerMixin&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::DoMatrixBasedRhsAssembly()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d1d376deefa9502c8e39f63866d2423c"></a><!-- doxytag: member="AbstractAssembler::SetBoundaryConditionsContainer" ref="d1d376deefa9502c8e39f63866d2423c" args="(BoundaryConditionsContainer&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; *pBoundaryConditions)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::SetBoundaryConditionsContainer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>pBoundaryConditions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the boundary conditions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pBoundaryConditions</em>&nbsp;</td><td>pointer to a <a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a> </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00418">418</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>References <a class="el" href="AbstractAssembler_8hpp-source.html#l00082">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::mpBoundaryConditions</a>.</p>

<p>Referenced by <a class="el" href="BidomainProblem_8cpp-source.html#l00303">BidomainProblem&lt; DIM &gt;::OnEndOfTimestep()</a>, <a class="el" href="SimpleDg0ParabolicAssemblerImplementation_8hpp-source.html#l00039">SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt;::SimpleDg0ParabolicAssembler()</a>, <a class="el" href="SimpleLinearEllipticAssembler_8hpp-source.html#l00155">SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt;::SimpleLinearEllipticAssembler()</a>, and <a class="el" href="SimpleNonlinearEllipticAssembler_8cpp-source.html#l00034">SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::SimpleNonlinearEllipticAssembler()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7359442e86e4b4c8db20544a0d26cf50"></a><!-- doxytag: member="AbstractAssembler::ResetInterpolatedQuantities" ref="7359442e86e4b4c8db20544a0d26cf50" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ResetInterpolatedQuantities           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The concrete subclass can overload this and <a class="el" href="classAbstractAssembler.html#4a669b99d2442d7ee1057fecb84cddf9">IncrementInterpolatedQuantities()</a> if there are some quantities which need to be computed at each Gauss point. They are called in <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a> 
<p>Reimplemented in <a class="el" href="classBidomainDg0Assembler.html#40daa2e1cae841a01d754f5e2be4cbe4">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classMonodomainDg0Assembler.html#8012acb8e9959c3e8fd1e27142b90fd2">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#40daa2e1cae841a01d754f5e2be4cbe4">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00362">362</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00305">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleOnElement()</a>, and <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00438">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleOnSurfaceElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4a669b99d2442d7ee1057fecb84cddf9"></a><!-- doxytag: member="AbstractAssembler::IncrementInterpolatedQuantities" ref="4a669b99d2442d7ee1057fecb84cddf9" args="(double phiI, const Node&lt; SPACE_DIM &gt; *pNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::IncrementInterpolatedQuantities           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phiI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNode.html">Node</a>&lt; SPACE_DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>pNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The concrete subclass can overload this and <a class="el" href="classAbstractAssembler.html#7359442e86e4b4c8db20544a0d26cf50">ResetInterpolatedQuantities()</a> if there are some quantities which need to be computed at each Gauss point. They are called in <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phiI</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNode</em>&nbsp;</td><td>pointer to a node </td></tr>
  </table>
</dl>

<p>Reimplemented in <a class="el" href="classBidomainDg0Assembler.html#0631b86db3f6165d08e01b95e2f1118f">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classMonodomainDg0Assembler.html#199891900d675a394708aa07ae7b5f25">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#0631b86db3f6165d08e01b95e2f1118f">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00373">373</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00305">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleOnElement()</a>, and <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00438">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::AssembleOnSurfaceElement()</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="eb85a48384f748109cb169d7b45c0b62"></a><!-- doxytag: member="AbstractAssembler::mpBoundaryConditions" ref="eb85a48384f748109cb169d7b45c0b62" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a>&lt;ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM&gt;* <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::<a class="el" href="classAbstractAssembler.html#eb85a48384f748109cb169d7b45c0b62">mpBoundaryConditions</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Boundary conditions to be applied 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00082">82</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00280">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::ApplyDirichletConditions()</a>, <a class="el" href="AbstractLinearAssembler_8hpp-source.html#l00154">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::ApplyDirichletConditions()</a>, <a class="el" href="AbstractAssembler_8hpp-source.html#l00385">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyNeummanBoundaryConditions()</a>, <a class="el" href="BidomainDg0Assembler_8cpp-source.html#l00323">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::BidomainDg0Assembler()</a>, <a class="el" href="BidomainMatrixBasedAssembler_8cpp-source.html#l00102">BidomainRhsMatrixAssembler&lt; DIM &gt;::BidomainRhsMatrixAssembler()</a>, <a class="el" href="BidomainWithBathMatrixBasedAssembler_8cpp-source.html#l00100">BidomainWithBathRhsMatrixAssembler&lt; DIM &gt;::BidomainWithBathRhsMatrixAssembler()</a>, <a class="el" href="BidomainDg0Assembler_8cpp-source.html#l00288">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::CheckCompatibilityCondition()</a>, <a class="el" href="SimpleNonlinearEllipticAssembler_8cpp-source.html#l00122">SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::ComputeVectorSurfaceTerm()</a>, <a class="el" href="SimpleLinearEllipticAssembler_8hpp-source.html#l00136">SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt;::ComputeVectorSurfaceTerm()</a>, <a class="el" href="SimpleDg0ParabolicAssemblerImplementation_8hpp-source.html#l00108">SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt;::ComputeVectorSurfaceTerm()</a>, <a class="el" href="BidomainDg0Assembler_8cpp-source.html#l00181">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::ComputeVectorSurfaceTerm()</a>, <a class="el" href="BidomainDg0Assembler_8cpp-source.html#l00233">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::FinaliseAssembleSystem()</a>, <a class="el" href="MonodomainDg0Assembler_8cpp-source.html#l00098">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::MonodomainDg0Assembler()</a>, <a class="el" href="MonodomainMatrixBasedAssembler_8cpp-source.html#l00092">MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt;::MonodomainRhsMatrixAssembler()</a>, <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00632">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;::PrepareForSolve()</a>, <a class="el" href="AbstractAssembler_8hpp-source.html#l00418">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::SetBoundaryConditionsContainer()</a>, <a class="el" href="BidomainDg0Assembler_8cpp-source.html#l00356">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::SetFixedExtracellularPotentialNodes()</a>, <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00452">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;::StaticSolve()</a>, <a class="el" href="BidomainMatrixBasedAssembler_8cpp-source.html#l00121">BidomainRhsMatrixAssembler&lt; DIM &gt;::~BidomainRhsMatrixAssembler()</a>, <a class="el" href="BidomainWithBathMatrixBasedAssembler_8cpp-source.html#l00119">BidomainWithBathRhsMatrixAssembler&lt; DIM &gt;::~BidomainWithBathRhsMatrixAssembler()</a>, and <a class="el" href="MonodomainMatrixBasedAssembler_8cpp-source.html#l00109">MonodomainRhsMatrixAssembler&lt; ELEM_DIM, SPACE_DIM &gt;::~MonodomainRhsMatrixAssembler()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/tmp/release_1.1/pde/src/solver/common/<a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Aug 4 16:10:29 2009 for Chaste by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
