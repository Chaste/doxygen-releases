<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Chaste: AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li class="current"><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; Class Template Reference</h1><!-- doxytag: class="AbstractAssembler" --><code>#include &lt;<a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;:</div>
<div class="dynsection">
<p><center><img src="classAbstractAssembler__inherit__graph.png" border="0" usemap="#AbstractAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_01_4__inherit__map" alt="Inheritance graph"></center>
<map name="AbstractAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_01_4__inherit__map">
<area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="6147,440,6616,712"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="9475,774,10053,1046"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="5269,774,6109,1046"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="2720,774,4115,1046"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="1795,774,2696,1046"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="7621,774,8640,1046"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="10077,774,10979,1046"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="4139,774,5245,1046"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="8664,774,9451,1046"><area shape="rect" href="classAbstractStaticAssembler.html" title="{AbstractStaticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|# mpMesh\l# mpQuadRule\l# mpSurfaceQuadRule\l# mCurrentSolutionOrGuessReplicated\l# mpLinearSystem\l|+ AbstractStaticAssembler()\l+ SetNumberOfQuadraturePointsPerDimension()\l+ SetMesh()\l+ ~AbstractStaticAssembler()\l# AssembleOnElement()\l# AssembleOnSurfaceElement()\l# AssembleSystem()\l# PrepareForSolve()\l# GetLinearSystem()\l# rGetCurrentSolutionOrGuess()\l# GetCurrentSolutionOrGuessValue()\l}" alt="" coords="6792,774,7597,1046"><area shape="rect" href="classBidomainDg0Assembler.html" title="{BidomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM, 2 \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mpBidomainPde\l# mpConfig\l# mIionic\l# mIIntracellularStimulus\l# mIExtracellularStimulus\l# mNullSpaceCreated\l# mExternalVoltageMask\l# mFixedExtracellularPotentialNodes\l# mRowForAverageOfPhiZeroed\l|+ BidomainDg0Assembler()\l+ ~BidomainDg0Assembler()\l+ SetFixedExtracellularPotentialNodes()\l+ SetRowForAverageOfPhiZeroed()\l# ResetInterpolatedQuantities()\l# InitialiseForSolve()\l# IncrementInterpolatedQuantities()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l# PrepareForAssembleSystem()\l# FinaliseAssembleSystem()\l}" alt="" coords="1032,1484,1408,1866"><area shape="rect" href="classBidomainDg0Assembler.html" title="{BidomainDg0Assembler\&lt; DIM, DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mpBidomainPde\l# mpConfig\l# mIionic\l# mIIntracellularStimulus\l# mIExtracellularStimulus\l# mNullSpaceCreated\l# mExternalVoltageMask\l# mFixedExtracellularPotentialNodes\l# mRowForAverageOfPhiZeroed\l|+ BidomainDg0Assembler()\l+ ~BidomainDg0Assembler()\l+ SetFixedExtracellularPotentialNodes()\l+ SetRowForAverageOfPhiZeroed()\l# ResetInterpolatedQuantities()\l# InitialiseForSolve()\l# IncrementInterpolatedQuantities()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l# PrepareForAssembleSystem()\l# FinaliseAssembleSystem()\l}" alt="" coords="1149,1930,1403,2311"><area shape="rect" href="classSimpleDg0ParabolicAssembler.html" title="{SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1 \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l&#45; mpParabolicPde\l|}" alt="" coords="1483,1616,1899,1734"><area shape="rect" href="classSimpleDg0ParabolicAssembler.html" title="{SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, false, MonodomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l&#45; mpParabolicPde\l|}" alt="" coords="2440,2062,3243,2179"><area shape="rect" href="classBidomainMatrixBasedAssembler.html" title="{BidomainMatrixBasedAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|# mpBidomainRhsMatrixAssembler\l|+ BidomainMatrixBasedAssembler()\l+ ~BidomainMatrixBasedAssembler()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l}" alt="" coords="1537,2068,1948,2172"><area shape="rect" href="classMonodomainDg0Assembler.html" title="{MonodomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mSourceTerm\l# mpMonodomainPde\l|+ MonodomainDg0Assembler()\l+ ~MonodomainDg0Assembler()\l# ComputeVectorTerm()\l# ResetInterpolatedQuantities()\l# IncrementInterpolatedQuantities()\l# PrepareForAssembleSystem()\l# InitialiseForSolve()\l}" alt="" coords="2652,2363,3031,2579"><area shape="rect" href="classMonodomainMatrixBasedAssembler.html" title="{MonodomainMatrixBasedAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|# mpMonodomainRhsMatrixAssembler\l|+ MonodomainMatrixBasedAssembler()\l+ ~MonodomainMatrixBasedAssembler()\l+ ConstructVectorForMatrixBasedRhsAssembly()\l}" alt="" coords="2627,2630,3056,2734"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="6133,823,6768,996"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="5981,1178,6563,1351"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="7440,1178,8315,1351"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="8415,1178,8943,1351"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="2788,1178,4095,1351"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="1999,1178,2764,1351"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="4119,1178,5140,1351"><area shape="rect" href="classAbstractLinearAssembler.html" title="{AbstractLinearAssembler\&lt; DIM, DIM, 1, false, MonodomainRhsMatrixAssembler\&lt; DIM \&gt; \&gt;\n|&#45; mMatrixIsConstant\l|+ AbstractLinearAssembler()\l+ ~AbstractLinearAssembler()\l+ Solve()\l# SetMatrixIsConst()\l# ApplyDirichletConditions()\l# InitialiseForSolve()\l# ProblemIsNonlinear()\l# StaticSolve()\l}" alt="" coords="6716,1178,7265,1351"><area shape="rect" href="classBidomainWithBathRhsMatrixAssembler.html" title="{BidomainWithBathRhsMatrixAssembler\&lt; DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ BidomainWithBathRhsMatrixAssembler()\l+ ~BidomainWithBathRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="6255,1588,6551,1762"><area shape="rect" href="classBidomainWithBathRhsMatrixAssembler.html" title="{BidomainWithBathRhsMatrixAssembler\&lt; SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ BidomainWithBathRhsMatrixAssembler()\l+ ~BidomainWithBathRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="6091,2034,6437,2207"><area shape="rect" href="classSimpleLinearEllipticAssembler.html" title="{SimpleLinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mpEllipticPde\l|}" alt="" coords="7639,1616,8116,1734"><area shape="rect" href="classBidomainRhsMatrixAssembler.html" title="{BidomainRhsMatrixAssembler\&lt; DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ BidomainRhsMatrixAssembler()\l+ ~BidomainRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="8668,1588,8911,1762"><area shape="rect" href="classBidomainRhsMatrixAssembler.html" title="{BidomainRhsMatrixAssembler\&lt; SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ BidomainRhsMatrixAssembler()\l+ ~BidomainRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="8533,2034,8829,2207"><area shape="rect" href="classBidomainDg0Assembler.html" title="{BidomainDg0Assembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l# mpBidomainPde\l# mpConfig\l# mIionic\l# mIIntracellularStimulus\l# mIExtracellularStimulus\l# mNullSpaceCreated\l# mExternalVoltageMask\l# mFixedExtracellularPotentialNodes\l# mRowForAverageOfPhiZeroed\l|+ BidomainDg0Assembler()\l+ ~BidomainDg0Assembler()\l+ SetFixedExtracellularPotentialNodes()\l+ SetRowForAverageOfPhiZeroed()\l# ResetInterpolatedQuantities()\l# InitialiseForSolve()\l# IncrementInterpolatedQuantities()\l# ComputeMatrixTerm()\l# ComputeVectorTerm()\l# ComputeVectorSurfaceTerm()\l# PrepareForAssembleSystem()\l# FinaliseAssembleSystem()\l}" alt="" coords="2427,1484,2787,1866"><area shape="rect" href="classSimpleDg0ParabolicAssembler.html" title="{SimpleDg0ParabolicAssembler\&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l&#45; mpParabolicPde\l|}" alt="" coords="3368,1616,3933,1734"><area shape="rect" href="classMonodomainRhsMatrixAssembler.html" title="{MonodomainRhsMatrixAssembler\&lt; DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ MonodomainRhsMatrixAssembler()\l+ ~MonodomainRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="7012,1588,7276,1762"><area shape="rect" href="classMonodomainRhsMatrixAssembler.html" title="{MonodomainRhsMatrixAssembler\&lt; SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l|+ ComputeMatrixTerm()\l+ ComputeVectorTerm()\l+ ComputeVectorSurfaceTerm()\l+ MonodomainRhsMatrixAssembler()\l+ ~MonodomainRhsMatrixAssembler()\l+ GetMatrix()\l}" alt="" coords="6871,2034,7185,2207"><area shape="rect" href="classAbstractNonlinearAssembler.html" title="{AbstractNonlinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE \&gt;\n|# mpSolver\l# mWeAllocatedSolverMemory\l# mUseAnalyticalJacobian\l&#45; mInitialGuess\l|+ AssembleResidual()\l+ AssembleJacobian()\l+ AbstractNonlinearAssembler()\l+ ~AbstractNonlinearAssembler()\l+ SetUseAnalyticalJacobian()\l+ Solve()\l+ SetNonlinearSolver()\l+ CreateConstantInitialGuess()\l+ VerifyJacobian()\l# ApplyDirichletConditions()\l# AssembleJacobianNumerically()\l# AssembleSystem()\l# ProblemIsNonlinear()\l# InitialiseForSolve()\l# StaticSolve()\l}" alt="" coords="9575,1108,10143,1420"><area shape="rect" href="classAbstractNonlinearAssembler.html" title="{AbstractNonlinearAssembler\&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt; \&gt;\n|# mpSolver\l# mWeAllocatedSolverMemory\l# mUseAnalyticalJacobian\l&#45; mInitialGuess\l|+ AssembleResidual()\l+ AssembleJacobian()\l+ AbstractNonlinearAssembler()\l+ ~AbstractNonlinearAssembler()\l+ SetUseAnalyticalJacobian()\l+ Solve()\l+ SetNonlinearSolver()\l+ CreateConstantInitialGuess()\l+ VerifyJacobian()\l# ApplyDirichletConditions()\l# AssembleJacobianNumerically()\l# AssembleSystem()\l# ProblemIsNonlinear()\l# InitialiseForSolve()\l# StaticSolve()\l}" alt="" coords="9784,1519,10587,1831"><area shape="rect" href="classSimpleNonlinearEllipticAssembler.html" title="{SimpleNonlinearEllipticAssembler\&lt; ELEMENT_DIM, SPACE_DIM \&gt;\n|+ E_DIM\l+ S_DIM\l+ P_DIM\l&#45; mpNonlinearEllipticPde\l|+ SimpleNonlinearEllipticAssembler()\l&#45; ComputeMatrixTerm()\l&#45; ComputeVectorTerm()\l&#45; ComputeVectorSurfaceTerm()\l}" alt="" coords="9977,2042,10393,2199"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>
<div class="dynheader">
Collaboration diagram for AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;:</div>
<div class="dynsection">
<p><center><img src="classAbstractAssembler__coll__graph.png" border="0" usemap="#AbstractAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_01_4__coll__map" alt="Collaboration graph"></center>
<map name="AbstractAssembler_3_01ELEMENT__DIM_00_01SPACE__DIM_00_01PROBLEM__DIM_01_4__coll__map">
<area shape="rect" href="classBoundaryConditionsContainer.html" title="{BoundaryConditionsContainer\&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|&#45; mpNeumannMap\l&#45; mLastNeumannCondition\l&#45; mAnyNonZeroNeumannConditionsForUnknown\l&#45; mpZeroBoundaryCondition\l|+ BoundaryConditionsContainer()\l+ ~BoundaryConditionsContainer()\l+ AddDirichletBoundaryCondition()\l+ AddNeumannBoundaryCondition()\l+ DefineZeroDirichletOnMeshBoundary()\l+ DefineConstantDirichletOnMeshBoundary()\l+ DefineZeroNeumannOnMeshBoundary()\l+ ApplyDirichletToLinearProblem()\l+ ApplyDirichletToNonlinearResidual()\l+ ApplyDirichletToNonlinearJacobian()\l+ Validate()\l+ GetNeumannBCValue()\l+ HasNeumannBoundaryCondition()\l+ AnyNonZeroNeumannConditions()\l+ BeginNeumann()\l+ EndNeumann()\l}" alt="" coords="988,756,1484,1081"><area shape="rect" href="classBoundaryConditionsContainer.html" title="{BoundaryConditionsContainer\&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM \&gt;\n|&#45; mpNeumannMap\l&#45; mLastNeumannCondition\l&#45; mAnyNonZeroNeumannConditionsForUnknown\l&#45; mpZeroBoundaryCondition\l|+ BoundaryConditionsContainer()\l+ ~BoundaryConditionsContainer()\l+ AddDirichletBoundaryCondition()\l+ AddNeumannBoundaryCondition()\l+ DefineZeroDirichletOnMeshBoundary()\l+ DefineConstantDirichletOnMeshBoundary()\l+ DefineZeroNeumannOnMeshBoundary()\l+ ApplyDirichletToLinearProblem()\l+ ApplyDirichletToNonlinearResidual()\l+ ApplyDirichletToNonlinearJacobian()\l+ Validate()\l+ GetNeumannBCValue()\l+ HasNeumannBoundaryCondition()\l+ AnyNonZeroNeumannConditions()\l+ BeginNeumann()\l+ EndNeumann()\l}" alt="" coords="840,366,1309,692"></map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center></div>

<p>
<a href="classAbstractAssembler-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#9a4a0d466be779b073a73748217e0556">AbstractAssembler</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#d1d376deefa9502c8e39f63866d2423c">SetBoundaryConditionsContainer</a> (<a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; *pBoundaryConditions)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#10834c3e77a4077674e7ad546032edee">~AbstractAssembler</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#d5bb534be4585dbd3bdf8637dfe619c1">ResetInterpolatedQuantities</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#c0b8cdb429b1a017f814a014241bf3ff">IncrementInterpolatedQuantities</a> (double phi_i, const <a class="el" href="classNode.html">Node</a>&lt; SPACE_DIM &gt; *pNode)</td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#68e46d5f7f836223d025d81351becae0">SetMatrixIsConst</a> (bool matrixIsConstant=true)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual c_matrix&lt; double, <br>
PROBLEM_DIM *(ELEMENT_DIM+1), <br>
PROBLEM_DIM *(ELEMENT_DIM+1)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#910cf3ecc9622af305c0bec507609545">ComputeMatrixTerm</a> (c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, ELEMENT_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, PROBLEM_DIM &gt; &amp;u, c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual c_vector&lt; double, <br>
PROBLEM_DIM *(ELEMENT_DIM+1)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#8965f7df926db96bbc5b2c3e6b967fc2">ComputeVectorTerm</a> (c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, ELEMENT_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, PROBLEM_DIM &gt; &amp;u, c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual c_vector&lt; double, <br>
PROBLEM_DIM *ELEMENT_DIM &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#0c8d53504e43c0acfc68f9cf98d97c8d">ComputeVectorSurfaceTerm</a> (const BoundaryElement&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, ELEMENT_DIM &gt; &amp;rPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement</a> (Element&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement, c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;rAElem, c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;rBElem, bool assembleVector, bool assembleMatrix)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#c3dee23c12daa3facaecbc13546e247b">AssembleOnSurfaceElement</a> (const BoundaryElement&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;rBSurfElem)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9ae4f4ce934a931a3be8b776c5191c31"></a><!-- doxytag: member="AbstractAssembler::AssembleSystem" ref="9ae4f4ce934a931a3be8b776c5191c31" args="(bool assembleVector, bool assembleMatrix, Vec currentSolutionOrGuess=NULL, double currentTime=0.0)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><b>AssembleSystem</b> (bool assembleVector, bool assembleMatrix, Vec currentSolutionOrGuess=NULL, double currentTime=0.0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#c95938dd3454b2f0175269cac4634ffe">PrepareForSolve</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#9b386b36c616c1bf9bda87c56701a7b1">PrepareForAssembleSystem</a> (Vec currentSolutionOrGuess, double currentTime)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#ee1ca595e6a96c333f5526a04a398b71">FinaliseAssembleSystem</a> (Vec currentSolutionOrGuess, double currentTime)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#6639e3911c942536ec17af7aa90db92d">FinaliseLinearSystem</a> (Vec currentSolutionOrGuess, double currentTime, bool assembleVector, bool assembleMatrix)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#ebd31166fc064a704dca661f259eda03">ApplyDirichletConditions</a> (Vec currentSolutionOrGuess, bool applyToMatrix)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#7c66cce275f297ad2c13a5f42d597a69">ProblemIsNonlinear</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual Vec&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#1f4769b876004c784a2d2ec8f845f8e3">StaticSolve</a> (Vec currentSolutionOrGuess=NULL, double currentTime=0.0, bool assembleMatrix=true)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#5dc3a84b7d6535cf2c1727c0fc00c75f">InitialiseForSolve</a> (Vec initialGuess)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="classLinearSystem.html">LinearSystem</a> **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#10bc9f80f9fcf7efe0989a67d0993d3c">GetLinearSystem</a> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b16b05fe3ba5b32d72f114ad587900ef"></a><!-- doxytag: member="AbstractAssembler::rGetCurrentSolutionOrGuess" ref="b16b05fe3ba5b32d72f114ad587900ef" args="()=0" -->
virtual ReplicatableVector &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><b>rGetCurrentSolutionOrGuess</b> ()=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#2affb9cf8a934b9fe2f3e15d7361151e">ApplyNeummanBoundaryConditions</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a><br>
&lt; ELEMENT_DIM, SPACE_DIM, <br>
PROBLEM_DIM &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAbstractAssembler.html#eb85a48384f748109cb169d7b45c0b62">mpBoundaryConditions</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt;<br>
 class AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;</h3>

<a class="el" href="classAbstractAssembler.html">AbstractAssembler</a><p>
Base class from which all solvers for linear and nonlinear PDEs inherit. Templated over the PROBLEM_DIM so also handles problems with more than one unknown variable (ie those of the form u_xx + v = 0, v_xx + 2u = 1, where PROBLEM_DIM is equal to 2)<p>
It defines a common interface for AssembleSystem, AssembleOnElement and AssembleOnSurfaceElement. Each of these work for any PROBLEM_DIM&gt;=1. Each of these methods work in both the dynamic case (when there is a current solution available) and the static case. The same code is used for the nonlinear and linear cases. Default code is defined in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a><p>
user calls:<p>
Solve(). In the linear case Solve() calls AssembleSystem() directly, in the nonlinear case Solve() calls the PETSc nonlinear solver which then calls AssembleResidual or AssembleJacobian, both of which call AssembleSystem():<p>
AssembleSystem(). (implemented in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a>, loops over elements and adds to the linear system or residual vector or jacobian matrix) AssembleSystem() calls:<p>
<a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a> and <a class="el" href="classAbstractAssembler.html#c3dee23c12daa3facaecbc13546e247b">AssembleOnSurfaceElement()</a>. (implemented in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a>. These loop over gauss points and create the element stiffness matrix and vector in the linear case ). They call:<p>
<a class="el" href="classAbstractAssembler.html#910cf3ecc9622af305c0bec507609545">ComputeMatrixTerm()</a>, <a class="el" href="classAbstractAssembler.html#8965f7df926db96bbc5b2c3e6b967fc2">ComputeVectorTerm()</a>, <a class="el" href="classAbstractAssembler.html#0c8d53504e43c0acfc68f9cf98d97c8d">ComputeVectorSurfaceTerm()</a> (implemented in the concrete assembler class (eg <a class="el" href="classSimpleDg0ParabolicAssembler.html">SimpleDg0ParabolicAssembler</a>), which tells this assembler exactly what function of bases, position, pde constants etc to add to the element stiffness matrix/vector). 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00077">77</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="9a4a0d466be779b073a73748217e0556"></a><!-- doxytag: member="AbstractAssembler::AbstractAssembler" ref="9a4a0d466be779b073a73748217e0556" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::<a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default constructor. 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00330">330</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>References <a class="el" href="AbstractAssembler_8hpp-source.html#l00082">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::mpBoundaryConditions</a>.</p>

</div>
</div><p>
<a class="anchor" name="10834c3e77a4077674e7ad546032edee"></a><!-- doxytag: member="AbstractAssembler::~AbstractAssembler" ref="10834c3e77a4077674e7ad546032edee" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::~<a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Delete any memory allocated by this class. 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00348">348</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="68e46d5f7f836223d025d81351becae0"></a><!-- doxytag: member="AbstractAssembler::SetMatrixIsConst" ref="68e46d5f7f836223d025d81351becae0" args="(bool matrixIsConstant=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::SetMatrixIsConst           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>matrixIsConstant</em> = <code>true</code>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Hack for dynamic mixin 
<p>Reimplemented in <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, and <a class="el" href="classAbstractLinearAssembler.html#2f640688069c08f9c132f7cf3511dc9e">AbstractLinearAssembler&lt; DIM, DIM, 1, false, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00086">86</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

</div>
</div><p>
<a class="anchor" name="910cf3ecc9622af305c0bec507609545"></a><!-- doxytag: member="AbstractAssembler::ComputeMatrixTerm" ref="910cf3ecc9622af305c0bec507609545" args="(c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, ELEMENT_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, PROBLEM_DIM &gt; &amp;u, c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual c_matrix&lt;double,PROBLEM_DIM*(ELEMENT_DIM+1),PROBLEM_DIM*(ELEMENT_DIM+1)&gt; <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ComputeMatrixTerm           </td>
          <td>(</td>
          <td class="paramtype">c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, ELEMENT_DIM, ELEMENT_DIM+1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rGradPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChastePoint&lt; SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, PROBLEM_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rGradU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>pElement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the matrix to be added to element stiffness matrix for a given gauss point. The arguments are the bases, bases gradients, x and current solution computed at the Gauss point. The returned matrix will be multiplied by the gauss weight and jacobian determinent and added to the element stiffness matrix (see <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a>).<p>
--This method has to be implemented in the concrete class--<p>
NOTE: for linear problems rGradU is NOT set up correctly because it should not be needed<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rPhi</em>&nbsp;</td><td>The basis functions, rPhi(i) = phi_i, i=1..numBases </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rGradPhi</em>&nbsp;</td><td>Basis gradients, rGradPhi(i,j) = d(phi_j)/d(X_i) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rX</em>&nbsp;</td><td>The point in space </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>The unknown as a vector, u(i) = u_i </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rGradU</em>&nbsp;</td><td>The gradient of the unknown as a matrix, rGradU(i,j) = d(u_i)/d(X_j) </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00152">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleOnElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="8965f7df926db96bbc5b2c3e6b967fc2"></a><!-- doxytag: member="AbstractAssembler::ComputeVectorTerm" ref="8965f7df926db96bbc5b2c3e6b967fc2" args="(c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, ELEMENT_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, PROBLEM_DIM &gt; &amp;u, c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual c_vector&lt;double,PROBLEM_DIM*(ELEMENT_DIM+1)&gt; <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ComputeVectorTerm           </td>
          <td>(</td>
          <td class="paramtype">c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, ELEMENT_DIM, ELEMENT_DIM+1 &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rGradPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChastePoint&lt; SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, PROBLEM_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, PROBLEM_DIM, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rGradU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>pElement</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the vector to be added to element stiffness vector for a given gauss point. The arguments are the bases, x and current solution computed at the Gauss point. The returned vector will be multiplied by the gauss weight and jacobian determinent and added to the element stiffness matrix (see <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a>).<p>
--This method has to be implemented in the concrete class--<p>
NOTE: for linear problems rGradPhi and rGradU are NOT set up correctly because they should not be needed<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rPhi</em>&nbsp;</td><td>The basis functions, rPhi(i) = phi_i, i=1..numBases </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rGradPhi</em>&nbsp;</td><td>Basis gradients, rGradPhi(i,j) = d(phi_j)/d(X_i) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rX</em>&nbsp;</td><td>The point in space </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>u</em>&nbsp;</td><td>The unknown as a vector, u(i) = u_i </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rGradU</em>&nbsp;</td><td>The gradient of the unknown as a matrix, rGradU(i,j) = d(u_i)/d(X_j) </td></tr>
  </table>
</dl>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00152">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleOnElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="0c8d53504e43c0acfc68f9cf98d97c8d"></a><!-- doxytag: member="AbstractAssembler::ComputeVectorSurfaceTerm" ref="0c8d53504e43c0acfc68f9cf98d97c8d" args="(const BoundaryElement&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, ELEMENT_DIM &gt; &amp;rPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual c_vector&lt;double, PROBLEM_DIM*ELEMENT_DIM&gt; <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ComputeVectorSurfaceTerm           </td>
          <td>(</td>
          <td class="paramtype">const BoundaryElement&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rSurfaceElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, ELEMENT_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rPhi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ChastePoint&lt; SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rX</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method returns the vector to be added to element stiffness vector for a given gauss point in BoundaryElement. The arguments are the bases, x and current solution computed at the Gauss point. The returned vector will be multiplied by the gauss weight and jacobian determinent and added to the element stiffness matrix (see <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a>).<p>
--This method has to be implemented in the concrete class--<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rSurfaceElement</em>&nbsp;</td><td>the element which is being considered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rPhi</em>&nbsp;</td><td>The basis functions, rPhi(i) = phi_i, i=1..numBases </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rX</em>&nbsp;</td><td>The point in space </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classBidomainDg0Assembler.html#8226b0e6346ab15ddb650455555da158">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classSimpleNonlinearEllipticAssembler.html#bda2f839ec3fd6573fb1dd34d2a954ea">SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#8226b0e6346ab15ddb650455555da158">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00295">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleOnSurfaceElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="4b3c3db59a7f16a894a6a2a273566cd1"></a><!-- doxytag: member="AbstractAssembler::AssembleOnElement" ref="4b3c3db59a7f16a894a6a2a273566cd1" args="(Element&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement, c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;rAElem, c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;rBElem, bool assembleVector, bool assembleMatrix)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AssembleOnElement           </td>
          <td>(</td>
          <td class="paramtype">Element&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rAElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rBElem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the contribution of a single element to the linear system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rElement</em>&nbsp;</td><td>The element to assemble on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rAElem</em>&nbsp;</td><td>The element's contribution to the LHS matrix is returned in this n by n matrix, where n is the no. of nodes in this element. There is no need to zero this matrix before calling. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rBElem</em>&nbsp;</td><td>The element's contribution to the RHS vector is returned in this vector of length n, the no. of nodes in this element. There is no need to zero this vector before calling. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td>For the parabolic linear case, the solution at the current timestep. NULL for the static linear case. In the nonlinear case, the current guess. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleVector</em>&nbsp;</td><td>a bool stating whether to assemble the load vector (in the linear case) or the residual vector (in the nonlinear case) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleMatrix</em>&nbsp;</td><td>a bool stating whether to assemble the stiffness matrix (in the linear case) or the Jacobian matrix (in the nonlinear case)</td></tr>
  </table>
</dl>
Called by AssembleSystem() Calls <a class="el" href="classAbstractAssembler.html#910cf3ecc9622af305c0bec507609545">ComputeMatrixTerm()</a> etc<p>
Implemented in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a> 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#3bc301a0f4ed1c956930eefd9a20cd7d">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="c3dee23c12daa3facaecbc13546e247b"></a><!-- doxytag: member="AbstractAssembler::AssembleOnSurfaceElement" ref="c3dee23c12daa3facaecbc13546e247b" args="(const BoundaryElement&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;rBSurfElem)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AssembleOnSurfaceElement           </td>
          <td>(</td>
          <td class="paramtype">const BoundaryElement&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rSurfaceElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rBSurfElem</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the contribution of a single surface element with Neumann boundary condition to the linear system.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rSurfaceElement</em>&nbsp;</td><td>The element to assemble on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rBSurfElem</em>&nbsp;</td><td>The element's contribution to the RHS vector is returned in this vector of length n, the no. of nodes in this element. There is no need to zero this vector before calling.</td></tr>
  </table>
</dl>
Implemented in <a class="el" href="classAbstractStaticAssembler.html">AbstractStaticAssembler</a> 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#67c03373c0ac41343d73c4e3adba52b1">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractAssembler_8hpp-source.html#l00299">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyNeummanBoundaryConditions()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c95938dd3454b2f0175269cac4634ffe"></a><!-- doxytag: member="AbstractAssembler::PrepareForSolve" ref="c95938dd3454b2f0175269cac4634ffe" args="()=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::PrepareForSolve           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called at the beginning of Solve(). Subclass assemblers can use it to check everything has been set up correctly 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#0eb4e7ff30b1e202cd7a95146f7546b7">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="9b386b36c616c1bf9bda87c56701a7b1"></a><!-- doxytag: member="AbstractAssembler::PrepareForAssembleSystem" ref="9b386b36c616c1bf9bda87c56701a7b1" args="(Vec currentSolutionOrGuess, double currentTime)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::PrepareForAssembleSystem           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called at the beginning of AssembleSystem() and should be overloaded in the concrete assembler class if there is any work to be done before assembling, for example integrating ODEs such as in the Monodomain assembler. 
<p>Reimplemented in <a class="el" href="classBidomainDg0Assembler.html#2888ba56071823d90c16dd27188d7df6">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classMonodomainDg0Assembler.html#37a972d5edc7d8c1ed546dcb511cfe7f">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#2888ba56071823d90c16dd27188d7df6">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00231">231</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00378">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleSystem()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ee1ca595e6a96c333f5526a04a398b71"></a><!-- doxytag: member="AbstractAssembler::FinaliseAssembleSystem" ref="ee1ca595e6a96c333f5526a04a398b71" args="(Vec currentSolutionOrGuess, double currentTime)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::FinaliseAssembleSystem           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called at the end of AssembleSystem() and should be overloaded in the concrete assembler class if there is any further work to be done 
<p>Reimplemented in <a class="el" href="classBidomainDg0Assembler.html#4afc62452630cc61dc26c5f6d19b42db">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#4afc62452630cc61dc26c5f6d19b42db">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00238">238</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00378">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleSystem()</a>.</p>

</div>
</div><p>
<a class="anchor" name="6639e3911c942536ec17af7aa90db92d"></a><!-- doxytag: member="AbstractAssembler::FinaliseLinearSystem" ref="6639e3911c942536ec17af7aa90db92d" args="(Vec currentSolutionOrGuess, double currentTime, bool assembleVector, bool assembleMatrix)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::FinaliseLinearSystem           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleVector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, protected, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Can be overloaded if the user needs to edit the linear system after the boundary conditions have been added by before it is solved 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00245">245</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00378">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleSystem()</a>.</p>

</div>
</div><p>
<a class="anchor" name="ebd31166fc064a704dca661f259eda03"></a><!-- doxytag: member="AbstractAssembler::ApplyDirichletConditions" ref="ebd31166fc064a704dca661f259eda03" args="(Vec currentSolutionOrGuess, bool applyToMatrix)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyDirichletConditions           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>applyToMatrix</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This method is called by AssembleSystem to apply dirichlet conditions to the system. 
<p>Implemented in <a class="el" href="classAbstractLinearAssembler.html#f0bae593e69eeab5fc0aba1a5042488e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#24df26dc705b54b2f626b5114e8c36a9">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#f0bae593e69eeab5fc0aba1a5042488e">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#f0bae593e69eeab5fc0aba1a5042488e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#f0bae593e69eeab5fc0aba1a5042488e">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#f0bae593e69eeab5fc0aba1a5042488e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#f0bae593e69eeab5fc0aba1a5042488e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#f0bae593e69eeab5fc0aba1a5042488e">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#f0bae593e69eeab5fc0aba1a5042488e">AbstractLinearAssembler&lt; DIM, DIM, 1, false, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classAbstractNonlinearAssembler.html#24df26dc705b54b2f626b5114e8c36a9">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00378">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleSystem()</a>.</p>

</div>
</div><p>
<a class="anchor" name="7c66cce275f297ad2c13a5f42d597a69"></a><!-- doxytag: member="AbstractAssembler::ProblemIsNonlinear" ref="7c66cce275f297ad2c13a5f42d597a69" args="()=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual bool <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ProblemIsNonlinear           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Whether grad_u should be calculated 
<p>Implemented in <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#249c069dddfd82fa3bd0429941131c09">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#dc0e5b6dc248a154fc425bf6ac618090">AbstractLinearAssembler&lt; DIM, DIM, 1, false, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classAbstractNonlinearAssembler.html#249c069dddfd82fa3bd0429941131c09">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00152">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleOnElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="1f4769b876004c784a2d2ec8f845f8e3"></a><!-- doxytag: member="AbstractAssembler::StaticSolve" ref="1f4769b876004c784a2d2ec8f845f8e3" args="(Vec currentSolutionOrGuess=NULL, double currentTime=0.0, bool assembleMatrix=true)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual Vec <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::StaticSolve           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>currentSolutionOrGuess</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>currentTime</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>assembleMatrix</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform the work of a single solve, but without any initialisation. Static assemblers must implement this method.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>currentSolutionOrGuess</em>&nbsp;</td><td>either the current solution (dynamic problem) or initial guess (static problem); optional in some cases </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currentTime</em>&nbsp;</td><td>for a dynamic problem, the current time </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>assembleMatrix</em>&nbsp;</td><td>whether to assemble the matrix (it may have been done by a previous call) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the solution vector </dd></dl>

<p>Implemented in <a class="el" href="classAbstractLinearAssembler.html#42921b192484e1aeba44e208f98dff25">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#5645b3fcde13bd8802099837e535e342">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#42921b192484e1aeba44e208f98dff25">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#42921b192484e1aeba44e208f98dff25">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#42921b192484e1aeba44e208f98dff25">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#42921b192484e1aeba44e208f98dff25">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#42921b192484e1aeba44e208f98dff25">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#42921b192484e1aeba44e208f98dff25">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#42921b192484e1aeba44e208f98dff25">AbstractLinearAssembler&lt; DIM, DIM, 1, false, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classAbstractNonlinearAssembler.html#5645b3fcde13bd8802099837e535e342">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="5dc3a84b7d6535cf2c1727c0fc00c75f"></a><!-- doxytag: member="AbstractAssembler::InitialiseForSolve" ref="5dc3a84b7d6535cf2c1727c0fc00c75f" args="(Vec initialGuess)=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::InitialiseForSolve           </td>
          <td>(</td>
          <td class="paramtype">Vec&nbsp;</td>
          <td class="paramname"> <em>initialGuess</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Perform any initialisation needed before a sequence of StaticSolve calls. 
<p>Implemented in <a class="el" href="classBidomainDg0Assembler.html#2020a53a83bc9a5cd93ac5b4c3c28e39">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classMonodomainDg0Assembler.html#5f9582fc6f0db41b2de406d56af94383">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#c38f20321598966e53a0e0300462c736">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractNonlinearAssembler.html#07c583a147955333eb5a909602973270">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, CONCRETE &gt;</a>, <a class="el" href="classBidomainDg0Assembler.html#2020a53a83bc9a5cd93ac5b4c3c28e39">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#c38f20321598966e53a0e0300462c736">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#c38f20321598966e53a0e0300462c736">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, true, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#c38f20321598966e53a0e0300462c736">AbstractLinearAssembler&lt; DIM, DIM, 2, false, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#c38f20321598966e53a0e0300462c736">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#c38f20321598966e53a0e0300462c736">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 2, false, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#c38f20321598966e53a0e0300462c736">AbstractLinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractLinearAssembler.html#c38f20321598966e53a0e0300462c736">AbstractLinearAssembler&lt; DIM, DIM, 1, false, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classAbstractNonlinearAssembler.html#07c583a147955333eb5a909602973270">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>.</p>

</div>
</div><p>
<a class="anchor" name="10bc9f80f9fcf7efe0989a67d0993d3c"></a><!-- doxytag: member="AbstractAssembler::GetLinearSystem" ref="10bc9f80f9fcf7efe0989a67d0993d3c" args="()=0" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearSystem.html">LinearSystem</a>** <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::GetLinearSystem           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Accessor methods that subclasses can use to get to useful data. 
<p>Implemented in <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, CONCRETE &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainWithBathRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleLinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, true, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, SimpleDg0ParabolicAssembler&lt; ELEMENT_DIM, SPACE_DIM, NON_HEART, CONCRETE &gt; &gt;</a>, <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, BidomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>, and <a class="el" href="classAbstractStaticAssembler.html#81ad99456f03dd5fe4cd85344c1a52f8">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;</a>.</p>

<p>Referenced by <a class="el" href="AbstractAssembler_8hpp-source.html#l00299">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyNeummanBoundaryConditions()</a>.</p>

</div>
</div><p>
<a class="anchor" name="2affb9cf8a934b9fe2f3e15d7361151e"></a><!-- doxytag: member="AbstractAssembler::ApplyNeummanBoundaryConditions" ref="2affb9cf8a934b9fe2f3e15d7361151e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyNeummanBoundaryConditions           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Apply Neumann boundary conditions to the RHS vector by looping over surface elements (though actually looping over the boundary condition objects).<p>
Note for PROBLEM_DIM&gt;1. We assume that if an element has a boundary condition on any unknown there is a boundary condition on unknown 0. This can be so for any problem by adding zero constant conditions where required although this is a bit inefficient. Proper solution involves changing BCC to have a map of arrays boundary conditions rather than an array of maps. 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00299">299</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>References <a class="el" href="BoundaryConditionsContainerImplementation_8hpp-source.html#l00419">BoundaryConditionsContainer&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AnyNonZeroNeumannConditions()</a>, <a class="el" href="classAbstractAssembler.html#c3dee23c12daa3facaecbc13546e247b">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AssembleOnSurfaceElement()</a>, <a class="el" href="GenericEventHandler_8hpp-source.html#l00114">GenericEventHandler&lt; 11, HeartEventHandler &gt;::BeginEvent()</a>, <a class="el" href="BoundaryConditionsContainerImplementation_8hpp-source.html#l00433">BoundaryConditionsContainer&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM &gt;::BeginNeumann()</a>, <a class="el" href="GenericEventHandler_8hpp-source.html#l00142">GenericEventHandler&lt; 11, HeartEventHandler &gt;::EndEvent()</a>, <a class="el" href="BoundaryConditionsContainerImplementation_8hpp-source.html#l00440">BoundaryConditionsContainer&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM &gt;::EndNeumann()</a>, <a class="el" href="classAbstractAssembler.html#10bc9f80f9fcf7efe0989a67d0993d3c">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::GetLinearSystem()</a>, and <a class="el" href="AbstractAssembler_8hpp-source.html#l00082">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::mpBoundaryConditions</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00378">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleSystem()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d1d376deefa9502c8e39f63866d2423c"></a><!-- doxytag: member="AbstractAssembler::SetBoundaryConditionsContainer" ref="d1d376deefa9502c8e39f63866d2423c" args="(BoundaryConditionsContainer&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; *pBoundaryConditions)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::SetBoundaryConditionsContainer           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>pBoundaryConditions</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the boundary conditions. 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00339">339</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>References <a class="el" href="AbstractAssembler_8hpp-source.html#l00082">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::mpBoundaryConditions</a>.</p>

<p>Referenced by <a class="el" href="BidomainProblem_8cpp-source.html#l00298">BidomainProblem&lt; DIM &gt;::OnEndOfTimestep()</a>, and <a class="el" href="SimpleNonlinearEllipticAssembler_8cpp-source.html#l00034">SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::SimpleNonlinearEllipticAssembler()</a>.</p>

</div>
</div><p>
<a class="anchor" name="d5bb534be4585dbd3bdf8637dfe619c1"></a><!-- doxytag: member="AbstractAssembler::ResetInterpolatedQuantities" ref="d5bb534be4585dbd3bdf8637dfe619c1" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ResetInterpolatedQuantities           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The concrete subclass can overload this and <a class="el" href="classAbstractAssembler.html#c0b8cdb429b1a017f814a014241bf3ff">IncrementInterpolatedQuantities()</a> if there are some quantities which need to be computed at each Gauss point. They are called in <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a> 
<p>Reimplemented in <a class="el" href="classBidomainDg0Assembler.html#174cf80830fe77d4198dfc9f3b12db52">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classMonodomainDg0Assembler.html#089872b34e8e3309c8ba9206f8389227">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#174cf80830fe77d4198dfc9f3b12db52">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00361">361</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00152">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleOnElement()</a>, and <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00295">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleOnSurfaceElement()</a>.</p>

</div>
</div><p>
<a class="anchor" name="c0b8cdb429b1a017f814a014241bf3ff"></a><!-- doxytag: member="AbstractAssembler::IncrementInterpolatedQuantities" ref="c0b8cdb429b1a017f814a014241bf3ff" args="(double phi_i, const Node&lt; SPACE_DIM &gt; *pNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::IncrementInterpolatedQuantities           </td>
          <td>(</td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phi_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNode.html">Node</a>&lt; SPACE_DIM &gt; *&nbsp;</td>
          <td class="paramname"> <em>pNode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The concrete subclass can overload this and <a class="el" href="classAbstractAssembler.html#d5bb534be4585dbd3bdf8637dfe619c1">ResetInterpolatedQuantities()</a> if there are some quantities which need to be computed at each Gauss point. They are called in <a class="el" href="classAbstractAssembler.html#4b3c3db59a7f16a894a6a2a273566cd1">AssembleOnElement()</a> 
<p>Reimplemented in <a class="el" href="classBidomainDg0Assembler.html#3fce21b3fbda161e16cf6fe94ad8e148">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, <a class="el" href="classMonodomainDg0Assembler.html#52c373783e8c5ed88fd4b71f881dfbc9">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>, and <a class="el" href="classBidomainDg0Assembler.html#3fce21b3fbda161e16cf6fe94ad8e148">BidomainDg0Assembler&lt; DIM, DIM &gt;</a>.</p>

<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00369">369</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00152">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleOnElement()</a>, and <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00295">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::AssembleOnSurfaceElement()</a>.</p>

</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="eb85a48384f748109cb169d7b45c0b62"></a><!-- doxytag: member="AbstractAssembler::mpBoundaryConditions" ref="eb85a48384f748109cb169d7b45c0b62" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;unsigned ELEMENT_DIM, unsigned SPACE_DIM, unsigned PROBLEM_DIM&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer</a>&lt;ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM&gt;* <a class="el" href="classAbstractAssembler.html">AbstractAssembler</a>&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::<a class="el" href="classAbstractAssembler.html#eb85a48384f748109cb169d7b45c0b62">mpBoundaryConditions</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Boundary conditions to be applied 
<p>Definition at line <a class="el" href="AbstractAssembler_8hpp-source.html#l00082">82</a> of file <a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a>.</p>

<p>Referenced by <a class="el" href="AbstractAssembler_8hpp-source.html#l00330">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::AbstractAssembler()</a>, <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00095">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::ApplyDirichletConditions()</a>, <a class="el" href="AbstractLinearAssembler_8hpp-source.html#l00059">AbstractLinearAssembler&lt; DIM, DIM, 1, false, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::ApplyDirichletConditions()</a>, <a class="el" href="AbstractAssembler_8hpp-source.html#l00299">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::ApplyNeummanBoundaryConditions()</a>, <a class="el" href="BidomainDg0Assembler_8cpp-source.html#l00294">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::BidomainDg0Assembler()</a>, <a class="el" href="BidomainMatrixBasedAssembler_8cpp-source.html#l00102">BidomainRhsMatrixAssembler&lt; DIM &gt;::BidomainRhsMatrixAssembler()</a>, <a class="el" href="BidomainWithBathMatrixBasedAssembler_8cpp-source.html#l00100">BidomainWithBathRhsMatrixAssembler&lt; DIM &gt;::BidomainWithBathRhsMatrixAssembler()</a>, <a class="el" href="SimpleNonlinearEllipticAssembler_8cpp-source.html#l00122">SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::ComputeVectorSurfaceTerm()</a>, <a class="el" href="BidomainDg0Assembler_8cpp-source.html#l00160">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::ComputeVectorSurfaceTerm()</a>, <a class="el" href="MonodomainDg0Assembler_8cpp-source.html#l00093">MonodomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::MonodomainDg0Assembler()</a>, <a class="el" href="MonodomainMatrixBasedAssembler_8cpp-source.html#l00080">MonodomainRhsMatrixAssembler&lt; DIM &gt;::MonodomainRhsMatrixAssembler()</a>, <a class="el" href="AbstractStaticAssembler_8hpp-source.html#l00533">AbstractStaticAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM, NON_HEART, MonodomainRhsMatrixAssembler&lt; DIM &gt; &gt;::PrepareForSolve()</a>, <a class="el" href="AbstractAssembler_8hpp-source.html#l00339">AbstractAssembler&lt; ELEMENT_DIM, SPACE_DIM, PROBLEM_DIM &gt;::SetBoundaryConditionsContainer()</a>, <a class="el" href="BidomainDg0Assembler_8cpp-source.html#l00331">BidomainDg0Assembler&lt; ELEMENT_DIM, SPACE_DIM &gt;::SetFixedExtracellularPotentialNodes()</a>, and <a class="el" href="AbstractNonlinearAssembler_8hpp-source.html#l00298">AbstractNonlinearAssembler&lt; ELEMENT_DIM, SPACE_DIM, 1, SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt; &gt;::StaticSolve()</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>/tmp/release_1/pde/src/solver/common/<a class="el" href="AbstractAssembler_8hpp-source.html">AbstractAssembler.hpp</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Mar 18 12:51:58 2009 for Chaste by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
