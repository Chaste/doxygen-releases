<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Chaste: mesh/src/3rdparty/tetgen1.4.2/tetgen.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Chaste&#160;<span id="projectnumber">Release::3.1</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('tetgen_8cpp.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">tetgen.cpp</div>  </div>
</div>
<div class="contents">
<a href="tetgen_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00008"></a>00008 <span class="comment">// This include is here so that the chaste_libs=0 build correctly links predicates.o.</span>
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;<a class="code" href="predicates_8hpp.html">predicates.hpp</a>&quot;</span>
<a name="l00010"></a>00010 
<a name="l00012"></a>00012 <span class="comment">//                                                                           //</span>
<a name="l00013"></a>00013 <span class="comment">// TetGen                                                                    //</span>
<a name="l00014"></a>00014 <span class="comment">//                                                                           //</span>
<a name="l00015"></a>00015 <span class="comment">// A Quality Tetrahedral Mesh Generator and 3D Delaunay Triangulator         //</span>
<a name="l00016"></a>00016 <span class="comment">//                                                                           //</span>
<a name="l00017"></a>00017 <span class="comment">// Version 1.4                                                               //</span>
<a name="l00018"></a>00018 <span class="comment">// April 16, 2007                                                            //</span>
<a name="l00019"></a>00019 <span class="comment">//                                                                           //</span>
<a name="l00020"></a>00020 <span class="comment">// Copyright (C) 2002--2007                                                  //</span>
<a name="l00021"></a>00021 <span class="comment">// Hang Si                                                                   //</span>
<a name="l00022"></a>00022 <span class="comment">// Research Group Numerical Mathematics and Scientific Computing             //</span>
<a name="l00023"></a>00023 <span class="comment">// Weierstrass Institute for Applied Analysis and Stochastics                //</span>
<a name="l00024"></a>00024 <span class="comment">// Mohrenstr. 39, 10117 Berlin, Germany                                      //</span>
<a name="l00025"></a>00025 <span class="comment">// si@wias-berlin.de                                                         //</span>
<a name="l00026"></a>00026 <span class="comment">//                                                                           //</span>
<a name="l00027"></a>00027 <span class="comment">// TetGen is freely available through the website: http://tetgen.berlios.de. //</span>
<a name="l00028"></a>00028 <span class="comment">//   It may be copied, modified, and redistributed for non-commercial use.   //</span>
<a name="l00029"></a>00029 <span class="comment">//   Please consult the file LICENSE for the detailed copyright notices.     //</span>
<a name="l00030"></a>00030 <span class="comment">//                                                                           //</span>
<a name="l00032"></a>00032 <span class="comment"></span>
<a name="l00034"></a>00034 <span class="comment">//                                                                           //</span>
<a name="l00035"></a>00035 <span class="comment">// tetgen.cxx                                                                //</span>
<a name="l00036"></a>00036 <span class="comment">//                                                                           //</span>
<a name="l00037"></a>00037 <span class="comment">// The TetGen library and program.                                           //</span>
<a name="l00038"></a>00038 <span class="comment">//                                                                           //</span>
<a name="l00040"></a>00040 <span class="comment"></span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &quot;tetgen.h&quot;</span>
<a name="l00042"></a>00042 <span class="keyword">namespace </span>tetgen
<a name="l00043"></a>00043 { <span class="comment">//Added namespace to avoid clash with triangle</span>
<a name="l00044"></a>00044 
<a name="l00046"></a>00046 <span class="comment">//                                                                           //</span>
<a name="l00047"></a>00047 <span class="comment">// terminatetetgen()    Terminate TetGen with a given exit code.             //</span>
<a name="l00048"></a>00048 <span class="comment">//                                                                           //</span>
<a name="l00050"></a>00050 <span class="comment"></span>
<a name="l00051"></a>00051 <span class="keywordtype">void</span> terminatetetgen(<span class="keywordtype">int</span> x)
<a name="l00052"></a>00052 {
<a name="l00053"></a>00053 <span class="preprocessor">#ifdef TETLIBRARY</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span>  <span class="keywordflow">throw</span> x;
<a name="l00055"></a>00055 <span class="preprocessor">#else</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span>  exit(x);
<a name="l00057"></a>00057 <span class="preprocessor">#endif // #ifdef TETLIBRARY</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span>}
<a name="l00059"></a>00059 
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00061"></a>00061 <span class="comment">// Begin of class &#39;tetgenio&#39; implementation</span>
<a name="l00062"></a>00062 <span class="comment">//</span>
<a name="l00063"></a>00063 
<a name="l00065"></a>00065 <span class="comment">//                                                                           //</span>
<a name="l00066"></a>00066 <span class="comment">// initialize()    Initialize all variables of &#39;tetgenio&#39;.                   //</span>
<a name="l00067"></a>00067 <span class="comment">//                                                                           //</span>
<a name="l00068"></a>00068 <span class="comment">// It is called by the only class constructor &#39;tetgenio()&#39; implicitly. Thus, //</span>
<a name="l00069"></a>00069 <span class="comment">// all variables are guaranteed to be initialized. Each array is initialized //</span>
<a name="l00070"></a>00070 <span class="comment">// to be a &#39;NULL&#39; pointer, and its length is equal zero. Some variables have //</span>
<a name="l00071"></a>00071 <span class="comment">// their default value, &#39;firstnumber&#39; equals zero, &#39;mesh_dim&#39; equals 3,  and //</span>
<a name="l00072"></a>00072 <span class="comment">// &#39;numberofcorners&#39; equals 4.  Another possible use of this routine is to   //</span>
<a name="l00073"></a>00073 <span class="comment">// call it before to re-use an object.                                       //</span>
<a name="l00074"></a>00074 <span class="comment">//                                                                           //</span>
<a name="l00076"></a>00076 <span class="comment"></span>
<a name="l00077"></a>00077 <span class="keywordtype">void</span> tetgenio::initialize()
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079   firstnumber = 0;              <span class="comment">// Default item index is numbered from Zero.</span>
<a name="l00080"></a>00080   mesh_dim = 3;                              <span class="comment">// Default mesh dimension is 3.</span>
<a name="l00081"></a>00081   useindex = <span class="keyword">true</span>;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083   pointlist = (REAL *) NULL;
<a name="l00084"></a>00084   pointattributelist = (REAL *) NULL;
<a name="l00085"></a>00085   pointmtrlist = (REAL *) NULL;
<a name="l00086"></a>00086   pointmarkerlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00087"></a>00087   numberofpoints = 0;
<a name="l00088"></a>00088   numberofpointattributes = 0;
<a name="l00089"></a>00089   numberofpointmtrs = 0;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091   tetrahedronlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00092"></a>00092   tetrahedronattributelist = (REAL *) NULL;
<a name="l00093"></a>00093   tetrahedronvolumelist = (REAL *) NULL;
<a name="l00094"></a>00094   neighborlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00095"></a>00095   numberoftetrahedra = 0;
<a name="l00096"></a>00096   numberofcorners = 4;                   <span class="comment">// Default is 4 nodes per element.</span>
<a name="l00097"></a>00097   numberoftetrahedronattributes = 0;
<a name="l00098"></a>00098 
<a name="l00099"></a>00099   trifacelist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00100"></a>00100   adjtetlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00101"></a>00101   trifacemarkerlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00102"></a>00102   numberoftrifaces = 0;
<a name="l00103"></a>00103 
<a name="l00104"></a>00104   facetlist = (facet *) NULL;
<a name="l00105"></a>00105   facetmarkerlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00106"></a>00106   numberoffacets = 0;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108   edgelist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00109"></a>00109   edgemarkerlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00110"></a>00110   numberofedges = 0;
<a name="l00111"></a>00111 
<a name="l00112"></a>00112   holelist = (REAL *) NULL;
<a name="l00113"></a>00113   numberofholes = 0;
<a name="l00114"></a>00114 
<a name="l00115"></a>00115   regionlist = (REAL *) NULL;
<a name="l00116"></a>00116   numberofregions = 0;
<a name="l00117"></a>00117 
<a name="l00118"></a>00118   facetconstraintlist = (REAL *) NULL;
<a name="l00119"></a>00119   numberoffacetconstraints = 0;
<a name="l00120"></a>00120   segmentconstraintlist = (REAL *) NULL;
<a name="l00121"></a>00121   numberofsegmentconstraints = 0;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123   pbcgrouplist = (pbcgroup *) NULL;
<a name="l00124"></a>00124   numberofpbcgroups = 0;
<a name="l00125"></a>00125 
<a name="l00126"></a>00126   vpointlist = (REAL *) NULL;
<a name="l00127"></a>00127   vedgelist = (voroedge *) NULL;
<a name="l00128"></a>00128   vfacetlist = (vorofacet *) NULL;
<a name="l00129"></a>00129   vcelllist = (<span class="keywordtype">int</span> **) NULL;
<a name="l00130"></a>00130   numberofvpoints = 0;
<a name="l00131"></a>00131   numberofvedges = 0;
<a name="l00132"></a>00132   numberofvfacets = 0;
<a name="l00133"></a>00133   numberofvcells = 0;
<a name="l00134"></a>00134 }
<a name="l00135"></a>00135 
<a name="l00137"></a>00137 <span class="comment">//                                                                           //</span>
<a name="l00138"></a>00138 <span class="comment">// deinitialize()    Free the memory allocated in &#39;tetgenio&#39;.                //</span>
<a name="l00139"></a>00139 <span class="comment">//                                                                           //</span>
<a name="l00140"></a>00140 <span class="comment">// It is called by the class destructor &#39;~tetgenio()&#39; implicitly. Hence, the //</span>
<a name="l00141"></a>00141 <span class="comment">// occupied memory by arrays of an object will be automatically released on  //</span>
<a name="l00142"></a>00142 <span class="comment">// the deletion of the object. However, this routine assumes that the memory //</span>
<a name="l00143"></a>00143 <span class="comment">// is allocated by C++ memory allocation operator &#39;new&#39;, thus it is freed by //</span>
<a name="l00144"></a>00144 <span class="comment">// the C++ array deletor &#39;delete []&#39;. If one uses the C/C++ library function //</span>
<a name="l00145"></a>00145 <span class="comment">// &#39;malloc()&#39; to allocate memory for arrays, one has to free them with the   //</span>
<a name="l00146"></a>00146 <span class="comment">// &#39;free()&#39; function, and call routine &#39;initialize()&#39; once to disable this   //</span>
<a name="l00147"></a>00147 <span class="comment">// routine on deletion of the object.                                        //</span>
<a name="l00148"></a>00148 <span class="comment">//                                                                           //</span>
<a name="l00150"></a>00150 <span class="comment"></span>
<a name="l00151"></a>00151 <span class="keywordtype">void</span> tetgenio::deinitialize()
<a name="l00152"></a>00152 {
<a name="l00153"></a>00153   facet *f;
<a name="l00154"></a>00154   polygon *p;
<a name="l00155"></a>00155   pbcgroup *pg;
<a name="l00156"></a>00156   <span class="keywordtype">int</span> i, j;
<a name="l00157"></a>00157 
<a name="l00158"></a>00158   <span class="keywordflow">if</span> (pointlist != (REAL *) NULL) {
<a name="l00159"></a>00159     <span class="keyword">delete</span> [] pointlist;
<a name="l00160"></a>00160   }
<a name="l00161"></a>00161   <span class="keywordflow">if</span> (pointattributelist != (REAL *) NULL) {
<a name="l00162"></a>00162     <span class="keyword">delete</span> [] pointattributelist;
<a name="l00163"></a>00163   }
<a name="l00164"></a>00164   <span class="keywordflow">if</span> (pointmtrlist != (REAL *) NULL) {
<a name="l00165"></a>00165     <span class="keyword">delete</span> [] pointmtrlist;
<a name="l00166"></a>00166   }
<a name="l00167"></a>00167   <span class="keywordflow">if</span> (pointmarkerlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00168"></a>00168     <span class="keyword">delete</span> [] pointmarkerlist;
<a name="l00169"></a>00169   }
<a name="l00170"></a>00170 
<a name="l00171"></a>00171   <span class="keywordflow">if</span> (tetrahedronlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00172"></a>00172     <span class="keyword">delete</span> [] tetrahedronlist;
<a name="l00173"></a>00173   }
<a name="l00174"></a>00174   <span class="keywordflow">if</span> (tetrahedronattributelist != (REAL *) NULL) {
<a name="l00175"></a>00175     <span class="keyword">delete</span> [] tetrahedronattributelist;
<a name="l00176"></a>00176   }
<a name="l00177"></a>00177   <span class="keywordflow">if</span> (tetrahedronvolumelist != (REAL *) NULL) {
<a name="l00178"></a>00178     <span class="keyword">delete</span> [] tetrahedronvolumelist;
<a name="l00179"></a>00179   }
<a name="l00180"></a>00180   <span class="keywordflow">if</span> (neighborlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00181"></a>00181     <span class="keyword">delete</span> [] neighborlist;
<a name="l00182"></a>00182   }
<a name="l00183"></a>00183 
<a name="l00184"></a>00184   <span class="keywordflow">if</span> (trifacelist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00185"></a>00185     <span class="keyword">delete</span> [] trifacelist;
<a name="l00186"></a>00186   }
<a name="l00187"></a>00187   <span class="keywordflow">if</span> (adjtetlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00188"></a>00188     <span class="keyword">delete</span> [] adjtetlist;
<a name="l00189"></a>00189   }
<a name="l00190"></a>00190   <span class="keywordflow">if</span> (trifacemarkerlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00191"></a>00191     <span class="keyword">delete</span> [] trifacemarkerlist;
<a name="l00192"></a>00192   }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194   <span class="keywordflow">if</span> (edgelist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00195"></a>00195     <span class="keyword">delete</span> [] edgelist;
<a name="l00196"></a>00196   }
<a name="l00197"></a>00197   <span class="keywordflow">if</span> (edgemarkerlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00198"></a>00198     <span class="keyword">delete</span> [] edgemarkerlist;
<a name="l00199"></a>00199   }
<a name="l00200"></a>00200 
<a name="l00201"></a>00201   <span class="keywordflow">if</span> (facetlist != (facet *) NULL) {
<a name="l00202"></a>00202     <span class="keywordflow">for</span> (i = 0; i &lt; numberoffacets; i++) {
<a name="l00203"></a>00203       f = &amp;facetlist[i];
<a name="l00204"></a>00204       <span class="keywordflow">for</span> (j = 0; j &lt; f-&gt;numberofpolygons; j++) {
<a name="l00205"></a>00205         p = &amp;f-&gt;polygonlist[j];
<a name="l00206"></a>00206         <span class="keyword">delete</span> [] p-&gt;vertexlist;
<a name="l00207"></a>00207       }
<a name="l00208"></a>00208       <span class="keyword">delete</span> [] f-&gt;polygonlist;
<a name="l00209"></a>00209       <span class="keywordflow">if</span> (f-&gt;holelist != (REAL *) NULL) {
<a name="l00210"></a>00210         <span class="keyword">delete</span> [] f-&gt;holelist;
<a name="l00211"></a>00211       }
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     <span class="keyword">delete</span> [] facetlist;
<a name="l00214"></a>00214   }
<a name="l00215"></a>00215   <span class="keywordflow">if</span> (facetmarkerlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00216"></a>00216     <span class="keyword">delete</span> [] facetmarkerlist;
<a name="l00217"></a>00217   }
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="keywordflow">if</span> (holelist != (REAL *) NULL) {
<a name="l00220"></a>00220     <span class="keyword">delete</span> [] holelist;
<a name="l00221"></a>00221   }
<a name="l00222"></a>00222   <span class="keywordflow">if</span> (regionlist != (REAL *) NULL) {
<a name="l00223"></a>00223     <span class="keyword">delete</span> [] regionlist;
<a name="l00224"></a>00224   }
<a name="l00225"></a>00225   <span class="keywordflow">if</span> (facetconstraintlist != (REAL *) NULL) {
<a name="l00226"></a>00226     <span class="keyword">delete</span> [] facetconstraintlist;
<a name="l00227"></a>00227   }
<a name="l00228"></a>00228   <span class="keywordflow">if</span> (segmentconstraintlist != (REAL *) NULL) {
<a name="l00229"></a>00229     <span class="keyword">delete</span> [] segmentconstraintlist;
<a name="l00230"></a>00230   }
<a name="l00231"></a>00231   <span class="keywordflow">if</span> (pbcgrouplist != (pbcgroup *) NULL) {
<a name="l00232"></a>00232     <span class="keywordflow">for</span> (i = 0; i &lt; numberofpbcgroups; i++) {
<a name="l00233"></a>00233       pg = &amp;(pbcgrouplist[i]);
<a name="l00234"></a>00234       <span class="keywordflow">if</span> (pg-&gt;pointpairlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l00235"></a>00235         <span class="keyword">delete</span> [] pg-&gt;pointpairlist;
<a name="l00236"></a>00236       }
<a name="l00237"></a>00237     }
<a name="l00238"></a>00238     <span class="keyword">delete</span> [] pbcgrouplist;
<a name="l00239"></a>00239   }
<a name="l00240"></a>00240   <span class="keywordflow">if</span> (vpointlist != (REAL *) NULL) {
<a name="l00241"></a>00241     <span class="keyword">delete</span> [] vpointlist;
<a name="l00242"></a>00242   }
<a name="l00243"></a>00243   <span class="keywordflow">if</span> (vedgelist != (voroedge *) NULL) {
<a name="l00244"></a>00244     <span class="keyword">delete</span> [] vedgelist;
<a name="l00245"></a>00245   }
<a name="l00246"></a>00246   <span class="keywordflow">if</span> (vfacetlist != (vorofacet *) NULL) {
<a name="l00247"></a>00247     <span class="keywordflow">for</span> (i = 0; i &lt; numberofvfacets; i++) {
<a name="l00248"></a>00248       <span class="keyword">delete</span> [] vfacetlist[i].elist;
<a name="l00249"></a>00249     }
<a name="l00250"></a>00250     <span class="keyword">delete</span> [] vfacetlist;
<a name="l00251"></a>00251   }
<a name="l00252"></a>00252   <span class="keywordflow">if</span> (vcelllist != (<span class="keywordtype">int</span> **) NULL) {
<a name="l00253"></a>00253     <span class="keywordflow">for</span> (i = 0; i &lt; numberofvcells; i++) {
<a name="l00254"></a>00254       <span class="keyword">delete</span> [] vcelllist[i];
<a name="l00255"></a>00255     }
<a name="l00256"></a>00256     <span class="keyword">delete</span> [] vcelllist;
<a name="l00257"></a>00257   }
<a name="l00258"></a>00258 }
<a name="l00259"></a>00259 
<a name="l00261"></a>00261 <span class="comment">//                                                                           //</span>
<a name="l00262"></a>00262 <span class="comment">// load_node_call()    Load a list of nodes.                                 //</span>
<a name="l00263"></a>00263 <span class="comment">//                                                                           //</span>
<a name="l00264"></a>00264 <span class="comment">// It is a support routine for routines: &#39;load_nodes()&#39;, &#39;load_poly()&#39;, and  //</span>
<a name="l00265"></a>00265 <span class="comment">// &#39;load_tetmesh()&#39;.  &#39;infile&#39; is the file handle contains the node list. It //</span>
<a name="l00266"></a>00266 <span class="comment">// may point to a .node, or .poly or .smesh file.  &#39;markers&#39; indicates each  //</span>
<a name="l00267"></a>00267 <span class="comment">// node contains an additional marker (integer) or not. &#39;infilename&#39; is the  //</span>
<a name="l00268"></a>00268 <span class="comment">// name of the file being read,  it is only appeared in error message.       //</span>
<a name="l00269"></a>00269 <span class="comment">//                                                                           //</span>
<a name="l00270"></a>00270 <span class="comment">// The &#39;firstnumber&#39; (0 or 1) is automatically determined by the number of   //</span>
<a name="l00271"></a>00271 <span class="comment">// the first index of the first point.                                       //</span>
<a name="l00272"></a>00272 <span class="comment">//                                                                           //</span>
<a name="l00274"></a>00274 <span class="comment"></span>
<a name="l00275"></a>00275 <span class="keywordtype">bool</span> tetgenio::load_node_call(FILE* infile, <span class="keywordtype">int</span> markers, <span class="keywordtype">char</span>* infilename)
<a name="l00276"></a>00276 {
<a name="l00277"></a>00277   <span class="keywordtype">char</span> inputline[INPUTLINESIZE];
<a name="l00278"></a>00278   <span class="keywordtype">char</span> *stringptr;
<a name="l00279"></a>00279   REAL x, y, z, attrib;
<a name="l00280"></a>00280   <span class="keywordtype">int</span> firstnode, currentmarker;
<a name="l00281"></a>00281   <span class="keywordtype">int</span> index, attribindex;
<a name="l00282"></a>00282   <span class="keywordtype">int</span> i, j;
<a name="l00283"></a>00283 
<a name="l00284"></a>00284   <span class="comment">// Initialize &#39;pointlist&#39;, &#39;pointattributelist&#39;, and &#39;pointmarkerlist&#39;.</span>
<a name="l00285"></a>00285   pointlist = <span class="keyword">new</span> REAL[numberofpoints * 3];
<a name="l00286"></a>00286   <span class="keywordflow">if</span> (pointlist == (REAL *) NULL) {
<a name="l00287"></a>00287     printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l00288"></a>00288     terminatetetgen(1);
<a name="l00289"></a>00289   }
<a name="l00290"></a>00290   <span class="keywordflow">if</span> (numberofpointattributes &gt; 0) {
<a name="l00291"></a>00291     pointattributelist = <span class="keyword">new</span> REAL[numberofpoints * numberofpointattributes];
<a name="l00292"></a>00292     <span class="keywordflow">if</span> (pointattributelist == (REAL *) NULL) {
<a name="l00293"></a>00293       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l00294"></a>00294       terminatetetgen(1);
<a name="l00295"></a>00295     }
<a name="l00296"></a>00296   }
<a name="l00297"></a>00297   <span class="keywordflow">if</span> (markers) {
<a name="l00298"></a>00298     pointmarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[numberofpoints];
<a name="l00299"></a>00299     <span class="keywordflow">if</span> (pointmarkerlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l00300"></a>00300       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l00301"></a>00301       terminatetetgen(1);
<a name="l00302"></a>00302     }
<a name="l00303"></a>00303   }
<a name="l00304"></a>00304 
<a name="l00305"></a>00305   <span class="comment">// Read the point section.</span>
<a name="l00306"></a>00306   index = 0;
<a name="l00307"></a>00307   attribindex = 0;
<a name="l00308"></a>00308   <span class="keywordflow">for</span> (i = 0; i &lt; numberofpoints; i++) {
<a name="l00309"></a>00309     stringptr = readnumberline(inputline, infile, infilename);
<a name="l00310"></a>00310     <span class="keywordflow">if</span> (useindex) {
<a name="l00311"></a>00311       <span class="keywordflow">if</span> (i == 0) {
<a name="l00312"></a>00312         firstnode = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00313"></a>00313         <span class="keywordflow">if</span> ((firstnode == 0) || (firstnode == 1)) {
<a name="l00314"></a>00314           firstnumber = firstnode;
<a name="l00315"></a>00315         }
<a name="l00316"></a>00316       }
<a name="l00317"></a>00317       stringptr = findnextnumber(stringptr);
<a name="l00318"></a>00318     } <span class="comment">// if (useindex)</span>
<a name="l00319"></a>00319     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00320"></a>00320       printf(<span class="stringliteral">&quot;Error:  Point %d has no x coordinate.\n&quot;</span>, firstnumber + i);
<a name="l00321"></a>00321       <span class="keywordflow">break</span>;
<a name="l00322"></a>00322     }
<a name="l00323"></a>00323     x = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00324"></a>00324     stringptr = findnextnumber(stringptr);
<a name="l00325"></a>00325     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00326"></a>00326       printf(<span class="stringliteral">&quot;Error:  Point %d has no y coordinate.\n&quot;</span>, firstnumber + i);
<a name="l00327"></a>00327       <span class="keywordflow">break</span>;
<a name="l00328"></a>00328     }
<a name="l00329"></a>00329     y = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00330"></a>00330     <span class="keywordflow">if</span> (mesh_dim == 3) {
<a name="l00331"></a>00331       stringptr = findnextnumber(stringptr);
<a name="l00332"></a>00332       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00333"></a>00333         printf(<span class="stringliteral">&quot;Error:  Point %d has no z coordinate.\n&quot;</span>, firstnumber + i);
<a name="l00334"></a>00334         <span class="keywordflow">break</span>;
<a name="l00335"></a>00335       }
<a name="l00336"></a>00336       z = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00337"></a>00337     } <span class="keywordflow">else</span> {
<a name="l00338"></a>00338       z = 0.0; <span class="comment">// mesh_dim == 2;</span>
<a name="l00339"></a>00339     }
<a name="l00340"></a>00340     pointlist[index++] = x;
<a name="l00341"></a>00341     pointlist[index++] = y;
<a name="l00342"></a>00342     pointlist[index++] = z;
<a name="l00343"></a>00343     <span class="comment">// Read the point attributes.</span>
<a name="l00344"></a>00344     <span class="keywordflow">for</span> (j = 0; j &lt; numberofpointattributes; j++) {
<a name="l00345"></a>00345       stringptr = findnextnumber(stringptr);
<a name="l00346"></a>00346       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00347"></a>00347         attrib = 0.0;
<a name="l00348"></a>00348       } <span class="keywordflow">else</span> {
<a name="l00349"></a>00349         attrib = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00350"></a>00350       }
<a name="l00351"></a>00351       pointattributelist[attribindex++] = attrib;
<a name="l00352"></a>00352     }
<a name="l00353"></a>00353     <span class="keywordflow">if</span> (markers) {
<a name="l00354"></a>00354       <span class="comment">// Read a point marker.</span>
<a name="l00355"></a>00355       stringptr = findnextnumber(stringptr);
<a name="l00356"></a>00356       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00357"></a>00357         currentmarker = 0;
<a name="l00358"></a>00358       } <span class="keywordflow">else</span> {
<a name="l00359"></a>00359         currentmarker = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00360"></a>00360       }
<a name="l00361"></a>00361       pointmarkerlist[i] = currentmarker;
<a name="l00362"></a>00362     }
<a name="l00363"></a>00363   }
<a name="l00364"></a>00364   <span class="keywordflow">if</span> (i &lt; numberofpoints) {
<a name="l00365"></a>00365     <span class="comment">// Failed to read points due to some error.</span>
<a name="l00366"></a>00366     <span class="keyword">delete</span> [] pointlist;
<a name="l00367"></a>00367     pointlist = (REAL *) NULL;
<a name="l00368"></a>00368     <span class="keywordflow">if</span> (markers) {
<a name="l00369"></a>00369       <span class="keyword">delete</span> [] pointmarkerlist;
<a name="l00370"></a>00370       pointmarkerlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00371"></a>00371     }
<a name="l00372"></a>00372     <span class="keywordflow">if</span> (numberofpointattributes &gt; 0) {
<a name="l00373"></a>00373       <span class="keyword">delete</span> [] pointattributelist;
<a name="l00374"></a>00374       pointattributelist = (REAL *) NULL;
<a name="l00375"></a>00375     }
<a name="l00376"></a>00376     numberofpoints = 0;
<a name="l00377"></a>00377     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00378"></a>00378   }
<a name="l00379"></a>00379   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00380"></a>00380 }
<a name="l00381"></a>00381 
<a name="l00383"></a>00383 <span class="comment">//                                                                           //</span>
<a name="l00384"></a>00384 <span class="comment">// load_node()    Load a list of nodes from a .node file.                    //</span>
<a name="l00385"></a>00385 <span class="comment">//                                                                           //</span>
<a name="l00386"></a>00386 <span class="comment">// &#39;filename&#39; is the inputfile without suffix. The node list is in &#39;filename.//</span>
<a name="l00387"></a>00387 <span class="comment">// node&#39;. On completion, the node list is returned in &#39;pointlist&#39;.           //</span>
<a name="l00388"></a>00388 <span class="comment">//                                                                           //</span>
<a name="l00390"></a>00390 <span class="comment"></span>
<a name="l00391"></a>00391 <span class="keywordtype">bool</span> tetgenio::load_node(<span class="keywordtype">char</span>* filename)
<a name="l00392"></a>00392 {
<a name="l00393"></a>00393   FILE *infile;
<a name="l00394"></a>00394   <span class="keywordtype">char</span> innodefilename[FILENAMESIZE];
<a name="l00395"></a>00395   <span class="keywordtype">char</span> inputline[INPUTLINESIZE];
<a name="l00396"></a>00396   <span class="keywordtype">char</span> *stringptr;
<a name="l00397"></a>00397   <span class="keywordtype">int</span> markers;
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   markers = 0;
<a name="l00400"></a>00400   <span class="comment">// Assembling the actual file names we want to open.</span>
<a name="l00401"></a>00401   strcpy(innodefilename, filename);
<a name="l00402"></a>00402   strcat(innodefilename, <span class="stringliteral">&quot;.node&quot;</span>);
<a name="l00403"></a>00403 
<a name="l00404"></a>00404   <span class="comment">// Try to open a .node file.</span>
<a name="l00405"></a>00405   infile = fopen(innodefilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00406"></a>00406   <span class="keywordflow">if</span> (infile == (FILE *) NULL) {
<a name="l00407"></a>00407     printf(<span class="stringliteral">&quot;File I/O Error:  Cannot access file %s.\n&quot;</span>, innodefilename);
<a name="l00408"></a>00408     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00409"></a>00409   }
<a name="l00410"></a>00410   printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, innodefilename);
<a name="l00411"></a>00411   <span class="comment">// Read the first line of the file.</span>
<a name="l00412"></a>00412   stringptr = readnumberline(inputline, infile, innodefilename);
<a name="l00413"></a>00413   <span class="comment">// Is this list of points generated from rbox?</span>
<a name="l00414"></a>00414   stringptr = strstr(inputline, <span class="stringliteral">&quot;rbox&quot;</span>);
<a name="l00415"></a>00415   <span class="keywordflow">if</span> (stringptr == NULL) {
<a name="l00416"></a>00416     <span class="comment">// Read number of points, number of dimensions, number of point</span>
<a name="l00417"></a>00417     <span class="comment">//   attributes, and number of boundary markers.</span>
<a name="l00418"></a>00418     stringptr = inputline;
<a name="l00419"></a>00419     numberofpoints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00420"></a>00420     stringptr = findnextnumber(stringptr);
<a name="l00421"></a>00421     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00422"></a>00422       mesh_dim = 3;
<a name="l00423"></a>00423     } <span class="keywordflow">else</span> {
<a name="l00424"></a>00424       mesh_dim = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00425"></a>00425     }
<a name="l00426"></a>00426     stringptr = findnextnumber(stringptr);
<a name="l00427"></a>00427     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00428"></a>00428       numberofpointattributes = 0;
<a name="l00429"></a>00429     } <span class="keywordflow">else</span> {
<a name="l00430"></a>00430       numberofpointattributes = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00431"></a>00431     }
<a name="l00432"></a>00432     stringptr = findnextnumber(stringptr);
<a name="l00433"></a>00433     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00434"></a>00434       markers = 0;
<a name="l00435"></a>00435     } <span class="keywordflow">else</span> {
<a name="l00436"></a>00436       markers = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00437"></a>00437     }
<a name="l00438"></a>00438   } <span class="keywordflow">else</span> {
<a name="l00439"></a>00439     <span class="comment">// It is a rbox (qhull) input file.</span>
<a name="l00440"></a>00440     stringptr = inputline;
<a name="l00441"></a>00441     <span class="comment">// Get the dimension.</span>
<a name="l00442"></a>00442     mesh_dim = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00443"></a>00443     <span class="comment">// Get the number of points.</span>
<a name="l00444"></a>00444     stringptr = readnumberline(inputline, infile, innodefilename);
<a name="l00445"></a>00445     numberofpoints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00446"></a>00446     <span class="comment">// There is no index column.</span>
<a name="l00447"></a>00447     useindex = 0;
<a name="l00448"></a>00448   }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450   <span class="comment">// if ((mesh_dim != 3) &amp;&amp; (mesh_dim != 2)) {</span>
<a name="l00451"></a>00451   <span class="comment">//   printf(&quot;Input error:  TetGen only works for 2D &amp; 3D point sets.\n&quot;);</span>
<a name="l00452"></a>00452   <span class="comment">//   fclose(infile);</span>
<a name="l00453"></a>00453   <span class="comment">//   return false;</span>
<a name="l00454"></a>00454   <span class="comment">// }</span>
<a name="l00455"></a>00455   <span class="keywordflow">if</span> (numberofpoints &lt; (mesh_dim + 1)) {
<a name="l00456"></a>00456     printf(<span class="stringliteral">&quot;Input error:  TetGen needs at least %d points.\n&quot;</span>, mesh_dim + 1);
<a name="l00457"></a>00457     fclose(infile);
<a name="l00458"></a>00458     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00459"></a>00459   }
<a name="l00460"></a>00460 
<a name="l00461"></a>00461   <span class="comment">// Load the list of nodes.</span>
<a name="l00462"></a>00462   <span class="keywordflow">if</span> (!load_node_call(infile, markers, innodefilename)) {
<a name="l00463"></a>00463     fclose(infile);
<a name="l00464"></a>00464     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00465"></a>00465   }
<a name="l00466"></a>00466   fclose(infile);
<a name="l00467"></a>00467   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00468"></a>00468 }
<a name="l00469"></a>00469 
<a name="l00471"></a>00471 <span class="comment">//                                                                           //</span>
<a name="l00472"></a>00472 <span class="comment">// load_pbc()    Load a list of pbc groups into &#39;pbcgrouplist&#39;.              //</span>
<a name="l00473"></a>00473 <span class="comment">//                                                                           //</span>
<a name="l00474"></a>00474 <span class="comment">// &#39;filename&#39; is the filename of the original inputfile without suffix. The  //</span>
<a name="l00475"></a>00475 <span class="comment">// pbc groups are found in file &#39;filename.pbc&#39;.                              //</span>
<a name="l00476"></a>00476 <span class="comment">//                                                                           //</span>
<a name="l00477"></a>00477 <span class="comment">// This routine will be called both in load_poly() and load_tetmesh().       //</span>
<a name="l00478"></a>00478 <span class="comment">//                                                                           //</span>
<a name="l00480"></a>00480 <span class="comment"></span>
<a name="l00481"></a>00481 <span class="keywordtype">bool</span> tetgenio::load_pbc(<span class="keywordtype">char</span>* filename)
<a name="l00482"></a>00482 {
<a name="l00483"></a>00483   FILE *infile;
<a name="l00484"></a>00484   <span class="keywordtype">char</span> pbcfilename[FILENAMESIZE];
<a name="l00485"></a>00485   <span class="keywordtype">char</span> inputline[INPUTLINESIZE];
<a name="l00486"></a>00486   <span class="keywordtype">char</span> *stringptr;
<a name="l00487"></a>00487   pbcgroup *pg;
<a name="l00488"></a>00488   <span class="keywordtype">int</span> index, p1, p2;
<a name="l00489"></a>00489   <span class="keywordtype">int</span> i, j, k;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491   <span class="comment">// Pbc groups are saved in file &quot;filename.pbc&quot;.</span>
<a name="l00492"></a>00492   strcpy(pbcfilename, filename);
<a name="l00493"></a>00493   strcat(pbcfilename, <span class="stringliteral">&quot;.pbc&quot;</span>);
<a name="l00494"></a>00494   infile = fopen(pbcfilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00495"></a>00495   <span class="keywordflow">if</span> (infile != (FILE *) NULL) {
<a name="l00496"></a>00496     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, pbcfilename);
<a name="l00497"></a>00497   } <span class="keywordflow">else</span> {
<a name="l00498"></a>00498     <span class="comment">// No such file. Return.</span>
<a name="l00499"></a>00499     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00500"></a>00500   }
<a name="l00501"></a>00501 
<a name="l00502"></a>00502   <span class="comment">// Read the number of pbc groups.</span>
<a name="l00503"></a>00503   stringptr = readnumberline(inputline, infile, pbcfilename);
<a name="l00504"></a>00504   numberofpbcgroups = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00505"></a>00505   <span class="keywordflow">if</span> (numberofpbcgroups == 0) {
<a name="l00506"></a>00506     <span class="comment">// It looks this file contains no point.</span>
<a name="l00507"></a>00507     fclose(infile);
<a name="l00508"></a>00508     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00509"></a>00509   }
<a name="l00510"></a>00510   <span class="comment">// Initialize &#39;pbcgrouplist&#39;;</span>
<a name="l00511"></a>00511   pbcgrouplist = <span class="keyword">new</span> pbcgroup[numberofpbcgroups];
<a name="l00512"></a>00512 
<a name="l00513"></a>00513   <span class="comment">// Read the list of pbc groups.</span>
<a name="l00514"></a>00514   <span class="keywordflow">for</span> (i = 0; i &lt; numberofpbcgroups; i++) {
<a name="l00515"></a>00515     pg = &amp;(pbcgrouplist[i]);
<a name="l00516"></a>00516     <span class="comment">// Initialize pbcgroup i;</span>
<a name="l00517"></a>00517     pg-&gt;numberofpointpairs = 0;
<a name="l00518"></a>00518     pg-&gt;pointpairlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l00519"></a>00519     <span class="comment">// Read &#39;fmark1&#39;, &#39;fmark2&#39;.</span>
<a name="l00520"></a>00520     stringptr = readnumberline(inputline, infile, pbcfilename);
<a name="l00521"></a>00521     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) <span class="keywordflow">break</span>;
<a name="l00522"></a>00522     pg-&gt;fmark1 = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l00523"></a>00523     stringptr = findnextnumber(stringptr);
<a name="l00524"></a>00524     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) <span class="keywordflow">break</span>;
<a name="l00525"></a>00525     pg-&gt;fmark2 = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l00526"></a>00526     <span class="comment">// Read &#39;transmat&#39;.</span>
<a name="l00527"></a>00527     <span class="keywordflow">do</span> {
<a name="l00528"></a>00528       stringptr = readline(inputline, infile, NULL);
<a name="l00529"></a>00529     } <span class="keywordflow">while</span> ((*stringptr != <span class="charliteral">&#39;[&#39;</span>) &amp;&amp; (*stringptr != <span class="charliteral">&#39;\0&#39;</span>));
<a name="l00530"></a>00530     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) <span class="keywordflow">break</span>;
<a name="l00531"></a>00531     <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l00532"></a>00532       <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) {
<a name="l00533"></a>00533         <span class="comment">// Read the entry of [j, k].</span>
<a name="l00534"></a>00534         stringptr = findnextnumber(stringptr);
<a name="l00535"></a>00535         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00536"></a>00536           <span class="comment">// Try to read another line.</span>
<a name="l00537"></a>00537           stringptr = readnumberline(inputline, infile, pbcfilename);
<a name="l00538"></a>00538           <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) <span class="keywordflow">break</span>;
<a name="l00539"></a>00539         }
<a name="l00540"></a>00540         pg-&gt;transmat[j][k] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00541"></a>00541       }
<a name="l00542"></a>00542       <span class="keywordflow">if</span> (k &lt; 4) <span class="keywordflow">break</span>; <span class="comment">// Not complete!</span>
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544     <span class="keywordflow">if</span> (j &lt; 4) <span class="keywordflow">break</span>; <span class="comment">// Not complete!</span>
<a name="l00545"></a>00545     <span class="comment">// Read &#39;numberofpointpairs&#39;.</span>
<a name="l00546"></a>00546     stringptr = readnumberline(inputline, infile, pbcfilename);
<a name="l00547"></a>00547     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) <span class="keywordflow">break</span>;
<a name="l00548"></a>00548     pg-&gt;numberofpointpairs = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l00549"></a>00549     <span class="keywordflow">if</span> (pg-&gt;numberofpointpairs &gt; 0) {
<a name="l00550"></a>00550       pg-&gt;pointpairlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[pg-&gt;numberofpointpairs * 2];
<a name="l00551"></a>00551       <span class="comment">// Read the point pairs.</span>
<a name="l00552"></a>00552       index = 0;
<a name="l00553"></a>00553       <span class="keywordflow">for</span> (j = 0; j &lt; pg-&gt;numberofpointpairs; j++) {
<a name="l00554"></a>00554         stringptr = readnumberline(inputline, infile, pbcfilename);
<a name="l00555"></a>00555         p1 = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l00556"></a>00556         stringptr = findnextnumber(stringptr);
<a name="l00557"></a>00557         p2 = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l00558"></a>00558         pg-&gt;pointpairlist[index++] = p1;
<a name="l00559"></a>00559         pg-&gt;pointpairlist[index++] = p2;
<a name="l00560"></a>00560       }
<a name="l00561"></a>00561     }
<a name="l00562"></a>00562   }
<a name="l00563"></a>00563   fclose(infile);
<a name="l00564"></a>00564 
<a name="l00565"></a>00565   <span class="keywordflow">if</span> (i &lt; numberofpbcgroups) {
<a name="l00566"></a>00566     <span class="comment">// Failed to read to additional points due to some error.</span>
<a name="l00567"></a>00567     <span class="keyword">delete</span> [] pbcgrouplist;
<a name="l00568"></a>00568     pbcgrouplist = (pbcgroup *) NULL;
<a name="l00569"></a>00569     numberofpbcgroups = 0;
<a name="l00570"></a>00570     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00571"></a>00571   }
<a name="l00572"></a>00572   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00576"></a>00576 <span class="comment">//                                                                           //</span>
<a name="l00577"></a>00577 <span class="comment">// load_var()    Load variant constraints applied on facets, segments, nodes.//</span>
<a name="l00578"></a>00578 <span class="comment">//                                                                           //</span>
<a name="l00579"></a>00579 <span class="comment">// &#39;filename&#39; is the filename of the original inputfile without suffix. The  //</span>
<a name="l00580"></a>00580 <span class="comment">// constraints are found in file &#39;filename.var&#39;.                             //</span>
<a name="l00581"></a>00581 <span class="comment">//                                                                           //</span>
<a name="l00583"></a>00583 <span class="comment"></span>
<a name="l00584"></a>00584 <span class="keywordtype">bool</span> tetgenio::load_var(<span class="keywordtype">char</span>* filename)
<a name="l00585"></a>00585 {
<a name="l00586"></a>00586   FILE *infile;
<a name="l00587"></a>00587   <span class="keywordtype">char</span> varfilename[FILENAMESIZE];
<a name="l00588"></a>00588   <span class="keywordtype">char</span> inputline[INPUTLINESIZE];
<a name="l00589"></a>00589   <span class="keywordtype">char</span> *stringptr;
<a name="l00590"></a>00590   <span class="keywordtype">int</span> index;
<a name="l00591"></a>00591   <span class="keywordtype">int</span> i;
<a name="l00592"></a>00592 
<a name="l00593"></a>00593   <span class="comment">// Variant constraints are saved in file &quot;filename.var&quot;.</span>
<a name="l00594"></a>00594   strcpy(varfilename, filename);
<a name="l00595"></a>00595   strcat(varfilename, <span class="stringliteral">&quot;.var&quot;</span>);
<a name="l00596"></a>00596   infile = fopen(varfilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00597"></a>00597   <span class="keywordflow">if</span> (infile != (FILE *) NULL) {
<a name="l00598"></a>00598     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, varfilename);
<a name="l00599"></a>00599   } <span class="keywordflow">else</span> {
<a name="l00600"></a>00600     <span class="comment">// No such file. Return.</span>
<a name="l00601"></a>00601     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00602"></a>00602   }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604   <span class="comment">// Read the facet constraint section.</span>
<a name="l00605"></a>00605   stringptr = readnumberline(inputline, infile, varfilename);
<a name="l00606"></a>00606   <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00607"></a>00607     numberoffacetconstraints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00608"></a>00608   } <span class="keywordflow">else</span> {
<a name="l00609"></a>00609     numberoffacetconstraints = 0;
<a name="l00610"></a>00610   }
<a name="l00611"></a>00611   <span class="keywordflow">if</span> (numberoffacetconstraints &gt; 0) {
<a name="l00612"></a>00612     <span class="comment">// Initialize &#39;facetconstraintlist&#39;.</span>
<a name="l00613"></a>00613     facetconstraintlist = <span class="keyword">new</span> REAL[numberoffacetconstraints * 2];
<a name="l00614"></a>00614     index = 0;
<a name="l00615"></a>00615     <span class="keywordflow">for</span> (i = 0; i &lt; numberoffacetconstraints; i++) {
<a name="l00616"></a>00616       stringptr = readnumberline(inputline, infile, varfilename);
<a name="l00617"></a>00617       stringptr = findnextnumber(stringptr);
<a name="l00618"></a>00618       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00619"></a>00619         printf(<span class="stringliteral">&quot;Error:  facet constraint %d has no facet marker.\n&quot;</span>,
<a name="l00620"></a>00620                firstnumber + i);
<a name="l00621"></a>00621         <span class="keywordflow">break</span>;
<a name="l00622"></a>00622       } <span class="keywordflow">else</span> {
<a name="l00623"></a>00623         facetconstraintlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00624"></a>00624       }
<a name="l00625"></a>00625       stringptr = findnextnumber(stringptr);
<a name="l00626"></a>00626       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00627"></a>00627         printf(<span class="stringliteral">&quot;Error:  facet constraint %d has no maximum area bound.\n&quot;</span>,
<a name="l00628"></a>00628                firstnumber + i);
<a name="l00629"></a>00629         <span class="keywordflow">break</span>;
<a name="l00630"></a>00630       } <span class="keywordflow">else</span> {
<a name="l00631"></a>00631         facetconstraintlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00632"></a>00632       }
<a name="l00633"></a>00633     }
<a name="l00634"></a>00634     <span class="keywordflow">if</span> (i &lt; numberoffacetconstraints) {
<a name="l00635"></a>00635       <span class="comment">// This must be caused by an error.</span>
<a name="l00636"></a>00636       fclose(infile);
<a name="l00637"></a>00637       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00638"></a>00638     }
<a name="l00639"></a>00639   }
<a name="l00640"></a>00640 
<a name="l00641"></a>00641   <span class="comment">// Read the segment constraint section.</span>
<a name="l00642"></a>00642   stringptr = readnumberline(inputline, infile, varfilename);
<a name="l00643"></a>00643   <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00644"></a>00644     numberofsegmentconstraints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00645"></a>00645   } <span class="keywordflow">else</span> {
<a name="l00646"></a>00646     numberofsegmentconstraints = 0;
<a name="l00647"></a>00647   }
<a name="l00648"></a>00648   <span class="keywordflow">if</span> (numberofsegmentconstraints &gt; 0) {
<a name="l00649"></a>00649     <span class="comment">// Initialize &#39;segmentconstraintlist&#39;.</span>
<a name="l00650"></a>00650     segmentconstraintlist = <span class="keyword">new</span> REAL[numberofsegmentconstraints * 3];
<a name="l00651"></a>00651     index = 0;
<a name="l00652"></a>00652     <span class="keywordflow">for</span> (i = 0; i &lt; numberofsegmentconstraints; i++) {
<a name="l00653"></a>00653       stringptr = readnumberline(inputline, infile, varfilename);
<a name="l00654"></a>00654       stringptr = findnextnumber(stringptr);
<a name="l00655"></a>00655       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00656"></a>00656         printf(<span class="stringliteral">&quot;Error:  segment constraint %d has no frist endpoint.\n&quot;</span>,
<a name="l00657"></a>00657                firstnumber + i);
<a name="l00658"></a>00658         <span class="keywordflow">break</span>;
<a name="l00659"></a>00659       } <span class="keywordflow">else</span> {
<a name="l00660"></a>00660         segmentconstraintlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00661"></a>00661       }
<a name="l00662"></a>00662       stringptr = findnextnumber(stringptr);
<a name="l00663"></a>00663       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00664"></a>00664         printf(<span class="stringliteral">&quot;Error:  segment constraint %d has no second endpoint.\n&quot;</span>,
<a name="l00665"></a>00665                firstnumber + i);
<a name="l00666"></a>00666         <span class="keywordflow">break</span>;
<a name="l00667"></a>00667       } <span class="keywordflow">else</span> {
<a name="l00668"></a>00668         segmentconstraintlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00669"></a>00669       }
<a name="l00670"></a>00670       stringptr = findnextnumber(stringptr);
<a name="l00671"></a>00671       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00672"></a>00672         printf(<span class="stringliteral">&quot;Error:  segment constraint %d has no maximum length bound.\n&quot;</span>,
<a name="l00673"></a>00673                firstnumber + i);
<a name="l00674"></a>00674         <span class="keywordflow">break</span>;
<a name="l00675"></a>00675       } <span class="keywordflow">else</span> {
<a name="l00676"></a>00676         segmentconstraintlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00677"></a>00677       }
<a name="l00678"></a>00678     }
<a name="l00679"></a>00679     <span class="keywordflow">if</span> (i &lt; numberofsegmentconstraints) {
<a name="l00680"></a>00680       <span class="comment">// This must be caused by an error.</span>
<a name="l00681"></a>00681       fclose(infile);
<a name="l00682"></a>00682       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00683"></a>00683     }
<a name="l00684"></a>00684   }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686   fclose(infile);
<a name="l00687"></a>00687   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00688"></a>00688 }
<a name="l00689"></a>00689 
<a name="l00691"></a>00691 <span class="comment">//                                                                           //</span>
<a name="l00692"></a>00692 <span class="comment">// load_mtr()    Load a size specification map from file.                    //</span>
<a name="l00693"></a>00693 <span class="comment">//                                                                           //</span>
<a name="l00694"></a>00694 <span class="comment">// &#39;filename&#39; is the filename of the original inputfile without suffix. The  //</span>
<a name="l00695"></a>00695 <span class="comment">// size map is found in file &#39;filename.mtr&#39;.                                 //</span>
<a name="l00696"></a>00696 <span class="comment">//                                                                           //</span>
<a name="l00698"></a>00698 <span class="comment"></span>
<a name="l00699"></a>00699 <span class="keywordtype">bool</span> tetgenio::load_mtr(<span class="keywordtype">char</span>* filename)
<a name="l00700"></a>00700 {
<a name="l00701"></a>00701   FILE *infile;
<a name="l00702"></a>00702   <span class="keywordtype">char</span> mtrfilename[FILENAMESIZE];
<a name="l00703"></a>00703   <span class="keywordtype">char</span> inputline[INPUTLINESIZE];
<a name="l00704"></a>00704   <span class="keywordtype">char</span> *stringptr;
<a name="l00705"></a>00705   REAL mtr;
<a name="l00706"></a>00706   <span class="keywordtype">int</span> mtrindex;
<a name="l00707"></a>00707   <span class="keywordtype">int</span> i, j;
<a name="l00708"></a>00708 
<a name="l00709"></a>00709   strcpy(mtrfilename, filename);
<a name="l00710"></a>00710   strcat(mtrfilename, <span class="stringliteral">&quot;.mtr&quot;</span>);
<a name="l00711"></a>00711   infile = fopen(mtrfilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00712"></a>00712   <span class="keywordflow">if</span> (infile != (FILE *) NULL) {
<a name="l00713"></a>00713     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, mtrfilename);
<a name="l00714"></a>00714   } <span class="keywordflow">else</span> {
<a name="l00715"></a>00715     <span class="comment">// No such file. Return.</span>
<a name="l00716"></a>00716     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00717"></a>00717   }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719   <span class="comment">// Read number of points, number of columns (1, 3, or 6).</span>
<a name="l00720"></a>00720   stringptr = readnumberline(inputline, infile, mtrfilename);
<a name="l00721"></a>00721   stringptr = findnextnumber(stringptr); <span class="comment">// Skip number of points.</span>
<a name="l00722"></a>00722   <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00723"></a>00723     numberofpointmtrs = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00724"></a>00724   }
<a name="l00725"></a>00725   <span class="keywordflow">if</span> (numberofpointmtrs == 0) {
<a name="l00726"></a>00726     <span class="comment">// Column number doesn&#39;t match. Set a default number (1).</span>
<a name="l00727"></a>00727     numberofpointmtrs = 1;
<a name="l00728"></a>00728   }
<a name="l00729"></a>00729 
<a name="l00730"></a>00730   <span class="comment">// Allocate space for pointmtrlist.</span>
<a name="l00731"></a>00731   pointmtrlist = <span class="keyword">new</span> REAL[numberofpoints * numberofpointmtrs];
<a name="l00732"></a>00732   <span class="keywordflow">if</span> (pointmtrlist == (REAL *) NULL) {
<a name="l00733"></a>00733     printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l00734"></a>00734     terminatetetgen(1);
<a name="l00735"></a>00735   }
<a name="l00736"></a>00736   mtrindex = 0;
<a name="l00737"></a>00737   <span class="keywordflow">for</span> (i = 0; i &lt; numberofpoints; i++) {
<a name="l00738"></a>00738     <span class="comment">// Read metrics.</span>
<a name="l00739"></a>00739     stringptr = readnumberline(inputline, infile, mtrfilename);
<a name="l00740"></a>00740     <span class="keywordflow">for</span> (j = 0; j &lt; numberofpointmtrs; j++) {
<a name="l00741"></a>00741       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00742"></a>00742         printf(<span class="stringliteral">&quot;Error:  Metric %d is missing value #%d in %s.\n&quot;</span>,
<a name="l00743"></a>00743                i + firstnumber, j + 1, mtrfilename);
<a name="l00744"></a>00744         terminatetetgen(1);
<a name="l00745"></a>00745       }
<a name="l00746"></a>00746       mtr = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l00747"></a>00747       pointmtrlist[mtrindex++] = mtr;
<a name="l00748"></a>00748       stringptr = findnextnumber(stringptr);
<a name="l00749"></a>00749     }
<a name="l00750"></a>00750   }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752   fclose(infile);
<a name="l00753"></a>00753   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00754"></a>00754 }
<a name="l00755"></a>00755 
<a name="l00757"></a>00757 <span class="comment">//                                                                           //</span>
<a name="l00758"></a>00758 <span class="comment">// load_poly()    Load a piecewise linear complex from a .poly or .smesh.    //</span>
<a name="l00759"></a>00759 <span class="comment">//                                                                           //</span>
<a name="l00760"></a>00760 <span class="comment">// &#39;filename&#39; is the inputfile without suffix. The PLC is in &#39;filename.poly&#39; //</span>
<a name="l00761"></a>00761 <span class="comment">// or &#39;filename.smesh&#39;, and possibly plus &#39;filename.node&#39; (when the first    //</span>
<a name="l00762"></a>00762 <span class="comment">// line of the file starts with a zero).                                     //</span>
<a name="l00763"></a>00763 <span class="comment">//                                                                           //</span>
<a name="l00765"></a>00765 <span class="comment"></span>
<a name="l00766"></a>00766 <span class="keywordtype">bool</span> tetgenio::load_poly(<span class="keywordtype">char</span>* filename)
<a name="l00767"></a>00767 {
<a name="l00768"></a>00768   FILE *infile, *polyfile;
<a name="l00769"></a>00769   <span class="keywordtype">char</span> innodefilename[FILENAMESIZE];
<a name="l00770"></a>00770   <span class="keywordtype">char</span> inpolyfilename[FILENAMESIZE];
<a name="l00771"></a>00771   <span class="keywordtype">char</span> insmeshfilename[FILENAMESIZE];
<a name="l00772"></a>00772   <span class="keywordtype">char</span> inputline[INPUTLINESIZE];
<a name="l00773"></a>00773   <span class="keywordtype">char</span> *stringptr, *infilename;
<a name="l00774"></a>00774   <span class="keywordtype">int</span> smesh, markers, currentmarker;
<a name="l00775"></a>00775   <span class="keywordtype">int</span> readnodefile, index;
<a name="l00776"></a>00776   <span class="keywordtype">int</span> i, j, k;
<a name="l00777"></a>00777 
<a name="l00778"></a>00778   <span class="comment">// Assembling the actual file names we want to open.</span>
<a name="l00779"></a>00779   strcpy(innodefilename, filename);
<a name="l00780"></a>00780   strcpy(inpolyfilename, filename);
<a name="l00781"></a>00781   strcpy(insmeshfilename, filename);
<a name="l00782"></a>00782   strcat(innodefilename, <span class="stringliteral">&quot;.node&quot;</span>);
<a name="l00783"></a>00783   strcat(inpolyfilename, <span class="stringliteral">&quot;.poly&quot;</span>);
<a name="l00784"></a>00784   strcat(insmeshfilename, <span class="stringliteral">&quot;.smesh&quot;</span>);
<a name="l00785"></a>00785 
<a name="l00786"></a>00786   <span class="comment">// First assume it is a .poly file.</span>
<a name="l00787"></a>00787   smesh = 0;
<a name="l00788"></a>00788   <span class="comment">// Try to open a .poly file.</span>
<a name="l00789"></a>00789   polyfile = fopen(inpolyfilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00790"></a>00790   <span class="keywordflow">if</span> (polyfile == (FILE *) NULL) {
<a name="l00791"></a>00791     <span class="comment">// .poly doesn&#39;t exist! Try to open a .smesh file.</span>
<a name="l00792"></a>00792     polyfile = fopen(insmeshfilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00793"></a>00793     <span class="keywordflow">if</span> (polyfile == (FILE *) NULL) {
<a name="l00794"></a>00794       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot access file %s and %s.\n&quot;</span>,
<a name="l00795"></a>00795              inpolyfilename, insmeshfilename);
<a name="l00796"></a>00796       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00797"></a>00797     } <span class="keywordflow">else</span> {
<a name="l00798"></a>00798       printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, insmeshfilename);
<a name="l00799"></a>00799     }
<a name="l00800"></a>00800     smesh = 1;
<a name="l00801"></a>00801   } <span class="keywordflow">else</span> {
<a name="l00802"></a>00802     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, inpolyfilename);
<a name="l00803"></a>00803   }
<a name="l00804"></a>00804   <span class="comment">// Initialize the default values.</span>
<a name="l00805"></a>00805   mesh_dim = 3;  <span class="comment">// Three-dimemsional accoordinates.</span>
<a name="l00806"></a>00806   numberofpointattributes = 0;  <span class="comment">// no point attribute.</span>
<a name="l00807"></a>00807   markers = 0;  <span class="comment">// no boundary marker.</span>
<a name="l00808"></a>00808   <span class="comment">// Read number of points, number of dimensions, number of point</span>
<a name="l00809"></a>00809   <span class="comment">//   attributes, and number of boundary markers.</span>
<a name="l00810"></a>00810   stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l00811"></a>00811   numberofpoints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00812"></a>00812   stringptr = findnextnumber(stringptr);
<a name="l00813"></a>00813   <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00814"></a>00814     mesh_dim = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00815"></a>00815   }
<a name="l00816"></a>00816   stringptr = findnextnumber(stringptr);
<a name="l00817"></a>00817   <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00818"></a>00818     numberofpointattributes = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00819"></a>00819   }
<a name="l00820"></a>00820   stringptr = findnextnumber(stringptr);
<a name="l00821"></a>00821   <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00822"></a>00822     markers = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00823"></a>00823   }
<a name="l00824"></a>00824   <span class="keywordflow">if</span> (numberofpoints &gt; 0) {
<a name="l00825"></a>00825     readnodefile = 0;
<a name="l00826"></a>00826     <span class="keywordflow">if</span> (smesh) {
<a name="l00827"></a>00827       infilename = insmeshfilename;
<a name="l00828"></a>00828     } <span class="keywordflow">else</span> {
<a name="l00829"></a>00829       infilename = inpolyfilename;
<a name="l00830"></a>00830     }
<a name="l00831"></a>00831     infile = polyfile;
<a name="l00832"></a>00832   } <span class="keywordflow">else</span> {
<a name="l00833"></a>00833     <span class="comment">// If the .poly or .smesh file claims there are zero points, that</span>
<a name="l00834"></a>00834     <span class="comment">//   means the points should be read from a separate .node file.</span>
<a name="l00835"></a>00835     readnodefile = 1;
<a name="l00836"></a>00836     infilename = innodefilename;
<a name="l00837"></a>00837   }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839   <span class="keywordflow">if</span> (readnodefile) {
<a name="l00840"></a>00840     <span class="comment">// Read the points from the .node file.</span>
<a name="l00841"></a>00841     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, innodefilename);
<a name="l00842"></a>00842     infile = fopen(innodefilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l00843"></a>00843     <span class="keywordflow">if</span> (infile == (FILE *) NULL) {
<a name="l00844"></a>00844       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot access file %s.\n&quot;</span>, innodefilename);
<a name="l00845"></a>00845       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00846"></a>00846     }
<a name="l00847"></a>00847     <span class="comment">// Initialize the default values.</span>
<a name="l00848"></a>00848     mesh_dim = 3;  <span class="comment">// Three-dimemsional accoordinates.</span>
<a name="l00849"></a>00849     numberofpointattributes = 0;  <span class="comment">// no point attribute.</span>
<a name="l00850"></a>00850     markers = 0;  <span class="comment">// no boundary marker.</span>
<a name="l00851"></a>00851     <span class="comment">// Read number of points, number of dimensions, number of point</span>
<a name="l00852"></a>00852     <span class="comment">//   attributes, and number of boundary markers.</span>
<a name="l00853"></a>00853     stringptr = readnumberline(inputline, infile, innodefilename);
<a name="l00854"></a>00854     numberofpoints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00855"></a>00855     stringptr = findnextnumber(stringptr);
<a name="l00856"></a>00856     <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00857"></a>00857       mesh_dim = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00858"></a>00858     }
<a name="l00859"></a>00859     stringptr = findnextnumber(stringptr);
<a name="l00860"></a>00860     <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00861"></a>00861       numberofpointattributes = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00862"></a>00862     }
<a name="l00863"></a>00863     stringptr = findnextnumber(stringptr);
<a name="l00864"></a>00864     <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00865"></a>00865       markers = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00866"></a>00866     }
<a name="l00867"></a>00867   }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869   <span class="keywordflow">if</span> ((mesh_dim != 3) &amp;&amp; (mesh_dim != 2)) {
<a name="l00870"></a>00870     printf(<span class="stringliteral">&quot;Input error:  TetGen only works for 2D &amp; 3D point sets.\n&quot;</span>);
<a name="l00871"></a>00871     fclose(infile);
<a name="l00872"></a>00872     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00873"></a>00873   }
<a name="l00874"></a>00874   <span class="keywordflow">if</span> (numberofpoints &lt; (mesh_dim + 1)) {
<a name="l00875"></a>00875     printf(<span class="stringliteral">&quot;Input error:  TetGen needs at least %d points.\n&quot;</span>, mesh_dim + 1);
<a name="l00876"></a>00876     fclose(infile);
<a name="l00877"></a>00877     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00878"></a>00878   }
<a name="l00879"></a>00879 
<a name="l00880"></a>00880   <span class="comment">// Load the list of nodes.</span>
<a name="l00881"></a>00881   <span class="keywordflow">if</span> (!load_node_call(infile, markers, infilename)) {
<a name="l00882"></a>00882     fclose(infile);
<a name="l00883"></a>00883     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00884"></a>00884   }
<a name="l00885"></a>00885 
<a name="l00886"></a>00886   <span class="keywordflow">if</span> (readnodefile) {
<a name="l00887"></a>00887     fclose(infile);
<a name="l00888"></a>00888   }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890   facet *f;
<a name="l00891"></a>00891   polygon *p;
<a name="l00892"></a>00892 
<a name="l00893"></a>00893   <span class="keywordflow">if</span> (mesh_dim == 3) {
<a name="l00894"></a>00894 
<a name="l00895"></a>00895     <span class="comment">// Read number of facets and number of boundary markers.</span>
<a name="l00896"></a>00896     stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l00897"></a>00897     numberoffacets = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00898"></a>00898     <span class="keywordflow">if</span> (numberoffacets &lt;= 0) {
<a name="l00899"></a>00899       <span class="comment">// No facet list, return.</span>
<a name="l00900"></a>00900       fclose(polyfile);
<a name="l00901"></a>00901       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00902"></a>00902     }
<a name="l00903"></a>00903     stringptr = findnextnumber(stringptr);
<a name="l00904"></a>00904     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00905"></a>00905       markers = 0;  <span class="comment">// no boundary marker.</span>
<a name="l00906"></a>00906     } <span class="keywordflow">else</span> {
<a name="l00907"></a>00907       markers = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00908"></a>00908     }
<a name="l00909"></a>00909 
<a name="l00910"></a>00910     <span class="comment">// Initialize the &#39;facetlist&#39;, &#39;facetmarkerlist&#39;.</span>
<a name="l00911"></a>00911     facetlist = <span class="keyword">new</span> facet[numberoffacets];
<a name="l00912"></a>00912     <span class="keywordflow">if</span> (markers == 1) {
<a name="l00913"></a>00913       facetmarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[numberoffacets];
<a name="l00914"></a>00914     }
<a name="l00915"></a>00915 
<a name="l00916"></a>00916     <span class="comment">// Read data into &#39;facetlist&#39;, &#39;facetmarkerlist&#39;.</span>
<a name="l00917"></a>00917     <span class="keywordflow">if</span> (smesh == 0) {
<a name="l00918"></a>00918       <span class="comment">// Facets are in .poly file format.</span>
<a name="l00919"></a>00919       <span class="keywordflow">for</span> (i = 1; i &lt;= numberoffacets; i++) {
<a name="l00920"></a>00920         f = &amp;(facetlist[i - 1]);
<a name="l00921"></a>00921         init(f);
<a name="l00922"></a>00922         f-&gt;numberofholes = 0;
<a name="l00923"></a>00923         currentmarker = 0;
<a name="l00924"></a>00924         <span class="comment">// Read number of polygons, number of holes, and a boundary marker.</span>
<a name="l00925"></a>00925         stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l00926"></a>00926         f-&gt;numberofpolygons = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00927"></a>00927         stringptr = findnextnumber(stringptr);
<a name="l00928"></a>00928         <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00929"></a>00929           f-&gt;numberofholes = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00930"></a>00930           <span class="keywordflow">if</span> (markers == 1) {
<a name="l00931"></a>00931             stringptr = findnextnumber(stringptr);
<a name="l00932"></a>00932             <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00933"></a>00933               currentmarker = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l00934"></a>00934             }
<a name="l00935"></a>00935           }
<a name="l00936"></a>00936         }
<a name="l00937"></a>00937         <span class="comment">// Initialize facetmarker if it needs.</span>
<a name="l00938"></a>00938         <span class="keywordflow">if</span> (markers == 1) {
<a name="l00939"></a>00939           facetmarkerlist[i - 1] = currentmarker;
<a name="l00940"></a>00940         }
<a name="l00941"></a>00941         <span class="comment">// Each facet should has at least one polygon.</span>
<a name="l00942"></a>00942         <span class="keywordflow">if</span> (f-&gt;numberofpolygons &lt;= 0) {
<a name="l00943"></a>00943           printf(<span class="stringliteral">&quot;Error:  Wrong number of polygon in %d facet.\n&quot;</span>, i);
<a name="l00944"></a>00944           <span class="keywordflow">break</span>;
<a name="l00945"></a>00945         }
<a name="l00946"></a>00946         <span class="comment">// Initialize the &#39;f-&gt;polygonlist&#39;.</span>
<a name="l00947"></a>00947         f-&gt;polygonlist = <span class="keyword">new</span> polygon[f-&gt;numberofpolygons];
<a name="l00948"></a>00948         <span class="comment">// Go through all polygons, read in their vertices.</span>
<a name="l00949"></a>00949         <span class="keywordflow">for</span> (j = 1; j &lt;= f-&gt;numberofpolygons; j++) {
<a name="l00950"></a>00950           p = &amp;(f-&gt;polygonlist[j - 1]);
<a name="l00951"></a>00951           init(p);
<a name="l00952"></a>00952           <span class="comment">// Read number of vertices of this polygon.</span>
<a name="l00953"></a>00953           stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l00954"></a>00954           p-&gt;numberofvertices = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l00955"></a>00955           <span class="keywordflow">if</span> (p-&gt;numberofvertices &lt; 1) {
<a name="l00956"></a>00956             printf(<span class="stringliteral">&quot;Error:  Wrong polygon %d in facet %d\n&quot;</span>, j, i);
<a name="l00957"></a>00957             <span class="keywordflow">break</span>;
<a name="l00958"></a>00958           }
<a name="l00959"></a>00959           <span class="comment">// Initialize &#39;p-&gt;vertexlist&#39;.</span>
<a name="l00960"></a>00960           p-&gt;vertexlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[p-&gt;numberofvertices];
<a name="l00961"></a>00961           <span class="comment">// Read all vertices of this polygon.</span>
<a name="l00962"></a>00962           <span class="keywordflow">for</span> (k = 1; k &lt;= p-&gt;numberofvertices; k++) {
<a name="l00963"></a>00963             stringptr = findnextnumber(stringptr);
<a name="l00964"></a>00964             <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00965"></a>00965               <span class="comment">// Try to load another non-empty line and continue to read the</span>
<a name="l00966"></a>00966               <span class="comment">//   rest of vertices.</span>
<a name="l00967"></a>00967               stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l00968"></a>00968               <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l00969"></a>00969                 printf(<span class="stringliteral">&quot;Error: Missing %d endpoints of polygon %d in facet %d&quot;</span>,
<a name="l00970"></a>00970                        p-&gt;numberofvertices - k, j, i);
<a name="l00971"></a>00971                 <span class="keywordflow">break</span>;
<a name="l00972"></a>00972               }
<a name="l00973"></a>00973             }
<a name="l00974"></a>00974             p-&gt;vertexlist[k - 1] = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l00975"></a>00975           }
<a name="l00976"></a>00976         }
<a name="l00977"></a>00977         <span class="keywordflow">if</span> (j &lt;= f-&gt;numberofpolygons) {
<a name="l00978"></a>00978           <span class="comment">// This must be caused by an error. However, there&#39;re j - 1</span>
<a name="l00979"></a>00979           <span class="comment">//   polygons have been read. Reset the &#39;f-&gt;numberofpolygon&#39;.</span>
<a name="l00980"></a>00980           <span class="keywordflow">if</span> (j == 1) {
<a name="l00981"></a>00981             <span class="comment">// This is the first polygon.</span>
<a name="l00982"></a>00982             <span class="keyword">delete</span> [] f-&gt;polygonlist;
<a name="l00983"></a>00983           }
<a name="l00984"></a>00984           f-&gt;numberofpolygons = j - 1;
<a name="l00985"></a>00985           <span class="comment">// No hole will be read even it exists.</span>
<a name="l00986"></a>00986           f-&gt;numberofholes = 0;
<a name="l00987"></a>00987           <span class="keywordflow">break</span>;
<a name="l00988"></a>00988         }
<a name="l00989"></a>00989         <span class="comment">// If this facet has hole pints defined, read them.</span>
<a name="l00990"></a>00990         <span class="keywordflow">if</span> (f-&gt;numberofholes &gt; 0) {
<a name="l00991"></a>00991           <span class="comment">// Initialize &#39;f-&gt;holelist&#39;.</span>
<a name="l00992"></a>00992           f-&gt;holelist = <span class="keyword">new</span> REAL[f-&gt;numberofholes * 3];
<a name="l00993"></a>00993           <span class="comment">// Read the holes&#39; coordinates.</span>
<a name="l00994"></a>00994           index = 0;
<a name="l00995"></a>00995           <span class="keywordflow">for</span> (j = 1; j &lt;= f-&gt;numberofholes; j++) {
<a name="l00996"></a>00996             stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l00997"></a>00997             <span class="keywordflow">for</span> (k = 1; k &lt;= 3; k++) {
<a name="l00998"></a>00998               stringptr = findnextnumber(stringptr);
<a name="l00999"></a>00999               <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01000"></a>01000                 printf(<span class="stringliteral">&quot;Error:  Hole %d in facet %d has no coordinates&quot;</span>, j, i);
<a name="l01001"></a>01001                 <span class="keywordflow">break</span>;
<a name="l01002"></a>01002               }
<a name="l01003"></a>01003               f-&gt;holelist[index++] = (REAL) strtod (stringptr, &amp;stringptr);
<a name="l01004"></a>01004             }
<a name="l01005"></a>01005             <span class="keywordflow">if</span> (k &lt;= 3) {
<a name="l01006"></a>01006               <span class="comment">// This must be caused by an error.</span>
<a name="l01007"></a>01007               <span class="keywordflow">break</span>;
<a name="l01008"></a>01008             }
<a name="l01009"></a>01009           }
<a name="l01010"></a>01010           <span class="keywordflow">if</span> (j &lt;= f-&gt;numberofholes) {
<a name="l01011"></a>01011             <span class="comment">// This must be caused by an error.</span>
<a name="l01012"></a>01012             <span class="keywordflow">break</span>;
<a name="l01013"></a>01013           }
<a name="l01014"></a>01014         }
<a name="l01015"></a>01015       }
<a name="l01016"></a>01016       <span class="keywordflow">if</span> (i &lt;= numberoffacets) {
<a name="l01017"></a>01017         <span class="comment">// This must be caused by an error.</span>
<a name="l01018"></a>01018         numberoffacets = i - 1;
<a name="l01019"></a>01019         fclose(polyfile);
<a name="l01020"></a>01020         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01021"></a>01021       }
<a name="l01022"></a>01022     } <span class="keywordflow">else</span> { <span class="comment">// poly == 0</span>
<a name="l01023"></a>01023       <span class="comment">// Read the facets from a .smesh file.</span>
<a name="l01024"></a>01024       <span class="keywordflow">for</span> (i = 1; i &lt;= numberoffacets; i++) {
<a name="l01025"></a>01025         f = &amp;(facetlist[i - 1]);
<a name="l01026"></a>01026         init(f);
<a name="l01027"></a>01027         <span class="comment">// Initialize &#39;f-&gt;facetlist&#39;. In a .smesh file, each facetlist only</span>
<a name="l01028"></a>01028         <span class="comment">//   contains exactly one polygon, no hole.</span>
<a name="l01029"></a>01029         f-&gt;numberofpolygons = 1;
<a name="l01030"></a>01030         f-&gt;polygonlist = <span class="keyword">new</span> polygon[f-&gt;numberofpolygons];
<a name="l01031"></a>01031         p = &amp;(f-&gt;polygonlist[0]);
<a name="l01032"></a>01032         init(p);
<a name="l01033"></a>01033         <span class="comment">// Read number of vertices of this polygon.</span>
<a name="l01034"></a>01034         stringptr = readnumberline(inputline, polyfile, insmeshfilename);
<a name="l01035"></a>01035         p-&gt;numberofvertices = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l01036"></a>01036         <span class="keywordflow">if</span> (p-&gt;numberofvertices &lt; 1) {
<a name="l01037"></a>01037           printf(<span class="stringliteral">&quot;Error:  Wrong number of vertex in facet %d\n&quot;</span>, i);
<a name="l01038"></a>01038           <span class="keywordflow">break</span>;
<a name="l01039"></a>01039         }
<a name="l01040"></a>01040         <span class="comment">// Initialize &#39;p-&gt;vertexlist&#39;.</span>
<a name="l01041"></a>01041         p-&gt;vertexlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[p-&gt;numberofvertices];
<a name="l01042"></a>01042         <span class="keywordflow">for</span> (k = 1; k &lt;= p-&gt;numberofvertices; k++) {
<a name="l01043"></a>01043           stringptr = findnextnumber(stringptr);
<a name="l01044"></a>01044           <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01045"></a>01045             <span class="comment">// Try to load another non-empty line and continue to read the</span>
<a name="l01046"></a>01046             <span class="comment">//   rest of vertices.</span>
<a name="l01047"></a>01047             stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l01048"></a>01048             <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01049"></a>01049               printf(<span class="stringliteral">&quot;Error:  Missing %d endpoints in facet %d&quot;</span>,
<a name="l01050"></a>01050                      p-&gt;numberofvertices - k, i);
<a name="l01051"></a>01051               <span class="keywordflow">break</span>;
<a name="l01052"></a>01052             }
<a name="l01053"></a>01053           }
<a name="l01054"></a>01054           p-&gt;vertexlist[k - 1] = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l01055"></a>01055         }
<a name="l01056"></a>01056         <span class="keywordflow">if</span> (k &lt;= p-&gt;numberofvertices) {
<a name="l01057"></a>01057           <span class="comment">// This must be caused by an error.</span>
<a name="l01058"></a>01058           <span class="keywordflow">break</span>;
<a name="l01059"></a>01059         }
<a name="l01060"></a>01060         <span class="comment">// Read facet&#39;s boundary marker at last.</span>
<a name="l01061"></a>01061         <span class="keywordflow">if</span> (markers == 1) {
<a name="l01062"></a>01062           stringptr = findnextnumber(stringptr);
<a name="l01063"></a>01063           <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01064"></a>01064             currentmarker = 0;
<a name="l01065"></a>01065           } <span class="keywordflow">else</span> {
<a name="l01066"></a>01066             currentmarker = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l01067"></a>01067           }
<a name="l01068"></a>01068           facetmarkerlist[i - 1] = currentmarker;
<a name="l01069"></a>01069         }
<a name="l01070"></a>01070       }
<a name="l01071"></a>01071       <span class="keywordflow">if</span> (i &lt;= numberoffacets) {
<a name="l01072"></a>01072         <span class="comment">// This must be caused by an error.</span>
<a name="l01073"></a>01073         numberoffacets = i - 1;
<a name="l01074"></a>01074         fclose(polyfile);
<a name="l01075"></a>01075         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01076"></a>01076       }
<a name="l01077"></a>01077     }
<a name="l01078"></a>01078 
<a name="l01079"></a>01079     <span class="comment">// Read the hole section.</span>
<a name="l01080"></a>01080     stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l01081"></a>01081     <span class="keywordflow">if</span> (*stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01082"></a>01082       numberofholes = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l01083"></a>01083     } <span class="keywordflow">else</span> {
<a name="l01084"></a>01084       numberofholes = 0;
<a name="l01085"></a>01085     }
<a name="l01086"></a>01086     <span class="keywordflow">if</span> (numberofholes &gt; 0) {
<a name="l01087"></a>01087       <span class="comment">// Initialize &#39;holelist&#39;.</span>
<a name="l01088"></a>01088       holelist = <span class="keyword">new</span> REAL[numberofholes * 3];
<a name="l01089"></a>01089       <span class="keywordflow">for</span> (i = 0; i &lt; 3 * numberofholes; i += 3) {
<a name="l01090"></a>01090         stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l01091"></a>01091         stringptr = findnextnumber(stringptr);
<a name="l01092"></a>01092         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01093"></a>01093           printf(<span class="stringliteral">&quot;Error:  Hole %d has no x coord.\n&quot;</span>, firstnumber + (i / 3));
<a name="l01094"></a>01094           <span class="keywordflow">break</span>;
<a name="l01095"></a>01095         } <span class="keywordflow">else</span> {
<a name="l01096"></a>01096           holelist[i] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l01097"></a>01097         }
<a name="l01098"></a>01098         stringptr = findnextnumber(stringptr);
<a name="l01099"></a>01099         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01100"></a>01100           printf(<span class="stringliteral">&quot;Error:  Hole %d has no y coord.\n&quot;</span>, firstnumber + (i / 3));
<a name="l01101"></a>01101           <span class="keywordflow">break</span>;
<a name="l01102"></a>01102         } <span class="keywordflow">else</span> {
<a name="l01103"></a>01103           holelist[i + 1] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l01104"></a>01104         }
<a name="l01105"></a>01105         stringptr = findnextnumber(stringptr);
<a name="l01106"></a>01106         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01107"></a>01107           printf(<span class="stringliteral">&quot;Error:  Hole %d has no z coord.\n&quot;</span>, firstnumber + (i / 3));
<a name="l01108"></a>01108           <span class="keywordflow">break</span>;
<a name="l01109"></a>01109         } <span class="keywordflow">else</span> {
<a name="l01110"></a>01110           holelist[i + 2] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l01111"></a>01111         }
<a name="l01112"></a>01112       }
<a name="l01113"></a>01113       <span class="keywordflow">if</span> (i &lt; 3 * numberofholes) {
<a name="l01114"></a>01114         <span class="comment">// This must be caused by an error.</span>
<a name="l01115"></a>01115         fclose(polyfile);
<a name="l01116"></a>01116         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01117"></a>01117       }
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119 
<a name="l01120"></a>01120     <span class="comment">// Read the region section.  The &#39;region&#39; section is optional, if we</span>
<a name="l01121"></a>01121     <span class="comment">//   don&#39;t reach the end-of-file, try read it in.</span>
<a name="l01122"></a>01122     stringptr = readnumberline(inputline, polyfile, NULL);
<a name="l01123"></a>01123     <span class="keywordflow">if</span> (stringptr != (<span class="keywordtype">char</span> *) NULL &amp;&amp; *stringptr != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01124"></a>01124       numberofregions = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l01125"></a>01125     } <span class="keywordflow">else</span> {
<a name="l01126"></a>01126       numberofregions = 0;
<a name="l01127"></a>01127     }
<a name="l01128"></a>01128     <span class="keywordflow">if</span> (numberofregions &gt; 0) {
<a name="l01129"></a>01129       <span class="comment">// Initialize &#39;regionlist&#39;.</span>
<a name="l01130"></a>01130       regionlist = <span class="keyword">new</span> REAL[numberofregions * 5];
<a name="l01131"></a>01131       index = 0;
<a name="l01132"></a>01132       <span class="keywordflow">for</span> (i = 0; i &lt; numberofregions; i++) {
<a name="l01133"></a>01133         stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l01134"></a>01134         stringptr = findnextnumber(stringptr);
<a name="l01135"></a>01135         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01136"></a>01136           printf(<span class="stringliteral">&quot;Error:  Region %d has no x coordinate.\n&quot;</span>, firstnumber + i);
<a name="l01137"></a>01137           <span class="keywordflow">break</span>;
<a name="l01138"></a>01138         } <span class="keywordflow">else</span> {
<a name="l01139"></a>01139           regionlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l01140"></a>01140         }
<a name="l01141"></a>01141         stringptr = findnextnumber(stringptr);
<a name="l01142"></a>01142         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01143"></a>01143           printf(<span class="stringliteral">&quot;Error:  Region %d has no y coordinate.\n&quot;</span>, firstnumber + i);
<a name="l01144"></a>01144           <span class="keywordflow">break</span>;
<a name="l01145"></a>01145         } <span class="keywordflow">else</span> {
<a name="l01146"></a>01146           regionlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l01147"></a>01147         }
<a name="l01148"></a>01148         stringptr = findnextnumber(stringptr);
<a name="l01149"></a>01149         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01150"></a>01150           printf(<span class="stringliteral">&quot;Error:  Region %d has no z coordinate.\n&quot;</span>, firstnumber + i);
<a name="l01151"></a>01151           <span class="keywordflow">break</span>;
<a name="l01152"></a>01152         } <span class="keywordflow">else</span> {
<a name="l01153"></a>01153           regionlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l01154"></a>01154         }
<a name="l01155"></a>01155         stringptr = findnextnumber(stringptr);
<a name="l01156"></a>01156         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01157"></a>01157           printf(<span class="stringliteral">&quot;Error:  Region %d has no region attrib.\n&quot;</span>, firstnumber + i);
<a name="l01158"></a>01158           <span class="keywordflow">break</span>;
<a name="l01159"></a>01159         } <span class="keywordflow">else</span> {
<a name="l01160"></a>01160           regionlist[index++] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l01161"></a>01161         }
<a name="l01162"></a>01162         stringptr = findnextnumber(stringptr);
<a name="l01163"></a>01163         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01164"></a>01164           regionlist[index] = regionlist[index - 1];
<a name="l01165"></a>01165         } <span class="keywordflow">else</span> {
<a name="l01166"></a>01166           regionlist[index] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l01167"></a>01167         }
<a name="l01168"></a>01168         index++;
<a name="l01169"></a>01169       }
<a name="l01170"></a>01170       <span class="keywordflow">if</span> (i &lt; numberofregions) {
<a name="l01171"></a>01171         <span class="comment">// This must be caused by an error.</span>
<a name="l01172"></a>01172         fclose(polyfile);
<a name="l01173"></a>01173         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01174"></a>01174       }
<a name="l01175"></a>01175     }
<a name="l01176"></a>01176 
<a name="l01177"></a>01177   } <span class="keywordflow">else</span> {
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     <span class="comment">// Read a PSLG from Triangle&#39;s poly file.</span>
<a name="l01180"></a>01180     assert(mesh_dim == 2);
<a name="l01181"></a>01181     <span class="comment">// A PSLG is a facet of a PLC.</span>
<a name="l01182"></a>01182     numberoffacets = 1;
<a name="l01183"></a>01183     <span class="comment">// Initialize the &#39;facetlist&#39;.</span>
<a name="l01184"></a>01184     facetlist = <span class="keyword">new</span> facet[numberoffacets];
<a name="l01185"></a>01185     facetmarkerlist = (<span class="keywordtype">int</span> *) NULL; <span class="comment">// No facet markers.</span>
<a name="l01186"></a>01186     f = &amp;(facetlist[0]);
<a name="l01187"></a>01187     init(f);
<a name="l01188"></a>01188     <span class="comment">// Read number of segments.</span>
<a name="l01189"></a>01189     stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l01190"></a>01190     <span class="comment">// Segments are degenerate polygons.</span>
<a name="l01191"></a>01191     f-&gt;numberofpolygons = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l01192"></a>01192     <span class="keywordflow">if</span> (f-&gt;numberofpolygons &gt; 0) {
<a name="l01193"></a>01193       f-&gt;polygonlist = <span class="keyword">new</span> polygon[f-&gt;numberofpolygons];
<a name="l01194"></a>01194     }
<a name="l01195"></a>01195     <span class="comment">// Go through all segments, read in their vertices.</span>
<a name="l01196"></a>01196     <span class="keywordflow">for</span> (j = 0; j &lt; f-&gt;numberofpolygons; j++) {
<a name="l01197"></a>01197       p = &amp;(f-&gt;polygonlist[j]);
<a name="l01198"></a>01198       init(p);
<a name="l01199"></a>01199       <span class="comment">// Read in a segment.</span>
<a name="l01200"></a>01200       stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l01201"></a>01201       stringptr = findnextnumber(stringptr); <span class="comment">// Skip its index.</span>
<a name="l01202"></a>01202       p-&gt;numberofvertices = 2; <span class="comment">// A segment always has two vertices.</span>
<a name="l01203"></a>01203       p-&gt;vertexlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[p-&gt;numberofvertices];
<a name="l01204"></a>01204       p-&gt;vertexlist[0] = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l01205"></a>01205       stringptr = findnextnumber(stringptr);
<a name="l01206"></a>01206       p-&gt;vertexlist[1] = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l01207"></a>01207     }
<a name="l01208"></a>01208     <span class="comment">// Read number of holes.</span>
<a name="l01209"></a>01209     stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l01210"></a>01210     f-&gt;numberofholes = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l01211"></a>01211     <span class="keywordflow">if</span> (f-&gt;numberofholes &gt; 0) {
<a name="l01212"></a>01212       <span class="comment">// Initialize &#39;f-&gt;holelist&#39;.</span>
<a name="l01213"></a>01213       f-&gt;holelist = <span class="keyword">new</span> REAL[f-&gt;numberofholes * 3];
<a name="l01214"></a>01214       <span class="comment">// Read the holes&#39; coordinates.</span>
<a name="l01215"></a>01215       <span class="keywordflow">for</span> (j = 0; j &lt; f-&gt;numberofholes; j++) {
<a name="l01216"></a>01216         <span class="comment">// Read a 2D hole point.</span>
<a name="l01217"></a>01217         stringptr = readnumberline(inputline, polyfile, inpolyfilename);
<a name="l01218"></a>01218         stringptr = findnextnumber(stringptr); <span class="comment">// Skip its index.</span>
<a name="l01219"></a>01219         f-&gt;holelist[j * 3] = (REAL) strtod (stringptr, &amp;stringptr);
<a name="l01220"></a>01220         stringptr = findnextnumber(stringptr);
<a name="l01221"></a>01221         f-&gt;holelist[j * 3 + 1] = (REAL) strtod (stringptr, &amp;stringptr);
<a name="l01222"></a>01222         f-&gt;holelist[j * 3 + 2] = 0.0; <span class="comment">// The z-coord.</span>
<a name="l01223"></a>01223       }
<a name="l01224"></a>01224     }
<a name="l01225"></a>01225     <span class="comment">// The regions are skipped.</span>
<a name="l01226"></a>01226 
<a name="l01227"></a>01227   }
<a name="l01228"></a>01228 
<a name="l01229"></a>01229   <span class="comment">// End of reading poly/smesh file.</span>
<a name="l01230"></a>01230   fclose(polyfile);
<a name="l01231"></a>01231 
<a name="l01232"></a>01232   <span class="comment">// Try to load a .var file if it exists.</span>
<a name="l01233"></a>01233   load_var(filename);
<a name="l01234"></a>01234   <span class="comment">// Try to load a .mtr file if it exists.</span>
<a name="l01235"></a>01235   load_mtr(filename);
<a name="l01236"></a>01236   <span class="comment">// Try to read a .pbc file if it exists.</span>
<a name="l01237"></a>01237   load_pbc(filename);
<a name="l01238"></a>01238 
<a name="l01239"></a>01239   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01240"></a>01240 }
<a name="l01241"></a>01241 
<a name="l01243"></a>01243 <span class="comment">//                                                                           //</span>
<a name="l01244"></a>01244 <span class="comment">// load_off()    Load a polyhedron described in a .off file.                 //</span>
<a name="l01245"></a>01245 <span class="comment">//                                                                           //</span>
<a name="l01246"></a>01246 <span class="comment">// The .off format is one of file formats of the Geomview, an interactive    //</span>
<a name="l01247"></a>01247 <span class="comment">// program for viewing and manipulating geometric objects.  More information //</span>
<a name="l01248"></a>01248 <span class="comment">// is available form: http://www.geomview.org.                               //</span>
<a name="l01249"></a>01249 <span class="comment">//                                                                           //</span>
<a name="l01250"></a>01250 <span class="comment">// &#39;filename&#39; is a input filename with extension .off or without extension ( //</span>
<a name="l01251"></a>01251 <span class="comment">// the .off will be added in this case). On completion, the polyhedron is    //</span>
<a name="l01252"></a>01252 <span class="comment">// returned in &#39;pointlist&#39; and &#39;facetlist&#39;.                                  //</span>
<a name="l01253"></a>01253 <span class="comment">//                                                                           //</span>
<a name="l01255"></a>01255 <span class="comment"></span>
<a name="l01256"></a>01256 <span class="keywordtype">bool</span> tetgenio::load_off(<span class="keywordtype">char</span>* filename)
<a name="l01257"></a>01257 {
<a name="l01258"></a>01258   FILE *fp;
<a name="l01259"></a>01259   tetgenio::facet *f;
<a name="l01260"></a>01260   tetgenio::polygon *p;
<a name="l01261"></a>01261   <span class="keywordtype">char</span> infilename[FILENAMESIZE];
<a name="l01262"></a>01262   <span class="keywordtype">char</span> buffer[INPUTLINESIZE];
<a name="l01263"></a>01263   <span class="keywordtype">char</span> *bufferp;
<a name="l01264"></a>01264   <span class="keywordtype">double</span> *coord;
<a name="l01265"></a>01265   <span class="keywordtype">int</span> nverts = 0, iverts = 0;
<a name="l01266"></a>01266   <span class="keywordtype">int</span> nfaces = 0, ifaces = 0;
<a name="l01267"></a>01267   <span class="keywordtype">int</span> nedges = 0;
<a name="l01268"></a>01268   <span class="keywordtype">int</span> line_count = 0, i;
<a name="l01269"></a>01269 
<a name="l01270"></a>01270   strncpy(infilename, filename, 1024 - 1);
<a name="l01271"></a>01271   infilename[FILENAMESIZE - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01272"></a>01272   <span class="keywordflow">if</span> (infilename[0] == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01273"></a>01273     printf(<span class="stringliteral">&quot;Error:  No filename.\n&quot;</span>);
<a name="l01274"></a>01274     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01275"></a>01275   }
<a name="l01276"></a>01276   <span class="keywordflow">if</span> (strcmp(&amp;infilename[strlen(infilename) - 4], <span class="stringliteral">&quot;.off&quot;</span>) != 0) {
<a name="l01277"></a>01277     strcat(infilename, <span class="stringliteral">&quot;.off&quot;</span>);
<a name="l01278"></a>01278   }
<a name="l01279"></a>01279 
<a name="l01280"></a>01280   <span class="keywordflow">if</span> (!(fp = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l01281"></a>01281     printf(<span class="stringliteral">&quot;File I/O Error:  Unable to open file %s\n&quot;</span>, infilename);
<a name="l01282"></a>01282     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01283"></a>01283   }
<a name="l01284"></a>01284   printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286   <span class="comment">// OFF requires the index starts from &#39;0&#39;.</span>
<a name="l01287"></a>01287   firstnumber = 0;
<a name="l01288"></a>01288 
<a name="l01289"></a>01289   <span class="keywordflow">while</span> ((bufferp = readline(buffer, fp, &amp;line_count)) != NULL) {
<a name="l01290"></a>01290     <span class="comment">// Check section</span>
<a name="l01291"></a>01291     <span class="keywordflow">if</span> (nverts == 0) {
<a name="l01292"></a>01292       <span class="comment">// Read header</span>
<a name="l01293"></a>01293       bufferp = strstr(bufferp, <span class="stringliteral">&quot;OFF&quot;</span>);
<a name="l01294"></a>01294       <span class="keywordflow">if</span> (bufferp != NULL) {
<a name="l01295"></a>01295         <span class="comment">// Read mesh counts</span>
<a name="l01296"></a>01296         bufferp = findnextnumber(bufferp); <span class="comment">// Skip field &quot;OFF&quot;.</span>
<a name="l01297"></a>01297         <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01298"></a>01298           <span class="comment">// Read a non-empty line.</span>
<a name="l01299"></a>01299           bufferp = readline(buffer, fp, &amp;line_count);
<a name="l01300"></a>01300         }
<a name="l01301"></a>01301         <span class="keywordflow">if</span> ((sscanf(bufferp, <span class="stringliteral">&quot;%d%d%d&quot;</span>, &amp;nverts, &amp;nfaces, &amp;nedges) != 3)
<a name="l01302"></a>01302             || (nverts == 0)) {
<a name="l01303"></a>01303           printf(<span class="stringliteral">&quot;Syntax error reading header on line %d in file %s\n&quot;</span>,
<a name="l01304"></a>01304                  line_count, infilename);
<a name="l01305"></a>01305           fclose(fp);
<a name="l01306"></a>01306           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01307"></a>01307         }
<a name="l01308"></a>01308         <span class="comment">// Allocate memory for &#39;tetgenio&#39;</span>
<a name="l01309"></a>01309         <span class="keywordflow">if</span> (nverts &gt; 0) {
<a name="l01310"></a>01310           numberofpoints = nverts;
<a name="l01311"></a>01311           pointlist = <span class="keyword">new</span> REAL[nverts * 3];
<a name="l01312"></a>01312         }
<a name="l01313"></a>01313         <span class="keywordflow">if</span> (nfaces &gt; 0) {
<a name="l01314"></a>01314           numberoffacets = nfaces;
<a name="l01315"></a>01315           facetlist = <span class="keyword">new</span> tetgenio::facet[nfaces];
<a name="l01316"></a>01316         }
<a name="l01317"></a>01317       }
<a name="l01318"></a>01318     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iverts &lt; nverts) {
<a name="l01319"></a>01319       <span class="comment">// Read vertex coordinates</span>
<a name="l01320"></a>01320       coord = &amp;pointlist[iverts * 3];
<a name="l01321"></a>01321       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l01322"></a>01322         <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01323"></a>01323           printf(<span class="stringliteral">&quot;Syntax error reading vertex coords on line %d in file %s\n&quot;</span>,
<a name="l01324"></a>01324                  line_count, infilename);
<a name="l01325"></a>01325           fclose(fp);
<a name="l01326"></a>01326           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01327"></a>01327         }
<a name="l01328"></a>01328         coord[i] = (REAL) strtod(bufferp, &amp;bufferp);
<a name="l01329"></a>01329         bufferp = findnextnumber(bufferp);
<a name="l01330"></a>01330       }
<a name="l01331"></a>01331       iverts++;
<a name="l01332"></a>01332     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ifaces &lt; nfaces) {
<a name="l01333"></a>01333       <span class="comment">// Get next face</span>
<a name="l01334"></a>01334       f = &amp;facetlist[ifaces];
<a name="l01335"></a>01335       init(f);
<a name="l01336"></a>01336       <span class="comment">// In .off format, each facet has one polygon, no hole.</span>
<a name="l01337"></a>01337       f-&gt;numberofpolygons = 1;
<a name="l01338"></a>01338       f-&gt;polygonlist = <span class="keyword">new</span> tetgenio::polygon[1];
<a name="l01339"></a>01339       p = &amp;f-&gt;polygonlist[0];
<a name="l01340"></a>01340       init(p);
<a name="l01341"></a>01341       <span class="comment">// Read the number of vertices, it should be greater than 0.</span>
<a name="l01342"></a>01342       p-&gt;numberofvertices = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01343"></a>01343       <span class="keywordflow">if</span> (p-&gt;numberofvertices == 0) {
<a name="l01344"></a>01344         printf(<span class="stringliteral">&quot;Syntax error reading polygon on line %d in file %s\n&quot;</span>,
<a name="l01345"></a>01345                line_count, infilename);
<a name="l01346"></a>01346         fclose(fp);
<a name="l01347"></a>01347         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01348"></a>01348       }
<a name="l01349"></a>01349       <span class="comment">// Allocate memory for face vertices</span>
<a name="l01350"></a>01350       p-&gt;vertexlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[p-&gt;numberofvertices];
<a name="l01351"></a>01351       <span class="keywordflow">for</span> (i = 0; i &lt; p-&gt;numberofvertices; i++) {
<a name="l01352"></a>01352         bufferp = findnextnumber(bufferp);
<a name="l01353"></a>01353         <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01354"></a>01354           printf(<span class="stringliteral">&quot;Syntax error reading polygon on line %d in file %s\n&quot;</span>,
<a name="l01355"></a>01355                  line_count, infilename);
<a name="l01356"></a>01356           fclose(fp);
<a name="l01357"></a>01357           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01358"></a>01358         }
<a name="l01359"></a>01359         p-&gt;vertexlist[i] = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01360"></a>01360       }
<a name="l01361"></a>01361       ifaces++;
<a name="l01362"></a>01362     } <span class="keywordflow">else</span> {
<a name="l01363"></a>01363       <span class="comment">// Should never get here</span>
<a name="l01364"></a>01364       printf(<span class="stringliteral">&quot;Found extra text starting at line %d in file %s\n&quot;</span>, line_count,
<a name="l01365"></a>01365              infilename);
<a name="l01366"></a>01366       <span class="keywordflow">break</span>;
<a name="l01367"></a>01367     }
<a name="l01368"></a>01368   }
<a name="l01369"></a>01369 
<a name="l01370"></a>01370   <span class="comment">// Close file</span>
<a name="l01371"></a>01371   fclose(fp);
<a name="l01372"></a>01372 
<a name="l01373"></a>01373   <span class="comment">// Check whether read all points</span>
<a name="l01374"></a>01374   <span class="keywordflow">if</span> (iverts != nverts) {
<a name="l01375"></a>01375     printf(<span class="stringliteral">&quot;Expected %d vertices, but read only %d vertices in file %s\n&quot;</span>,
<a name="l01376"></a>01376            nverts, iverts, infilename);
<a name="l01377"></a>01377     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01378"></a>01378   }
<a name="l01379"></a>01379 
<a name="l01380"></a>01380   <span class="comment">// Check whether read all faces</span>
<a name="l01381"></a>01381   <span class="keywordflow">if</span> (ifaces != nfaces) {
<a name="l01382"></a>01382     printf(<span class="stringliteral">&quot;Expected %d faces, but read only %d faces in file %s\n&quot;</span>,
<a name="l01383"></a>01383            nfaces, ifaces, infilename);
<a name="l01384"></a>01384     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01385"></a>01385   }
<a name="l01386"></a>01386 
<a name="l01387"></a>01387   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01388"></a>01388 }
<a name="l01389"></a>01389 
<a name="l01391"></a>01391 <span class="comment">//                                                                           //</span>
<a name="l01392"></a>01392 <span class="comment">// load_ply()    Load a polyhedron described in a .ply file.                 //</span>
<a name="l01393"></a>01393 <span class="comment">//                                                                           //</span>
<a name="l01394"></a>01394 <span class="comment">// &#39;filename&#39; is the file name with extension .ply or without extension (the //</span>
<a name="l01395"></a>01395 <span class="comment">// .ply will be added in this case).                                         //</span>
<a name="l01396"></a>01396 <span class="comment">//                                                                           //</span>
<a name="l01397"></a>01397 <span class="comment">// This is a simplified version of reading .ply files, which only reads the  //</span>
<a name="l01398"></a>01398 <span class="comment">// set of vertices and the set of faces. Other informations (such as color,  //</span>
<a name="l01399"></a>01399 <span class="comment">// material, texture, etc) in .ply file are ignored. Complete routines for   //</span>
<a name="l01400"></a>01400 <span class="comment">// reading and writing ,ply files are available from: http://www.cc.gatech.  //</span>
<a name="l01401"></a>01401 <span class="comment">// edu/projects/large_models/ply.html.  Except the header section, ply file  //</span>
<a name="l01402"></a>01402 <span class="comment">// format has exactly the same format for listing vertices and polygons as   //</span>
<a name="l01403"></a>01403 <span class="comment">// off file format.                                                          //</span>
<a name="l01404"></a>01404 <span class="comment">//                                                                           //</span>
<a name="l01405"></a>01405 <span class="comment">// On completion, &#39;pointlist&#39; and &#39;facetlist&#39; together return the polyhedron.//</span>
<a name="l01406"></a>01406 <span class="comment">//                                                                           //</span>
<a name="l01408"></a>01408 <span class="comment"></span>
<a name="l01409"></a>01409 <span class="keywordtype">bool</span> tetgenio::load_ply(<span class="keywordtype">char</span>* filename)
<a name="l01410"></a>01410 {
<a name="l01411"></a>01411   FILE *fp;
<a name="l01412"></a>01412   tetgenio::facet *f;
<a name="l01413"></a>01413   tetgenio::polygon *p;
<a name="l01414"></a>01414   <span class="keywordtype">char</span> infilename[FILENAMESIZE];
<a name="l01415"></a>01415   <span class="keywordtype">char</span> buffer[INPUTLINESIZE];
<a name="l01416"></a>01416   <span class="keywordtype">char</span> *bufferp, *str;
<a name="l01417"></a>01417   <span class="keywordtype">double</span> *coord;
<a name="l01418"></a>01418   <span class="keywordtype">int</span> endheader = 0, format = 0;
<a name="l01419"></a>01419   <span class="keywordtype">int</span> nverts = 0, iverts = 0;
<a name="l01420"></a>01420   <span class="keywordtype">int</span> nfaces = 0, ifaces = 0;
<a name="l01421"></a>01421   <span class="keywordtype">int</span> line_count = 0, i;
<a name="l01422"></a>01422 
<a name="l01423"></a>01423   strncpy(infilename, filename, FILENAMESIZE - 1);
<a name="l01424"></a>01424   infilename[FILENAMESIZE - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01425"></a>01425   <span class="keywordflow">if</span> (infilename[0] == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01426"></a>01426     printf(<span class="stringliteral">&quot;Error:  No filename.\n&quot;</span>);
<a name="l01427"></a>01427     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01428"></a>01428   }
<a name="l01429"></a>01429   <span class="keywordflow">if</span> (strcmp(&amp;infilename[strlen(infilename) - 4], <span class="stringliteral">&quot;.ply&quot;</span>) != 0) {
<a name="l01430"></a>01430     strcat(infilename, <span class="stringliteral">&quot;.ply&quot;</span>);
<a name="l01431"></a>01431   }
<a name="l01432"></a>01432 
<a name="l01433"></a>01433   <span class="keywordflow">if</span> (!(fp = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l01434"></a>01434     printf(<span class="stringliteral">&quot;Error:  Unable to open file %s\n&quot;</span>, infilename);
<a name="l01435"></a>01435     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01436"></a>01436   }
<a name="l01437"></a>01437   printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l01438"></a>01438 
<a name="l01439"></a>01439   <span class="comment">// PLY requires the index starts from &#39;0&#39;.</span>
<a name="l01440"></a>01440   firstnumber = 0;
<a name="l01441"></a>01441 
<a name="l01442"></a>01442   <span class="keywordflow">while</span> ((bufferp = readline(buffer, fp, &amp;line_count)) != NULL) {
<a name="l01443"></a>01443     <span class="keywordflow">if</span> (!endheader) {
<a name="l01444"></a>01444       <span class="comment">// Find if it is the keyword &quot;end_header&quot;.</span>
<a name="l01445"></a>01445       str = strstr(bufferp, <span class="stringliteral">&quot;end_header&quot;</span>);
<a name="l01446"></a>01446       <span class="comment">// strstr() is case sensitive.</span>
<a name="l01447"></a>01447       <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;End_header&quot;</span>);
<a name="l01448"></a>01448       <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;End_Header&quot;</span>);
<a name="l01449"></a>01449       <span class="keywordflow">if</span> (str) {
<a name="l01450"></a>01450         <span class="comment">// This is the end of the header section.</span>
<a name="l01451"></a>01451         endheader = 1;
<a name="l01452"></a>01452         <span class="keywordflow">continue</span>;
<a name="l01453"></a>01453       }
<a name="l01454"></a>01454       <span class="comment">// Parse the number of vertices and the number of faces.</span>
<a name="l01455"></a>01455       <span class="keywordflow">if</span> (nverts == 0 || nfaces == 0) {
<a name="l01456"></a>01456         <span class="comment">// Find if it si the keyword &quot;element&quot;.</span>
<a name="l01457"></a>01457         str = strstr(bufferp, <span class="stringliteral">&quot;element&quot;</span>);
<a name="l01458"></a>01458         <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;Element&quot;</span>);
<a name="l01459"></a>01459         <span class="keywordflow">if</span> (str) {
<a name="l01460"></a>01460           bufferp = findnextfield(str);
<a name="l01461"></a>01461           <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01462"></a>01462             printf(<span class="stringliteral">&quot;Syntax error reading element type on line%d in file %s\n&quot;</span>,
<a name="l01463"></a>01463                    line_count, infilename);
<a name="l01464"></a>01464             fclose(fp);
<a name="l01465"></a>01465             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01466"></a>01466           }
<a name="l01467"></a>01467           <span class="keywordflow">if</span> (nverts == 0) {
<a name="l01468"></a>01468             <span class="comment">// Find if it is the keyword &quot;vertex&quot;.</span>
<a name="l01469"></a>01469             str = strstr(bufferp, <span class="stringliteral">&quot;vertex&quot;</span>);
<a name="l01470"></a>01470             <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;Vertex&quot;</span>);
<a name="l01471"></a>01471             <span class="keywordflow">if</span> (str) {
<a name="l01472"></a>01472               bufferp = findnextnumber(str);
<a name="l01473"></a>01473               <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01474"></a>01474                 printf(<span class="stringliteral">&quot;Syntax error reading vertex number on line&quot;</span>);
<a name="l01475"></a>01475                 printf(<span class="stringliteral">&quot; %d in file %s\n&quot;</span>, line_count, infilename);
<a name="l01476"></a>01476                 fclose(fp);
<a name="l01477"></a>01477                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01478"></a>01478               }
<a name="l01479"></a>01479               nverts = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01480"></a>01480               <span class="comment">// Allocate memory for &#39;tetgenio&#39;</span>
<a name="l01481"></a>01481               <span class="keywordflow">if</span> (nverts &gt; 0) {
<a name="l01482"></a>01482                 numberofpoints = nverts;
<a name="l01483"></a>01483                 pointlist = <span class="keyword">new</span> REAL[nverts * 3];
<a name="l01484"></a>01484               }
<a name="l01485"></a>01485             }
<a name="l01486"></a>01486           }
<a name="l01487"></a>01487           <span class="keywordflow">if</span> (nfaces == 0) {
<a name="l01488"></a>01488             <span class="comment">// Find if it is the keyword &quot;face&quot;.</span>
<a name="l01489"></a>01489             str = strstr(bufferp, <span class="stringliteral">&quot;face&quot;</span>);
<a name="l01490"></a>01490             <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;Face&quot;</span>);
<a name="l01491"></a>01491             <span class="keywordflow">if</span> (str) {
<a name="l01492"></a>01492               bufferp = findnextnumber(str);
<a name="l01493"></a>01493               <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01494"></a>01494                 printf(<span class="stringliteral">&quot;Syntax error reading face number on line&quot;</span>);
<a name="l01495"></a>01495                 printf(<span class="stringliteral">&quot; %d in file %s\n&quot;</span>, line_count, infilename);
<a name="l01496"></a>01496                 fclose(fp);
<a name="l01497"></a>01497                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01498"></a>01498               }
<a name="l01499"></a>01499               nfaces = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01500"></a>01500               <span class="comment">// Allocate memory for &#39;tetgenio&#39;</span>
<a name="l01501"></a>01501               <span class="keywordflow">if</span> (nfaces &gt; 0) {
<a name="l01502"></a>01502                 numberoffacets = nfaces;
<a name="l01503"></a>01503                 facetlist = <span class="keyword">new</span> tetgenio::facet[nfaces];
<a name="l01504"></a>01504               }
<a name="l01505"></a>01505             }
<a name="l01506"></a>01506           }
<a name="l01507"></a>01507         } <span class="comment">// It is not the string &quot;element&quot;.</span>
<a name="l01508"></a>01508       }
<a name="l01509"></a>01509       <span class="keywordflow">if</span> (format == 0) {
<a name="l01510"></a>01510         <span class="comment">// Find the keyword &quot;format&quot;.</span>
<a name="l01511"></a>01511         str = strstr(bufferp, <span class="stringliteral">&quot;format&quot;</span>);
<a name="l01512"></a>01512         <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;Format&quot;</span>);
<a name="l01513"></a>01513         <span class="keywordflow">if</span> (str) {
<a name="l01514"></a>01514           format = 1;
<a name="l01515"></a>01515           bufferp = findnextfield(str);
<a name="l01516"></a>01516           <span class="comment">// Find if it is the string &quot;ascii&quot;.</span>
<a name="l01517"></a>01517           str = strstr(bufferp, <span class="stringliteral">&quot;ascii&quot;</span>);
<a name="l01518"></a>01518           <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;ASCII&quot;</span>);
<a name="l01519"></a>01519           <span class="keywordflow">if</span> (!str) {
<a name="l01520"></a>01520             printf(<span class="stringliteral">&quot;This routine only reads ascii format of ply files.\n&quot;</span>);
<a name="l01521"></a>01521             printf(<span class="stringliteral">&quot;Hint: You can convert the binary to ascii format by\n&quot;</span>);
<a name="l01522"></a>01522             printf(<span class="stringliteral">&quot;  using the provided ply tools:\n&quot;</span>);
<a name="l01523"></a>01523             printf(<span class="stringliteral">&quot;  ply2ascii &lt; %s &gt; ascii_%s\n&quot;</span>, infilename, infilename);
<a name="l01524"></a>01524             fclose(fp);
<a name="l01525"></a>01525             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01526"></a>01526           }
<a name="l01527"></a>01527         }
<a name="l01528"></a>01528       }
<a name="l01529"></a>01529     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (iverts &lt; nverts) {
<a name="l01530"></a>01530       <span class="comment">// Read vertex coordinates</span>
<a name="l01531"></a>01531       coord = &amp;pointlist[iverts * 3];
<a name="l01532"></a>01532       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l01533"></a>01533         <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01534"></a>01534           printf(<span class="stringliteral">&quot;Syntax error reading vertex coords on line %d in file %s\n&quot;</span>,
<a name="l01535"></a>01535                  line_count, infilename);
<a name="l01536"></a>01536           fclose(fp);
<a name="l01537"></a>01537           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01538"></a>01538         }
<a name="l01539"></a>01539         coord[i] = (REAL) strtod(bufferp, &amp;bufferp);
<a name="l01540"></a>01540         bufferp = findnextnumber(bufferp);
<a name="l01541"></a>01541       }
<a name="l01542"></a>01542       iverts++;
<a name="l01543"></a>01543     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ifaces &lt; nfaces) {
<a name="l01544"></a>01544       <span class="comment">// Get next face</span>
<a name="l01545"></a>01545       f = &amp;facetlist[ifaces];
<a name="l01546"></a>01546       init(f);
<a name="l01547"></a>01547       <span class="comment">// In .off format, each facet has one polygon, no hole.</span>
<a name="l01548"></a>01548       f-&gt;numberofpolygons = 1;
<a name="l01549"></a>01549       f-&gt;polygonlist = <span class="keyword">new</span> tetgenio::polygon[1];
<a name="l01550"></a>01550       p = &amp;f-&gt;polygonlist[0];
<a name="l01551"></a>01551       init(p);
<a name="l01552"></a>01552       <span class="comment">// Read the number of vertices, it should be greater than 0.</span>
<a name="l01553"></a>01553       p-&gt;numberofvertices = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01554"></a>01554       <span class="keywordflow">if</span> (p-&gt;numberofvertices == 0) {
<a name="l01555"></a>01555         printf(<span class="stringliteral">&quot;Syntax error reading polygon on line %d in file %s\n&quot;</span>,
<a name="l01556"></a>01556                line_count, infilename);
<a name="l01557"></a>01557         fclose(fp);
<a name="l01558"></a>01558         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01559"></a>01559       }
<a name="l01560"></a>01560       <span class="comment">// Allocate memory for face vertices</span>
<a name="l01561"></a>01561       p-&gt;vertexlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[p-&gt;numberofvertices];
<a name="l01562"></a>01562       <span class="keywordflow">for</span> (i = 0; i &lt; p-&gt;numberofvertices; i++) {
<a name="l01563"></a>01563         bufferp = findnextnumber(bufferp);
<a name="l01564"></a>01564         <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01565"></a>01565           printf(<span class="stringliteral">&quot;Syntax error reading polygon on line %d in file %s\n&quot;</span>,
<a name="l01566"></a>01566                  line_count, infilename);
<a name="l01567"></a>01567           fclose(fp);
<a name="l01568"></a>01568           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01569"></a>01569         }
<a name="l01570"></a>01570         p-&gt;vertexlist[i] = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01571"></a>01571       }
<a name="l01572"></a>01572       ifaces++;
<a name="l01573"></a>01573     } <span class="keywordflow">else</span> {
<a name="l01574"></a>01574       <span class="comment">// Should never get here</span>
<a name="l01575"></a>01575       printf(<span class="stringliteral">&quot;Found extra text starting at line %d in file %s\n&quot;</span>, line_count,
<a name="l01576"></a>01576              infilename);
<a name="l01577"></a>01577       <span class="keywordflow">break</span>;
<a name="l01578"></a>01578     }
<a name="l01579"></a>01579   }
<a name="l01580"></a>01580 
<a name="l01581"></a>01581   <span class="comment">// Close file</span>
<a name="l01582"></a>01582   fclose(fp);
<a name="l01583"></a>01583 
<a name="l01584"></a>01584   <span class="comment">// Check whether read all points</span>
<a name="l01585"></a>01585   <span class="keywordflow">if</span> (iverts != nverts) {
<a name="l01586"></a>01586     printf(<span class="stringliteral">&quot;Expected %d vertices, but read only %d vertices in file %s\n&quot;</span>,
<a name="l01587"></a>01587            nverts, iverts, infilename);
<a name="l01588"></a>01588     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01589"></a>01589   }
<a name="l01590"></a>01590 
<a name="l01591"></a>01591   <span class="comment">// Check whether read all faces</span>
<a name="l01592"></a>01592   <span class="keywordflow">if</span> (ifaces != nfaces) {
<a name="l01593"></a>01593     printf(<span class="stringliteral">&quot;Expected %d faces, but read only %d faces in file %s\n&quot;</span>,
<a name="l01594"></a>01594            nfaces, ifaces, infilename);
<a name="l01595"></a>01595     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01596"></a>01596   }
<a name="l01597"></a>01597 
<a name="l01598"></a>01598   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01599"></a>01599 }
<a name="l01600"></a>01600 
<a name="l01602"></a>01602 <span class="comment">//                                                                           //</span>
<a name="l01603"></a>01603 <span class="comment">// load_stl()    Load a surface mesh described in a .stl file.               //</span>
<a name="l01604"></a>01604 <span class="comment">//                                                                           //</span>
<a name="l01605"></a>01605 <span class="comment">// &#39;filename&#39; is the file name with extension .stl or without extension (the //</span>
<a name="l01606"></a>01606 <span class="comment">// .stl will be added in this case).                                         //</span>
<a name="l01607"></a>01607 <span class="comment">//                                                                           //</span>
<a name="l01608"></a>01608 <span class="comment">// The .stl or stereolithography format is an ASCII or binary file used in   //</span>
<a name="l01609"></a>01609 <span class="comment">// manufacturing.  It is a list of the triangular surfaces that describe a   //</span>
<a name="l01610"></a>01610 <span class="comment">// computer generated solid model. This is the standard input for most rapid //</span>
<a name="l01611"></a>01611 <span class="comment">// prototyping machines.                                                     //</span>
<a name="l01612"></a>01612 <span class="comment">//                                                                           //</span>
<a name="l01613"></a>01613 <span class="comment">// On completion, &#39;pointlist&#39; and &#39;facetlist&#39; together return the polyhedron.//</span>
<a name="l01614"></a>01614 <span class="comment">// Note: After load_stl(), there exist many duplicated points in &#39;pointlist&#39;.//</span>
<a name="l01615"></a>01615 <span class="comment">// They will be unified during the Delaunay tetrahedralization process.      //</span>
<a name="l01616"></a>01616 <span class="comment">//                                                                           //</span>
<a name="l01618"></a>01618 <span class="comment"></span>
<a name="l01619"></a>01619 <span class="keywordtype">bool</span> tetgenio::load_stl(<span class="keywordtype">char</span>* filename)
<a name="l01620"></a>01620 {
<a name="l01621"></a>01621   FILE *fp;
<a name="l01622"></a>01622   tetgenmesh::list *plist;
<a name="l01623"></a>01623   tetgenio::facet *f;
<a name="l01624"></a>01624   tetgenio::polygon *p;
<a name="l01625"></a>01625   <span class="keywordtype">char</span> infilename[FILENAMESIZE];
<a name="l01626"></a>01626   <span class="keywordtype">char</span> buffer[INPUTLINESIZE];
<a name="l01627"></a>01627   <span class="keywordtype">char</span> *bufferp, *str;
<a name="l01628"></a>01628   <span class="keywordtype">double</span> *coord;
<a name="l01629"></a>01629   <span class="keywordtype">int</span> solid = 0;
<a name="l01630"></a>01630   <span class="keywordtype">int</span> nverts = 0, iverts = 0;
<a name="l01631"></a>01631   <span class="keywordtype">int</span> nfaces = 0;
<a name="l01632"></a>01632   <span class="keywordtype">int</span> line_count = 0, i;
<a name="l01633"></a>01633 
<a name="l01634"></a>01634   strncpy(infilename, filename, FILENAMESIZE - 1);
<a name="l01635"></a>01635   infilename[FILENAMESIZE - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01636"></a>01636   <span class="keywordflow">if</span> (infilename[0] == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01637"></a>01637     printf(<span class="stringliteral">&quot;Error:  No filename.\n&quot;</span>);
<a name="l01638"></a>01638     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01639"></a>01639   }
<a name="l01640"></a>01640   <span class="keywordflow">if</span> (strcmp(&amp;infilename[strlen(infilename) - 4], <span class="stringliteral">&quot;.stl&quot;</span>) != 0) {
<a name="l01641"></a>01641     strcat(infilename, <span class="stringliteral">&quot;.stl&quot;</span>);
<a name="l01642"></a>01642   }
<a name="l01643"></a>01643 
<a name="l01644"></a>01644   <span class="keywordflow">if</span> (!(fp = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l01645"></a>01645     printf(<span class="stringliteral">&quot;Error:  Unable to open file %s\n&quot;</span>, infilename);
<a name="l01646"></a>01646     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01647"></a>01647   }
<a name="l01648"></a>01648   printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l01649"></a>01649 
<a name="l01650"></a>01650   <span class="comment">// STL file has no number of points available. Use a list to read points.</span>
<a name="l01651"></a>01651   plist = <span class="keyword">new</span> tetgenmesh::list(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>) * 3, NULL, 1024);
<a name="l01652"></a>01652 
<a name="l01653"></a>01653   <span class="keywordflow">while</span> ((bufferp = readline(buffer, fp, &amp;line_count)) != NULL) {
<a name="l01654"></a>01654     <span class="comment">// The ASCII .stl file must start with the lower case keyword solid and</span>
<a name="l01655"></a>01655     <span class="comment">//   end with endsolid.</span>
<a name="l01656"></a>01656     <span class="keywordflow">if</span> (solid == 0) {
<a name="l01657"></a>01657       <span class="comment">// Read header</span>
<a name="l01658"></a>01658       bufferp = strstr(bufferp, <span class="stringliteral">&quot;solid&quot;</span>);
<a name="l01659"></a>01659       <span class="keywordflow">if</span> (bufferp != NULL) {
<a name="l01660"></a>01660         solid = 1;
<a name="l01661"></a>01661       }
<a name="l01662"></a>01662     } <span class="keywordflow">else</span> {
<a name="l01663"></a>01663       <span class="comment">// We&#39;re inside the block of the solid.</span>
<a name="l01664"></a>01664       str = bufferp;
<a name="l01665"></a>01665       <span class="comment">// Is this the end of the solid.</span>
<a name="l01666"></a>01666       bufferp = strstr(bufferp, <span class="stringliteral">&quot;endsolid&quot;</span>);
<a name="l01667"></a>01667       <span class="keywordflow">if</span> (bufferp != NULL) {
<a name="l01668"></a>01668         solid = 0;
<a name="l01669"></a>01669       } <span class="keywordflow">else</span> {
<a name="l01670"></a>01670         <span class="comment">// Read the XYZ coordinates if it is a vertex.</span>
<a name="l01671"></a>01671         bufferp = str;
<a name="l01672"></a>01672         bufferp = strstr(bufferp, <span class="stringliteral">&quot;vertex&quot;</span>);
<a name="l01673"></a>01673         <span class="keywordflow">if</span> (bufferp != NULL) {
<a name="l01674"></a>01674           coord = (<span class="keywordtype">double</span> *) plist-&gt;append(NULL);
<a name="l01675"></a>01675           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l01676"></a>01676             bufferp = findnextnumber(bufferp);
<a name="l01677"></a>01677             <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01678"></a>01678               printf(<span class="stringliteral">&quot;Syntax error reading vertex coords on line %d\n&quot;</span>,
<a name="l01679"></a>01679                    line_count);
<a name="l01680"></a>01680               <span class="keyword">delete</span> plist;
<a name="l01681"></a>01681               fclose(fp);
<a name="l01682"></a>01682               <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01683"></a>01683             }
<a name="l01684"></a>01684             coord[i] = (REAL) strtod(bufferp, &amp;bufferp);
<a name="l01685"></a>01685           }
<a name="l01686"></a>01686         }
<a name="l01687"></a>01687       }
<a name="l01688"></a>01688     }
<a name="l01689"></a>01689   }
<a name="l01690"></a>01690   fclose(fp);
<a name="l01691"></a>01691 
<a name="l01692"></a>01692   nverts = plist-&gt;len();
<a name="l01693"></a>01693   <span class="comment">// nverts should be an integer times 3 (every 3 vertices denote a face).</span>
<a name="l01694"></a>01694   <span class="keywordflow">if</span> (nverts == 0 || (nverts % 3 != 0)) {
<a name="l01695"></a>01695     printf(<span class="stringliteral">&quot;Error:  Wrong number of vertices in file %s.\n&quot;</span>, infilename);
<a name="l01696"></a>01696     <span class="keyword">delete</span> plist;
<a name="l01697"></a>01697     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01698"></a>01698   }
<a name="l01699"></a>01699   numberofpoints = nverts;
<a name="l01700"></a>01700   pointlist = <span class="keyword">new</span> REAL[nverts * 3];
<a name="l01701"></a>01701   <span class="keywordflow">for</span> (i = 0; i &lt; nverts; i++) {
<a name="l01702"></a>01702     coord = (<span class="keywordtype">double</span> *) (* plist)[i];
<a name="l01703"></a>01703     iverts = i * 3;
<a name="l01704"></a>01704     pointlist[iverts] = (REAL) coord[0];
<a name="l01705"></a>01705     pointlist[iverts + 1] = (REAL) coord[1];
<a name="l01706"></a>01706     pointlist[iverts + 2] = (REAL) coord[2];
<a name="l01707"></a>01707   }
<a name="l01708"></a>01708 
<a name="l01709"></a>01709   nfaces = (int) (nverts / 3);
<a name="l01710"></a>01710   numberoffacets = nfaces;
<a name="l01711"></a>01711   facetlist = <span class="keyword">new</span> tetgenio::facet[nfaces];
<a name="l01712"></a>01712 
<a name="l01713"></a>01713   <span class="comment">// Default use &#39;1&#39; as the array starting index.</span>
<a name="l01714"></a>01714   firstnumber = 1;
<a name="l01715"></a>01715   iverts = firstnumber;
<a name="l01716"></a>01716   <span class="keywordflow">for</span> (i = 0; i &lt; nfaces; i++) {
<a name="l01717"></a>01717     f = &amp;facetlist[i];
<a name="l01718"></a>01718     init(f);
<a name="l01719"></a>01719     <span class="comment">// In .stl format, each facet has one polygon, no hole.</span>
<a name="l01720"></a>01720     f-&gt;numberofpolygons = 1;
<a name="l01721"></a>01721     f-&gt;polygonlist = <span class="keyword">new</span> tetgenio::polygon[1];
<a name="l01722"></a>01722     p = &amp;f-&gt;polygonlist[0];
<a name="l01723"></a>01723     init(p);
<a name="l01724"></a>01724     <span class="comment">// Each polygon has three vertices.</span>
<a name="l01725"></a>01725     p-&gt;numberofvertices = 3;
<a name="l01726"></a>01726     p-&gt;vertexlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[p-&gt;numberofvertices];
<a name="l01727"></a>01727     p-&gt;vertexlist[0] = iverts;
<a name="l01728"></a>01728     p-&gt;vertexlist[1] = iverts + 1;
<a name="l01729"></a>01729     p-&gt;vertexlist[2] = iverts + 2;
<a name="l01730"></a>01730     iverts += 3;
<a name="l01731"></a>01731   }
<a name="l01732"></a>01732 
<a name="l01733"></a>01733   <span class="keyword">delete</span> plist;
<a name="l01734"></a>01734   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01735"></a>01735 }
<a name="l01736"></a>01736 
<a name="l01738"></a>01738 <span class="comment">//                                                                           //</span>
<a name="l01739"></a>01739 <span class="comment">// load_medit()    Load a surface mesh described in .mesh file.              //</span>
<a name="l01740"></a>01740 <span class="comment">//                                                                           //</span>
<a name="l01741"></a>01741 <span class="comment">// &#39;filename&#39; is the file name with extension .mesh or without entension (   //</span>
<a name="l01742"></a>01742 <span class="comment">// the .mesh will be added in this case). .mesh is the file format of Medit, //</span>
<a name="l01743"></a>01743 <span class="comment">// a user-friendly interactive mesh viewing program.                         //</span>
<a name="l01744"></a>01744 <span class="comment">//                                                                           //</span>
<a name="l01745"></a>01745 <span class="comment">// This routine ONLY reads the sections containing vertices, triangles, and  //</span>
<a name="l01746"></a>01746 <span class="comment">// quadrilaters. Other sections (such as tetrahedra, edges, ...) are ignored.//</span>
<a name="l01747"></a>01747 <span class="comment">//                                                                           //</span>
<a name="l01749"></a>01749 <span class="comment"></span>
<a name="l01750"></a>01750 <span class="keywordtype">bool</span> tetgenio::load_medit(<span class="keywordtype">char</span>* filename)
<a name="l01751"></a>01751 {
<a name="l01752"></a>01752   FILE *fp;
<a name="l01753"></a>01753   tetgenio::facet *tmpflist, *f;
<a name="l01754"></a>01754   tetgenio::polygon *p;
<a name="l01755"></a>01755   <span class="keywordtype">char</span> infilename[FILENAMESIZE];
<a name="l01756"></a>01756   <span class="keywordtype">char</span> buffer[INPUTLINESIZE];
<a name="l01757"></a>01757   <span class="keywordtype">char</span> *bufferp, *str;
<a name="l01758"></a>01758   <span class="keywordtype">double</span> *coord;
<a name="l01759"></a>01759   <span class="keywordtype">int</span> *tmpfmlist;
<a name="l01760"></a>01760   <span class="keywordtype">int</span> dimension = 0;
<a name="l01761"></a>01761   <span class="keywordtype">int</span> nverts = 0;
<a name="l01762"></a>01762   <span class="keywordtype">int</span> nfaces = 0;
<a name="l01763"></a>01763   <span class="keywordtype">int</span> line_count = 0;
<a name="l01764"></a>01764   <span class="keywordtype">int</span> corners = 0; <span class="comment">// 3 (triangle) or 4 (quad).</span>
<a name="l01765"></a>01765   <span class="keywordtype">int</span> i, j;
<a name="l01766"></a>01766 
<a name="l01767"></a>01767   strncpy(infilename, filename, FILENAMESIZE - 1);
<a name="l01768"></a>01768   infilename[FILENAMESIZE - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l01769"></a>01769   <span class="keywordflow">if</span> (infilename[0] == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01770"></a>01770     printf(<span class="stringliteral">&quot;Error:  No filename.\n&quot;</span>);
<a name="l01771"></a>01771     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01772"></a>01772   }
<a name="l01773"></a>01773   <span class="keywordflow">if</span> (strcmp(&amp;infilename[strlen(infilename) - 5], <span class="stringliteral">&quot;.mesh&quot;</span>) != 0) {
<a name="l01774"></a>01774     strcat(infilename, <span class="stringliteral">&quot;.mesh&quot;</span>);
<a name="l01775"></a>01775   }
<a name="l01776"></a>01776 
<a name="l01777"></a>01777   <span class="keywordflow">if</span> (!(fp = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>))) {
<a name="l01778"></a>01778     printf(<span class="stringliteral">&quot;Error:  Unable to open file %s\n&quot;</span>, infilename);
<a name="l01779"></a>01779     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01780"></a>01780   }
<a name="l01781"></a>01781   printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l01782"></a>01782 
<a name="l01783"></a>01783   <span class="comment">// Default uses the index starts from &#39;1&#39;.</span>
<a name="l01784"></a>01784   firstnumber = 1;
<a name="l01785"></a>01785 
<a name="l01786"></a>01786   <span class="keywordflow">while</span> ((bufferp = readline(buffer, fp, &amp;line_count)) != NULL) {
<a name="l01787"></a>01787     <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;#&#39;</span>) <span class="keywordflow">continue</span>;  <span class="comment">// A comment line is skipped.</span>
<a name="l01788"></a>01788     <span class="keywordflow">if</span> (dimension == 0) {
<a name="l01789"></a>01789       <span class="comment">// Find if it is the keyword &quot;Dimension&quot;.</span>
<a name="l01790"></a>01790       str = strstr(bufferp, <span class="stringliteral">&quot;Dimension&quot;</span>);
<a name="l01791"></a>01791       <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;dimension&quot;</span>);
<a name="l01792"></a>01792       <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;DIMENSION&quot;</span>);
<a name="l01793"></a>01793       <span class="keywordflow">if</span> (str) {
<a name="l01794"></a>01794         <span class="comment">// Read the dimensions</span>
<a name="l01795"></a>01795         bufferp = findnextnumber(str); <span class="comment">// Skip field &quot;Dimension&quot;.</span>
<a name="l01796"></a>01796         <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01797"></a>01797           <span class="comment">// Read a non-empty line.</span>
<a name="l01798"></a>01798           bufferp = readline(buffer, fp, &amp;line_count);
<a name="l01799"></a>01799         }
<a name="l01800"></a>01800         dimension = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01801"></a>01801         <span class="keywordflow">if</span> (dimension != 2 &amp;&amp; dimension != 3) {
<a name="l01802"></a>01802           printf(<span class="stringliteral">&quot;Unknown dimension in file on line %d in file %s\n&quot;</span>,
<a name="l01803"></a>01803                  line_count, infilename);
<a name="l01804"></a>01804           fclose(fp);
<a name="l01805"></a>01805           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01806"></a>01806         }
<a name="l01807"></a>01807         mesh_dim = dimension;
<a name="l01808"></a>01808       }
<a name="l01809"></a>01809     }
<a name="l01810"></a>01810     <span class="keywordflow">if</span> (nverts == 0) {
<a name="l01811"></a>01811       <span class="comment">// Find if it is the keyword &quot;Vertices&quot;.</span>
<a name="l01812"></a>01812       str = strstr(bufferp, <span class="stringliteral">&quot;Vertices&quot;</span>);
<a name="l01813"></a>01813       <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;vertices&quot;</span>);
<a name="l01814"></a>01814       <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;VERTICES&quot;</span>);
<a name="l01815"></a>01815       <span class="keywordflow">if</span> (str) {
<a name="l01816"></a>01816         <span class="comment">// Read the number of vertices.</span>
<a name="l01817"></a>01817         bufferp = findnextnumber(str); <span class="comment">// Skip field &quot;Vertices&quot;.</span>
<a name="l01818"></a>01818         <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01819"></a>01819           <span class="comment">// Read a non-empty line.</span>
<a name="l01820"></a>01820           bufferp = readline(buffer, fp, &amp;line_count);
<a name="l01821"></a>01821         }
<a name="l01822"></a>01822         nverts = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01823"></a>01823         <span class="comment">// Allocate memory for &#39;tetgenio&#39;</span>
<a name="l01824"></a>01824         <span class="keywordflow">if</span> (nverts &gt; 0) {
<a name="l01825"></a>01825           numberofpoints = nverts;
<a name="l01826"></a>01826           pointlist = <span class="keyword">new</span> REAL[nverts * 3];
<a name="l01827"></a>01827         }
<a name="l01828"></a>01828         <span class="comment">// Read the follwoing node list.</span>
<a name="l01829"></a>01829         <span class="keywordflow">for</span> (i = 0; i &lt; nverts; i++) {
<a name="l01830"></a>01830           bufferp = readline(buffer, fp, &amp;line_count);
<a name="l01831"></a>01831           <span class="keywordflow">if</span> (bufferp == NULL) {
<a name="l01832"></a>01832             printf(<span class="stringliteral">&quot;Unexpected end of file on line %d in file %s\n&quot;</span>,
<a name="l01833"></a>01833                    line_count, infilename);
<a name="l01834"></a>01834             fclose(fp);
<a name="l01835"></a>01835             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01836"></a>01836           }
<a name="l01837"></a>01837           <span class="comment">// Read vertex coordinates</span>
<a name="l01838"></a>01838           coord = &amp;pointlist[i * 3];
<a name="l01839"></a>01839           <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l01840"></a>01840             <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01841"></a>01841               printf(<span class="stringliteral">&quot;Syntax error reading vertex coords on line&quot;</span>);
<a name="l01842"></a>01842               printf(<span class="stringliteral">&quot; %d in file %s\n&quot;</span>, line_count, infilename);
<a name="l01843"></a>01843               fclose(fp);
<a name="l01844"></a>01844               <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01845"></a>01845             }
<a name="l01846"></a>01846             <span class="keywordflow">if</span> ((j &lt; 2) || (dimension == 3)) {
<a name="l01847"></a>01847               coord[j] = (REAL) strtod(bufferp, &amp;bufferp);
<a name="l01848"></a>01848             } <span class="keywordflow">else</span> {
<a name="l01849"></a>01849               assert((j == 2) &amp;&amp; (dimension == 2));
<a name="l01850"></a>01850               coord[j] = 0.0;
<a name="l01851"></a>01851             }
<a name="l01852"></a>01852             bufferp = findnextnumber(bufferp);
<a name="l01853"></a>01853           }
<a name="l01854"></a>01854         }
<a name="l01855"></a>01855         <span class="keywordflow">continue</span>;
<a name="l01856"></a>01856       }
<a name="l01857"></a>01857     }
<a name="l01858"></a>01858     <span class="keywordflow">if</span> (nfaces == 0) {
<a name="l01859"></a>01859       <span class="comment">// Find if it is the keyword &quot;Triangles&quot; or &quot;Quadrilaterals&quot;.</span>
<a name="l01860"></a>01860       corners = 0;
<a name="l01861"></a>01861       str = strstr(bufferp, <span class="stringliteral">&quot;Triangles&quot;</span>);
<a name="l01862"></a>01862       <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;triangles&quot;</span>);
<a name="l01863"></a>01863       <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;TRIANGLES&quot;</span>);
<a name="l01864"></a>01864       <span class="keywordflow">if</span> (str) {
<a name="l01865"></a>01865         corners = 3;
<a name="l01866"></a>01866       } <span class="keywordflow">else</span> {
<a name="l01867"></a>01867         str = strstr(bufferp, <span class="stringliteral">&quot;Quadrilaterals&quot;</span>);
<a name="l01868"></a>01868         <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;quadrilaterals&quot;</span>);
<a name="l01869"></a>01869         <span class="keywordflow">if</span> (!str) str = strstr(bufferp, <span class="stringliteral">&quot;QUADRILATERALS&quot;</span>);
<a name="l01870"></a>01870         <span class="keywordflow">if</span> (str) {
<a name="l01871"></a>01871           corners = 4;
<a name="l01872"></a>01872         }
<a name="l01873"></a>01873       }
<a name="l01874"></a>01874       <span class="keywordflow">if</span> (corners == 3 || corners == 4) {
<a name="l01875"></a>01875         <span class="comment">// Read the number of triangles (or quadrilaterals).</span>
<a name="l01876"></a>01876         bufferp = findnextnumber(str); <span class="comment">// Skip field &quot;Triangles&quot;.</span>
<a name="l01877"></a>01877         <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01878"></a>01878           <span class="comment">// Read a non-empty line.</span>
<a name="l01879"></a>01879           bufferp = readline(buffer, fp, &amp;line_count);
<a name="l01880"></a>01880         }
<a name="l01881"></a>01881         nfaces = strtol(bufferp, &amp;bufferp, 0);
<a name="l01882"></a>01882         <span class="comment">// Allocate memory for &#39;tetgenio&#39;</span>
<a name="l01883"></a>01883         <span class="keywordflow">if</span> (nfaces &gt; 0) {
<a name="l01884"></a>01884           <span class="keywordflow">if</span> (numberoffacets &gt; 0) {
<a name="l01885"></a>01885             <span class="comment">// facetlist has already been allocated. Enlarge arrays.</span>
<a name="l01886"></a>01886             tmpflist = <span class="keyword">new</span> tetgenio::facet[numberoffacets + nfaces];
<a name="l01887"></a>01887             tmpfmlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[numberoffacets + nfaces];
<a name="l01888"></a>01888             <span class="comment">// Copy the data of old arrays into new arrays.</span>
<a name="l01889"></a>01889             <span class="keywordflow">for</span> (i = 0; i &lt; numberoffacets; i++) {
<a name="l01890"></a>01890               f = &amp;(tmpflist[i]);
<a name="l01891"></a>01891               tetgenio::init(f);
<a name="l01892"></a>01892               *f = facetlist[i];
<a name="l01893"></a>01893               tmpfmlist[i] = facetmarkerlist[i];
<a name="l01894"></a>01894             }
<a name="l01895"></a>01895             <span class="comment">// Release old arrays.</span>
<a name="l01896"></a>01896             <span class="keyword">delete</span> [] facetlist;
<a name="l01897"></a>01897             <span class="keyword">delete</span> [] facetmarkerlist;
<a name="l01898"></a>01898             <span class="comment">// Remember the new arrays.</span>
<a name="l01899"></a>01899             facetlist = tmpflist;
<a name="l01900"></a>01900             facetmarkerlist = tmpfmlist;
<a name="l01901"></a>01901           } <span class="keywordflow">else</span> {
<a name="l01902"></a>01902             <span class="comment">// This is the first time to allocate facetlist.</span>
<a name="l01903"></a>01903             facetlist = <span class="keyword">new</span> tetgenio::facet[nfaces];
<a name="l01904"></a>01904             facetmarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[nfaces];
<a name="l01905"></a>01905           }
<a name="l01906"></a>01906         }
<a name="l01907"></a>01907         <span class="comment">// Read the following list of faces.</span>
<a name="l01908"></a>01908         <span class="keywordflow">for</span> (i = numberoffacets; i &lt; numberoffacets + nfaces; i++) {
<a name="l01909"></a>01909           bufferp = readline(buffer, fp, &amp;line_count);
<a name="l01910"></a>01910           <span class="keywordflow">if</span> (bufferp == NULL) {
<a name="l01911"></a>01911             printf(<span class="stringliteral">&quot;Unexpected end of file on line %d in file %s\n&quot;</span>,
<a name="l01912"></a>01912                    line_count, infilename);
<a name="l01913"></a>01913             fclose(fp);
<a name="l01914"></a>01914             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01915"></a>01915           }
<a name="l01916"></a>01916           f = &amp;facetlist[i];
<a name="l01917"></a>01917           tetgenio::init(f);
<a name="l01918"></a>01918           <span class="comment">// In .mesh format, each facet has one polygon, no hole.</span>
<a name="l01919"></a>01919           f-&gt;numberofpolygons = 1;
<a name="l01920"></a>01920           f-&gt;polygonlist = <span class="keyword">new</span> tetgenio::polygon[1];
<a name="l01921"></a>01921           p = &amp;f-&gt;polygonlist[0];
<a name="l01922"></a>01922           tetgenio::init(p);
<a name="l01923"></a>01923           p-&gt;numberofvertices = corners;
<a name="l01924"></a>01924           <span class="comment">// Allocate memory for face vertices</span>
<a name="l01925"></a>01925           p-&gt;vertexlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[p-&gt;numberofvertices];
<a name="l01926"></a>01926           <span class="comment">// Read the vertices of the face.</span>
<a name="l01927"></a>01927           <span class="keywordflow">for</span> (j = 0; j &lt; corners; j++) {
<a name="l01928"></a>01928             <span class="keywordflow">if</span> (*bufferp == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01929"></a>01929               printf(<span class="stringliteral">&quot;Syntax error reading face on line %d in file %s\n&quot;</span>,
<a name="l01930"></a>01930                      line_count, infilename);
<a name="l01931"></a>01931               fclose(fp);
<a name="l01932"></a>01932               <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01933"></a>01933             }
<a name="l01934"></a>01934             p-&gt;vertexlist[j] = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01935"></a>01935             <span class="keywordflow">if</span> (firstnumber == 1) {
<a name="l01936"></a>01936               <span class="comment">// Check if a &#39;0&#39; index appears.</span>
<a name="l01937"></a>01937               <span class="keywordflow">if</span> (p-&gt;vertexlist[j] == 0) {
<a name="l01938"></a>01938                 <span class="comment">// The first index is set to be 0.</span>
<a name="l01939"></a>01939                 firstnumber = 0;
<a name="l01940"></a>01940               }
<a name="l01941"></a>01941             }
<a name="l01942"></a>01942             bufferp = findnextnumber(bufferp);
<a name="l01943"></a>01943           }
<a name="l01944"></a>01944           <span class="comment">// Read the marker of the face if it exists.</span>
<a name="l01945"></a>01945           facetmarkerlist[i] = 0;
<a name="l01946"></a>01946           <span class="keywordflow">if</span> (*bufferp != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l01947"></a>01947             facetmarkerlist[i] = (int) strtol(bufferp, &amp;bufferp, 0);
<a name="l01948"></a>01948           }
<a name="l01949"></a>01949         }
<a name="l01950"></a>01950         <span class="comment">// Have read in a list of triangles/quads.</span>
<a name="l01951"></a>01951         numberoffacets += nfaces;
<a name="l01952"></a>01952         nfaces = 0;
<a name="l01953"></a>01953       }
<a name="l01954"></a>01954     }
<a name="l01955"></a>01955     <span class="comment">// if (nverts &gt; 0 &amp;&amp; nfaces &gt; 0) break; // Ignore other data.</span>
<a name="l01956"></a>01956   }
<a name="l01957"></a>01957 
<a name="l01958"></a>01958   <span class="comment">// Close file</span>
<a name="l01959"></a>01959   fclose(fp);
<a name="l01960"></a>01960 
<a name="l01961"></a>01961   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l01962"></a>01962 }
<a name="l01963"></a>01963 
<a name="l01965"></a>01965 <span class="comment">//                                                                           //</span>
<a name="l01966"></a>01966 <span class="comment">// load_plc()    Load a piecewise linear complex from file.                  //</span>
<a name="l01967"></a>01967 <span class="comment">//                                                                           //</span>
<a name="l01968"></a>01968 <span class="comment">// This is main entrance for loading plcs from different file formats into   //</span>
<a name="l01969"></a>01969 <span class="comment">// tetgenio.  &#39;filename&#39; is the input file name without extention. &#39;object&#39;  //</span>
<a name="l01970"></a>01970 <span class="comment">// indicates which file format is used to describ the plc.                   //</span>
<a name="l01971"></a>01971 <span class="comment">//                                                                           //</span>
<a name="l01973"></a>01973 <span class="comment"></span>
<a name="l01974"></a>01974 <span class="keywordtype">bool</span> tetgenio::load_plc(<span class="keywordtype">char</span>* filename, <span class="keywordtype">int</span> <span class="keywordtype">object</span>)
<a name="l01975"></a>01975 {
<a name="l01976"></a>01976   <span class="keyword">enum</span> tetgenbehavior::objecttype type;
<a name="l01977"></a>01977 
<a name="l01978"></a>01978   type = (<span class="keyword">enum</span> tetgenbehavior::objecttype) <span class="keywordtype">object</span>;
<a name="l01979"></a>01979   <span class="keywordflow">switch</span> (type) {
<a name="l01980"></a>01980   <span class="keywordflow">case</span> tetgenbehavior::NODES:
<a name="l01981"></a>01981     <span class="keywordflow">return</span> load_node(filename);
<a name="l01982"></a>01982   <span class="keywordflow">case</span> tetgenbehavior::POLY:
<a name="l01983"></a>01983     <span class="keywordflow">return</span> load_poly(filename);
<a name="l01984"></a>01984   <span class="keywordflow">case</span> tetgenbehavior::OFF:
<a name="l01985"></a>01985     <span class="keywordflow">return</span> load_off(filename);
<a name="l01986"></a>01986   <span class="keywordflow">case</span> tetgenbehavior::PLY:
<a name="l01987"></a>01987     <span class="keywordflow">return</span> load_ply(filename);
<a name="l01988"></a>01988   <span class="keywordflow">case</span> tetgenbehavior::STL:
<a name="l01989"></a>01989     <span class="keywordflow">return</span> load_stl(filename);
<a name="l01990"></a>01990   <span class="keywordflow">case</span> tetgenbehavior::MEDIT:
<a name="l01991"></a>01991     <span class="keywordflow">return</span> load_medit(filename);
<a name="l01992"></a>01992   <span class="keywordflow">default</span>:
<a name="l01993"></a>01993     <span class="keywordflow">return</span> load_poly(filename);
<a name="l01994"></a>01994   }
<a name="l01995"></a>01995 }
<a name="l01996"></a>01996 
<a name="l01998"></a>01998 <span class="comment">//                                                                           //</span>
<a name="l01999"></a>01999 <span class="comment">// load_tetmesh()    Load a tetrahedral mesh from files.                     //</span>
<a name="l02000"></a>02000 <span class="comment">//                                                                           //</span>
<a name="l02001"></a>02001 <span class="comment">// &#39;filename&#39; is the inputfile without suffix.  The nodes of the tetrahedral //</span>
<a name="l02002"></a>02002 <span class="comment">// mesh is in &quot;filename.node&quot;,  the elements is in &quot;filename.ele&quot;, if the    //</span>
<a name="l02003"></a>02003 <span class="comment">// &quot;filename.face&quot; and &quot;filename.vol&quot; exists, they will also be read.        //</span>
<a name="l02004"></a>02004 <span class="comment">//                                                                           //</span>
<a name="l02006"></a>02006 <span class="comment"></span>
<a name="l02007"></a>02007 <span class="keywordtype">bool</span> tetgenio::load_tetmesh(<span class="keywordtype">char</span>* filename)
<a name="l02008"></a>02008 {
<a name="l02009"></a>02009   FILE *infile;
<a name="l02010"></a>02010   <span class="keywordtype">char</span> innodefilename[FILENAMESIZE];
<a name="l02011"></a>02011   <span class="keywordtype">char</span> inelefilename[FILENAMESIZE];
<a name="l02012"></a>02012   <span class="keywordtype">char</span> infacefilename[FILENAMESIZE];
<a name="l02013"></a>02013   <span class="keywordtype">char</span> inedgefilename[FILENAMESIZE];
<a name="l02014"></a>02014   <span class="keywordtype">char</span> involfilename[FILENAMESIZE];
<a name="l02015"></a>02015   <span class="keywordtype">char</span> inputline[INPUTLINESIZE];
<a name="l02016"></a>02016   <span class="keywordtype">char</span> *stringptr, *infilename;
<a name="l02017"></a>02017   REAL attrib, volume;
<a name="l02018"></a>02018   <span class="keywordtype">int</span> volelements;
<a name="l02019"></a>02019   <span class="keywordtype">int</span> markers, corner;
<a name="l02020"></a>02020   <span class="keywordtype">int</span> index, attribindex;
<a name="l02021"></a>02021   <span class="keywordtype">int</span> i, j;
<a name="l02022"></a>02022 
<a name="l02023"></a>02023   markers = 0;
<a name="l02024"></a>02024 
<a name="l02025"></a>02025   <span class="comment">// Assembling the actual file names we want to open.</span>
<a name="l02026"></a>02026   strcpy(innodefilename, filename);
<a name="l02027"></a>02027   strcpy(inelefilename, filename);
<a name="l02028"></a>02028   strcpy(infacefilename, filename);
<a name="l02029"></a>02029   strcpy(inedgefilename, filename);
<a name="l02030"></a>02030   strcpy(involfilename, filename);
<a name="l02031"></a>02031   strcat(innodefilename, <span class="stringliteral">&quot;.node&quot;</span>);
<a name="l02032"></a>02032   strcat(inelefilename, <span class="stringliteral">&quot;.ele&quot;</span>);
<a name="l02033"></a>02033   strcat(infacefilename, <span class="stringliteral">&quot;.face&quot;</span>);
<a name="l02034"></a>02034   strcat(inedgefilename, <span class="stringliteral">&quot;.edge&quot;</span>);
<a name="l02035"></a>02035   strcat(involfilename, <span class="stringliteral">&quot;.vol&quot;</span>);
<a name="l02036"></a>02036 
<a name="l02037"></a>02037   <span class="comment">// Read the points from a .node file.</span>
<a name="l02038"></a>02038   infilename = innodefilename;
<a name="l02039"></a>02039   printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l02040"></a>02040   infile = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l02041"></a>02041   <span class="keywordflow">if</span> (infile == (FILE *) NULL) {
<a name="l02042"></a>02042     printf(<span class="stringliteral">&quot;File I/O Error:  Cannot access file %s.\n&quot;</span>, infilename);
<a name="l02043"></a>02043     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02044"></a>02044   }
<a name="l02045"></a>02045   <span class="comment">// Read the first line of the file.</span>
<a name="l02046"></a>02046   stringptr = readnumberline(inputline, infile, infilename);
<a name="l02047"></a>02047   <span class="comment">// Is this list of points generated from rbox?</span>
<a name="l02048"></a>02048   stringptr = strstr(inputline, <span class="stringliteral">&quot;rbox&quot;</span>);
<a name="l02049"></a>02049   <span class="keywordflow">if</span> (stringptr == NULL) {
<a name="l02050"></a>02050     <span class="comment">// Read number of points, number of dimensions, number of point</span>
<a name="l02051"></a>02051     <span class="comment">//   attributes, and number of boundary markers.</span>
<a name="l02052"></a>02052     stringptr = inputline;
<a name="l02053"></a>02053     numberofpoints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02054"></a>02054     stringptr = findnextnumber(stringptr);
<a name="l02055"></a>02055     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02056"></a>02056       mesh_dim = 3;
<a name="l02057"></a>02057     } <span class="keywordflow">else</span> {
<a name="l02058"></a>02058       mesh_dim = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02059"></a>02059     }
<a name="l02060"></a>02060     stringptr = findnextnumber(stringptr);
<a name="l02061"></a>02061     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02062"></a>02062       numberofpointattributes = 0;
<a name="l02063"></a>02063     } <span class="keywordflow">else</span> {
<a name="l02064"></a>02064       numberofpointattributes = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02065"></a>02065     }
<a name="l02066"></a>02066     stringptr = findnextnumber(stringptr);
<a name="l02067"></a>02067     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02068"></a>02068       markers = 0;  <span class="comment">// Default value.</span>
<a name="l02069"></a>02069     } <span class="keywordflow">else</span> {
<a name="l02070"></a>02070       markers = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02071"></a>02071     }
<a name="l02072"></a>02072   } <span class="keywordflow">else</span> {
<a name="l02073"></a>02073     <span class="comment">// It is a rbox (qhull) input file.</span>
<a name="l02074"></a>02074     stringptr = inputline;
<a name="l02075"></a>02075     <span class="comment">// Get the dimension.</span>
<a name="l02076"></a>02076     mesh_dim = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02077"></a>02077     <span class="comment">// Get the number of points.</span>
<a name="l02078"></a>02078     stringptr = readnumberline(inputline, infile, infilename);
<a name="l02079"></a>02079     numberofpoints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02080"></a>02080     <span class="comment">// There is no index column.</span>
<a name="l02081"></a>02081     useindex = 0;
<a name="l02082"></a>02082   }
<a name="l02083"></a>02083 
<a name="l02084"></a>02084   <span class="comment">// Load the list of nodes.</span>
<a name="l02085"></a>02085   <span class="keywordflow">if</span> (!load_node_call(infile, markers, infilename)) {
<a name="l02086"></a>02086     fclose(infile);
<a name="l02087"></a>02087     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02088"></a>02088   }
<a name="l02089"></a>02089   fclose(infile);
<a name="l02090"></a>02090 
<a name="l02091"></a>02091   <span class="comment">// Read the elements from an .ele file.</span>
<a name="l02092"></a>02092   <span class="keywordflow">if</span> (mesh_dim == 3) {
<a name="l02093"></a>02093     infilename = inelefilename;
<a name="l02094"></a>02094     infile = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l02095"></a>02095     <span class="keywordflow">if</span> (infile != (FILE *) NULL) {
<a name="l02096"></a>02096       printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l02097"></a>02097       <span class="comment">// Read number of elements, number of corners (4 or 10), number of</span>
<a name="l02098"></a>02098       <span class="comment">//   element attributes.</span>
<a name="l02099"></a>02099       stringptr = readnumberline(inputline, infile, infilename);
<a name="l02100"></a>02100       numberoftetrahedra = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02101"></a>02101       stringptr = findnextnumber(stringptr);
<a name="l02102"></a>02102       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02103"></a>02103         numberofcorners = 4;  <span class="comment">// Default read 4 nodes per element.</span>
<a name="l02104"></a>02104       } <span class="keywordflow">else</span> {
<a name="l02105"></a>02105         numberofcorners = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l02106"></a>02106       }
<a name="l02107"></a>02107       stringptr = findnextnumber(stringptr);
<a name="l02108"></a>02108       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02109"></a>02109         numberoftetrahedronattributes = 0; <span class="comment">// Default no attribute.</span>
<a name="l02110"></a>02110       } <span class="keywordflow">else</span> {
<a name="l02111"></a>02111         numberoftetrahedronattributes = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l02112"></a>02112       }
<a name="l02113"></a>02113       <span class="keywordflow">if</span> (numberofcorners != 4 &amp;&amp; numberofcorners != 10) {
<a name="l02114"></a>02114         printf(<span class="stringliteral">&quot;Error:  Wrong number of corners %d (should be 4 or 10).\n&quot;</span>,
<a name="l02115"></a>02115                numberofcorners);
<a name="l02116"></a>02116         fclose(infile);
<a name="l02117"></a>02117         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02118"></a>02118       }
<a name="l02119"></a>02119       <span class="comment">// Allocate memory for tetrahedra.</span>
<a name="l02120"></a>02120       <span class="keywordflow">if</span> (numberoftetrahedra &gt; 0) {
<a name="l02121"></a>02121         tetrahedronlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[numberoftetrahedra * numberofcorners];
<a name="l02122"></a>02122         <span class="keywordflow">if</span> (tetrahedronlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l02123"></a>02123           printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l02124"></a>02124           terminatetetgen(1);
<a name="l02125"></a>02125         }
<a name="l02126"></a>02126         <span class="comment">// Allocate memory for output tetrahedron attributes if necessary.</span>
<a name="l02127"></a>02127         <span class="keywordflow">if</span> (numberoftetrahedronattributes &gt; 0) {
<a name="l02128"></a>02128           tetrahedronattributelist = <span class="keyword">new</span> REAL[numberoftetrahedra *
<a name="l02129"></a>02129                                           numberoftetrahedronattributes];
<a name="l02130"></a>02130           <span class="keywordflow">if</span> (tetrahedronattributelist == (REAL *) NULL) {
<a name="l02131"></a>02131             printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l02132"></a>02132             terminatetetgen(1);
<a name="l02133"></a>02133           }
<a name="l02134"></a>02134         }
<a name="l02135"></a>02135       }
<a name="l02136"></a>02136       <span class="comment">// Read the list of tetrahedra.</span>
<a name="l02137"></a>02137       index = 0;
<a name="l02138"></a>02138       attribindex = 0;
<a name="l02139"></a>02139       <span class="keywordflow">for</span> (i = 0; i &lt; numberoftetrahedra; i++) {
<a name="l02140"></a>02140         <span class="comment">// Read tetrahedron index and the tetrahedron&#39;s corners.</span>
<a name="l02141"></a>02141         stringptr = readnumberline(inputline, infile, infilename);
<a name="l02142"></a>02142         <span class="keywordflow">for</span> (j = 0; j &lt; numberofcorners; j++) {
<a name="l02143"></a>02143           stringptr = findnextnumber(stringptr);
<a name="l02144"></a>02144           <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02145"></a>02145             printf(<span class="stringliteral">&quot;Error:  Tetrahedron %d is missing vertex %d in %s.\n&quot;</span>,
<a name="l02146"></a>02146                    i + firstnumber, j + 1, infilename);
<a name="l02147"></a>02147             terminatetetgen(1);
<a name="l02148"></a>02148           }
<a name="l02149"></a>02149           corner = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l02150"></a>02150           <span class="keywordflow">if</span> (corner &lt; firstnumber || corner &gt;= numberofpoints + firstnumber) {
<a name="l02151"></a>02151             printf(<span class="stringliteral">&quot;Error:  Tetrahedron %d has an invalid vertex index.\n&quot;</span>,
<a name="l02152"></a>02152                    i + firstnumber);
<a name="l02153"></a>02153             terminatetetgen(1);
<a name="l02154"></a>02154           }
<a name="l02155"></a>02155           tetrahedronlist[index++] = corner;
<a name="l02156"></a>02156         }
<a name="l02157"></a>02157         <span class="comment">// Read the tetrahedron&#39;s attributes.</span>
<a name="l02158"></a>02158         <span class="keywordflow">for</span> (j = 0; j &lt; numberoftetrahedronattributes; j++) {
<a name="l02159"></a>02159           stringptr = findnextnumber(stringptr);
<a name="l02160"></a>02160           <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02161"></a>02161             attrib = 0.0;
<a name="l02162"></a>02162           } <span class="keywordflow">else</span> {
<a name="l02163"></a>02163             attrib = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l02164"></a>02164           }
<a name="l02165"></a>02165           tetrahedronattributelist[attribindex++] = attrib;
<a name="l02166"></a>02166         }
<a name="l02167"></a>02167       }
<a name="l02168"></a>02168       fclose(infile);
<a name="l02169"></a>02169     }
<a name="l02170"></a>02170   } <span class="comment">// if (meshdim == 3)</span>
<a name="l02171"></a>02171 
<a name="l02172"></a>02172   <span class="comment">// Read the hullfaces or subfaces from a .face file if it exists.</span>
<a name="l02173"></a>02173   <span class="keywordflow">if</span> (mesh_dim == 3) {
<a name="l02174"></a>02174     infilename = infacefilename;
<a name="l02175"></a>02175   } <span class="keywordflow">else</span> {
<a name="l02176"></a>02176     infilename = inelefilename;
<a name="l02177"></a>02177   }
<a name="l02178"></a>02178   infile = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l02179"></a>02179   <span class="keywordflow">if</span> (infile != (FILE *) NULL) {
<a name="l02180"></a>02180     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l02181"></a>02181     <span class="comment">// Read number of faces, boundary markers.</span>
<a name="l02182"></a>02182     stringptr = readnumberline(inputline, infile, infilename);
<a name="l02183"></a>02183     numberoftrifaces = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02184"></a>02184     stringptr = findnextnumber(stringptr);
<a name="l02185"></a>02185     <span class="keywordflow">if</span> (mesh_dim == 2) {
<a name="l02186"></a>02186       <span class="comment">// Skip a number.</span>
<a name="l02187"></a>02187       stringptr = findnextnumber(stringptr);
<a name="l02188"></a>02188     }
<a name="l02189"></a>02189     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02190"></a>02190       markers = 0;  <span class="comment">// Default there is no marker per face.</span>
<a name="l02191"></a>02191     } <span class="keywordflow">else</span> {
<a name="l02192"></a>02192       markers = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02193"></a>02193     }
<a name="l02194"></a>02194     <span class="keywordflow">if</span> (numberoftrifaces &gt; 0) {
<a name="l02195"></a>02195       trifacelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[numberoftrifaces * 3];
<a name="l02196"></a>02196       <span class="keywordflow">if</span> (trifacelist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l02197"></a>02197         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l02198"></a>02198         terminatetetgen(1);
<a name="l02199"></a>02199       }
<a name="l02200"></a>02200       <span class="keywordflow">if</span> (markers) {
<a name="l02201"></a>02201         trifacemarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[numberoftrifaces * 3];
<a name="l02202"></a>02202         <span class="keywordflow">if</span> (trifacemarkerlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l02203"></a>02203           printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l02204"></a>02204           terminatetetgen(1);
<a name="l02205"></a>02205         }
<a name="l02206"></a>02206       }
<a name="l02207"></a>02207     }
<a name="l02208"></a>02208     <span class="comment">// Read the list of faces.</span>
<a name="l02209"></a>02209     index = 0;
<a name="l02210"></a>02210     <span class="keywordflow">for</span> (i = 0; i &lt; numberoftrifaces; i++) {
<a name="l02211"></a>02211       <span class="comment">// Read face index and the face&#39;s three corners.</span>
<a name="l02212"></a>02212       stringptr = readnumberline(inputline, infile, infilename);
<a name="l02213"></a>02213       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l02214"></a>02214         stringptr = findnextnumber(stringptr);
<a name="l02215"></a>02215         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02216"></a>02216           printf(<span class="stringliteral">&quot;Error:  Face %d is missing vertex %d in %s.\n&quot;</span>,
<a name="l02217"></a>02217                  i + firstnumber, j + 1, infilename);
<a name="l02218"></a>02218           terminatetetgen(1);
<a name="l02219"></a>02219         }
<a name="l02220"></a>02220         corner = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l02221"></a>02221         <span class="keywordflow">if</span> (corner &lt; firstnumber || corner &gt;= numberofpoints + firstnumber) {
<a name="l02222"></a>02222           printf(<span class="stringliteral">&quot;Error:  Face %d has an invalid vertex index.\n&quot;</span>,
<a name="l02223"></a>02223                  i + firstnumber);
<a name="l02224"></a>02224           terminatetetgen(1);
<a name="l02225"></a>02225         }
<a name="l02226"></a>02226         trifacelist[index++] = corner;
<a name="l02227"></a>02227       }
<a name="l02228"></a>02228       <span class="comment">// Read the boundary marker if it exists.</span>
<a name="l02229"></a>02229       <span class="keywordflow">if</span> (markers) {
<a name="l02230"></a>02230         stringptr = findnextnumber(stringptr);
<a name="l02231"></a>02231         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02232"></a>02232           attrib = 0.0;
<a name="l02233"></a>02233         } <span class="keywordflow">else</span> {
<a name="l02234"></a>02234           attrib = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l02235"></a>02235         }
<a name="l02236"></a>02236         trifacemarkerlist[i] = (int) attrib;
<a name="l02237"></a>02237       }
<a name="l02238"></a>02238     }
<a name="l02239"></a>02239     fclose(infile);
<a name="l02240"></a>02240   }
<a name="l02241"></a>02241 
<a name="l02242"></a>02242   <span class="comment">// Read the boundary edges from a .edge file if it exists.</span>
<a name="l02243"></a>02243   infilename = inedgefilename;
<a name="l02244"></a>02244   infile = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l02245"></a>02245   <span class="keywordflow">if</span> (infile != (FILE *) NULL) {
<a name="l02246"></a>02246     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l02247"></a>02247     <span class="comment">// Read number of boundary edges.</span>
<a name="l02248"></a>02248     stringptr = readnumberline(inputline, infile, infilename);
<a name="l02249"></a>02249     numberofedges = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02250"></a>02250     <span class="keywordflow">if</span> (numberofedges &gt; 0) {
<a name="l02251"></a>02251       edgelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[numberofedges * 2];
<a name="l02252"></a>02252       <span class="keywordflow">if</span> (edgelist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l02253"></a>02253         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l02254"></a>02254         terminatetetgen(1);
<a name="l02255"></a>02255       }
<a name="l02256"></a>02256     }
<a name="l02257"></a>02257     <span class="comment">// Read the list of faces.</span>
<a name="l02258"></a>02258     index = 0;
<a name="l02259"></a>02259     <span class="keywordflow">for</span> (i = 0; i &lt; numberofedges; i++) {
<a name="l02260"></a>02260       <span class="comment">// Read face index and the edge&#39;s two endpoints.</span>
<a name="l02261"></a>02261       stringptr = readnumberline(inputline, infile, infilename);
<a name="l02262"></a>02262       <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l02263"></a>02263         stringptr = findnextnumber(stringptr);
<a name="l02264"></a>02264         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02265"></a>02265           printf(<span class="stringliteral">&quot;Error:  Edge %d is missing vertex %d in %s.\n&quot;</span>,
<a name="l02266"></a>02266                  i + firstnumber, j + 1, infilename);
<a name="l02267"></a>02267           terminatetetgen(1);
<a name="l02268"></a>02268         }
<a name="l02269"></a>02269         corner = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l02270"></a>02270         <span class="keywordflow">if</span> (corner &lt; firstnumber || corner &gt;= numberofpoints + firstnumber) {
<a name="l02271"></a>02271           printf(<span class="stringliteral">&quot;Error:  Edge %d has an invalid vertex index.\n&quot;</span>,
<a name="l02272"></a>02272                  i + firstnumber);
<a name="l02273"></a>02273           terminatetetgen(1);
<a name="l02274"></a>02274         }
<a name="l02275"></a>02275         edgelist[index++] = corner;
<a name="l02276"></a>02276       }
<a name="l02277"></a>02277     }
<a name="l02278"></a>02278     fclose(infile);
<a name="l02279"></a>02279   }
<a name="l02280"></a>02280 
<a name="l02281"></a>02281   <span class="comment">// Read the volume constraints from a .vol file if it exists.</span>
<a name="l02282"></a>02282   infilename = involfilename;
<a name="l02283"></a>02283   infile = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l02284"></a>02284   <span class="keywordflow">if</span> (infile != (FILE *) NULL) {
<a name="l02285"></a>02285     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l02286"></a>02286     <span class="comment">// Read number of tetrahedra.</span>
<a name="l02287"></a>02287     stringptr = readnumberline(inputline, infile, infilename);
<a name="l02288"></a>02288     volelements = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02289"></a>02289     <span class="keywordflow">if</span> (volelements != numberoftetrahedra) {
<a name="l02290"></a>02290       printf(<span class="stringliteral">&quot;Warning:  %s and %s disagree on number of tetrahedra.\n&quot;</span>,
<a name="l02291"></a>02291              inelefilename, involfilename);
<a name="l02292"></a>02292       volelements = 0;
<a name="l02293"></a>02293     }
<a name="l02294"></a>02294     <span class="keywordflow">if</span> (volelements &gt; 0) {
<a name="l02295"></a>02295       tetrahedronvolumelist = <span class="keyword">new</span> REAL[volelements];
<a name="l02296"></a>02296       <span class="keywordflow">if</span> (tetrahedronvolumelist == (REAL *) NULL) {
<a name="l02297"></a>02297         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l02298"></a>02298         terminatetetgen(1);
<a name="l02299"></a>02299       }
<a name="l02300"></a>02300     }
<a name="l02301"></a>02301     <span class="comment">// Read the list of volume constraints.</span>
<a name="l02302"></a>02302     <span class="keywordflow">for</span> (i = 0; i &lt; volelements; i++) {
<a name="l02303"></a>02303       stringptr = readnumberline(inputline, infile, infilename);
<a name="l02304"></a>02304       stringptr = findnextnumber(stringptr);
<a name="l02305"></a>02305       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02306"></a>02306         volume = -1.0; <span class="comment">// No constraint on this tetrahedron.</span>
<a name="l02307"></a>02307       } <span class="keywordflow">else</span> {
<a name="l02308"></a>02308         volume = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l02309"></a>02309       }
<a name="l02310"></a>02310       tetrahedronvolumelist[i] = volume;
<a name="l02311"></a>02311     }
<a name="l02312"></a>02312     fclose(infile);
<a name="l02313"></a>02313   }
<a name="l02314"></a>02314 
<a name="l02315"></a>02315   <span class="comment">// Try to load a .mtr file if it exists.</span>
<a name="l02316"></a>02316   load_mtr(filename);
<a name="l02317"></a>02317   <span class="comment">// Try to read a .pbc file if it exists.</span>
<a name="l02318"></a>02318   load_pbc(filename);
<a name="l02319"></a>02319 
<a name="l02320"></a>02320   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02321"></a>02321 }
<a name="l02322"></a>02322 
<a name="l02324"></a>02324 <span class="comment">//                                                                           //</span>
<a name="l02325"></a>02325 <span class="comment">// load_voronoi()    Load a Voronoi diagram from files.                      //</span>
<a name="l02326"></a>02326 <span class="comment">//                                                                           //</span>
<a name="l02327"></a>02327 <span class="comment">// &#39;filename&#39; is the inputfile without suffix.  The Voronoi diagram is read  //</span>
<a name="l02328"></a>02328 <span class="comment">// from files: filename.v.node, filename.v.edge, and filename.v.face.        //</span>
<a name="l02329"></a>02329 <span class="comment">//                                                                           //</span>
<a name="l02331"></a>02331 <span class="comment"></span>
<a name="l02332"></a>02332 <span class="keywordtype">bool</span> tetgenio::load_voronoi(<span class="keywordtype">char</span>* filename)
<a name="l02333"></a>02333 {
<a name="l02334"></a>02334   FILE *infile;
<a name="l02335"></a>02335   <span class="keywordtype">char</span> innodefilename[FILENAMESIZE];
<a name="l02336"></a>02336   <span class="keywordtype">char</span> inedgefilename[FILENAMESIZE];
<a name="l02337"></a>02337   <span class="keywordtype">char</span> inputline[INPUTLINESIZE];
<a name="l02338"></a>02338   <span class="keywordtype">char</span> *stringptr, *infilename;
<a name="l02339"></a>02339   voroedge *vedge;
<a name="l02340"></a>02340   REAL x, y, z;
<a name="l02341"></a>02341   <span class="keywordtype">int</span> firstnode, corner;
<a name="l02342"></a>02342   <span class="keywordtype">int</span> index;
<a name="l02343"></a>02343   <span class="keywordtype">int</span> i, j;
<a name="l02344"></a>02344 
<a name="l02345"></a>02345   <span class="comment">// Assembling the actual file names we want to open.</span>
<a name="l02346"></a>02346   strcpy(innodefilename, filename);
<a name="l02347"></a>02347   strcpy(inedgefilename, filename);
<a name="l02348"></a>02348   strcat(innodefilename, <span class="stringliteral">&quot;.v.node&quot;</span>);
<a name="l02349"></a>02349   strcat(inedgefilename, <span class="stringliteral">&quot;.v.edge&quot;</span>);
<a name="l02350"></a>02350 
<a name="l02351"></a>02351   <span class="comment">// Read the points from a .v.node file.</span>
<a name="l02352"></a>02352   infilename = innodefilename;
<a name="l02353"></a>02353   printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l02354"></a>02354   infile = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l02355"></a>02355   <span class="keywordflow">if</span> (infile == (FILE *) NULL) {
<a name="l02356"></a>02356     printf(<span class="stringliteral">&quot;File I/O Error:  Cannot access file %s.\n&quot;</span>, infilename);
<a name="l02357"></a>02357     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02358"></a>02358   }
<a name="l02359"></a>02359   <span class="comment">// Read the first line of the file.</span>
<a name="l02360"></a>02360   stringptr = readnumberline(inputline, infile, infilename);
<a name="l02361"></a>02361   <span class="comment">// Is this list of points generated from rbox?</span>
<a name="l02362"></a>02362   stringptr = strstr(inputline, <span class="stringliteral">&quot;rbox&quot;</span>);
<a name="l02363"></a>02363   <span class="keywordflow">if</span> (stringptr == NULL) {
<a name="l02364"></a>02364     <span class="comment">// Read number of points, number of dimensions, number of point</span>
<a name="l02365"></a>02365     <span class="comment">//   attributes, and number of boundary markers.</span>
<a name="l02366"></a>02366     stringptr = inputline;
<a name="l02367"></a>02367     numberofvpoints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02368"></a>02368     stringptr = findnextnumber(stringptr);
<a name="l02369"></a>02369     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02370"></a>02370       mesh_dim = 3;  <span class="comment">// Default.</span>
<a name="l02371"></a>02371     } <span class="keywordflow">else</span> {
<a name="l02372"></a>02372       mesh_dim = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02373"></a>02373     }
<a name="l02374"></a>02374     useindex = 1;  <span class="comment">// There is an index column.</span>
<a name="l02375"></a>02375   } <span class="keywordflow">else</span> {
<a name="l02376"></a>02376     <span class="comment">// It is a rbox (qhull) input file.</span>
<a name="l02377"></a>02377     stringptr = inputline;
<a name="l02378"></a>02378     <span class="comment">// Get the dimension.</span>
<a name="l02379"></a>02379     mesh_dim = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02380"></a>02380     <span class="comment">// Get the number of points.</span>
<a name="l02381"></a>02381     stringptr = readnumberline(inputline, infile, infilename);
<a name="l02382"></a>02382     numberofvpoints = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02383"></a>02383     useindex = 0;  <span class="comment">// No index column.</span>
<a name="l02384"></a>02384   }
<a name="l02385"></a>02385   <span class="comment">// Initialize &#39;vpointlist&#39;.</span>
<a name="l02386"></a>02386   vpointlist = <span class="keyword">new</span> REAL[numberofvpoints * 3];
<a name="l02387"></a>02387   <span class="keywordflow">if</span> (vpointlist == (REAL *) NULL) {
<a name="l02388"></a>02388     printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l02389"></a>02389     terminatetetgen(1);
<a name="l02390"></a>02390   }
<a name="l02391"></a>02391   <span class="comment">// Read the point section.</span>
<a name="l02392"></a>02392   index = 0;
<a name="l02393"></a>02393   <span class="keywordflow">for</span> (i = 0; i &lt; numberofvpoints; i++) {
<a name="l02394"></a>02394     stringptr = readnumberline(inputline, infile, infilename);
<a name="l02395"></a>02395     <span class="keywordflow">if</span> (useindex) {
<a name="l02396"></a>02396       <span class="keywordflow">if</span> (i == 0) {
<a name="l02397"></a>02397         firstnode = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02398"></a>02398         <span class="keywordflow">if</span> ((firstnode == 0) || (firstnode == 1)) {
<a name="l02399"></a>02399           firstnumber = firstnode;
<a name="l02400"></a>02400         }
<a name="l02401"></a>02401       }
<a name="l02402"></a>02402       stringptr = findnextnumber(stringptr);
<a name="l02403"></a>02403     } <span class="comment">// if (useindex)</span>
<a name="l02404"></a>02404     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02405"></a>02405       printf(<span class="stringliteral">&quot;Error:  Point %d has no x coordinate.\n&quot;</span>, firstnumber + i);
<a name="l02406"></a>02406       terminatetetgen(1);
<a name="l02407"></a>02407     }
<a name="l02408"></a>02408     x = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l02409"></a>02409     stringptr = findnextnumber(stringptr);
<a name="l02410"></a>02410     <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02411"></a>02411       printf(<span class="stringliteral">&quot;Error:  Point %d has no y coordinate.\n&quot;</span>, firstnumber + i);
<a name="l02412"></a>02412       terminatetetgen(1);
<a name="l02413"></a>02413     }
<a name="l02414"></a>02414     y = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l02415"></a>02415     <span class="keywordflow">if</span> (mesh_dim == 3) {
<a name="l02416"></a>02416       stringptr = findnextnumber(stringptr);
<a name="l02417"></a>02417       <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02418"></a>02418         printf(<span class="stringliteral">&quot;Error:  Point %d has no z coordinate.\n&quot;</span>, firstnumber + i);
<a name="l02419"></a>02419         terminatetetgen(1);
<a name="l02420"></a>02420       }
<a name="l02421"></a>02421       z = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l02422"></a>02422     } <span class="keywordflow">else</span> {
<a name="l02423"></a>02423       z = 0.0; <span class="comment">// mesh_dim == 2;</span>
<a name="l02424"></a>02424     }
<a name="l02425"></a>02425     vpointlist[index++] = x;
<a name="l02426"></a>02426     vpointlist[index++] = y;
<a name="l02427"></a>02427     vpointlist[index++] = z;
<a name="l02428"></a>02428   }
<a name="l02429"></a>02429   fclose(infile);
<a name="l02430"></a>02430 
<a name="l02431"></a>02431   <span class="comment">// Read the Voronoi edges from a .v.edge file if it exists.</span>
<a name="l02432"></a>02432   infilename = inedgefilename;
<a name="l02433"></a>02433   infile = fopen(infilename, <span class="stringliteral">&quot;r&quot;</span>);
<a name="l02434"></a>02434   <span class="keywordflow">if</span> (infile != (FILE *) NULL) {
<a name="l02435"></a>02435     printf(<span class="stringliteral">&quot;Opening %s.\n&quot;</span>, infilename);
<a name="l02436"></a>02436     <span class="comment">// Read number of boundary edges.</span>
<a name="l02437"></a>02437     stringptr = readnumberline(inputline, infile, infilename);
<a name="l02438"></a>02438     numberofvedges = (int) strtol (stringptr, &amp;stringptr, 0);
<a name="l02439"></a>02439     <span class="keywordflow">if</span> (numberofvedges &gt; 0) {
<a name="l02440"></a>02440       vedgelist = <span class="keyword">new</span> voroedge[numberofvedges];
<a name="l02441"></a>02441     }
<a name="l02442"></a>02442     <span class="comment">// Read the list of faces.</span>
<a name="l02443"></a>02443     index = 0;
<a name="l02444"></a>02444     <span class="keywordflow">for</span> (i = 0; i &lt; numberofvedges; i++) {
<a name="l02445"></a>02445       <span class="comment">// Read edge index and the edge&#39;s two endpoints.</span>
<a name="l02446"></a>02446       stringptr = readnumberline(inputline, infile, infilename);
<a name="l02447"></a>02447       vedge = &amp;(vedgelist[i]);
<a name="l02448"></a>02448       <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l02449"></a>02449         stringptr = findnextnumber(stringptr);
<a name="l02450"></a>02450         <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02451"></a>02451           printf(<span class="stringliteral">&quot;Error:  Edge %d is missing vertex %d in %s.\n&quot;</span>,
<a name="l02452"></a>02452                  i + firstnumber, j + 1, infilename);
<a name="l02453"></a>02453           terminatetetgen(1);
<a name="l02454"></a>02454         }
<a name="l02455"></a>02455         corner = (int) strtol(stringptr, &amp;stringptr, 0);
<a name="l02456"></a>02456         j == 0 ? vedge-&gt;v1 = corner : vedge-&gt;v2 = corner;
<a name="l02457"></a>02457       }
<a name="l02458"></a>02458       <span class="keywordflow">if</span> (vedge-&gt;v2 &lt; 0) {
<a name="l02459"></a>02459         <span class="keywordflow">for</span> (j = 0; j &lt; mesh_dim; j++) {
<a name="l02460"></a>02460           stringptr = findnextnumber(stringptr);
<a name="l02461"></a>02461           <span class="keywordflow">if</span> (*stringptr == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l02462"></a>02462             printf(<span class="stringliteral">&quot;Error:  Edge %d is missing normal in %s.\n&quot;</span>,
<a name="l02463"></a>02463                    i + firstnumber, infilename);
<a name="l02464"></a>02464             terminatetetgen(1);
<a name="l02465"></a>02465           }
<a name="l02466"></a>02466           vedge-&gt;vnormal[j] = (REAL) strtod(stringptr, &amp;stringptr);
<a name="l02467"></a>02467         }
<a name="l02468"></a>02468         <span class="keywordflow">if</span> (mesh_dim == 2) {
<a name="l02469"></a>02469           vedge-&gt;vnormal[2] = 0.0;
<a name="l02470"></a>02470         }
<a name="l02471"></a>02471       } <span class="keywordflow">else</span> {
<a name="l02472"></a>02472         vedge-&gt;vnormal[0] = 0.0;
<a name="l02473"></a>02473         vedge-&gt;vnormal[1] = 0.0;
<a name="l02474"></a>02474         vedge-&gt;vnormal[2] = 0.0;
<a name="l02475"></a>02475       }
<a name="l02476"></a>02476     }
<a name="l02477"></a>02477     fclose(infile);
<a name="l02478"></a>02478   }
<a name="l02479"></a>02479 
<a name="l02480"></a>02480   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02481"></a>02481 }
<a name="l02482"></a>02482 
<a name="l02484"></a>02484 <span class="comment">//                                                                           //</span>
<a name="l02485"></a>02485 <span class="comment">// save_nodes()    Save points to a .node file.                              //</span>
<a name="l02486"></a>02486 <span class="comment">//                                                                           //</span>
<a name="l02487"></a>02487 <span class="comment">// &#39;filename&#39; is a string containing the file name without suffix.           //</span>
<a name="l02488"></a>02488 <span class="comment">//                                                                           //</span>
<a name="l02490"></a>02490 <span class="comment"></span>
<a name="l02491"></a>02491 <span class="keywordtype">void</span> tetgenio::save_nodes(<span class="keywordtype">char</span>* filename)
<a name="l02492"></a>02492 {
<a name="l02493"></a>02493   FILE *fout;
<a name="l02494"></a>02494   <span class="keywordtype">char</span> outnodefilename[FILENAMESIZE];
<a name="l02495"></a>02495   <span class="keywordtype">char</span> outmtrfilename[FILENAMESIZE];
<a name="l02496"></a>02496   <span class="keywordtype">int</span> i, j;
<a name="l02497"></a>02497 
<a name="l02498"></a>02498   sprintf(outnodefilename, <span class="stringliteral">&quot;%s.node&quot;</span>, filename);
<a name="l02499"></a>02499   printf(<span class="stringliteral">&quot;Saving nodes to %s\n&quot;</span>, outnodefilename);
<a name="l02500"></a>02500   fout = fopen(outnodefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l02501"></a>02501   fprintf(fout, <span class="stringliteral">&quot;%d  %d  %d  %d\n&quot;</span>, numberofpoints, mesh_dim,
<a name="l02502"></a>02502           numberofpointattributes, pointmarkerlist != NULL ? 1 : 0);
<a name="l02503"></a>02503   <span class="keywordflow">for</span> (i = 0; i &lt; numberofpoints; i++) {
<a name="l02504"></a>02504     <span class="keywordflow">if</span> (mesh_dim == 2) {
<a name="l02505"></a>02505       fprintf(fout, <span class="stringliteral">&quot;%d  %.16g  %.16g&quot;</span>, i + firstnumber, pointlist[i * 2],
<a name="l02506"></a>02506               pointlist[i * 2 + 1]);
<a name="l02507"></a>02507     } <span class="keywordflow">else</span> {
<a name="l02508"></a>02508       fprintf(fout, <span class="stringliteral">&quot;%d  %.16g  %.16g  %.16g&quot;</span>, i + firstnumber,
<a name="l02509"></a>02509               pointlist[i * 3], pointlist[i * 3 + 1], pointlist[i * 3 + 2]);
<a name="l02510"></a>02510     }
<a name="l02511"></a>02511     <span class="keywordflow">for</span> (j = 0; j &lt; numberofpointattributes; j++) {
<a name="l02512"></a>02512       fprintf(fout, <span class="stringliteral">&quot;  %.16g&quot;</span>,
<a name="l02513"></a>02513               pointattributelist[i * numberofpointattributes + j]);
<a name="l02514"></a>02514     }
<a name="l02515"></a>02515     <span class="keywordflow">if</span> (pointmarkerlist != NULL) {
<a name="l02516"></a>02516       fprintf(fout, <span class="stringliteral">&quot;  %d&quot;</span>, pointmarkerlist[i]);
<a name="l02517"></a>02517     }
<a name="l02518"></a>02518     fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02519"></a>02519   }
<a name="l02520"></a>02520   fclose(fout);
<a name="l02521"></a>02521 
<a name="l02522"></a>02522   <span class="comment">// If the point metrics exist, output them to a .mtr file.</span>
<a name="l02523"></a>02523   <span class="keywordflow">if</span> ((numberofpointmtrs &gt; 0) &amp;&amp; (pointmtrlist != (REAL *) NULL)) {
<a name="l02524"></a>02524     sprintf(outmtrfilename, <span class="stringliteral">&quot;%s.mtr&quot;</span>, filename);
<a name="l02525"></a>02525     printf(<span class="stringliteral">&quot;Saving metrics to %s\n&quot;</span>, outmtrfilename);
<a name="l02526"></a>02526     fout = fopen(outmtrfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l02527"></a>02527     fprintf(fout, <span class="stringliteral">&quot;%d  %d\n&quot;</span>, numberofpoints, numberofpointmtrs);
<a name="l02528"></a>02528     <span class="keywordflow">for</span> (i = 0; i &lt; numberofpoints; i++) {
<a name="l02529"></a>02529       <span class="keywordflow">for</span> (j = 0; j &lt; numberofpointmtrs; j++) {
<a name="l02530"></a>02530         fprintf(fout, <span class="stringliteral">&quot;%.16g &quot;</span>, pointmtrlist[i * numberofpointmtrs + j]);
<a name="l02531"></a>02531       }
<a name="l02532"></a>02532       fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02533"></a>02533     }
<a name="l02534"></a>02534     fclose(fout);
<a name="l02535"></a>02535   }
<a name="l02536"></a>02536 }
<a name="l02537"></a>02537 
<a name="l02539"></a>02539 <span class="comment">//                                                                           //</span>
<a name="l02540"></a>02540 <span class="comment">// save_elements()    Save elements to a .ele file.                          //</span>
<a name="l02541"></a>02541 <span class="comment">//                                                                           //</span>
<a name="l02542"></a>02542 <span class="comment">// &#39;filename&#39; is a string containing the file name without suffix.           //</span>
<a name="l02543"></a>02543 <span class="comment">//                                                                           //</span>
<a name="l02545"></a>02545 <span class="comment"></span>
<a name="l02546"></a>02546 <span class="keywordtype">void</span> tetgenio::save_elements(<span class="keywordtype">char</span>* filename)
<a name="l02547"></a>02547 {
<a name="l02548"></a>02548   FILE *fout;
<a name="l02549"></a>02549   <span class="keywordtype">char</span> outelefilename[FILENAMESIZE];
<a name="l02550"></a>02550   <span class="keywordtype">int</span> i, j;
<a name="l02551"></a>02551 
<a name="l02552"></a>02552   sprintf(outelefilename, <span class="stringliteral">&quot;%s.ele&quot;</span>, filename);
<a name="l02553"></a>02553   printf(<span class="stringliteral">&quot;Saving elements to %s\n&quot;</span>, outelefilename);
<a name="l02554"></a>02554   fout = fopen(outelefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l02555"></a>02555   fprintf(fout, <span class="stringliteral">&quot;%d  %d  %d\n&quot;</span>, numberoftetrahedra, numberofcorners,
<a name="l02556"></a>02556           numberoftetrahedronattributes);
<a name="l02557"></a>02557   <span class="keywordflow">for</span> (i = 0; i &lt; numberoftetrahedra; i++) {
<a name="l02558"></a>02558     fprintf(fout, <span class="stringliteral">&quot;%d&quot;</span>, i + firstnumber);
<a name="l02559"></a>02559     <span class="keywordflow">for</span> (j = 0; j &lt; numberofcorners; j++) {
<a name="l02560"></a>02560       fprintf(fout, <span class="stringliteral">&quot;  %5d&quot;</span>, tetrahedronlist[i * numberofcorners + j]);
<a name="l02561"></a>02561     }
<a name="l02562"></a>02562     <span class="keywordflow">for</span> (j = 0; j &lt; numberoftetrahedronattributes; j++) {
<a name="l02563"></a>02563       fprintf(fout, <span class="stringliteral">&quot;  %g&quot;</span>,
<a name="l02564"></a>02564         tetrahedronattributelist[i * numberoftetrahedronattributes + j]);
<a name="l02565"></a>02565     }
<a name="l02566"></a>02566     fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02567"></a>02567   }
<a name="l02568"></a>02568 
<a name="l02569"></a>02569   fclose(fout);
<a name="l02570"></a>02570 }
<a name="l02571"></a>02571 
<a name="l02573"></a>02573 <span class="comment">//                                                                           //</span>
<a name="l02574"></a>02574 <span class="comment">// save_faces()    Save faces to a .face file.                               //</span>
<a name="l02575"></a>02575 <span class="comment">//                                                                           //</span>
<a name="l02576"></a>02576 <span class="comment">// &#39;filename&#39; is a string containing the file name without suffix.           //</span>
<a name="l02577"></a>02577 <span class="comment">//                                                                           //</span>
<a name="l02579"></a>02579 <span class="comment"></span>
<a name="l02580"></a>02580 <span class="keywordtype">void</span> tetgenio::save_faces(<span class="keywordtype">char</span>* filename)
<a name="l02581"></a>02581 {
<a name="l02582"></a>02582   FILE *fout;
<a name="l02583"></a>02583   <span class="keywordtype">char</span> outfacefilename[FILENAMESIZE];
<a name="l02584"></a>02584   <span class="keywordtype">int</span> i;
<a name="l02585"></a>02585 
<a name="l02586"></a>02586   sprintf(outfacefilename, <span class="stringliteral">&quot;%s.face&quot;</span>, filename);
<a name="l02587"></a>02587   printf(<span class="stringliteral">&quot;Saving faces to %s\n&quot;</span>, outfacefilename);
<a name="l02588"></a>02588   fout = fopen(outfacefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l02589"></a>02589   fprintf(fout, <span class="stringliteral">&quot;%d  %d\n&quot;</span>, numberoftrifaces,
<a name="l02590"></a>02590           trifacemarkerlist != NULL ? 1 : 0);
<a name="l02591"></a>02591   <span class="keywordflow">for</span> (i = 0; i &lt; numberoftrifaces; i++) {
<a name="l02592"></a>02592     fprintf(fout, <span class="stringliteral">&quot;%d  %5d  %5d  %5d&quot;</span>, i + firstnumber, trifacelist[i * 3],
<a name="l02593"></a>02593             trifacelist[i * 3 + 1], trifacelist[i * 3 + 2]);
<a name="l02594"></a>02594     <span class="keywordflow">if</span> (trifacemarkerlist != NULL) {
<a name="l02595"></a>02595       fprintf(fout, <span class="stringliteral">&quot;  %d&quot;</span>, trifacemarkerlist[i]);
<a name="l02596"></a>02596     }
<a name="l02597"></a>02597     fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02598"></a>02598   }
<a name="l02599"></a>02599 
<a name="l02600"></a>02600   fclose(fout);
<a name="l02601"></a>02601 }
<a name="l02602"></a>02602 
<a name="l02604"></a>02604 <span class="comment">//                                                                           //</span>
<a name="l02605"></a>02605 <span class="comment">// save_edges()    Save egdes to a .edge file.                               //</span>
<a name="l02606"></a>02606 <span class="comment">//                                                                           //</span>
<a name="l02607"></a>02607 <span class="comment">// &#39;filename&#39; is a string containing the file name without suffix.           //</span>
<a name="l02608"></a>02608 <span class="comment">//                                                                           //</span>
<a name="l02610"></a>02610 <span class="comment"></span>
<a name="l02611"></a>02611 <span class="keywordtype">void</span> tetgenio::save_edges(<span class="keywordtype">char</span>* filename)
<a name="l02612"></a>02612 {
<a name="l02613"></a>02613   FILE *fout;
<a name="l02614"></a>02614   <span class="keywordtype">char</span> outedgefilename[FILENAMESIZE];
<a name="l02615"></a>02615   <span class="keywordtype">int</span> i;
<a name="l02616"></a>02616 
<a name="l02617"></a>02617   sprintf(outedgefilename, <span class="stringliteral">&quot;%s.edge&quot;</span>, filename);
<a name="l02618"></a>02618   printf(<span class="stringliteral">&quot;Saving edges to %s\n&quot;</span>, outedgefilename);
<a name="l02619"></a>02619   fout = fopen(outedgefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l02620"></a>02620   fprintf(fout, <span class="stringliteral">&quot;%d  %d\n&quot;</span>, numberofedges, edgemarkerlist != NULL ? 1 : 0);
<a name="l02621"></a>02621   <span class="keywordflow">for</span> (i = 0; i &lt; numberofedges; i++) {
<a name="l02622"></a>02622     fprintf(fout, <span class="stringliteral">&quot;%d  %4d  %4d&quot;</span>, i + firstnumber, edgelist[i * 2],
<a name="l02623"></a>02623             edgelist[i * 2 + 1]);
<a name="l02624"></a>02624     <span class="keywordflow">if</span> (edgemarkerlist != NULL) {
<a name="l02625"></a>02625       fprintf(fout, <span class="stringliteral">&quot;  %d&quot;</span>, edgemarkerlist[i]);
<a name="l02626"></a>02626     }
<a name="l02627"></a>02627     fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02628"></a>02628   }
<a name="l02629"></a>02629 
<a name="l02630"></a>02630   fclose(fout);
<a name="l02631"></a>02631 }
<a name="l02632"></a>02632 
<a name="l02634"></a>02634 <span class="comment">//                                                                           //</span>
<a name="l02635"></a>02635 <span class="comment">// save_neighbors()    Save egdes to a .neigh file.                          //</span>
<a name="l02636"></a>02636 <span class="comment">//                                                                           //</span>
<a name="l02637"></a>02637 <span class="comment">// &#39;filename&#39; is a string containing the file name without suffix.           //</span>
<a name="l02638"></a>02638 <span class="comment">//                                                                           //</span>
<a name="l02640"></a>02640 <span class="comment"></span>
<a name="l02641"></a>02641 <span class="keywordtype">void</span> tetgenio::save_neighbors(<span class="keywordtype">char</span>* filename)
<a name="l02642"></a>02642 {
<a name="l02643"></a>02643   FILE *fout;
<a name="l02644"></a>02644   <span class="keywordtype">char</span> outneighborfilename[FILENAMESIZE];
<a name="l02645"></a>02645   <span class="keywordtype">int</span> i;
<a name="l02646"></a>02646 
<a name="l02647"></a>02647   sprintf(outneighborfilename, <span class="stringliteral">&quot;%s.neigh&quot;</span>, filename);
<a name="l02648"></a>02648   printf(<span class="stringliteral">&quot;Saving neighbors to %s\n&quot;</span>, outneighborfilename);
<a name="l02649"></a>02649   fout = fopen(outneighborfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l02650"></a>02650   fprintf(fout, <span class="stringliteral">&quot;%d  %d\n&quot;</span>, numberoftetrahedra, mesh_dim + 1);
<a name="l02651"></a>02651   <span class="keywordflow">for</span> (i = 0; i &lt; numberoftetrahedra; i++) {
<a name="l02652"></a>02652     <span class="keywordflow">if</span> (mesh_dim == 2) {
<a name="l02653"></a>02653       fprintf(fout, <span class="stringliteral">&quot;%d  %5d  %5d  %5d&quot;</span>, i + firstnumber,  neighborlist[i * 3],
<a name="l02654"></a>02654               neighborlist[i * 3 + 1], neighborlist[i * 3 + 2]);
<a name="l02655"></a>02655     } <span class="keywordflow">else</span> {
<a name="l02656"></a>02656       fprintf(fout, <span class="stringliteral">&quot;%d  %5d  %5d  %5d  %5d&quot;</span>, i + firstnumber,
<a name="l02657"></a>02657               neighborlist[i * 4], neighborlist[i * 4 + 1],
<a name="l02658"></a>02658               neighborlist[i * 4 + 2], neighborlist[i * 4 + 3]);
<a name="l02659"></a>02659     }
<a name="l02660"></a>02660     fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02661"></a>02661   }
<a name="l02662"></a>02662 
<a name="l02663"></a>02663   fclose(fout);
<a name="l02664"></a>02664 }
<a name="l02665"></a>02665 
<a name="l02667"></a>02667 <span class="comment">//                                                                           //</span>
<a name="l02668"></a>02668 <span class="comment">// save_poly()    Save segments or facets to a .poly file.                   //</span>
<a name="l02669"></a>02669 <span class="comment">//                                                                           //</span>
<a name="l02670"></a>02670 <span class="comment">// &#39;filename&#39; is a string containing the file name without suffix.  It only  //</span>
<a name="l02671"></a>02671 <span class="comment">// save the facets, holes and regions.  The nodes are saved in a .node file  //</span>
<a name="l02672"></a>02672 <span class="comment">// by routine save_nodes().                                                  //</span>
<a name="l02673"></a>02673 <span class="comment">//                                                                           //</span>
<a name="l02675"></a>02675 <span class="comment"></span>
<a name="l02676"></a>02676 <span class="keywordtype">void</span> tetgenio::save_poly(<span class="keywordtype">char</span>* filename)
<a name="l02677"></a>02677 {
<a name="l02678"></a>02678   FILE *fout;
<a name="l02679"></a>02679   facet *f;
<a name="l02680"></a>02680   polygon *p;
<a name="l02681"></a>02681   <span class="keywordtype">char</span> outpolyfilename[FILENAMESIZE];
<a name="l02682"></a>02682   <span class="keywordtype">int</span> i, j, k;
<a name="l02683"></a>02683 
<a name="l02684"></a>02684   sprintf(outpolyfilename, <span class="stringliteral">&quot;%s.poly&quot;</span>, filename);
<a name="l02685"></a>02685   printf(<span class="stringliteral">&quot;Saving poly to %s\n&quot;</span>, outpolyfilename);
<a name="l02686"></a>02686   fout = fopen(outpolyfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l02687"></a>02687 
<a name="l02688"></a>02688   <span class="comment">// The zero indicates that the vertices are in a separate .node file.</span>
<a name="l02689"></a>02689   <span class="comment">//   Followed by number of dimensions, number of vertex attributes,</span>
<a name="l02690"></a>02690   <span class="comment">//   and number of boundary markers (zero or one).</span>
<a name="l02691"></a>02691   fprintf(fout, <span class="stringliteral">&quot;%d  %d  %d  %d\n&quot;</span>, 0, mesh_dim, numberofpointattributes,
<a name="l02692"></a>02692           pointmarkerlist != NULL ? 1 : 0);
<a name="l02693"></a>02693 
<a name="l02694"></a>02694   <span class="comment">// Save segments or facets.</span>
<a name="l02695"></a>02695   <span class="keywordflow">if</span> (mesh_dim == 2) {
<a name="l02696"></a>02696     <span class="comment">// Number of segments, number of boundary markers (zero or one).</span>
<a name="l02697"></a>02697     fprintf(fout, <span class="stringliteral">&quot;%d  %d\n&quot;</span>, numberofedges, edgemarkerlist != NULL ? 1 : 0);
<a name="l02698"></a>02698     <span class="keywordflow">for</span> (i = 0; i &lt; numberofedges; i++) {
<a name="l02699"></a>02699       fprintf(fout, <span class="stringliteral">&quot;%d  %4d  %4d&quot;</span>, i + firstnumber, edgelist[i * 2],
<a name="l02700"></a>02700               edgelist[i * 2 + 1]);
<a name="l02701"></a>02701       <span class="keywordflow">if</span> (edgemarkerlist != NULL) {
<a name="l02702"></a>02702         fprintf(fout, <span class="stringliteral">&quot;  %d&quot;</span>, edgemarkerlist[i]);
<a name="l02703"></a>02703       }
<a name="l02704"></a>02704       fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02705"></a>02705     }
<a name="l02706"></a>02706   } <span class="keywordflow">else</span> {
<a name="l02707"></a>02707     <span class="comment">// Number of facets, number of boundary markers (zero or one).</span>
<a name="l02708"></a>02708     fprintf(fout, <span class="stringliteral">&quot;%d  %d\n&quot;</span>, numberoffacets, facetmarkerlist != NULL ? 1 : 0);
<a name="l02709"></a>02709     <span class="keywordflow">for</span> (i = 0; i &lt; numberoffacets; i++) {
<a name="l02710"></a>02710       f = &amp;(facetlist[i]);
<a name="l02711"></a>02711       fprintf(fout, <span class="stringliteral">&quot;%d  %d  %d  # %d\n&quot;</span>, f-&gt;numberofpolygons,f-&gt;numberofholes,
<a name="l02712"></a>02712             facetmarkerlist != NULL ? facetmarkerlist[i] : 0, i + firstnumber);
<a name="l02713"></a>02713       <span class="comment">// Output polygons of this facet.</span>
<a name="l02714"></a>02714       <span class="keywordflow">for</span> (j = 0; j &lt; f-&gt;numberofpolygons; j++) {
<a name="l02715"></a>02715         p = &amp;(f-&gt;polygonlist[j]);
<a name="l02716"></a>02716         fprintf(fout, <span class="stringliteral">&quot;%d  &quot;</span>, p-&gt;numberofvertices);
<a name="l02717"></a>02717         <span class="keywordflow">for</span> (k = 0; k &lt; p-&gt;numberofvertices; k++) {
<a name="l02718"></a>02718           <span class="keywordflow">if</span> (((k + 1) % 10) == 0) {
<a name="l02719"></a>02719             fprintf(fout, <span class="stringliteral">&quot;\n  &quot;</span>);
<a name="l02720"></a>02720           }
<a name="l02721"></a>02721           fprintf(fout, <span class="stringliteral">&quot;  %d&quot;</span>, p-&gt;vertexlist[k]);
<a name="l02722"></a>02722         }
<a name="l02723"></a>02723         fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02724"></a>02724       }
<a name="l02725"></a>02725       <span class="comment">// Output holes of this facet.</span>
<a name="l02726"></a>02726       <span class="keywordflow">for</span> (j = 0; j &lt; f-&gt;numberofholes; j++) {
<a name="l02727"></a>02727         fprintf(fout, <span class="stringliteral">&quot;%d  %.12g  %.12g  %.12g\n&quot;</span>, j + firstnumber,
<a name="l02728"></a>02728            f-&gt;holelist[j * 3], f-&gt;holelist[j * 3 + 1], f-&gt;holelist[j * 3 + 2]);
<a name="l02729"></a>02729       }
<a name="l02730"></a>02730     }
<a name="l02731"></a>02731   }
<a name="l02732"></a>02732 
<a name="l02733"></a>02733   <span class="comment">// Save holes.</span>
<a name="l02734"></a>02734   fprintf(fout, <span class="stringliteral">&quot;%d\n&quot;</span>, numberofholes);
<a name="l02735"></a>02735   <span class="keywordflow">for</span> (i = 0; i &lt; numberofholes; i++) {
<a name="l02736"></a>02736     <span class="comment">// Output x, y coordinates.</span>
<a name="l02737"></a>02737     fprintf(fout, <span class="stringliteral">&quot;%d  %.12g  %.12g&quot;</span>, i + firstnumber, holelist[i * mesh_dim],
<a name="l02738"></a>02738             holelist[i * mesh_dim + 1]);
<a name="l02739"></a>02739     <span class="keywordflow">if</span> (mesh_dim == 3) {
<a name="l02740"></a>02740       <span class="comment">// Output z coordinate.</span>
<a name="l02741"></a>02741       fprintf(fout, <span class="stringliteral">&quot;  %.12g&quot;</span>, holelist[i * mesh_dim + 2]);
<a name="l02742"></a>02742     }
<a name="l02743"></a>02743     fprintf(fout, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02744"></a>02744   }
<a name="l02745"></a>02745 
<a name="l02746"></a>02746   <span class="comment">// Save regions.</span>
<a name="l02747"></a>02747   fprintf(fout, <span class="stringliteral">&quot;%d\n&quot;</span>, numberofregions);
<a name="l02748"></a>02748   <span class="keywordflow">for</span> (i = 0; i &lt; numberofregions; i++) {
<a name="l02749"></a>02749     <span class="keywordflow">if</span> (mesh_dim == 2) {
<a name="l02750"></a>02750       <span class="comment">// Output the index, x, y coordinates, attribute (region number)</span>
<a name="l02751"></a>02751       <span class="comment">//   and maximum area constraint (maybe -1).</span>
<a name="l02752"></a>02752       fprintf(fout, <span class="stringliteral">&quot;%d  %.12g  %.12g  %.12g  %.12g\n&quot;</span>, i + firstnumber,
<a name="l02753"></a>02753               regionlist[i * 4], regionlist[i * 4 + 1],
<a name="l02754"></a>02754               regionlist[i * 4 + 2], regionlist[i * 4 + 3]);
<a name="l02755"></a>02755     } <span class="keywordflow">else</span> {
<a name="l02756"></a>02756       <span class="comment">// Output the index, x, y, z coordinates, attribute (region number)</span>
<a name="l02757"></a>02757       <span class="comment">//   and maximum volume constraint (maybe -1).</span>
<a name="l02758"></a>02758       fprintf(fout, <span class="stringliteral">&quot;%d  %.12g  %.12g  %.12g  %.12g  %.12g\n&quot;</span>, i + firstnumber,
<a name="l02759"></a>02759               regionlist[i * 5], regionlist[i * 5 + 1],
<a name="l02760"></a>02760               regionlist[i * 5 + 2], regionlist[i * 5 + 3],
<a name="l02761"></a>02761               regionlist[i * 5 + 4]);
<a name="l02762"></a>02762     }
<a name="l02763"></a>02763   }
<a name="l02764"></a>02764 
<a name="l02765"></a>02765   fclose(fout);
<a name="l02766"></a>02766 }
<a name="l02767"></a>02767 
<a name="l02769"></a>02769 <span class="comment">//                                                                           //</span>
<a name="l02770"></a>02770 <span class="comment">// readline()   Read a nonempty line from a file.                            //</span>
<a name="l02771"></a>02771 <span class="comment">//                                                                           //</span>
<a name="l02772"></a>02772 <span class="comment">// A line is considered &quot;nonempty&quot; if it contains something more than white  //</span>
<a name="l02773"></a>02773 <span class="comment">// spaces.  If a line is considered empty, it will be dropped and the next   //</span>
<a name="l02774"></a>02774 <span class="comment">// line will be read, this process ends until reaching the end-of-file or a  //</span>
<a name="l02775"></a>02775 <span class="comment">// non-empty line.  Return NULL if it is the end-of-file, otherwise, return  //</span>
<a name="l02776"></a>02776 <span class="comment">// a pointer to the first non-whitespace character of the line.              //</span>
<a name="l02777"></a>02777 <span class="comment">//                                                                           //</span>
<a name="l02779"></a>02779 <span class="comment"></span>
<a name="l02780"></a>02780 <span class="keywordtype">char</span>* tetgenio::readline(<span class="keywordtype">char</span> *<span class="keywordtype">string</span>, FILE *infile, <span class="keywordtype">int</span> *linenumber)
<a name="l02781"></a>02781 {
<a name="l02782"></a>02782   <span class="keywordtype">char</span> *result;
<a name="l02783"></a>02783 
<a name="l02784"></a>02784   <span class="comment">// Search for a non-empty line.</span>
<a name="l02785"></a>02785   <span class="keywordflow">do</span> {
<a name="l02786"></a>02786     result = fgets(<span class="keywordtype">string</span>, INPUTLINESIZE - 1, infile);
<a name="l02787"></a>02787     <span class="keywordflow">if</span> (linenumber) (*linenumber)++;
<a name="l02788"></a>02788     <span class="keywordflow">if</span> (result == (<span class="keywordtype">char</span> *) NULL) {
<a name="l02789"></a>02789       <span class="keywordflow">return</span> (<span class="keywordtype">char</span> *) NULL;
<a name="l02790"></a>02790     }
<a name="l02791"></a>02791     <span class="comment">// Skip white spaces.</span>
<a name="l02792"></a>02792     <span class="keywordflow">while</span> ((*result == <span class="charliteral">&#39; &#39;</span>) || (*result == <span class="charliteral">&#39;\t&#39;</span>)) result++;
<a name="l02793"></a>02793     <span class="comment">// If it&#39;s end of line, read another line and try again.</span>
<a name="l02794"></a>02794   } <span class="keywordflow">while</span> (*result == <span class="charliteral">&#39;\0&#39;</span>);
<a name="l02795"></a>02795   <span class="keywordflow">return</span> result;
<a name="l02796"></a>02796 }
<a name="l02797"></a>02797 
<a name="l02799"></a>02799 <span class="comment">//                                                                           //</span>
<a name="l02800"></a>02800 <span class="comment">// findnextfield()   Find the next field of a string.                        //</span>
<a name="l02801"></a>02801 <span class="comment">//                                                                           //</span>
<a name="l02802"></a>02802 <span class="comment">// Jumps past the current field by searching for whitespace or a comma, then //</span>
<a name="l02803"></a>02803 <span class="comment">// jumps past the whitespace or the comma to find the next field.            //</span>
<a name="l02804"></a>02804 <span class="comment">//                                                                           //</span>
<a name="l02806"></a>02806 <span class="comment"></span>
<a name="l02807"></a>02807 <span class="keywordtype">char</span>* tetgenio::findnextfield(<span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l02808"></a>02808 {
<a name="l02809"></a>02809   <span class="keywordtype">char</span> *result;
<a name="l02810"></a>02810 
<a name="l02811"></a>02811   result = string;
<a name="l02812"></a>02812   <span class="comment">// Skip the current field.  Stop upon reaching whitespace or a comma.</span>
<a name="l02813"></a>02813   <span class="keywordflow">while</span> ((*result != <span class="charliteral">&#39;\0&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39; &#39;</span>) &amp;&amp;  (*result != <span class="charliteral">&#39;\t&#39;</span>) &amp;&amp;
<a name="l02814"></a>02814          (*result != <span class="charliteral">&#39;,&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;;&#39;</span>)) {
<a name="l02815"></a>02815     result++;
<a name="l02816"></a>02816   }
<a name="l02817"></a>02817   <span class="comment">// Now skip the whitespace or the comma, stop at anything else that looks</span>
<a name="l02818"></a>02818   <span class="comment">//   like a character, or the end of a line.</span>
<a name="l02819"></a>02819   <span class="keywordflow">while</span> ((*result == <span class="charliteral">&#39; &#39;</span>) || (*result == <span class="charliteral">&#39;\t&#39;</span>) || (*result == <span class="charliteral">&#39;,&#39;</span>) ||
<a name="l02820"></a>02820          (*result == <span class="charliteral">&#39;;&#39;</span>)) {
<a name="l02821"></a>02821     result++;
<a name="l02822"></a>02822   }
<a name="l02823"></a>02823   <span class="keywordflow">return</span> result;
<a name="l02824"></a>02824 }
<a name="l02825"></a>02825 
<a name="l02827"></a>02827 <span class="comment">//                                                                           //</span>
<a name="l02828"></a>02828 <span class="comment">// readnumberline()   Read a nonempty number line from a file.               //</span>
<a name="l02829"></a>02829 <span class="comment">//                                                                           //</span>
<a name="l02830"></a>02830 <span class="comment">// A line is considered &quot;nonempty&quot; if it contains something that looks like  //</span>
<a name="l02831"></a>02831 <span class="comment">// a number.  Comments (prefaced by `#&#39;) are ignored.                        //</span>
<a name="l02832"></a>02832 <span class="comment">//                                                                           //</span>
<a name="l02834"></a>02834 <span class="comment"></span>
<a name="l02835"></a>02835 <span class="keywordtype">char</span>* tetgenio::readnumberline(<span class="keywordtype">char</span> *<span class="keywordtype">string</span>, FILE *infile, <span class="keywordtype">char</span> *infilename)
<a name="l02836"></a>02836 {
<a name="l02837"></a>02837   <span class="keywordtype">char</span> *result;
<a name="l02838"></a>02838 
<a name="l02839"></a>02839   <span class="comment">// Search for something that looks like a number.</span>
<a name="l02840"></a>02840   <span class="keywordflow">do</span> {
<a name="l02841"></a>02841     result = fgets(<span class="keywordtype">string</span>, INPUTLINESIZE, infile);
<a name="l02842"></a>02842     <span class="keywordflow">if</span> (result == (<span class="keywordtype">char</span> *) NULL) {
<a name="l02843"></a>02843       <span class="keywordflow">if</span> (infilename != (<span class="keywordtype">char</span> *) NULL) {
<a name="l02844"></a>02844         printf(<span class="stringliteral">&quot;  Error:  Unexpected end of file in %s.\n&quot;</span>, infilename);
<a name="l02845"></a>02845         terminatetetgen(1);
<a name="l02846"></a>02846       }
<a name="l02847"></a>02847       <span class="keywordflow">return</span> result;
<a name="l02848"></a>02848     }
<a name="l02849"></a>02849     <span class="comment">// Skip anything that doesn&#39;t look like a number, a comment,</span>
<a name="l02850"></a>02850     <span class="comment">//   or the end of a line.</span>
<a name="l02851"></a>02851     <span class="keywordflow">while</span> ((*result != <span class="charliteral">&#39;\0&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;#&#39;</span>)
<a name="l02852"></a>02852            &amp;&amp; (*result != <span class="charliteral">&#39;.&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;+&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;-&#39;</span>)
<a name="l02853"></a>02853            &amp;&amp; ((*result &lt; <span class="charliteral">&#39;0&#39;</span>) || (*result &gt; <span class="charliteral">&#39;9&#39;</span>))) {
<a name="l02854"></a>02854       result++;
<a name="l02855"></a>02855     }
<a name="l02856"></a>02856     <span class="comment">// If it&#39;s a comment or end of line, read another line and try again.</span>
<a name="l02857"></a>02857   } <span class="keywordflow">while</span> ((*result == <span class="charliteral">&#39;#&#39;</span>) || (*result == <span class="charliteral">&#39;\0&#39;</span>));
<a name="l02858"></a>02858   <span class="keywordflow">return</span> result;
<a name="l02859"></a>02859 }
<a name="l02860"></a>02860 
<a name="l02862"></a>02862 <span class="comment">//                                                                           //</span>
<a name="l02863"></a>02863 <span class="comment">// findnextnumber()   Find the next field of a number string.                //</span>
<a name="l02864"></a>02864 <span class="comment">//                                                                           //</span>
<a name="l02865"></a>02865 <span class="comment">// Jumps past the current field by searching for whitespace or a comma, then //</span>
<a name="l02866"></a>02866 <span class="comment">// jumps past the whitespace or the comma to find the next field that looks  //</span>
<a name="l02867"></a>02867 <span class="comment">// like a number.                                                            //</span>
<a name="l02868"></a>02868 <span class="comment">//                                                                           //</span>
<a name="l02870"></a>02870 <span class="comment"></span>
<a name="l02871"></a>02871 <span class="keywordtype">char</span>* tetgenio::findnextnumber(<span class="keywordtype">char</span> *<span class="keywordtype">string</span>)
<a name="l02872"></a>02872 {
<a name="l02873"></a>02873   <span class="keywordtype">char</span> *result;
<a name="l02874"></a>02874 
<a name="l02875"></a>02875   result = string;
<a name="l02876"></a>02876   <span class="comment">// Skip the current field.  Stop upon reaching whitespace or a comma.</span>
<a name="l02877"></a>02877   <span class="keywordflow">while</span> ((*result != <span class="charliteral">&#39;\0&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;#&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39; &#39;</span>) &amp;&amp;
<a name="l02878"></a>02878          (*result != <span class="charliteral">&#39;\t&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;,&#39;</span>)) {
<a name="l02879"></a>02879     result++;
<a name="l02880"></a>02880   }
<a name="l02881"></a>02881   <span class="comment">// Now skip the whitespace and anything else that doesn&#39;t look like a</span>
<a name="l02882"></a>02882   <span class="comment">//   number, a comment, or the end of a line.</span>
<a name="l02883"></a>02883   <span class="keywordflow">while</span> ((*result != <span class="charliteral">&#39;\0&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;#&#39;</span>)
<a name="l02884"></a>02884          &amp;&amp; (*result != <span class="charliteral">&#39;.&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;+&#39;</span>) &amp;&amp; (*result != <span class="charliteral">&#39;-&#39;</span>)
<a name="l02885"></a>02885          &amp;&amp; ((*result &lt; <span class="charliteral">&#39;0&#39;</span>) || (*result &gt; <span class="charliteral">&#39;9&#39;</span>))) {
<a name="l02886"></a>02886     result++;
<a name="l02887"></a>02887   }
<a name="l02888"></a>02888   <span class="comment">// Check for a comment (prefixed with `#&#39;).</span>
<a name="l02889"></a>02889   <span class="keywordflow">if</span> (*result == <span class="charliteral">&#39;#&#39;</span>) {
<a name="l02890"></a>02890     *result = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02891"></a>02891   }
<a name="l02892"></a>02892   <span class="keywordflow">return</span> result;
<a name="l02893"></a>02893 }
<a name="l02894"></a>02894 
<a name="l02895"></a>02895 <span class="comment">//</span>
<a name="l02896"></a>02896 <span class="comment">// End of class &#39;tetgenio&#39; implementation</span>
<a name="l02897"></a>02897 <span class="comment">//</span>
<a name="l02898"></a>02898 
<a name="l02899"></a>02899 <span class="keyword">static</span> REAL PI = 3.14159265358979323846264338327950288419716939937510582;
<a name="l02900"></a>02900 
<a name="l02901"></a>02901 <span class="comment">//</span>
<a name="l02902"></a>02902 <span class="comment">// Begin of class &#39;tetgenbehavior&#39; implementation</span>
<a name="l02903"></a>02903 <span class="comment">//</span>
<a name="l02904"></a>02904 
<a name="l02906"></a>02906 <span class="comment">//                                                                           //</span>
<a name="l02907"></a>02907 <span class="comment">// tetgenbehavior()    Initialize veriables of &#39;tetgenbehavior&#39;.             //</span>
<a name="l02908"></a>02908 <span class="comment">//                                                                           //</span>
<a name="l02910"></a>02910 <span class="comment"></span>
<a name="l02911"></a>02911 tetgenbehavior::tetgenbehavior()
<a name="l02912"></a>02912 {
<a name="l02913"></a>02913   <span class="comment">// Initialize command line switches.</span>
<a name="l02914"></a>02914   plc = 0;
<a name="l02915"></a>02915   quality = 0;
<a name="l02916"></a>02916   refine = 0;
<a name="l02917"></a>02917   coarse = 0;
<a name="l02918"></a>02918   metric = 0;
<a name="l02919"></a>02919   minratio = 2.0;
<a name="l02920"></a>02920   goodratio = 0.0;
<a name="l02921"></a>02921   minangle = 20.0;
<a name="l02922"></a>02922   goodangle = 0.0;
<a name="l02923"></a>02923   maxdihedral = 165.0;
<a name="l02924"></a>02924   mindihedral = 5.0;
<a name="l02925"></a>02925   varvolume = 0;
<a name="l02926"></a>02926   fixedvolume = 0;
<a name="l02927"></a>02927   maxvolume = -1.0;
<a name="l02928"></a>02928   regionattrib = 0;
<a name="l02929"></a>02929   insertaddpoints = 0;
<a name="l02930"></a>02930   diagnose = 0;
<a name="l02931"></a>02931   offcenter = 0;
<a name="l02932"></a>02932   conformdel = 0;
<a name="l02933"></a>02933   alpha1 = sqrt(2.0);
<a name="l02934"></a>02934   alpha2 = 1.0;
<a name="l02935"></a>02935   alpha3 = 0.6;
<a name="l02936"></a>02936   zeroindex = 0;
<a name="l02937"></a>02937   facesout = 0;
<a name="l02938"></a>02938   edgesout = 0;
<a name="l02939"></a>02939   neighout = 0;
<a name="l02940"></a>02940   voroout = 0;
<a name="l02941"></a>02941   meditview = 0;
<a name="l02942"></a>02942   gidview = 0;
<a name="l02943"></a>02943   geomview = 0;
<a name="l02944"></a>02944   optlevel = 3;
<a name="l02945"></a>02945   optpasses = 3;
<a name="l02946"></a>02946   order = 1;
<a name="l02947"></a>02947   nojettison = 0;
<a name="l02948"></a>02948   nobound = 0;
<a name="l02949"></a>02949   nonodewritten = 0;
<a name="l02950"></a>02950   noelewritten = 0;
<a name="l02951"></a>02951   nofacewritten = 0;
<a name="l02952"></a>02952   noiterationnum = 0;
<a name="l02953"></a>02953   nobisect = 0;
<a name="l02954"></a>02954   noflip = 0;
<a name="l02955"></a>02955   steiner = -1;
<a name="l02956"></a>02956   fliprepair = 1;
<a name="l02957"></a>02957   nomerge = 0;
<a name="l02958"></a>02958   docheck = 0;
<a name="l02959"></a>02959   quiet = 0;
<a name="l02960"></a>02960   verbose = 0;
<a name="l02961"></a>02961   useshelles = 0;
<a name="l02962"></a>02962   epsilon = 1.0e-8;
<a name="l02963"></a>02963   epsilon2 = 1.0e-5;
<a name="l02964"></a>02964   <span class="keywordtype">object</span> = NONE;
<a name="l02965"></a>02965   <span class="comment">// Initialize strings</span>
<a name="l02966"></a>02966   commandline[0] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02967"></a>02967   infilename[0] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02968"></a>02968   outfilename[0] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02969"></a>02969   addinfilename[0] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02970"></a>02970   bgmeshfilename[0] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l02971"></a>02971 }
<a name="l02972"></a>02972 
<a name="l02974"></a>02974 <span class="comment">//                                                                           //</span>
<a name="l02975"></a>02975 <span class="comment">// versioninfo()    Print the version information of TetGen.                 //</span>
<a name="l02976"></a>02976 <span class="comment">//                                                                           //</span>
<a name="l02978"></a>02978 <span class="comment"></span>
<a name="l02979"></a>02979 <span class="keywordtype">void</span> tetgenbehavior::versioninfo()
<a name="l02980"></a>02980 {
<a name="l02981"></a>02981   printf(<span class="stringliteral">&quot;Version 1.4.2 (April 16, 2007).\n&quot;</span>);
<a name="l02982"></a>02982   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l02983"></a>02983   printf(<span class="stringliteral">&quot;Copyright (C) 2002 - 2007\n&quot;</span>);
<a name="l02984"></a>02984   printf(<span class="stringliteral">&quot;Hang Si\n&quot;</span>);
<a name="l02985"></a>02985   printf(<span class="stringliteral">&quot;Mohrenstr. 39, 10117 Berlin, Germany\n&quot;</span>);
<a name="l02986"></a>02986   printf(<span class="stringliteral">&quot;si@wias-berlin.de\n&quot;</span>);
<a name="l02987"></a>02987 }
<a name="l02988"></a>02988 
<a name="l02990"></a>02990 <span class="comment">//                                                                           //</span>
<a name="l02991"></a>02991 <span class="comment">// syntax()    Print list of command line switches and exit the program.     //</span>
<a name="l02992"></a>02992 <span class="comment">//                                                                           //</span>
<a name="l02994"></a>02994 <span class="comment"></span>
<a name="l02995"></a>02995 <span class="keywordtype">void</span> tetgenbehavior::syntax()
<a name="l02996"></a>02996 {
<a name="l02997"></a>02997   printf(<span class="stringliteral">&quot;  tetgen [-prq_Ra_AiMYS_T_dzo_fenvgGOJBNEFICQVh] input_file\n&quot;</span>);
<a name="l02998"></a>02998   printf(<span class="stringliteral">&quot;    -p  Tetrahedralizes a piecewise linear complex (PLC).\n&quot;</span>);
<a name="l02999"></a>02999   printf(<span class="stringliteral">&quot;    -r  Reconstructs a previously generated mesh.\n&quot;</span>);
<a name="l03000"></a>03000   printf(<span class="stringliteral">&quot;    -q  Quality mesh generation (adding new mesh points to &quot;</span>);
<a name="l03001"></a>03001   printf(<span class="stringliteral">&quot;improve mesh quality).\n&quot;</span>);
<a name="l03002"></a>03002   printf(<span class="stringliteral">&quot;    -R  Mesh coarsening (deleting redundant mesh points).\n&quot;</span>);
<a name="l03003"></a>03003   printf(<span class="stringliteral">&quot;    -a  Applies a maximum tetrahedron volume constraint.\n&quot;</span>);
<a name="l03004"></a>03004   printf(<span class="stringliteral">&quot;    -A  Assigns attributes to identify tetrahedra in different &quot;</span>);
<a name="l03005"></a>03005   printf(<span class="stringliteral">&quot;regions.\n&quot;</span>);
<a name="l03006"></a>03006   printf(<span class="stringliteral">&quot;    -i  Inserts a list of additional points into mesh.\n&quot;</span>);
<a name="l03007"></a>03007   printf(<span class="stringliteral">&quot;    -M  Does not merge coplanar facets.\n&quot;</span>);
<a name="l03008"></a>03008   printf(<span class="stringliteral">&quot;    -Y  Suppresses boundary facets/segments splitting.\n&quot;</span>);
<a name="l03009"></a>03009   printf(<span class="stringliteral">&quot;    -S  Specifies maximum number of added points.\n&quot;</span>);
<a name="l03010"></a>03010   printf(<span class="stringliteral">&quot;    -T  Sets a tolerance for coplanar test (default 1e-8).\n&quot;</span>);
<a name="l03011"></a>03011   printf(<span class="stringliteral">&quot;    -d  Detects self-intersections of facets of the PLC.\n&quot;</span>);
<a name="l03012"></a>03012   printf(<span class="stringliteral">&quot;    -z  Numbers all output items starting from zero.\n&quot;</span>);
<a name="l03013"></a>03013   printf(<span class="stringliteral">&quot;    -o2 Generates second-order subparametric elements.\n&quot;</span>);
<a name="l03014"></a>03014   printf(<span class="stringliteral">&quot;    -f  Outputs all faces to .face file.&quot;</span>);
<a name="l03015"></a>03015   printf(<span class="stringliteral">&quot;file.\n&quot;</span>);
<a name="l03016"></a>03016   printf(<span class="stringliteral">&quot;    -e  Outputs all edges to .edge file.\n&quot;</span>);
<a name="l03017"></a>03017   printf(<span class="stringliteral">&quot;    -n  Outputs tetrahedra neighbors to .neigh file.\n&quot;</span>);
<a name="l03018"></a>03018   printf(<span class="stringliteral">&quot;    -v  Outputs Voronoi diagram to files.\n&quot;</span>);
<a name="l03019"></a>03019   printf(<span class="stringliteral">&quot;    -g  Outputs mesh to .mesh file for viewing by Medit.\n&quot;</span>);
<a name="l03020"></a>03020   printf(<span class="stringliteral">&quot;    -G  Outputs mesh to .msh file for viewing by Gid.\n&quot;</span>);
<a name="l03021"></a>03021   printf(<span class="stringliteral">&quot;    -O  Outputs mesh to .off file for viewing by Geomview.\n&quot;</span>);
<a name="l03022"></a>03022   printf(<span class="stringliteral">&quot;    -J  No jettison of unused vertices from output .node file.\n&quot;</span>);
<a name="l03023"></a>03023   printf(<span class="stringliteral">&quot;    -B  Suppresses output of boundary information.\n&quot;</span>);
<a name="l03024"></a>03024   printf(<span class="stringliteral">&quot;    -N  Suppresses output of .node file.\n&quot;</span>);
<a name="l03025"></a>03025   printf(<span class="stringliteral">&quot;    -E  Suppresses output of .ele file.\n&quot;</span>);
<a name="l03026"></a>03026   printf(<span class="stringliteral">&quot;    -F  Suppresses output of .face file.\n&quot;</span>);
<a name="l03027"></a>03027   printf(<span class="stringliteral">&quot;    -I  Suppresses mesh iteration numbers.\n&quot;</span>);
<a name="l03028"></a>03028   printf(<span class="stringliteral">&quot;    -C  Checks the consistency of the final mesh.\n&quot;</span>);
<a name="l03029"></a>03029   printf(<span class="stringliteral">&quot;    -Q  Quiet:  No terminal output except errors.\n&quot;</span>);
<a name="l03030"></a>03030   printf(<span class="stringliteral">&quot;    -V  Verbose:  Detailed information, more terminal output.\n&quot;</span>);
<a name="l03031"></a>03031   printf(<span class="stringliteral">&quot;    -h  Help:  A brief instruction for using TetGen.\n&quot;</span>);
<a name="l03032"></a>03032 }
<a name="l03033"></a>03033 
<a name="l03035"></a>03035 <span class="comment">//                                                                           //</span>
<a name="l03036"></a>03036 <span class="comment">// usage()    Print a brief instruction for using TetGen.                    //</span>
<a name="l03037"></a>03037 <span class="comment">//                                                                           //</span>
<a name="l03039"></a>03039 <span class="comment"></span>
<a name="l03040"></a>03040 <span class="keywordtype">void</span> tetgenbehavior::usage()
<a name="l03041"></a>03041 {
<a name="l03042"></a>03042   printf(<span class="stringliteral">&quot;TetGen\n&quot;</span>);
<a name="l03043"></a>03043   printf(<span class="stringliteral">&quot;A Quality Tetrahedral Mesh Generator and 3D Delaunay &quot;</span>);
<a name="l03044"></a>03044   printf(<span class="stringliteral">&quot;Triangulator\n&quot;</span>);
<a name="l03045"></a>03045   versioninfo();
<a name="l03046"></a>03046   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03047"></a>03047   printf(<span class="stringliteral">&quot;What Can TetGen Do?\n&quot;</span>);
<a name="l03048"></a>03048   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03049"></a>03049   printf(<span class="stringliteral">&quot;  TetGen generates exact Delaunay tetrahedralizations, exact\n&quot;</span>);
<a name="l03050"></a>03050   printf(<span class="stringliteral">&quot;  constrained Delaunay tetrahedralizations, and quality &quot;</span>);
<a name="l03051"></a>03051   printf(<span class="stringliteral">&quot;tetrahedral\n  meshes. The latter are nicely graded and whose &quot;</span>);
<a name="l03052"></a>03052   printf(<span class="stringliteral">&quot;tetrahedra have\n  radius-edge ratio bounded, thus are suitable &quot;</span>);
<a name="l03053"></a>03053   printf(<span class="stringliteral">&quot;for finite element and\n  finite volume analysis.\n&quot;</span>);
<a name="l03054"></a>03054   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03055"></a>03055   printf(<span class="stringliteral">&quot;Command Line Syntax:\n&quot;</span>);
<a name="l03056"></a>03056   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03057"></a>03057   printf(<span class="stringliteral">&quot;  Below is the command line syntax of TetGen with a list of &quot;</span>);
<a name="l03058"></a>03058   printf(<span class="stringliteral">&quot;short\n&quot;</span>);
<a name="l03059"></a>03059   printf(<span class="stringliteral">&quot;  descriptions. Underscores indicate that numbers may optionally\n&quot;</span>);
<a name="l03060"></a>03060   printf(<span class="stringliteral">&quot;  follow certain switches.  Do not leave any space between a &quot;</span>);
<a name="l03061"></a>03061   printf(<span class="stringliteral">&quot;switch\n&quot;</span>);
<a name="l03062"></a>03062   printf(<span class="stringliteral">&quot;  and its numeric parameter.  \&#39;input_file\&#39; contains input data\n&quot;</span>);
<a name="l03063"></a>03063   printf(<span class="stringliteral">&quot;  depending on the switches you supplied which may be a &quot;</span>);
<a name="l03064"></a>03064   printf(<span class="stringliteral">&quot;  piecewise\n&quot;</span>);
<a name="l03065"></a>03065   printf(<span class="stringliteral">&quot;  linear complex or a list of nodes.  File formats and detailed\n&quot;</span>);
<a name="l03066"></a>03066   printf(<span class="stringliteral">&quot;  description of command line switches are found in user&#39;s &quot;</span>);
<a name="l03067"></a>03067   printf(<span class="stringliteral">&quot;manual.\n&quot;</span>);
<a name="l03068"></a>03068   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03069"></a>03069   syntax();
<a name="l03070"></a>03070   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03071"></a>03071   printf(<span class="stringliteral">&quot;Examples of How to Use TetGen:\n&quot;</span>);
<a name="l03072"></a>03072   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03073"></a>03073   printf(<span class="stringliteral">&quot;  \&#39;tetgen object\&#39; reads vertices from object.node, and writes &quot;</span>);
<a name="l03074"></a>03074   printf(<span class="stringliteral">&quot;their\n  Delaunay tetrahedralization to object.1.node and &quot;</span>);
<a name="l03075"></a>03075   printf(<span class="stringliteral">&quot;object.1.ele.\n&quot;</span>);
<a name="l03076"></a>03076   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03077"></a>03077   printf(<span class="stringliteral">&quot;  \&#39;tetgen -p object\&#39; reads a PLC from object.poly or object.&quot;</span>);
<a name="l03078"></a>03078   printf(<span class="stringliteral">&quot;smesh (and\n  possibly object.node) and writes its constrained &quot;</span>);
<a name="l03079"></a>03079   printf(<span class="stringliteral">&quot;Delaunay\n  tetrahedralization to object.1.node, object.1.ele and &quot;</span>);
<a name="l03080"></a>03080   printf(<span class="stringliteral">&quot;object.1.face.\n&quot;</span>);
<a name="l03081"></a>03081   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03082"></a>03082   printf(<span class="stringliteral">&quot;  \&#39;tetgen -pq1.414a.1 object\&#39; reads a PLC from object.poly or\n&quot;</span>);
<a name="l03083"></a>03083   printf(<span class="stringliteral">&quot;  object.smesh (and possibly object.node), generates a mesh &quot;</span>);
<a name="l03084"></a>03084   printf(<span class="stringliteral">&quot;whose\n  tetrahedra have radius-edge ratio smaller than 1.414 and &quot;</span>);
<a name="l03085"></a>03085   printf(<span class="stringliteral">&quot;have volume\n  of 0.1 or less, and writes the mesh to &quot;</span>);
<a name="l03086"></a>03086   printf(<span class="stringliteral">&quot;object.1.node, object.1.ele\n  and object.1.face.\n&quot;</span>);
<a name="l03087"></a>03087   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l03088"></a>03088   printf(<span class="stringliteral">&quot;Please send bugs/comments to Hang Si &lt;si@wias-berlin.de&gt;\n&quot;</span>);
<a name="l03089"></a>03089 }
<a name="l03090"></a>03090 
<a name="l03092"></a>03092 <span class="comment">//                                                                           //</span>
<a name="l03093"></a>03093 <span class="comment">// parse_commandline()    Read the command line, identify switches, and set  //</span>
<a name="l03094"></a>03094 <span class="comment">//                        up options and file names.                         //</span>
<a name="l03095"></a>03095 <span class="comment">//                                                                           //</span>
<a name="l03096"></a>03096 <span class="comment">// &#39;argc&#39; and &#39;argv&#39; are the same parameters passed to the function main()   //</span>
<a name="l03097"></a>03097 <span class="comment">// of a C/C++ program. They together represent the command line user invoked //</span>
<a name="l03098"></a>03098 <span class="comment">// from an environment in which TetGen is running.                           //</span>
<a name="l03099"></a>03099 <span class="comment">//                                                                           //</span>
<a name="l03100"></a>03100 <span class="comment">// When TetGen is invoked from an environment. &#39;argc&#39; is nonzero, switches   //</span>
<a name="l03101"></a>03101 <span class="comment">// and input filename should be supplied as zero-terminated strings in       //</span>
<a name="l03102"></a>03102 <span class="comment">// argv[0] through argv[argc - 1] and argv[0] shall be the name used to      //</span>
<a name="l03103"></a>03103 <span class="comment">// invoke TetGen, i.e. &quot;tetgen&quot;.  Switches are previously started with a     //</span>
<a name="l03104"></a>03104 <span class="comment">// dash &#39;-&#39; to identify them from the input filename.                        //</span>
<a name="l03105"></a>03105 <span class="comment">//                                                                           //</span>
<a name="l03106"></a>03106 <span class="comment">// When TetGen is called from within another program. &#39;argc&#39; is set to zero. //</span>
<a name="l03107"></a>03107 <span class="comment">// switches are given in one zero-terminated string (no previous dash is     //</span>
<a name="l03108"></a>03108 <span class="comment">// required.), and &#39;argv&#39; is a pointer points to this string.  No input      //</span>
<a name="l03109"></a>03109 <span class="comment">// filename is required (usually the input data has been directly created by //</span>
<a name="l03110"></a>03110 <span class="comment">// user in the &#39;tetgenio&#39; structure).  A default filename &#39;tetgen-tmpfile&#39;   //</span>
<a name="l03111"></a>03111 <span class="comment">// will be created for debugging output purpose.                             //</span>
<a name="l03112"></a>03112 <span class="comment">//                                                                           //</span>
<a name="l03114"></a>03114 <span class="comment"></span>
<a name="l03115"></a>03115 <span class="keywordtype">bool</span> tetgenbehavior::parse_commandline(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
<a name="l03116"></a>03116 {
<a name="l03117"></a>03117   <span class="keywordtype">int</span> startindex;
<a name="l03118"></a>03118   <span class="keywordtype">int</span> increment;
<a name="l03119"></a>03119   <span class="keywordtype">int</span> meshnumber;
<a name="l03120"></a>03120   <span class="keywordtype">int</span> scount;
<a name="l03121"></a>03121   <span class="keywordtype">int</span> i, j, k;
<a name="l03122"></a>03122   <span class="keywordtype">char</span> workstring[1024];
<a name="l03123"></a>03123 
<a name="l03124"></a>03124   <span class="comment">// First determine the input style of the switches.</span>
<a name="l03125"></a>03125   <span class="keywordflow">if</span> (argc == 0) {
<a name="l03126"></a>03126     startindex = 0;                    <span class="comment">// Switches are given without a dash.</span>
<a name="l03127"></a>03127     argc = 1;                    <span class="comment">// For running the following for-loop once.</span>
<a name="l03128"></a>03128     commandline[0] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03129"></a>03129   } <span class="keywordflow">else</span> {
<a name="l03130"></a>03130     startindex = 1;
<a name="l03131"></a>03131     strcpy(commandline, argv[0]);
<a name="l03132"></a>03132     strcat(commandline, <span class="stringliteral">&quot; &quot;</span>);
<a name="l03133"></a>03133   }
<a name="l03134"></a>03134 
<a name="l03135"></a>03135   <span class="comment">// Rcount used to count the number of &#39;-R&#39; be used.</span>
<a name="l03136"></a>03136   scount = 0;
<a name="l03137"></a>03137 
<a name="l03138"></a>03138   <span class="keywordflow">for</span> (i = startindex; i &lt; argc; i++) {
<a name="l03139"></a>03139     <span class="comment">// Remember the command line switches.</span>
<a name="l03140"></a>03140     strcat(commandline, argv[i]);
<a name="l03141"></a>03141     strcat(commandline, <span class="stringliteral">&quot; &quot;</span>);
<a name="l03142"></a>03142     <span class="keywordflow">if</span> (startindex == 1) {
<a name="l03143"></a>03143       <span class="comment">// Is this string a filename?</span>
<a name="l03144"></a>03144       <span class="keywordflow">if</span> (argv[i][0] != <span class="charliteral">&#39;-&#39;</span>) {
<a name="l03145"></a>03145         strncpy(infilename, argv[i], 1024 - 1);
<a name="l03146"></a>03146         infilename[1024 - 1] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03147"></a>03147         <span class="comment">// Go to the next string directly.</span>
<a name="l03148"></a>03148         <span class="keywordflow">continue</span>;
<a name="l03149"></a>03149       }
<a name="l03150"></a>03150     }
<a name="l03151"></a>03151     <span class="comment">// Parse the individual switch from the string.</span>
<a name="l03152"></a>03152     <span class="keywordflow">for</span> (j = startindex; argv[i][j] != <span class="charliteral">&#39;\0&#39;</span>; j++) {
<a name="l03153"></a>03153       <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;p&#39;</span>) {
<a name="l03154"></a>03154         plc = 1;
<a name="l03155"></a>03155       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;r&#39;</span>) {
<a name="l03156"></a>03156         refine = 1;
<a name="l03157"></a>03157       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;R&#39;</span>) {
<a name="l03158"></a>03158         coarse = 1;
<a name="l03159"></a>03159       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;q&#39;</span>) {
<a name="l03160"></a>03160         quality++;
<a name="l03161"></a>03161         <span class="keywordflow">if</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03162"></a>03162             (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>)) {
<a name="l03163"></a>03163           k = 0;
<a name="l03164"></a>03164           <span class="keywordflow">while</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03165"></a>03165                  (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>)) {
<a name="l03166"></a>03166             j++;
<a name="l03167"></a>03167             workstring[k] = argv[i][j];
<a name="l03168"></a>03168             k++;
<a name="l03169"></a>03169           }
<a name="l03170"></a>03170           workstring[k] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03171"></a>03171           <span class="keywordflow">if</span> (quality == 1) {
<a name="l03172"></a>03172             minratio = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03173"></a>03173           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quality == 2) {
<a name="l03174"></a>03174             mindihedral = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03175"></a>03175           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quality == 3) {
<a name="l03176"></a>03176             maxdihedral = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03177"></a>03177           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quality == 4) {
<a name="l03178"></a>03178             alpha2 = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03179"></a>03179           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (quality == 5) {
<a name="l03180"></a>03180             alpha1 = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03181"></a>03181           }
<a name="l03182"></a>03182         }
<a name="l03183"></a>03183       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;m&#39;</span>) {
<a name="l03184"></a>03184         metric++;
<a name="l03185"></a>03185         <span class="keywordflow">if</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03186"></a>03186             (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>)) {
<a name="l03187"></a>03187           k = 0;
<a name="l03188"></a>03188           <span class="keywordflow">while</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03189"></a>03189                  (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>)) {
<a name="l03190"></a>03190             j++;
<a name="l03191"></a>03191             workstring[k] = argv[i][j];
<a name="l03192"></a>03192             k++;
<a name="l03193"></a>03193           }
<a name="l03194"></a>03194           workstring[k] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03195"></a>03195           <span class="keywordflow">if</span> (metric == 1) {
<a name="l03196"></a>03196             alpha1 = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03197"></a>03197           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (metric == 2) {
<a name="l03198"></a>03198             alpha2 = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03199"></a>03199           }
<a name="l03200"></a>03200         }
<a name="l03201"></a>03201       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;a&#39;</span>) {
<a name="l03202"></a>03202         <span class="keywordflow">if</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03203"></a>03203             (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>)) {
<a name="l03204"></a>03204           fixedvolume = 1;
<a name="l03205"></a>03205           k = 0;
<a name="l03206"></a>03206           <span class="keywordflow">while</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03207"></a>03207                  (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>) || (argv[i][j + 1] == <span class="charliteral">&#39;e&#39;</span>) ||
<a name="l03208"></a>03208                  (argv[i][j + 1] == <span class="charliteral">&#39;-&#39;</span>) || (argv[i][j + 1] == <span class="charliteral">&#39;+&#39;</span>)) {
<a name="l03209"></a>03209             j++;
<a name="l03210"></a>03210             workstring[k] = argv[i][j];
<a name="l03211"></a>03211             k++;
<a name="l03212"></a>03212           }
<a name="l03213"></a>03213           workstring[k] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03214"></a>03214           maxvolume = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03215"></a>03215         } <span class="keywordflow">else</span> {
<a name="l03216"></a>03216           varvolume = 1;
<a name="l03217"></a>03217         }
<a name="l03218"></a>03218       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;A&#39;</span>) {
<a name="l03219"></a>03219         regionattrib++;
<a name="l03220"></a>03220       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;i&#39;</span>) {
<a name="l03221"></a>03221         insertaddpoints = 1;
<a name="l03222"></a>03222       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;d&#39;</span>) {
<a name="l03223"></a>03223         diagnose = 1;
<a name="l03224"></a>03224       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;z&#39;</span>) {
<a name="l03225"></a>03225         zeroindex = 1;
<a name="l03226"></a>03226       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;f&#39;</span>) {
<a name="l03227"></a>03227         facesout = 1;
<a name="l03228"></a>03228       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;e&#39;</span>) {
<a name="l03229"></a>03229         edgesout++;
<a name="l03230"></a>03230       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;n&#39;</span>) {
<a name="l03231"></a>03231         neighout++;
<a name="l03232"></a>03232       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;v&#39;</span>) {
<a name="l03233"></a>03233         voroout = 1;
<a name="l03234"></a>03234       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;g&#39;</span>) {
<a name="l03235"></a>03235         meditview = 1;
<a name="l03236"></a>03236       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;G&#39;</span>) {
<a name="l03237"></a>03237         gidview = 1;
<a name="l03238"></a>03238       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;O&#39;</span>) {
<a name="l03239"></a>03239         geomview = 1;
<a name="l03240"></a>03240       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;M&#39;</span>) {
<a name="l03241"></a>03241         nomerge = 1;
<a name="l03242"></a>03242       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;Y&#39;</span>) {
<a name="l03243"></a>03243         nobisect++;
<a name="l03244"></a>03244       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;J&#39;</span>) {
<a name="l03245"></a>03245         nojettison = 1;
<a name="l03246"></a>03246       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;B&#39;</span>) {
<a name="l03247"></a>03247         nobound = 1;
<a name="l03248"></a>03248       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;N&#39;</span>) {
<a name="l03249"></a>03249         nonodewritten = 1;
<a name="l03250"></a>03250       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;E&#39;</span>) {
<a name="l03251"></a>03251         noelewritten = 1;
<a name="l03252"></a>03252       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;F&#39;</span>) {
<a name="l03253"></a>03253         nofacewritten = 1;
<a name="l03254"></a>03254       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;I&#39;</span>) {
<a name="l03255"></a>03255         noiterationnum = 1;
<a name="l03256"></a>03256       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;o&#39;</span>) {
<a name="l03257"></a>03257         <span class="keywordflow">if</span> (argv[i][j + 1] == <span class="charliteral">&#39;2&#39;</span>) {
<a name="l03258"></a>03258           j++;
<a name="l03259"></a>03259           order = 2;
<a name="l03260"></a>03260         }
<a name="l03261"></a>03261       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;S&#39;</span>) {
<a name="l03262"></a>03262         <span class="keywordflow">if</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03263"></a>03263             (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>)) {
<a name="l03264"></a>03264           k = 0;
<a name="l03265"></a>03265           <span class="keywordflow">while</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03266"></a>03266                  (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>) || (argv[i][j + 1] == <span class="charliteral">&#39;e&#39;</span>) ||
<a name="l03267"></a>03267                  (argv[i][j + 1] == <span class="charliteral">&#39;-&#39;</span>) || (argv[i][j + 1] == <span class="charliteral">&#39;+&#39;</span>)) {
<a name="l03268"></a>03268             j++;
<a name="l03269"></a>03269             workstring[k] = argv[i][j];
<a name="l03270"></a>03270             k++;
<a name="l03271"></a>03271           }
<a name="l03272"></a>03272           workstring[k] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03273"></a>03273           steiner = (int) strtol(workstring, (<span class="keywordtype">char</span> **) NULL, 0);
<a name="l03274"></a>03274         }
<a name="l03275"></a>03275       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;s&#39;</span>) {
<a name="l03276"></a>03276         scount++;
<a name="l03277"></a>03277         <span class="keywordflow">if</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03278"></a>03278             (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>)) {
<a name="l03279"></a>03279           k = 0;
<a name="l03280"></a>03280           <span class="keywordflow">while</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03281"></a>03281                  (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>) || (argv[i][j + 1] == <span class="charliteral">&#39;e&#39;</span>) ||
<a name="l03282"></a>03282                  (argv[i][j + 1] == <span class="charliteral">&#39;-&#39;</span>) || (argv[i][j + 1] == <span class="charliteral">&#39;+&#39;</span>)) {
<a name="l03283"></a>03283             j++;
<a name="l03284"></a>03284             workstring[k] = argv[i][j];
<a name="l03285"></a>03285             k++;
<a name="l03286"></a>03286           }
<a name="l03287"></a>03287           workstring[k] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03288"></a>03288           <span class="keywordflow">if</span> (scount == 1) {
<a name="l03289"></a>03289             optlevel = (int) strtol(workstring, (<span class="keywordtype">char</span> **) NULL, 0);
<a name="l03290"></a>03290           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (scount == 2) {
<a name="l03291"></a>03291             optpasses = (int) strtol(workstring, (<span class="keywordtype">char</span> **) NULL, 0);
<a name="l03292"></a>03292           }
<a name="l03293"></a>03293         }
<a name="l03294"></a>03294       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;D&#39;</span>) {
<a name="l03295"></a>03295         conformdel++;
<a name="l03296"></a>03296       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;T&#39;</span>) {
<a name="l03297"></a>03297         <span class="keywordflow">if</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03298"></a>03298             (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>)) {
<a name="l03299"></a>03299           k = 0;
<a name="l03300"></a>03300           <span class="keywordflow">while</span> (((argv[i][j + 1] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (argv[i][j + 1] &lt;= <span class="charliteral">&#39;9&#39;</span>)) ||
<a name="l03301"></a>03301                  (argv[i][j + 1] == <span class="charliteral">&#39;.&#39;</span>) || (argv[i][j + 1] == <span class="charliteral">&#39;e&#39;</span>) ||
<a name="l03302"></a>03302                  (argv[i][j + 1] == <span class="charliteral">&#39;-&#39;</span>) || (argv[i][j + 1] == <span class="charliteral">&#39;+&#39;</span>)) {
<a name="l03303"></a>03303             j++;
<a name="l03304"></a>03304             workstring[k] = argv[i][j];
<a name="l03305"></a>03305             k++;
<a name="l03306"></a>03306           }
<a name="l03307"></a>03307           workstring[k] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03308"></a>03308           epsilon = (REAL) strtod(workstring, (<span class="keywordtype">char</span> **) NULL);
<a name="l03309"></a>03309         }
<a name="l03310"></a>03310       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;C&#39;</span>) {
<a name="l03311"></a>03311         docheck++;
<a name="l03312"></a>03312       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;X&#39;</span>) {
<a name="l03313"></a>03313         fliprepair = 0;
<a name="l03314"></a>03314       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;Q&#39;</span>) {
<a name="l03315"></a>03315         quiet = 1;
<a name="l03316"></a>03316       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argv[i][j] == <span class="charliteral">&#39;V&#39;</span>) {
<a name="l03317"></a>03317         verbose++;
<a name="l03318"></a>03318       <span class="comment">// } else if (argv[i][j] == &#39;v&#39;) {</span>
<a name="l03319"></a>03319         <span class="comment">// versioninfo();</span>
<a name="l03320"></a>03320         <span class="comment">// terminatetetgen(0);</span>
<a name="l03321"></a>03321       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((argv[i][j] == <span class="charliteral">&#39;h&#39;</span>) || (argv[i][j] == <span class="charliteral">&#39;H&#39;</span>) ||
<a name="l03322"></a>03322                  (argv[i][j] == <span class="charliteral">&#39;?&#39;</span>)) {
<a name="l03323"></a>03323         usage();
<a name="l03324"></a>03324         terminatetetgen(0);
<a name="l03325"></a>03325       } <span class="keywordflow">else</span> {
<a name="l03326"></a>03326         printf(<span class="stringliteral">&quot;Warning:  Unknown switch -%c.\n&quot;</span>, argv[i][j]);
<a name="l03327"></a>03327       }
<a name="l03328"></a>03328     }
<a name="l03329"></a>03329   }
<a name="l03330"></a>03330 
<a name="l03331"></a>03331   <span class="keywordflow">if</span> (startindex == 0) {
<a name="l03332"></a>03332     <span class="comment">// Set a temporary filename for debugging output.</span>
<a name="l03333"></a>03333     strcpy(infilename, <span class="stringliteral">&quot;tetgen-tmpfile&quot;</span>);
<a name="l03334"></a>03334   } <span class="keywordflow">else</span> {
<a name="l03335"></a>03335     <span class="keywordflow">if</span> (infilename[0] == <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l03336"></a>03336       <span class="comment">// No input file name. Print the syntax and exit.</span>
<a name="l03337"></a>03337       syntax();
<a name="l03338"></a>03338       terminatetetgen(0);
<a name="l03339"></a>03339     }
<a name="l03340"></a>03340     <span class="comment">// Recognize the object from file extension if it is available.</span>
<a name="l03341"></a>03341     <span class="keywordflow">if</span> (!strcmp(&amp;infilename[strlen(infilename) - 5], <span class="stringliteral">&quot;.node&quot;</span>)) {
<a name="l03342"></a>03342       infilename[strlen(infilename) - 5] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03343"></a>03343       <span class="keywordtype">object</span> = NODES;
<a name="l03344"></a>03344     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(&amp;infilename[strlen(infilename) - 5], <span class="stringliteral">&quot;.poly&quot;</span>)) {
<a name="l03345"></a>03345       infilename[strlen(infilename) - 5] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03346"></a>03346       <span class="keywordtype">object</span> = POLY;
<a name="l03347"></a>03347       plc = 1;
<a name="l03348"></a>03348     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(&amp;infilename[strlen(infilename) - 6], <span class="stringliteral">&quot;.smesh&quot;</span>)) {
<a name="l03349"></a>03349       infilename[strlen(infilename) - 6] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03350"></a>03350       <span class="keywordtype">object</span> = POLY;
<a name="l03351"></a>03351       plc = 1;
<a name="l03352"></a>03352     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(&amp;infilename[strlen(infilename) - 4], <span class="stringliteral">&quot;.off&quot;</span>)) {
<a name="l03353"></a>03353       infilename[strlen(infilename) - 4] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03354"></a>03354       <span class="keywordtype">object</span> = OFF;
<a name="l03355"></a>03355       plc = 1;
<a name="l03356"></a>03356     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(&amp;infilename[strlen(infilename) - 4], <span class="stringliteral">&quot;.ply&quot;</span>)) {
<a name="l03357"></a>03357       infilename[strlen(infilename) - 4] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03358"></a>03358       <span class="keywordtype">object</span> = PLY;
<a name="l03359"></a>03359       plc = 1;
<a name="l03360"></a>03360     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(&amp;infilename[strlen(infilename) - 4], <span class="stringliteral">&quot;.stl&quot;</span>)) {
<a name="l03361"></a>03361       infilename[strlen(infilename) - 4] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03362"></a>03362       <span class="keywordtype">object</span> = STL;
<a name="l03363"></a>03363       plc = 1;
<a name="l03364"></a>03364     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(&amp;infilename[strlen(infilename) - 5], <span class="stringliteral">&quot;.mesh&quot;</span>)) {
<a name="l03365"></a>03365       infilename[strlen(infilename) - 5] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03366"></a>03366       <span class="keywordtype">object</span> = MEDIT;
<a name="l03367"></a>03367       plc = 1;
<a name="l03368"></a>03368     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(&amp;infilename[strlen(infilename) - 4], <span class="stringliteral">&quot;.ele&quot;</span>)) {
<a name="l03369"></a>03369       infilename[strlen(infilename) - 4] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03370"></a>03370       <span class="keywordtype">object</span> = MESH;
<a name="l03371"></a>03371       refine = 1;
<a name="l03372"></a>03372     }
<a name="l03373"></a>03373   }
<a name="l03374"></a>03374   plc = plc || diagnose;
<a name="l03375"></a>03375   useshelles = plc || refine || coarse || quality;
<a name="l03376"></a>03376   goodratio = minratio;
<a name="l03377"></a>03377   goodratio *= goodratio;
<a name="l03378"></a>03378 
<a name="l03379"></a>03379   <span class="comment">// Detect improper combinations of switches.</span>
<a name="l03380"></a>03380   <span class="keywordflow">if</span> (plc &amp;&amp; refine) {
<a name="l03381"></a>03381     printf(<span class="stringliteral">&quot;Error:  Switch -r cannot use together with -p.\n&quot;</span>);
<a name="l03382"></a>03382     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03383"></a>03383   }
<a name="l03384"></a>03384   <span class="keywordflow">if</span> (refine &amp;&amp; (plc || noiterationnum)) {
<a name="l03385"></a>03385     printf(<span class="stringliteral">&quot;Error:  Switches %s cannot use together with -r.\n&quot;</span>,
<a name="l03386"></a>03386            <span class="stringliteral">&quot;-p, -d, and -I&quot;</span>);
<a name="l03387"></a>03387     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03388"></a>03388   }
<a name="l03389"></a>03389   <span class="keywordflow">if</span> (diagnose &amp;&amp; (quality || insertaddpoints || (order == 2) || neighout
<a name="l03390"></a>03390       || docheck)) {
<a name="l03391"></a>03391     printf(<span class="stringliteral">&quot;Error:  Switches %s cannot use together with -d.\n&quot;</span>,
<a name="l03392"></a>03392            <span class="stringliteral">&quot;-q, -i, -o2, -n, and -C&quot;</span>);
<a name="l03393"></a>03393     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l03394"></a>03394   }
<a name="l03395"></a>03395 
<a name="l03396"></a>03396   <span class="comment">// Be careful not to allocate space for element area constraints that</span>
<a name="l03397"></a>03397   <span class="comment">//   will never be assigned any value (other than the default -1.0).</span>
<a name="l03398"></a>03398   <span class="keywordflow">if</span> (!refine &amp;&amp; !plc) {
<a name="l03399"></a>03399     varvolume = 0;
<a name="l03400"></a>03400   }
<a name="l03401"></a>03401   <span class="comment">// Be careful not to add an extra attribute to each element unless the</span>
<a name="l03402"></a>03402   <span class="comment">//   input supports it (PLC in, but not refining a preexisting mesh).</span>
<a name="l03403"></a>03403   <span class="keywordflow">if</span> (refine || !plc) {
<a name="l03404"></a>03404     regionattrib = 0;
<a name="l03405"></a>03405   }
<a name="l03406"></a>03406   <span class="comment">// If &#39;-a&#39; or &#39;-aa&#39; is in use, enable &#39;-q&#39; option too.</span>
<a name="l03407"></a>03407   <span class="keywordflow">if</span> (fixedvolume || varvolume) {
<a name="l03408"></a>03408     <span class="keywordflow">if</span> (quality == 0) {
<a name="l03409"></a>03409       quality = 1;
<a name="l03410"></a>03410     }
<a name="l03411"></a>03411   }
<a name="l03412"></a>03412   <span class="comment">// Calculate the goodangle for testing bad subfaces.</span>
<a name="l03413"></a>03413   goodangle = cos(minangle * PI / 180.0);
<a name="l03414"></a>03414   goodangle *= goodangle;
<a name="l03415"></a>03415 
<a name="l03416"></a>03416   increment = 0;
<a name="l03417"></a>03417   strcpy(workstring, infilename);
<a name="l03418"></a>03418   j = 1;
<a name="l03419"></a>03419   <span class="keywordflow">while</span> (workstring[j] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l03420"></a>03420     <span class="keywordflow">if</span> ((workstring[j] == <span class="charliteral">&#39;.&#39;</span>) &amp;&amp; (workstring[j + 1] != <span class="charliteral">&#39;\0&#39;</span>)) {
<a name="l03421"></a>03421       increment = j + 1;
<a name="l03422"></a>03422     }
<a name="l03423"></a>03423     j++;
<a name="l03424"></a>03424   }
<a name="l03425"></a>03425   meshnumber = 0;
<a name="l03426"></a>03426   <span class="keywordflow">if</span> (increment &gt; 0) {
<a name="l03427"></a>03427     j = increment;
<a name="l03428"></a>03428     <span class="keywordflow">do</span> {
<a name="l03429"></a>03429       <span class="keywordflow">if</span> ((workstring[j] &gt;= <span class="charliteral">&#39;0&#39;</span>) &amp;&amp; (workstring[j] &lt;= <span class="charliteral">&#39;9&#39;</span>)) {
<a name="l03430"></a>03430         meshnumber = meshnumber * 10 + (int) (workstring[j] - <span class="charliteral">&#39;0&#39;</span>);
<a name="l03431"></a>03431       } <span class="keywordflow">else</span> {
<a name="l03432"></a>03432         increment = 0;
<a name="l03433"></a>03433       }
<a name="l03434"></a>03434       j++;
<a name="l03435"></a>03435     } <span class="keywordflow">while</span> (workstring[j] != <span class="charliteral">&#39;\0&#39;</span>);
<a name="l03436"></a>03436   }
<a name="l03437"></a>03437   <span class="keywordflow">if</span> (noiterationnum) {
<a name="l03438"></a>03438     strcpy(outfilename, infilename);
<a name="l03439"></a>03439   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (increment == 0) {
<a name="l03440"></a>03440     strcpy(outfilename, infilename);
<a name="l03441"></a>03441     strcat(outfilename, <span class="stringliteral">&quot;.1&quot;</span>);
<a name="l03442"></a>03442   } <span class="keywordflow">else</span> {
<a name="l03443"></a>03443     workstring[increment] = <span class="charliteral">&#39;%&#39;</span>;
<a name="l03444"></a>03444     workstring[increment + 1] = <span class="charliteral">&#39;d&#39;</span>;
<a name="l03445"></a>03445     workstring[increment + 2] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l03446"></a>03446     sprintf(outfilename, workstring, meshnumber + 1);
<a name="l03447"></a>03447   }
<a name="l03448"></a>03448   <span class="comment">// Additional input file name has the end &quot;.a&quot;.</span>
<a name="l03449"></a>03449   strcpy(addinfilename, infilename);
<a name="l03450"></a>03450   strcat(addinfilename, <span class="stringliteral">&quot;.a&quot;</span>);
<a name="l03451"></a>03451   <span class="comment">// Background filename has the form &quot;*.b.ele&quot;, &quot;*.b.node&quot;, ...</span>
<a name="l03452"></a>03452   strcpy(bgmeshfilename, infilename);
<a name="l03453"></a>03453   strcat(bgmeshfilename, <span class="stringliteral">&quot;.b&quot;</span>);
<a name="l03454"></a>03454 
<a name="l03455"></a>03455   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l03456"></a>03456 }
<a name="l03457"></a>03457 
<a name="l03458"></a>03458 <span class="comment">//</span>
<a name="l03459"></a>03459 <span class="comment">// End of class &#39;tetgenbehavior&#39; implementation</span>
<a name="l03460"></a>03460 <span class="comment">//</span>
<a name="l03461"></a>03461 
<a name="l03462"></a>03462 <span class="comment">//</span>
<a name="l03463"></a>03463 <span class="comment">// Begin of class &#39;tetgenmesh&#39; implementation</span>
<a name="l03464"></a>03464 <span class="comment">//</span>
<a name="l03465"></a>03465 
<a name="l03466"></a>03466 <span class="comment">//</span>
<a name="l03467"></a>03467 <span class="comment">// Begin of class &#39;list&#39;, &#39;memorypool&#39; and &#39;link&#39; implementation</span>
<a name="l03468"></a>03468 <span class="comment">//</span>
<a name="l03469"></a>03469 
<a name="l03470"></a>03470 <span class="comment">// Following are predefined compare functions for primitive data types.</span>
<a name="l03471"></a>03471 <span class="comment">//   These functions take two pointers of the corresponding date type,</span>
<a name="l03472"></a>03472 <span class="comment">//   perform the comparation. Return -1, 0 or 1 indicating the default</span>
<a name="l03473"></a>03473 <span class="comment">//   linear order of two operators.</span>
<a name="l03474"></a>03474 
<a name="l03475"></a>03475 <span class="comment">// Compare two &#39;integers&#39;.</span>
<a name="l03476"></a>03476 <span class="keywordtype">int</span> tetgenmesh::compare_2_ints(<span class="keyword">const</span> <span class="keywordtype">void</span>* x, <span class="keyword">const</span> <span class="keywordtype">void</span>* y) {
<a name="l03477"></a>03477   <span class="keywordflow">if</span> (* (<span class="keywordtype">int</span> *) x &lt; * (<span class="keywordtype">int</span> *) y) {
<a name="l03478"></a>03478     <span class="keywordflow">return</span> -1;
<a name="l03479"></a>03479   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (* (<span class="keywordtype">int</span> *) x &gt; * (<span class="keywordtype">int</span> *) y) {
<a name="l03480"></a>03480     <span class="keywordflow">return</span> 1;
<a name="l03481"></a>03481   } <span class="keywordflow">else</span> {
<a name="l03482"></a>03482     <span class="keywordflow">return</span> 0;
<a name="l03483"></a>03483   }
<a name="l03484"></a>03484 }
<a name="l03485"></a>03485 
<a name="l03486"></a>03486 <span class="comment">// Compare two &#39;longs&#39;.  Note: in 64-bit machine the &#39;long&#39; type is 64-bit</span>
<a name="l03487"></a>03487 <span class="comment">//   (8-byte) where the &#39;int&#39; only 32-bit (4-byte).</span>
<a name="l03488"></a>03488 <span class="keywordtype">int</span> tetgenmesh::compare_2_longs(<span class="keyword">const</span> <span class="keywordtype">void</span>* x, <span class="keyword">const</span> <span class="keywordtype">void</span>* y) {
<a name="l03489"></a>03489   <span class="keywordflow">if</span> (* (<span class="keywordtype">long</span> *) x &lt; * (<span class="keywordtype">long</span> *) y) {
<a name="l03490"></a>03490     <span class="keywordflow">return</span> -1;
<a name="l03491"></a>03491   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (* (<span class="keywordtype">long</span> *) x &gt; * (<span class="keywordtype">long</span> *) y) {
<a name="l03492"></a>03492     <span class="keywordflow">return</span> 1;
<a name="l03493"></a>03493   } <span class="keywordflow">else</span> {
<a name="l03494"></a>03494     <span class="keywordflow">return</span> 0;
<a name="l03495"></a>03495   }
<a name="l03496"></a>03496 }
<a name="l03497"></a>03497 
<a name="l03498"></a>03498 <span class="comment">// Compare two &#39;unsigned longs&#39;.</span>
<a name="l03499"></a>03499 <span class="keywordtype">int</span> tetgenmesh::compare_2_unsignedlongs(<span class="keyword">const</span> <span class="keywordtype">void</span>* x, <span class="keyword">const</span> <span class="keywordtype">void</span>* y) {
<a name="l03500"></a>03500   <span class="keywordflow">if</span> (* (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) x &lt; * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) y) {
<a name="l03501"></a>03501     <span class="keywordflow">return</span> -1;
<a name="l03502"></a>03502   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (* (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) x &gt; * (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> *) y) {
<a name="l03503"></a>03503     <span class="keywordflow">return</span> 1;
<a name="l03504"></a>03504   } <span class="keywordflow">else</span> {
<a name="l03505"></a>03505     <span class="keywordflow">return</span> 0;
<a name="l03506"></a>03506   }
<a name="l03507"></a>03507 }
<a name="l03508"></a>03508 
<a name="l03510"></a>03510 <span class="comment">//                                                                           //</span>
<a name="l03511"></a>03511 <span class="comment">// set_compfunc()    Determine the size of primitive data types and set the  //</span>
<a name="l03512"></a>03512 <span class="comment">//                   corresponding predefined linear order functions.        //</span>
<a name="l03513"></a>03513 <span class="comment">//                                                                           //</span>
<a name="l03514"></a>03514 <span class="comment">// &#39;str&#39; is a zero-end string indicating a primitive data type, like &#39;int&#39;,  //</span>
<a name="l03515"></a>03515 <span class="comment">// &#39;long&#39; or &#39;unsigned long&#39;.  Every string ending with a &#39;*&#39; is though as a //</span>
<a name="l03516"></a>03516 <span class="comment">// type of pointer and the type &#39;unsign long&#39; is used for it.                //</span>
<a name="l03517"></a>03517 <span class="comment">//                                                                           //</span>
<a name="l03518"></a>03518 <span class="comment">// When the type of &#39;str&#39; is determined, the size of this type (in byte) is  //</span>
<a name="l03519"></a>03519 <span class="comment">// returned in &#39;itbytes&#39;, and the pointer of corresponding predefined linear //</span>
<a name="l03520"></a>03520 <span class="comment">// order functions is returned in &#39;pcomp&#39;.                                   //</span>
<a name="l03521"></a>03521 <span class="comment">//                                                                           //</span>
<a name="l03523"></a>03523 <span class="comment"></span>
<a name="l03524"></a>03524 <span class="keywordtype">void</span> tetgenmesh::set_compfunc(<span class="keywordtype">char</span>* str, <span class="keywordtype">int</span>* itbytes, compfunc* pcomp)
<a name="l03525"></a>03525 {
<a name="l03526"></a>03526   <span class="comment">// First figure out whether it is a pointer or not.</span>
<a name="l03527"></a>03527   <span class="keywordflow">if</span> (str[strlen(str) - 1] == <span class="charliteral">&#39;*&#39;</span>) {
<a name="l03528"></a>03528     *itbytes = <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> long);
<a name="l03529"></a>03529     *pcomp = &amp;compare_2_unsignedlongs;
<a name="l03530"></a>03530     <span class="keywordflow">return</span>;
<a name="l03531"></a>03531   }
<a name="l03532"></a>03532   <span class="comment">// Then determine other types.</span>
<a name="l03533"></a>03533   <span class="keywordflow">if</span> (strcmp(str, <span class="stringliteral">&quot;int&quot;</span>) == 0) {
<a name="l03534"></a>03534     *itbytes = <span class="keyword">sizeof</span>(int);
<a name="l03535"></a>03535     *pcomp = &amp;compare_2_ints;
<a name="l03536"></a>03536   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(str, <span class="stringliteral">&quot;long&quot;</span>) == 0) {
<a name="l03537"></a>03537     *itbytes = <span class="keyword">sizeof</span>(long);
<a name="l03538"></a>03538     *pcomp = &amp;compare_2_longs;
<a name="l03539"></a>03539   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(str, <span class="stringliteral">&quot;unsigned long&quot;</span>) == 0) {
<a name="l03540"></a>03540     *itbytes = <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> long);
<a name="l03541"></a>03541     *pcomp = &amp;compare_2_unsignedlongs;
<a name="l03542"></a>03542   } <span class="keywordflow">else</span> {
<a name="l03543"></a>03543     <span class="comment">// It is an unknown type.</span>
<a name="l03544"></a>03544     printf(<span class="stringliteral">&quot;Error in set_compfunc():  unknown type %s.\n&quot;</span>, str);
<a name="l03545"></a>03545     terminatetetgen(1);
<a name="l03546"></a>03546   }
<a name="l03547"></a>03547 }
<a name="l03548"></a>03548 
<a name="l03550"></a>03550 <span class="comment">//                                                                           //</span>
<a name="l03551"></a>03551 <span class="comment">// listinit()    Initialize a list for storing a data type.                  //</span>
<a name="l03552"></a>03552 <span class="comment">//                                                                           //</span>
<a name="l03553"></a>03553 <span class="comment">// Determine the size of each item, set the maximum size allocated at onece, //</span>
<a name="l03554"></a>03554 <span class="comment">// set the expand size in case the list is full, and set the linear order    //</span>
<a name="l03555"></a>03555 <span class="comment">// function if it is provided (default is NULL).                             //</span>
<a name="l03556"></a>03556 <span class="comment">//                                                                           //</span>
<a name="l03558"></a>03558 <span class="comment"></span>
<a name="l03559"></a>03559 <span class="keywordtype">void</span> tetgenmesh::list::
<a name="l03560"></a>03560 listinit(<span class="keywordtype">int</span> itbytes, compfunc pcomp, <span class="keywordtype">int</span> mitems,<span class="keywordtype">int</span> exsize)
<a name="l03561"></a>03561 {
<a name="l03562"></a>03562 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l03563"></a>03563 <span class="preprocessor"></span>  assert(itbytes &gt; 0 &amp;&amp; mitems &gt; 0 &amp;&amp; exsize &gt; 0);
<a name="l03564"></a>03564 <span class="preprocessor">#endif</span>
<a name="l03565"></a>03565 <span class="preprocessor"></span>  itembytes = itbytes;
<a name="l03566"></a>03566   comp = pcomp;
<a name="l03567"></a>03567   maxitems = mitems;
<a name="l03568"></a>03568   expandsize = exsize;
<a name="l03569"></a>03569   base = (<span class="keywordtype">char</span> *) malloc(maxitems * itembytes);
<a name="l03570"></a>03570   <span class="keywordflow">if</span> (base == (<span class="keywordtype">char</span> *) NULL) {
<a name="l03571"></a>03571     printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l03572"></a>03572     terminatetetgen(1);
<a name="l03573"></a>03573   }
<a name="l03574"></a>03574   items = 0;
<a name="l03575"></a>03575 }
<a name="l03576"></a>03576 
<a name="l03578"></a>03578 <span class="comment">//                                                                           //</span>
<a name="l03579"></a>03579 <span class="comment">// append()    Add a new item at the end of the list.                        //</span>
<a name="l03580"></a>03580 <span class="comment">//                                                                           //</span>
<a name="l03581"></a>03581 <span class="comment">// A new space at the end of this list will be allocated for storing the new //</span>
<a name="l03582"></a>03582 <span class="comment">// item. If the memory is not sufficient, reallocation will be performed. If //</span>
<a name="l03583"></a>03583 <span class="comment">// &#39;appitem&#39; is not NULL, the contents of this pointer will be copied to the //</span>
<a name="l03584"></a>03584 <span class="comment">// new allocated space.  Returns the pointer to the new allocated space.     //</span>
<a name="l03585"></a>03585 <span class="comment">//                                                                           //</span>
<a name="l03587"></a>03587 <span class="comment"></span>
<a name="l03588"></a>03588 <span class="keywordtype">void</span>* tetgenmesh::list::append(<span class="keywordtype">void</span> *appitem)
<a name="l03589"></a>03589 {
<a name="l03590"></a>03590   <span class="comment">// Do we have enough space?</span>
<a name="l03591"></a>03591   <span class="keywordflow">if</span> (items == maxitems) {
<a name="l03592"></a>03592     <span class="keywordtype">char</span>* newbase = (<span class="keywordtype">char</span> *) realloc(base, (maxitems + expandsize) *
<a name="l03593"></a>03593                                      itembytes);
<a name="l03594"></a>03594     <span class="keywordflow">if</span> (newbase == (<span class="keywordtype">char</span> *) NULL) {
<a name="l03595"></a>03595       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l03596"></a>03596       terminatetetgen(1);
<a name="l03597"></a>03597     }
<a name="l03598"></a>03598     base = newbase;
<a name="l03599"></a>03599     maxitems += expandsize;
<a name="l03600"></a>03600   }
<a name="l03601"></a>03601   <span class="keywordflow">if</span> (appitem != (<span class="keywordtype">void</span> *) NULL) {
<a name="l03602"></a>03602     memcpy(base + items * itembytes, appitem, itembytes);
<a name="l03603"></a>03603   }
<a name="l03604"></a>03604   items++;
<a name="l03605"></a>03605   <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) (base + (items - 1) * itembytes);
<a name="l03606"></a>03606 }
<a name="l03607"></a>03607 
<a name="l03609"></a>03609 <span class="comment">//                                                                           //</span>
<a name="l03610"></a>03610 <span class="comment">// insert()    Insert an item before &#39;pos&#39; (range from 0 to items - 1).      //</span>
<a name="l03611"></a>03611 <span class="comment">//                                                                           //</span>
<a name="l03612"></a>03612 <span class="comment">// A new space will be inserted at the position &#39;pos&#39;, that is, items lie    //</span>
<a name="l03613"></a>03613 <span class="comment">// after pos (including the item at pos) will be moved one space downwords.  //</span>
<a name="l03614"></a>03614 <span class="comment">// If &#39;insitem&#39; is not NULL, its contents will be copied into the new        //</span>
<a name="l03615"></a>03615 <span class="comment">// inserted space. Return a pointer to the new inserted space.               //</span>
<a name="l03616"></a>03616 <span class="comment">//                                                                           //</span>
<a name="l03618"></a>03618 <span class="comment"></span>
<a name="l03619"></a>03619 <span class="keywordtype">void</span>* tetgenmesh::list::insert(<span class="keywordtype">int</span> pos, <span class="keywordtype">void</span>* insitem)
<a name="l03620"></a>03620 {
<a name="l03621"></a>03621   <span class="keywordflow">if</span> (pos &gt;= items) {
<a name="l03622"></a>03622     <span class="keywordflow">return</span> append(insitem);
<a name="l03623"></a>03623   }
<a name="l03624"></a>03624   <span class="comment">// Do we have enough space.</span>
<a name="l03625"></a>03625   <span class="keywordflow">if</span> (items == maxitems) {
<a name="l03626"></a>03626     <span class="keywordtype">char</span>* newbase = (<span class="keywordtype">char</span> *) realloc(base, (maxitems + expandsize) *
<a name="l03627"></a>03627                                      itembytes);
<a name="l03628"></a>03628     <span class="keywordflow">if</span> (newbase == (<span class="keywordtype">char</span> *) NULL) {
<a name="l03629"></a>03629       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l03630"></a>03630       terminatetetgen(1);
<a name="l03631"></a>03631     }
<a name="l03632"></a>03632     base = newbase;
<a name="l03633"></a>03633     maxitems += expandsize;
<a name="l03634"></a>03634   }
<a name="l03635"></a>03635   <span class="comment">// Do block move.</span>
<a name="l03636"></a>03636   memmove(base + (pos + 1) * itembytes,   <span class="comment">// dest</span>
<a name="l03637"></a>03637           base + pos * itembytes,         <span class="comment">// src</span>
<a name="l03638"></a>03638           (items - pos) * itembytes);     <span class="comment">// size in bytes</span>
<a name="l03639"></a>03639   <span class="comment">// Insert the item.</span>
<a name="l03640"></a>03640   <span class="keywordflow">if</span> (insitem != (<span class="keywordtype">void</span> *) NULL) {
<a name="l03641"></a>03641     memcpy(base + pos * itembytes, insitem, itembytes);
<a name="l03642"></a>03642   }
<a name="l03643"></a>03643   items++;
<a name="l03644"></a>03644   <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) (base + pos * itembytes);
<a name="l03645"></a>03645 }
<a name="l03646"></a>03646 
<a name="l03648"></a>03648 <span class="comment">//                                                                           //</span>
<a name="l03649"></a>03649 <span class="comment">// del()    Delete an item at &#39;pos&#39; (range from 0 to items - 1).             //</span>
<a name="l03650"></a>03650 <span class="comment">//                                                                           //</span>
<a name="l03651"></a>03651 <span class="comment">// The space at &#39;pos&#39; will be overlapped by other item. If &#39;order&#39; is 1, the //</span>
<a name="l03652"></a>03652 <span class="comment">// remaining items of the list have the same order as usual, i.e., items lie //</span>
<a name="l03653"></a>03653 <span class="comment">// after pos will be moved one space upwords. If &#39;order&#39; is 0, the last item //</span>
<a name="l03654"></a>03654 <span class="comment">// of the list will be moved up to pos.                                      //</span>
<a name="l03655"></a>03655 <span class="comment">//                                                                           //</span>
<a name="l03657"></a>03657 <span class="comment"></span>
<a name="l03658"></a>03658 <span class="keywordtype">void</span> tetgenmesh::list::del(<span class="keywordtype">int</span> pos, <span class="keywordtype">int</span> order)
<a name="l03659"></a>03659 {
<a name="l03660"></a>03660   <span class="comment">// If &#39;pos&#39; is the last item of the list, nothing need to do.</span>
<a name="l03661"></a>03661   <span class="keywordflow">if</span> (pos &gt;= 0 &amp;&amp; pos &lt; items - 1) {
<a name="l03662"></a>03662     <span class="keywordflow">if</span> (order == 1) {
<a name="l03663"></a>03663       <span class="comment">// Do block move.</span>
<a name="l03664"></a>03664       memmove(base + pos * itembytes,       <span class="comment">// dest</span>
<a name="l03665"></a>03665               base + (pos + 1) * itembytes, <span class="comment">// src</span>
<a name="l03666"></a>03666               (items - pos - 1) * itembytes);
<a name="l03667"></a>03667     } <span class="keywordflow">else</span> {
<a name="l03668"></a>03668       <span class="comment">// Use the last item to overlap the del item.</span>
<a name="l03669"></a>03669       memcpy(base + pos * itembytes, <span class="comment">// item at pos</span>
<a name="l03670"></a>03670              base + (items - 1) * itembytes, <span class="comment">// item at last</span>
<a name="l03671"></a>03671              itembytes);
<a name="l03672"></a>03672     }
<a name="l03673"></a>03673   }
<a name="l03674"></a>03674   <span class="keywordflow">if</span> (items &gt; 0) {
<a name="l03675"></a>03675     items--;
<a name="l03676"></a>03676   }
<a name="l03677"></a>03677 }
<a name="l03678"></a>03678 
<a name="l03680"></a>03680 <span class="comment">//                                                                           //</span>
<a name="l03681"></a>03681 <span class="comment">// hasitem()    Search in this list to find if &#39;checkitem&#39; exists.           //</span>
<a name="l03682"></a>03682 <span class="comment">//                                                                           //</span>
<a name="l03683"></a>03683 <span class="comment">// This routine assumes that a linear order function has been set.  It loops //</span>
<a name="l03684"></a>03684 <span class="comment">// through the entire list, compares each item to &#39;checkitem&#39;. If it exists, //</span>
<a name="l03685"></a>03685 <span class="comment">// return its position (between 0 to items - 1), otherwise, return -1.       //</span>
<a name="l03686"></a>03686 <span class="comment">//                                                                           //</span>
<a name="l03688"></a>03688 <span class="comment"></span>
<a name="l03689"></a>03689 <span class="keywordtype">int</span> tetgenmesh::list::hasitem(<span class="keywordtype">void</span>* checkitem)
<a name="l03690"></a>03690 {
<a name="l03691"></a>03691   <span class="keywordtype">int</span> i;
<a name="l03692"></a>03692 
<a name="l03693"></a>03693   <span class="keywordflow">for</span> (i = 0; i &lt; items; i++) {
<a name="l03694"></a>03694     <span class="keywordflow">if</span> (comp != (compfunc) NULL) {
<a name="l03695"></a>03695       <span class="keywordflow">if</span> ((* comp)((<span class="keywordtype">void</span> *)(base + i * itembytes), checkitem) == 0) {
<a name="l03696"></a>03696         <span class="keywordflow">return</span> i;
<a name="l03697"></a>03697       }
<a name="l03698"></a>03698     }
<a name="l03699"></a>03699   }
<a name="l03700"></a>03700   <span class="keywordflow">return</span> -1;
<a name="l03701"></a>03701 }
<a name="l03702"></a>03702 
<a name="l03704"></a>03704 <span class="comment">//                                                                           //</span>
<a name="l03705"></a>03705 <span class="comment">// sort()    Sort the items with respect to a linear order function.         //</span>
<a name="l03706"></a>03706 <span class="comment">//                                                                           //</span>
<a name="l03707"></a>03707 <span class="comment">// Uses QuickSort routines (qsort) of the standard C/C++ library (stdlib.h). //</span>
<a name="l03708"></a>03708 <span class="comment">//                                                                           //</span>
<a name="l03710"></a>03710 <span class="comment"></span>
<a name="l03711"></a>03711 <span class="keywordtype">void</span> tetgenmesh::list::sort()
<a name="l03712"></a>03712 {
<a name="l03713"></a>03713   qsort((<span class="keywordtype">void</span> *) base, (<span class="keywordtype">size_t</span>) items, (<span class="keywordtype">size_t</span>) itembytes, comp);
<a name="l03714"></a>03714 }
<a name="l03715"></a>03715 
<a name="l03717"></a>03717 <span class="comment">//                                                                           //</span>
<a name="l03718"></a>03718 <span class="comment">// memorypool()   The constructors of memorypool.                            //</span>
<a name="l03719"></a>03719 <span class="comment">//                                                                           //</span>
<a name="l03721"></a>03721 <span class="comment"></span>
<a name="l03722"></a>03722 tetgenmesh::memorypool::memorypool()
<a name="l03723"></a>03723 {
<a name="l03724"></a>03724   firstblock = nowblock = (<span class="keywordtype">void</span> **) NULL;
<a name="l03725"></a>03725   nextitem = (<span class="keywordtype">void</span> *) NULL;
<a name="l03726"></a>03726   deaditemstack = (<span class="keywordtype">void</span> *) NULL;
<a name="l03727"></a>03727   pathblock = (<span class="keywordtype">void</span> **) NULL;
<a name="l03728"></a>03728   pathitem = (<span class="keywordtype">void</span> *) NULL;
<a name="l03729"></a>03729   itemwordtype = POINTER;
<a name="l03730"></a>03730   alignbytes = 0;
<a name="l03731"></a>03731   itembytes = itemwords = 0;
<a name="l03732"></a>03732   itemsperblock = 0;
<a name="l03733"></a>03733   items = maxitems = 0l;
<a name="l03734"></a>03734   unallocateditems = 0;
<a name="l03735"></a>03735   pathitemsleft = 0;
<a name="l03736"></a>03736 }
<a name="l03737"></a>03737 
<a name="l03738"></a>03738 tetgenmesh::memorypool::
<a name="l03739"></a>03739 memorypool(<span class="keywordtype">int</span> bytecount, <span class="keywordtype">int</span> itemcount, <span class="keyword">enum</span> wordtype wtype, <span class="keywordtype">int</span> alignment)
<a name="l03740"></a>03740 {
<a name="l03741"></a>03741   poolinit(bytecount, itemcount, wtype, alignment);
<a name="l03742"></a>03742 }
<a name="l03743"></a>03743 
<a name="l03745"></a>03745 <span class="comment">//                                                                           //</span>
<a name="l03746"></a>03746 <span class="comment">// ~memorypool()   Free to the operating system all memory taken by a pool.  //</span>
<a name="l03747"></a>03747 <span class="comment">//                                                                           //</span>
<a name="l03749"></a>03749 <span class="comment"></span>
<a name="l03750"></a>03750 tetgenmesh::memorypool::~memorypool()
<a name="l03751"></a>03751 {
<a name="l03752"></a>03752   <span class="keywordflow">while</span> (firstblock != (<span class="keywordtype">void</span> **) NULL) {
<a name="l03753"></a>03753     nowblock = (<span class="keywordtype">void</span> **) *(firstblock);
<a name="l03754"></a>03754     free(firstblock);
<a name="l03755"></a>03755     firstblock = nowblock;
<a name="l03756"></a>03756   }
<a name="l03757"></a>03757 }
<a name="l03758"></a>03758 
<a name="l03760"></a>03760 <span class="comment">//                                                                           //</span>
<a name="l03761"></a>03761 <span class="comment">// poolinit()    Initialize a pool of memory for allocation of items.        //</span>
<a name="l03762"></a>03762 <span class="comment">//                                                                           //</span>
<a name="l03763"></a>03763 <span class="comment">// A `pool&#39; is created whose records have size at least `bytecount&#39;.  Items  //</span>
<a name="l03764"></a>03764 <span class="comment">// will be allocated in `itemcount&#39;-item blocks.  Each item is assumed to be //</span>
<a name="l03765"></a>03765 <span class="comment">// a collection of words, and either pointers or floating-point values are   //</span>
<a name="l03766"></a>03766 <span class="comment">// assumed to be the &quot;primary&quot; word type.  (The &quot;primary&quot; word type is used  //</span>
<a name="l03767"></a>03767 <span class="comment">// to determine alignment of items.)  If `alignment&#39; isn&#39;t zero, all items   //</span>
<a name="l03768"></a>03768 <span class="comment">// will be `alignment&#39;-byte aligned in memory.  `alignment&#39; must be either a //</span>
<a name="l03769"></a>03769 <span class="comment">// multiple or a factor of the primary word size;  powers of two are safe.   //</span>
<a name="l03770"></a>03770 <span class="comment">// `alignment&#39; is normally used to create a few unused bits at the bottom of //</span>
<a name="l03771"></a>03771 <span class="comment">// each item&#39;s pointer, in which information may be stored.                  //</span>
<a name="l03772"></a>03772 <span class="comment">//                                                                           //</span>
<a name="l03774"></a>03774 <span class="comment"></span>
<a name="l03775"></a>03775 <span class="keywordtype">void</span> tetgenmesh::memorypool::
<a name="l03776"></a>03776 poolinit(<span class="keywordtype">int</span> bytecount, <span class="keywordtype">int</span> itemcount, <span class="keyword">enum</span> wordtype wtype, <span class="keywordtype">int</span> alignment)
<a name="l03777"></a>03777 {
<a name="l03778"></a>03778   <span class="keywordtype">int</span> wordsize;
<a name="l03779"></a>03779 
<a name="l03780"></a>03780   <span class="comment">// Initialize values in the pool.</span>
<a name="l03781"></a>03781   itemwordtype = wtype;
<a name="l03782"></a>03782   wordsize = (itemwordtype == POINTER) ? <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *) : <span class="keyword">sizeof</span>(REAL);
<a name="l03783"></a>03783   <span class="comment">// Find the proper alignment, which must be at least as large as:</span>
<a name="l03784"></a>03784   <span class="comment">//   - The parameter `alignment&#39;.</span>
<a name="l03785"></a>03785   <span class="comment">//   - The primary word type, to avoid unaligned accesses.</span>
<a name="l03786"></a>03786   <span class="comment">//   - sizeof(void *), so the stack of dead items can be maintained</span>
<a name="l03787"></a>03787   <span class="comment">//       without unaligned accesses.</span>
<a name="l03788"></a>03788   <span class="keywordflow">if</span> (alignment &gt; wordsize) {
<a name="l03789"></a>03789     alignbytes = alignment;
<a name="l03790"></a>03790   } <span class="keywordflow">else</span> {
<a name="l03791"></a>03791     alignbytes = wordsize;
<a name="l03792"></a>03792   }
<a name="l03793"></a>03793   <span class="keywordflow">if</span> ((<span class="keywordtype">int</span>) <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *) &gt; alignbytes) {
<a name="l03794"></a>03794     alignbytes = (int) <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *);
<a name="l03795"></a>03795   }
<a name="l03796"></a>03796   itemwords = ((bytecount + alignbytes - 1) /  alignbytes)
<a name="l03797"></a>03797             * (alignbytes / wordsize);
<a name="l03798"></a>03798   itembytes = itemwords * wordsize;
<a name="l03799"></a>03799   itemsperblock = itemcount;
<a name="l03800"></a>03800 
<a name="l03801"></a>03801   <span class="comment">// Allocate a block of items.  Space for `itemsperblock&#39; items and one</span>
<a name="l03802"></a>03802   <span class="comment">//   pointer (to point to the next block) are allocated, as well as space</span>
<a name="l03803"></a>03803   <span class="comment">//   to ensure alignment of the items.</span>
<a name="l03804"></a>03804   firstblock = (<span class="keywordtype">void</span> **) malloc(itemsperblock * itembytes + <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *)
<a name="l03805"></a>03805                                 + alignbytes);
<a name="l03806"></a>03806   <span class="keywordflow">if</span> (firstblock == (<span class="keywordtype">void</span> **) NULL) {
<a name="l03807"></a>03807     printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l03808"></a>03808     terminatetetgen(1);
<a name="l03809"></a>03809   }
<a name="l03810"></a>03810   <span class="comment">// Set the next block pointer to NULL.</span>
<a name="l03811"></a>03811   *(firstblock) = (<span class="keywordtype">void</span> *) NULL;
<a name="l03812"></a>03812   restart();
<a name="l03813"></a>03813 }
<a name="l03814"></a>03814 
<a name="l03816"></a>03816 <span class="comment">//                                                                           //</span>
<a name="l03817"></a>03817 <span class="comment">// restart()   Deallocate all items in this pool.                            //</span>
<a name="l03818"></a>03818 <span class="comment">//                                                                           //</span>
<a name="l03819"></a>03819 <span class="comment">// The pool is returned to its starting state, except that no memory is      //</span>
<a name="l03820"></a>03820 <span class="comment">// freed to the operating system.  Rather, the previously allocated blocks   //</span>
<a name="l03821"></a>03821 <span class="comment">// are ready to be reused.                                                   //</span>
<a name="l03822"></a>03822 <span class="comment">//                                                                           //</span>
<a name="l03824"></a>03824 <span class="comment"></span>
<a name="l03825"></a>03825 <span class="keywordtype">void</span> tetgenmesh::memorypool::restart()
<a name="l03826"></a>03826 {
<a name="l03827"></a>03827   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> alignptr;
<a name="l03828"></a>03828 
<a name="l03829"></a>03829   items = 0;
<a name="l03830"></a>03830   maxitems = 0;
<a name="l03831"></a>03831 
<a name="l03832"></a>03832   <span class="comment">// Set the currently active block.</span>
<a name="l03833"></a>03833   nowblock = firstblock;
<a name="l03834"></a>03834   <span class="comment">// Find the first item in the pool.  Increment by the size of (void *).</span>
<a name="l03835"></a>03835   alignptr = (<span class="keywordtype">unsigned</span> long) (nowblock + 1);
<a name="l03836"></a>03836   <span class="comment">// Align the item on an `alignbytes&#39;-byte boundary.</span>
<a name="l03837"></a>03837   nextitem = (<span class="keywordtype">void</span> *)
<a name="l03838"></a>03838     (alignptr + (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) alignbytes -
<a name="l03839"></a>03839      (alignptr % (<span class="keywordtype">unsigned</span> long) alignbytes));
<a name="l03840"></a>03840   <span class="comment">// There are lots of unallocated items left in this block.</span>
<a name="l03841"></a>03841   unallocateditems = itemsperblock;
<a name="l03842"></a>03842   <span class="comment">// The stack of deallocated items is empty.</span>
<a name="l03843"></a>03843   deaditemstack = (<span class="keywordtype">void</span> *) NULL;
<a name="l03844"></a>03844 }
<a name="l03845"></a>03845 
<a name="l03847"></a>03847 <span class="comment">//                                                                           //</span>
<a name="l03848"></a>03848 <span class="comment">// alloc()   Allocate space for an item.                                     //</span>
<a name="l03849"></a>03849 <span class="comment">//                                                                           //</span>
<a name="l03851"></a>03851 <span class="comment"></span>
<a name="l03852"></a>03852 <span class="keywordtype">void</span>* tetgenmesh::memorypool::alloc()
<a name="l03853"></a>03853 {
<a name="l03854"></a>03854   <span class="keywordtype">void</span> *newitem;
<a name="l03855"></a>03855   <span class="keywordtype">void</span> **newblock;
<a name="l03856"></a>03856   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> alignptr;
<a name="l03857"></a>03857 
<a name="l03858"></a>03858   <span class="comment">// First check the linked list of dead items.  If the list is not</span>
<a name="l03859"></a>03859   <span class="comment">//   empty, allocate an item from the list rather than a fresh one.</span>
<a name="l03860"></a>03860   <span class="keywordflow">if</span> (deaditemstack != (<span class="keywordtype">void</span> *) NULL) {
<a name="l03861"></a>03861     newitem = deaditemstack;                     <span class="comment">// Take first item in list.</span>
<a name="l03862"></a>03862     deaditemstack = * (<span class="keywordtype">void</span> **) deaditemstack;
<a name="l03863"></a>03863   } <span class="keywordflow">else</span> {
<a name="l03864"></a>03864     <span class="comment">// Check if there are any free items left in the current block.</span>
<a name="l03865"></a>03865     <span class="keywordflow">if</span> (unallocateditems == 0) {
<a name="l03866"></a>03866       <span class="comment">// Check if another block must be allocated.</span>
<a name="l03867"></a>03867       <span class="keywordflow">if</span> (*nowblock == (<span class="keywordtype">void</span> *) NULL) {
<a name="l03868"></a>03868         <span class="comment">// Allocate a new block of items, pointed to by the previous block.</span>
<a name="l03869"></a>03869         newblock = (<span class="keywordtype">void</span> **) malloc(itemsperblock * itembytes + <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *)
<a name="l03870"></a>03870                                     + alignbytes);
<a name="l03871"></a>03871         <span class="keywordflow">if</span> (newblock == (<span class="keywordtype">void</span> **) NULL) {
<a name="l03872"></a>03872           printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l03873"></a>03873           terminatetetgen(1);
<a name="l03874"></a>03874         }
<a name="l03875"></a>03875         *nowblock = (<span class="keywordtype">void</span> *) newblock;
<a name="l03876"></a>03876         <span class="comment">// The next block pointer is NULL.</span>
<a name="l03877"></a>03877         *newblock = (<span class="keywordtype">void</span> *) NULL;
<a name="l03878"></a>03878       }
<a name="l03879"></a>03879       <span class="comment">// Move to the new block.</span>
<a name="l03880"></a>03880       nowblock = (<span class="keywordtype">void</span> **) *nowblock;
<a name="l03881"></a>03881       <span class="comment">// Find the first item in the block.</span>
<a name="l03882"></a>03882       <span class="comment">//   Increment by the size of (void *).</span>
<a name="l03883"></a>03883       alignptr = (<span class="keywordtype">unsigned</span> long) (nowblock + 1);
<a name="l03884"></a>03884       <span class="comment">// Align the item on an `alignbytes&#39;-byte boundary.</span>
<a name="l03885"></a>03885       nextitem = (<span class="keywordtype">void</span> *)
<a name="l03886"></a>03886         (alignptr + (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) alignbytes -
<a name="l03887"></a>03887          (alignptr % (<span class="keywordtype">unsigned</span> long) alignbytes));
<a name="l03888"></a>03888       <span class="comment">// There are lots of unallocated items left in this block.</span>
<a name="l03889"></a>03889       unallocateditems = itemsperblock;
<a name="l03890"></a>03890     }
<a name="l03891"></a>03891     <span class="comment">// Allocate a new item.</span>
<a name="l03892"></a>03892     newitem = nextitem;
<a name="l03893"></a>03893     <span class="comment">// Advance `nextitem&#39; pointer to next free item in block.</span>
<a name="l03894"></a>03894     <span class="keywordflow">if</span> (itemwordtype == POINTER) {
<a name="l03895"></a>03895       nextitem = (<span class="keywordtype">void</span> *) ((<span class="keywordtype">void</span> **) nextitem + itemwords);
<a name="l03896"></a>03896     } <span class="keywordflow">else</span> {
<a name="l03897"></a>03897       nextitem = (<span class="keywordtype">void</span> *) ((REAL *) nextitem + itemwords);
<a name="l03898"></a>03898     }
<a name="l03899"></a>03899     unallocateditems--;
<a name="l03900"></a>03900     maxitems++;
<a name="l03901"></a>03901   }
<a name="l03902"></a>03902   items++;
<a name="l03903"></a>03903   <span class="keywordflow">return</span> newitem;
<a name="l03904"></a>03904 }
<a name="l03905"></a>03905 
<a name="l03907"></a>03907 <span class="comment">//                                                                           //</span>
<a name="l03908"></a>03908 <span class="comment">// dealloc()   Deallocate space for an item.                                 //</span>
<a name="l03909"></a>03909 <span class="comment">//                                                                           //</span>
<a name="l03910"></a>03910 <span class="comment">// The deallocated space is stored in a queue for later reuse.               //</span>
<a name="l03911"></a>03911 <span class="comment">//                                                                           //</span>
<a name="l03913"></a>03913 <span class="comment"></span>
<a name="l03914"></a>03914 <span class="keywordtype">void</span> tetgenmesh::memorypool::dealloc(<span class="keywordtype">void</span> *dyingitem)
<a name="l03915"></a>03915 {
<a name="l03916"></a>03916   <span class="comment">// Push freshly killed item onto stack.</span>
<a name="l03917"></a>03917   *((<span class="keywordtype">void</span> **) dyingitem) = deaditemstack;
<a name="l03918"></a>03918   deaditemstack = dyingitem;
<a name="l03919"></a>03919   items--;
<a name="l03920"></a>03920 }
<a name="l03921"></a>03921 
<a name="l03923"></a>03923 <span class="comment">//                                                                           //</span>
<a name="l03924"></a>03924 <span class="comment">// traversalinit()   Prepare to traverse the entire list of items.           //</span>
<a name="l03925"></a>03925 <span class="comment">//                                                                           //</span>
<a name="l03926"></a>03926 <span class="comment">// This routine is used in conjunction with traverse().                      //</span>
<a name="l03927"></a>03927 <span class="comment">//                                                                           //</span>
<a name="l03929"></a>03929 <span class="comment"></span>
<a name="l03930"></a>03930 <span class="keywordtype">void</span> tetgenmesh::memorypool::traversalinit()
<a name="l03931"></a>03931 {
<a name="l03932"></a>03932   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> alignptr;
<a name="l03933"></a>03933 
<a name="l03934"></a>03934   <span class="comment">// Begin the traversal in the first block.</span>
<a name="l03935"></a>03935   pathblock = firstblock;
<a name="l03936"></a>03936   <span class="comment">// Find the first item in the block.  Increment by the size of (void *).</span>
<a name="l03937"></a>03937   alignptr = (<span class="keywordtype">unsigned</span> long) (pathblock + 1);
<a name="l03938"></a>03938   <span class="comment">// Align with item on an `alignbytes&#39;-byte boundary.</span>
<a name="l03939"></a>03939   pathitem = (<span class="keywordtype">void</span> *)
<a name="l03940"></a>03940     (alignptr + (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) alignbytes -
<a name="l03941"></a>03941      (alignptr % (<span class="keywordtype">unsigned</span> long) alignbytes));
<a name="l03942"></a>03942   <span class="comment">// Set the number of items left in the current block.</span>
<a name="l03943"></a>03943   pathitemsleft = itemsperblock;
<a name="l03944"></a>03944 }
<a name="l03945"></a>03945 
<a name="l03947"></a>03947 <span class="comment">//                                                                           //</span>
<a name="l03948"></a>03948 <span class="comment">// traverse()   Find the next item in the list.                              //</span>
<a name="l03949"></a>03949 <span class="comment">//                                                                           //</span>
<a name="l03950"></a>03950 <span class="comment">// This routine is used in conjunction with traversalinit().  Be forewarned  //</span>
<a name="l03951"></a>03951 <span class="comment">// that this routine successively returns all items in the list, including   //</span>
<a name="l03952"></a>03952 <span class="comment">// deallocated ones on the deaditemqueue. It&#39;s up to you to figure out which //</span>
<a name="l03953"></a>03953 <span class="comment">// ones are actually dead.  It can usually be done more space-efficiently by //</span>
<a name="l03954"></a>03954 <span class="comment">// a routine that knows something about the structure of the item.           //</span>
<a name="l03955"></a>03955 <span class="comment">//                                                                           //</span>
<a name="l03957"></a>03957 <span class="comment"></span>
<a name="l03958"></a>03958 <span class="keywordtype">void</span>* tetgenmesh::memorypool::traverse()
<a name="l03959"></a>03959 {
<a name="l03960"></a>03960   <span class="keywordtype">void</span> *newitem;
<a name="l03961"></a>03961   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> alignptr;
<a name="l03962"></a>03962 
<a name="l03963"></a>03963   <span class="comment">// Stop upon exhausting the list of items.</span>
<a name="l03964"></a>03964   <span class="keywordflow">if</span> (pathitem == nextitem) {
<a name="l03965"></a>03965     <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) NULL;
<a name="l03966"></a>03966   }
<a name="l03967"></a>03967   <span class="comment">// Check whether any untraversed items remain in the current block.</span>
<a name="l03968"></a>03968   <span class="keywordflow">if</span> (pathitemsleft == 0) {
<a name="l03969"></a>03969     <span class="comment">// Find the next block.</span>
<a name="l03970"></a>03970     pathblock = (<span class="keywordtype">void</span> **) *pathblock;
<a name="l03971"></a>03971     <span class="comment">// Find the first item in the block.  Increment by the size of (void *).</span>
<a name="l03972"></a>03972     alignptr = (<span class="keywordtype">unsigned</span> long) (pathblock + 1);
<a name="l03973"></a>03973     <span class="comment">// Align with item on an `alignbytes&#39;-byte boundary.</span>
<a name="l03974"></a>03974     pathitem = (<span class="keywordtype">void</span> *)
<a name="l03975"></a>03975       (alignptr + (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) alignbytes -
<a name="l03976"></a>03976        (alignptr % (<span class="keywordtype">unsigned</span> long) alignbytes));
<a name="l03977"></a>03977     <span class="comment">// Set the number of items left in the current block.</span>
<a name="l03978"></a>03978     pathitemsleft = itemsperblock;
<a name="l03979"></a>03979   }
<a name="l03980"></a>03980   newitem = pathitem;
<a name="l03981"></a>03981   <span class="comment">// Find the next item in the block.</span>
<a name="l03982"></a>03982   <span class="keywordflow">if</span> (itemwordtype == POINTER) {
<a name="l03983"></a>03983     pathitem = (<span class="keywordtype">void</span> *) ((<span class="keywordtype">void</span> **) pathitem + itemwords);
<a name="l03984"></a>03984   } <span class="keywordflow">else</span> {
<a name="l03985"></a>03985     pathitem = (<span class="keywordtype">void</span> *) ((REAL *) pathitem + itemwords);
<a name="l03986"></a>03986   }
<a name="l03987"></a>03987   pathitemsleft--;
<a name="l03988"></a>03988   <span class="keywordflow">return</span> newitem;
<a name="l03989"></a>03989 }
<a name="l03990"></a>03990 
<a name="l03992"></a>03992 <span class="comment">//                                                                           //</span>
<a name="l03993"></a>03993 <span class="comment">// linkinit()    Initialize a link for storing items.                        //</span>
<a name="l03994"></a>03994 <span class="comment">//                                                                           //</span>
<a name="l03995"></a>03995 <span class="comment">// The input parameters are the size of each item, a pointer of a linear     //</span>
<a name="l03996"></a>03996 <span class="comment">// order function and the number of items allocating in one memory bulk.     //</span>
<a name="l03997"></a>03997 <span class="comment">//                                                                           //</span>
<a name="l03999"></a>03999 <span class="comment"></span>
<a name="l04000"></a>04000 <span class="keywordtype">void</span> tetgenmesh::link::linkinit(<span class="keywordtype">int</span> bytecount, compfunc pcomp, <span class="keywordtype">int</span> itemcount)
<a name="l04001"></a>04001 {
<a name="l04002"></a>04002 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l04003"></a>04003 <span class="preprocessor"></span>  assert(bytecount &gt; 0 &amp;&amp; itemcount &gt; 0);
<a name="l04004"></a>04004 <span class="preprocessor">#endif</span>
<a name="l04005"></a>04005 <span class="preprocessor"></span>  <span class="comment">// Remember the real size of each item.</span>
<a name="l04006"></a>04006   linkitembytes = bytecount;
<a name="l04007"></a>04007   <span class="comment">// Set the linear order function for this link.</span>
<a name="l04008"></a>04008   comp = pcomp;
<a name="l04009"></a>04009 
<a name="l04010"></a>04010   <span class="comment">// Call the constructor of &#39;memorypool&#39; to initialize its variables.</span>
<a name="l04011"></a>04011   <span class="comment">//   like: itembytes, itemwords, items, ... Each node has size</span>
<a name="l04012"></a>04012   <span class="comment">//   bytecount + 2 * sizeof(void **), and total &#39;itemcount + 2&#39; (because</span>
<a name="l04013"></a>04013   <span class="comment">//   link has additional two nodes &#39;head&#39; and &#39;tail&#39;).</span>
<a name="l04014"></a>04014   poolinit(bytecount + 2 * <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> **), itemcount + 2, POINTER, 0);
<a name="l04015"></a>04015 
<a name="l04016"></a>04016   <span class="comment">// Initial state of this link.</span>
<a name="l04017"></a>04017   head = (<span class="keywordtype">void</span> **) alloc();
<a name="l04018"></a>04018   tail = (<span class="keywordtype">void</span> **) alloc();
<a name="l04019"></a>04019   *head = (<span class="keywordtype">void</span> *) tail;
<a name="l04020"></a>04020   *(head + 1) = NULL;
<a name="l04021"></a>04021   *tail = NULL;
<a name="l04022"></a>04022   *(tail + 1) = (<span class="keywordtype">void</span> *) head;
<a name="l04023"></a>04023   nextlinkitem = *head;
<a name="l04024"></a>04024   curpos = 1;
<a name="l04025"></a>04025   linkitems = 0;
<a name="l04026"></a>04026 }
<a name="l04027"></a>04027 
<a name="l04029"></a>04029 <span class="comment">//                                                                           //</span>
<a name="l04030"></a>04030 <span class="comment">// clear()   Deallocate all nodes in this link.                              //</span>
<a name="l04031"></a>04031 <span class="comment">//                                                                           //</span>
<a name="l04032"></a>04032 <span class="comment">// The link is returned to its starting state, except that no memory is      //</span>
<a name="l04033"></a>04033 <span class="comment">// freed to the operating system.  Rather, the previously allocated blocks   //</span>
<a name="l04034"></a>04034 <span class="comment">// are ready to be reused.                                                   //</span>
<a name="l04035"></a>04035 <span class="comment">//                                                                           //</span>
<a name="l04037"></a>04037 <span class="comment"></span>
<a name="l04038"></a>04038 <span class="keywordtype">void</span> tetgenmesh::link::clear()
<a name="l04039"></a>04039 {
<a name="l04040"></a>04040   <span class="comment">// Reset the pool.</span>
<a name="l04041"></a>04041   restart();
<a name="l04042"></a>04042 
<a name="l04043"></a>04043   <span class="comment">// Initial state of this link.</span>
<a name="l04044"></a>04044   head = (<span class="keywordtype">void</span> **) alloc();
<a name="l04045"></a>04045   tail = (<span class="keywordtype">void</span> **) alloc();
<a name="l04046"></a>04046   *head = (<span class="keywordtype">void</span> *) tail;
<a name="l04047"></a>04047   *(head + 1) = NULL;
<a name="l04048"></a>04048   *tail = NULL;
<a name="l04049"></a>04049   *(tail + 1) = (<span class="keywordtype">void</span> *) head;
<a name="l04050"></a>04050   nextlinkitem = *head;
<a name="l04051"></a>04051   curpos = 1;
<a name="l04052"></a>04052   linkitems = 0;
<a name="l04053"></a>04053 }
<a name="l04054"></a>04054 
<a name="l04056"></a>04056 <span class="comment">//                                                                           //</span>
<a name="l04057"></a>04057 <span class="comment">// move()    Causes &#39;nextlinkitem&#39; to traverse the specified number of nodes,//</span>
<a name="l04058"></a>04058 <span class="comment">//           updates &#39;curpos&#39; to be the node to which &#39;nextlinkitem&#39; points. //</span>
<a name="l04059"></a>04059 <span class="comment">//                                                                           //</span>
<a name="l04060"></a>04060 <span class="comment">// &#39;numberofnodes&#39; is a number indicating how many nodes need be traversed   //</span>
<a name="l04061"></a>04061 <span class="comment">// (not counter the current node) need be traversed. It may be positive(move //</span>
<a name="l04062"></a>04062 <span class="comment">// forward) or negative (move backward).  Return TRUE if it is successful.   //</span>
<a name="l04063"></a>04063 <span class="comment">//                                                                           //</span>
<a name="l04065"></a>04065 <span class="comment"></span>
<a name="l04066"></a>04066 <span class="keywordtype">bool</span> tetgenmesh::link::move(<span class="keywordtype">int</span> numberofnodes)
<a name="l04067"></a>04067 {
<a name="l04068"></a>04068   <span class="keywordtype">void</span> **nownode;
<a name="l04069"></a>04069   <span class="keywordtype">int</span> i;
<a name="l04070"></a>04070 
<a name="l04071"></a>04071   nownode = (<span class="keywordtype">void</span> **) nextlinkitem;
<a name="l04072"></a>04072   <span class="keywordflow">if</span> (numberofnodes &gt; 0) {
<a name="l04073"></a>04073     <span class="comment">// Move forward.</span>
<a name="l04074"></a>04074     i = 0;
<a name="l04075"></a>04075     <span class="keywordflow">while</span> ((i &lt; numberofnodes) &amp;&amp; *nownode) {
<a name="l04076"></a>04076       nownode = (<span class="keywordtype">void</span> **) *nownode;
<a name="l04077"></a>04077       i++;
<a name="l04078"></a>04078     }
<a name="l04079"></a>04079     <span class="keywordflow">if</span> (*nownode == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04080"></a>04080     nextlinkitem = (<span class="keywordtype">void</span> *) nownode;
<a name="l04081"></a>04081     curpos += numberofnodes;
<a name="l04082"></a>04082   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numberofnodes &lt; 0) {
<a name="l04083"></a>04083     <span class="comment">// Move backward.</span>
<a name="l04084"></a>04084     i = 0;
<a name="l04085"></a>04085     numberofnodes = -numberofnodes;
<a name="l04086"></a>04086     <span class="keywordflow">while</span> ((i &lt; numberofnodes) &amp;&amp; *(nownode + 1)) {
<a name="l04087"></a>04087       nownode = (<span class="keywordtype">void</span> **) *(nownode + 1);
<a name="l04088"></a>04088       i++;
<a name="l04089"></a>04089     }
<a name="l04090"></a>04090     <span class="keywordflow">if</span> (*(nownode + 1) == NULL) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04091"></a>04091     nextlinkitem = (<span class="keywordtype">void</span> *) nownode;
<a name="l04092"></a>04092     curpos -= numberofnodes;
<a name="l04093"></a>04093   }
<a name="l04094"></a>04094   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l04095"></a>04095 }
<a name="l04096"></a>04096 
<a name="l04098"></a>04098 <span class="comment">//                                                                           //</span>
<a name="l04099"></a>04099 <span class="comment">// locate()    Locates the node at the specified position.                   //</span>
<a name="l04100"></a>04100 <span class="comment">//                                                                           //</span>
<a name="l04101"></a>04101 <span class="comment">// The number &#39;pos&#39; (between 1 and &#39;linkitems&#39;) indicates the location. This //</span>
<a name="l04102"></a>04102 <span class="comment">// routine first decides the shortest path traversing from &#39;curpos&#39; to &#39;pos&#39;,//</span>
<a name="l04103"></a>04103 <span class="comment">// i.e., from head, tail or &#39;curpos&#39;.   Routine &#39;move()&#39; is called to really //</span>
<a name="l04104"></a>04104 <span class="comment">// traverse the link. If success, &#39;nextlinkitem&#39; points to the node, &#39;curpos&#39;//</span>
<a name="l04105"></a>04105 <span class="comment">// and &#39;pos&#39; are equal. Otherwise, return FALSE.                             //</span>
<a name="l04106"></a>04106 <span class="comment">//                                                                           //</span>
<a name="l04108"></a>04108 <span class="comment"></span>
<a name="l04109"></a>04109 <span class="keywordtype">bool</span> tetgenmesh::link::locate(<span class="keywordtype">int</span> pos)
<a name="l04110"></a>04110 {
<a name="l04111"></a>04111   <span class="keywordtype">int</span> headdist, taildist, curdist;
<a name="l04112"></a>04112   <span class="keywordtype">int</span> abscurdist, mindist;
<a name="l04113"></a>04113 
<a name="l04114"></a>04114   <span class="keywordflow">if</span> (pos &lt; 1 || pos &gt; linkitems) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l04115"></a>04115 
<a name="l04116"></a>04116   headdist = pos - 1;
<a name="l04117"></a>04117   taildist = linkitems - pos;
<a name="l04118"></a>04118   curdist = pos - curpos;
<a name="l04119"></a>04119   abscurdist = curdist &gt;= 0 ? curdist : -curdist;
<a name="l04120"></a>04120 
<a name="l04121"></a>04121   <span class="keywordflow">if</span> (headdist &gt; taildist) {
<a name="l04122"></a>04122     <span class="keywordflow">if</span> (taildist &gt; abscurdist) {
<a name="l04123"></a>04123       mindist = curdist;
<a name="l04124"></a>04124     } <span class="keywordflow">else</span> {
<a name="l04125"></a>04125       <span class="comment">// taildist &lt;= abs(curdist)</span>
<a name="l04126"></a>04126       mindist = -taildist;
<a name="l04127"></a>04127       goend();
<a name="l04128"></a>04128     }
<a name="l04129"></a>04129   } <span class="keywordflow">else</span> {
<a name="l04130"></a>04130     <span class="comment">// headdist &lt;= taildist</span>
<a name="l04131"></a>04131     <span class="keywordflow">if</span> (headdist &gt; abscurdist) {
<a name="l04132"></a>04132       mindist = curdist;
<a name="l04133"></a>04133     } <span class="keywordflow">else</span> {
<a name="l04134"></a>04134       <span class="comment">// headdist &lt;= abs(curdist)</span>
<a name="l04135"></a>04135       mindist = headdist;
<a name="l04136"></a>04136       rewind();
<a name="l04137"></a>04137     }
<a name="l04138"></a>04138   }
<a name="l04139"></a>04139 
<a name="l04140"></a>04140   <span class="keywordflow">return</span> move(mindist);
<a name="l04141"></a>04141 }
<a name="l04142"></a>04142 
<a name="l04144"></a>04144 <span class="comment">//                                                                           //</span>
<a name="l04145"></a>04145 <span class="comment">// add()    Add a node at the end of this link.                              //</span>
<a name="l04146"></a>04146 <span class="comment">//                                                                           //</span>
<a name="l04147"></a>04147 <span class="comment">// A new node is appended to the end of the link.  If &#39;newitem&#39; is not NULL, //</span>
<a name="l04148"></a>04148 <span class="comment">// its conents will be copied to the data slot of the new node. Returns the  //</span>
<a name="l04149"></a>04149 <span class="comment">// pointer to the newest added node.                                         //</span>
<a name="l04150"></a>04150 <span class="comment">//                                                                           //</span>
<a name="l04152"></a>04152 <span class="comment"></span>
<a name="l04153"></a>04153 <span class="keywordtype">void</span>* tetgenmesh::link::add(<span class="keywordtype">void</span>* newitem)
<a name="l04154"></a>04154 {
<a name="l04155"></a>04155   <span class="keywordtype">void</span> **newnode = tail;
<a name="l04156"></a>04156   <span class="keywordflow">if</span> (newitem != (<span class="keywordtype">void</span> *) NULL) {
<a name="l04157"></a>04157     memcpy((<span class="keywordtype">void</span> *)(newnode + 2), newitem, linkitembytes);
<a name="l04158"></a>04158   }
<a name="l04159"></a>04159   tail = (<span class="keywordtype">void</span> **) alloc();
<a name="l04160"></a>04160   *tail = NULL;
<a name="l04161"></a>04161   *newnode = (<span class="keywordtype">void</span>*) tail;
<a name="l04162"></a>04162   *(tail + 1) = (<span class="keywordtype">void</span>*) newnode;
<a name="l04163"></a>04163   linkitems++;
<a name="l04164"></a>04164   <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(newnode + 2);
<a name="l04165"></a>04165 }
<a name="l04166"></a>04166 
<a name="l04168"></a>04168 <span class="comment">//                                                                           //</span>
<a name="l04169"></a>04169 <span class="comment">// insert()    Inserts a node before the specified position.                 //</span>
<a name="l04170"></a>04170 <span class="comment">//                                                                           //</span>
<a name="l04171"></a>04171 <span class="comment">// &#39;pos&#39; (between 1 and &#39;linkitems&#39;) indicates the inserting position.  This //</span>
<a name="l04172"></a>04172 <span class="comment">// routine inserts a new node before the node of &#39;pos&#39;.  If &#39;newitem&#39; is not //</span>
<a name="l04173"></a>04173 <span class="comment">// NULL,  its conents will be copied into the data slot of the new node.  If //</span>
<a name="l04174"></a>04174 <span class="comment">// &#39;pos&#39; is larger than &#39;linkitems&#39;, it is equal as &#39;add()&#39;.  A pointer to   //</span>
<a name="l04175"></a>04175 <span class="comment">// the newest inserted item is returned.                                     //</span>
<a name="l04176"></a>04176 <span class="comment">//                                                                           //</span>
<a name="l04178"></a>04178 <span class="comment"></span>
<a name="l04179"></a>04179 <span class="keywordtype">void</span>* tetgenmesh::link::insert(<span class="keywordtype">int</span> pos, <span class="keywordtype">void</span>* insitem)
<a name="l04180"></a>04180 {
<a name="l04181"></a>04181   <span class="keywordflow">if</span> (!locate(pos)) {
<a name="l04182"></a>04182     <span class="keywordflow">return</span> add(insitem);
<a name="l04183"></a>04183   }
<a name="l04184"></a>04184 
<a name="l04185"></a>04185   <span class="keywordtype">void</span> **nownode = (<span class="keywordtype">void</span> **) nextlinkitem;
<a name="l04186"></a>04186 
<a name="l04187"></a>04187   <span class="comment">// Insert a node before &#39;nownode&#39;.</span>
<a name="l04188"></a>04188   <span class="keywordtype">void</span> **newnode = (<span class="keywordtype">void</span> **) alloc();
<a name="l04189"></a>04189   <span class="keywordflow">if</span> (insitem != (<span class="keywordtype">void</span> *) NULL) {
<a name="l04190"></a>04190     memcpy((<span class="keywordtype">void</span> *)(newnode + 2), insitem, linkitembytes);
<a name="l04191"></a>04191   }
<a name="l04192"></a>04192 
<a name="l04193"></a>04193   *(<span class="keywordtype">void</span> **)(*(nownode + 1)) = (<span class="keywordtype">void</span> *) newnode;
<a name="l04194"></a>04194   *newnode = (<span class="keywordtype">void</span> *) nownode;
<a name="l04195"></a>04195   *(newnode + 1) = *(nownode + 1);
<a name="l04196"></a>04196   *(nownode + 1) = (<span class="keywordtype">void</span> *) newnode;
<a name="l04197"></a>04197 
<a name="l04198"></a>04198   linkitems++;
<a name="l04199"></a>04199 
<a name="l04200"></a>04200   nextlinkitem = (<span class="keywordtype">void</span> *) newnode;
<a name="l04201"></a>04201   <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(newnode + 2);
<a name="l04202"></a>04202 }
<a name="l04203"></a>04203 
<a name="l04205"></a>04205 <span class="comment">//                                                                           //</span>
<a name="l04206"></a>04206 <span class="comment">// del()    Delete a node.                                                   //</span>
<a name="l04207"></a>04207 <span class="comment">//                                                                           //</span>
<a name="l04208"></a>04208 <span class="comment">// Returns a pointer of the deleted data. If you try to delete a non-existed //</span>
<a name="l04209"></a>04209 <span class="comment">// node (e.g. link is empty or a wrong index is given) return NULL.          //</span>
<a name="l04210"></a>04210 <span class="comment">//                                                                           //</span>
<a name="l04212"></a>04212 <span class="comment"></span>
<a name="l04213"></a>04213 <span class="keywordtype">void</span>* tetgenmesh::link::deletenode(<span class="keywordtype">void</span>** deadnode)
<a name="l04214"></a>04214 {
<a name="l04215"></a>04215   <span class="keywordtype">void</span> **nextnode = (<span class="keywordtype">void</span> **) *deadnode;
<a name="l04216"></a>04216   <span class="keywordtype">void</span> **prevnode = (<span class="keywordtype">void</span> **) *(deadnode + 1);
<a name="l04217"></a>04217   *prevnode = (<span class="keywordtype">void</span> *) nextnode;
<a name="l04218"></a>04218   *(nextnode + 1) = (<span class="keywordtype">void</span> *) prevnode;
<a name="l04219"></a>04219 
<a name="l04220"></a>04220   dealloc((<span class="keywordtype">void</span> *) deadnode);
<a name="l04221"></a>04221   linkitems--;
<a name="l04222"></a>04222 
<a name="l04223"></a>04223   nextlinkitem = (<span class="keywordtype">void</span> *) nextnode;
<a name="l04224"></a>04224   <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(deadnode + 2);
<a name="l04225"></a>04225 }
<a name="l04226"></a>04226 
<a name="l04228"></a>04228 <span class="comment">//                                                                           //</span>
<a name="l04229"></a>04229 <span class="comment">// del()    Delete a node at the specified position.                         //</span>
<a name="l04230"></a>04230 <span class="comment">//                                                                           //</span>
<a name="l04231"></a>04231 <span class="comment">// &#39;pos&#39; between 1 and &#39;linkitems&#39;.  Returns a pointer of the deleted data.  //</span>
<a name="l04232"></a>04232 <span class="comment">// If you try to delete a non-existed node (e.g. link is empty or a wrong    //</span>
<a name="l04233"></a>04233 <span class="comment">// index is given) return NULL.                                              //</span>
<a name="l04234"></a>04234 <span class="comment">//                                                                           //</span>
<a name="l04236"></a>04236 <span class="comment"></span>
<a name="l04237"></a>04237 <span class="keywordtype">void</span>* tetgenmesh::link::del(<span class="keywordtype">int</span> pos)
<a name="l04238"></a>04238 {
<a name="l04239"></a>04239   <span class="keywordflow">if</span> (!locate(pos) || (linkitems == 0)) {
<a name="l04240"></a>04240     <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) NULL;
<a name="l04241"></a>04241   }
<a name="l04242"></a>04242   <span class="keywordflow">return</span> deletenode((<span class="keywordtype">void</span> **) nextlinkitem);
<a name="l04243"></a>04243 }
<a name="l04244"></a>04244 
<a name="l04246"></a>04246 <span class="comment">//                                                                           //</span>
<a name="l04247"></a>04247 <span class="comment">// getitem()    The link traversal routine.                                  //</span>
<a name="l04248"></a>04248 <span class="comment">//                                                                           //</span>
<a name="l04249"></a>04249 <span class="comment">// Returns the node to which &#39;nextlinkitem&#39; points. Returns a &#39;NULL&#39; if the  //</span>
<a name="l04250"></a>04250 <span class="comment">// end of the link is reaching.  Both &#39;nextlinkitem&#39; and &#39;curpos&#39; will be    //</span>
<a name="l04251"></a>04251 <span class="comment">// updated after this operation.                                             //</span>
<a name="l04252"></a>04252 <span class="comment">//                                                                           //</span>
<a name="l04254"></a>04254 <span class="comment"></span>
<a name="l04255"></a>04255 <span class="keywordtype">void</span>* tetgenmesh::link::getitem()
<a name="l04256"></a>04256 {
<a name="l04257"></a>04257   <span class="keywordflow">if</span> (nextlinkitem == (<span class="keywordtype">void</span> *) tail) <span class="keywordflow">return</span> NULL;
<a name="l04258"></a>04258   <span class="keywordtype">void</span> **nownode = (<span class="keywordtype">void</span> **) nextlinkitem;
<a name="l04259"></a>04259   nextlinkitem = *nownode;
<a name="l04260"></a>04260   curpos += 1;
<a name="l04261"></a>04261   <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)(nownode + 2);
<a name="l04262"></a>04262 }
<a name="l04263"></a>04263 
<a name="l04265"></a>04265 <span class="comment">//                                                                           //</span>
<a name="l04266"></a>04266 <span class="comment">// getnitem()    Returns the node at a specified position.                   //</span>
<a name="l04267"></a>04267 <span class="comment">//                                                                           //</span>
<a name="l04268"></a>04268 <span class="comment">// &#39;pos&#39; between 1 and &#39;linkitems&#39;. After this operation, &#39;nextlinkitem&#39; and //</span>
<a name="l04269"></a>04269 <span class="comment">// &#39;curpos&#39; will be updated to indicate this node.                           //</span>
<a name="l04270"></a>04270 <span class="comment">//                                                                           //</span>
<a name="l04272"></a>04272 <span class="comment"></span>
<a name="l04273"></a>04273 <span class="keywordtype">void</span>* tetgenmesh::link::getnitem(<span class="keywordtype">int</span> pos)
<a name="l04274"></a>04274 {
<a name="l04275"></a>04275   <span class="keywordflow">if</span> (!locate(pos)) <span class="keywordflow">return</span> NULL;
<a name="l04276"></a>04276   <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *)((<span class="keywordtype">void</span> **) nextlinkitem + 2);
<a name="l04277"></a>04277 }
<a name="l04278"></a>04278 
<a name="l04280"></a>04280 <span class="comment">//                                                                           //</span>
<a name="l04281"></a>04281 <span class="comment">// hasitem()    Search in this link to find if &#39;checkitem&#39; exists.           //</span>
<a name="l04282"></a>04282 <span class="comment">//                                                                           //</span>
<a name="l04283"></a>04283 <span class="comment">// If &#39;checkitem&#39; exists, return its position (between 1 to &#39;linkitems&#39;),    //</span>
<a name="l04284"></a>04284 <span class="comment">// otherwise, return -1. This routine requires the linear order function has //</span>
<a name="l04285"></a>04285 <span class="comment">// been set.                                                                 //</span>
<a name="l04286"></a>04286 <span class="comment">//                                                                           //</span>
<a name="l04288"></a>04288 <span class="comment"></span>
<a name="l04289"></a>04289 <span class="keywordtype">int</span> tetgenmesh::link::hasitem(<span class="keywordtype">void</span>* checkitem)
<a name="l04290"></a>04290 {
<a name="l04291"></a>04291   <span class="keywordtype">void</span> *pathitem;
<a name="l04292"></a>04292   <span class="keywordtype">int</span> count;
<a name="l04293"></a>04293 
<a name="l04294"></a>04294   rewind();
<a name="l04295"></a>04295   pathitem = getitem();
<a name="l04296"></a>04296   count = 0;
<a name="l04297"></a>04297   <span class="keywordflow">while</span> (pathitem) {
<a name="l04298"></a>04298     count ++;
<a name="l04299"></a>04299     <span class="keywordflow">if</span> (comp) {
<a name="l04300"></a>04300       <span class="keywordflow">if</span> ((* comp)(pathitem, checkitem) == 0) {
<a name="l04301"></a>04301         <span class="keywordflow">return</span> count;
<a name="l04302"></a>04302       }
<a name="l04303"></a>04303     }
<a name="l04304"></a>04304     pathitem = getitem();
<a name="l04305"></a>04305   }
<a name="l04306"></a>04306   <span class="keywordflow">return</span> -1;
<a name="l04307"></a>04307 }
<a name="l04308"></a>04308 
<a name="l04309"></a>04309 <span class="comment">//</span>
<a name="l04310"></a>04310 <span class="comment">// End of class &#39;list&#39;, &#39;memorypool&#39; and &#39;link&#39; implementation</span>
<a name="l04311"></a>04311 <span class="comment">//</span>
<a name="l04312"></a>04312 
<a name="l04313"></a>04313 <span class="comment">//</span>
<a name="l04314"></a>04314 <span class="comment">// Begin of mesh manipulation primitives</span>
<a name="l04315"></a>04315 <span class="comment">//</span>
<a name="l04316"></a>04316 
<a name="l04317"></a>04317 <span class="comment">//</span>
<a name="l04318"></a>04318 <span class="comment">// Begin of tables initialization.</span>
<a name="l04319"></a>04319 <span class="comment">//</span>
<a name="l04320"></a>04320 
<a name="l04321"></a>04321 <span class="comment">// For enumerating three edges of a triangle.</span>
<a name="l04322"></a>04322 
<a name="l04323"></a>04323 <span class="keywordtype">int</span> <a class="code" href="triangle_8cpp.html#a5e3cab38396aa9ef129ce2f7461448cb">tetgenmesh::plus1mod3</a>[3] = {1, 2, 0};
<a name="l04324"></a>04324 <span class="keywordtype">int</span> tetgenmesh::minus1mod3[3] = {2, 0, 1};
<a name="l04325"></a>04325 
<a name="l04326"></a>04326 <span class="comment">// Table &#39;ve&#39; takes an edge version as input, returns the next edge version</span>
<a name="l04327"></a>04327 <span class="comment">//   in the same edge ring.</span>
<a name="l04328"></a>04328 
<a name="l04329"></a>04329 <span class="keywordtype">int</span> tetgenmesh::ve[6] = { 2, 5, 4, 1, 0, 3 };
<a name="l04330"></a>04330 
<a name="l04331"></a>04331 <span class="comment">// Tables &#39;vo&#39;, &#39;vd&#39; and &#39;va&#39; take an edge version, return the positions of</span>
<a name="l04332"></a>04332 <span class="comment">//   the origin, destination and apex in the triangle.</span>
<a name="l04333"></a>04333 
<a name="l04334"></a>04334 <span class="keywordtype">int</span> tetgenmesh::vo[6] = { 0, 1, 1, 2, 2, 0 };
<a name="l04335"></a>04335 <span class="keywordtype">int</span> tetgenmesh::vd[6] = { 1, 0, 2, 1, 0, 2 };
<a name="l04336"></a>04336 <span class="keywordtype">int</span> tetgenmesh::va[6] = { 2, 2, 0, 0, 1, 1 };
<a name="l04337"></a>04337 
<a name="l04338"></a>04338 <span class="comment">// The following tables are for tetrahedron primitives (operate on trifaces).</span>
<a name="l04339"></a>04339 
<a name="l04340"></a>04340 <span class="comment">// For &#39;org()&#39;, &#39;dest()&#39; and &#39;apex()&#39;.  Use &#39;loc&#39; as the first index and</span>
<a name="l04341"></a>04341 <span class="comment">//   &#39;ver&#39; as the second index.</span>
<a name="l04342"></a>04342 
<a name="l04343"></a>04343 <span class="keywordtype">int</span> tetgenmesh::locver2org[4][6]  = {
<a name="l04344"></a>04344   {0, 1, 1, 2, 2, 0},
<a name="l04345"></a>04345   {0, 3, 3, 1, 1, 0},
<a name="l04346"></a>04346   {1, 3, 3, 2, 2, 1},
<a name="l04347"></a>04347   {2, 3, 3, 0, 0, 2}
<a name="l04348"></a>04348 };
<a name="l04349"></a>04349 <span class="keywordtype">int</span> tetgenmesh::locver2dest[4][6] = {
<a name="l04350"></a>04350   {1, 0, 2, 1, 0, 2},
<a name="l04351"></a>04351   {3, 0, 1, 3, 0, 1},
<a name="l04352"></a>04352   {3, 1, 2, 3, 1, 2},
<a name="l04353"></a>04353   {3, 2, 0, 3, 2, 0}
<a name="l04354"></a>04354 };
<a name="l04355"></a>04355 <span class="keywordtype">int</span> tetgenmesh::locver2apex[4][6] = {
<a name="l04356"></a>04356   {2, 2, 0, 0, 1, 1},
<a name="l04357"></a>04357   {1, 1, 0, 0, 3, 3},
<a name="l04358"></a>04358   {2, 2, 1, 1, 3, 3},
<a name="l04359"></a>04359   {0, 0, 2, 2, 3, 3}
<a name="l04360"></a>04360 };
<a name="l04361"></a>04361 
<a name="l04362"></a>04362 <span class="comment">// For oppo() primitives, use &#39;loc&#39; as the index.</span>
<a name="l04363"></a>04363 
<a name="l04364"></a>04364 <span class="keywordtype">int</span> tetgenmesh::loc2oppo[4] = { 3, 2, 0, 1 };
<a name="l04365"></a>04365 
<a name="l04366"></a>04366 <span class="comment">// For fnext() primitive.  Use &#39;loc&#39; as the first index and &#39;ver&#39; as the</span>
<a name="l04367"></a>04367 <span class="comment">//   second index. Returns a new &#39;loc&#39; and new &#39;ver&#39; in an array. (It is</span>
<a name="l04368"></a>04368 <span class="comment">//   only valid for edge version equals one of {0, 2, 4}.)</span>
<a name="l04369"></a>04369 
<a name="l04370"></a>04370 <span class="keywordtype">int</span> tetgenmesh::locver2nextf[4][6][2] = {
<a name="l04371"></a>04371   { {1, 5}, {-1, -1}, {2, 5}, {-1, -1}, {3, 5}, {-1, -1} },
<a name="l04372"></a>04372   { {3, 3}, {-1, -1}, {2, 1}, {-1, -1}, {0, 1}, {-1, -1} },
<a name="l04373"></a>04373   { {1, 3}, {-1, -1}, {3, 1}, {-1, -1}, {0, 3}, {-1, -1} },
<a name="l04374"></a>04374   { {2, 3}, {-1, -1}, {1, 1}, {-1, -1}, {0, 5}, {-1, -1} }
<a name="l04375"></a>04375 };
<a name="l04376"></a>04376 
<a name="l04377"></a>04377 <span class="comment">// The edge number (from 0 to 5) of a tet is defined as follows:</span>
<a name="l04378"></a>04378 <span class="comment">//   0 - (v0, v1), 1 - (v1, v2), 2 - (v2, v0)</span>
<a name="l04379"></a>04379 <span class="comment">//   3 - (v3, v0), 4 - (v3, v1), 5 - (v3, v2).</span>
<a name="l04380"></a>04380 
<a name="l04381"></a>04381 <span class="keywordtype">int</span> tetgenmesh::locver2edge[4][6] = {
<a name="l04382"></a>04382   {0, 0, 1, 1, 2, 2},
<a name="l04383"></a>04383   {3, 3, 4, 4, 0, 0},
<a name="l04384"></a>04384   {4, 4, 5, 5, 1, 1},
<a name="l04385"></a>04385   {5, 5, 3, 3, 2, 2}
<a name="l04386"></a>04386 };
<a name="l04387"></a>04387 
<a name="l04388"></a>04388 <span class="keywordtype">int</span> tetgenmesh::edge2locver[6][2] = {
<a name="l04389"></a>04389   {0, 0}, <span class="comment">// 0  v0 -&gt; v1</span>
<a name="l04390"></a>04390   {0, 2}, <span class="comment">// 1  v1 -&gt; v2</span>
<a name="l04391"></a>04391   {0, 4}, <span class="comment">// 2  v2 -&gt; v1</span>
<a name="l04392"></a>04392   {1, 0}, <span class="comment">// 3  v0 -&gt; v3</span>
<a name="l04393"></a>04393   {1, 2}, <span class="comment">// 4  v1 -&gt; v3</span>
<a name="l04394"></a>04394   {2, 2}  <span class="comment">// 5  v2 -&gt; v3</span>
<a name="l04395"></a>04395 };
<a name="l04396"></a>04396 
<a name="l04397"></a>04397 <span class="comment">//</span>
<a name="l04398"></a>04398 <span class="comment">// End of tables initialization.</span>
<a name="l04399"></a>04399 <span class="comment">//</span>
<a name="l04400"></a>04400 
<a name="l04401"></a>04401 <span class="comment">// Some macros for convenience</span>
<a name="l04402"></a>04402 
<a name="l04403"></a>04403 <span class="preprocessor">#define Div2  &gt;&gt; 1</span>
<a name="l04404"></a>04404 <span class="preprocessor"></span><span class="preprocessor">#define Mod2  &amp; 01</span>
<a name="l04405"></a>04405 <span class="preprocessor"></span>
<a name="l04406"></a>04406 <span class="comment">// NOTE: These bit operators should only be used in macros below.</span>
<a name="l04407"></a>04407 
<a name="l04408"></a>04408 <span class="comment">// Get orient(Range from 0 to 2) from face version(Range from 0 to 5).</span>
<a name="l04409"></a>04409 
<a name="l04410"></a>04410 <span class="preprocessor">#define Orient(V)   ((V) Div2)</span>
<a name="l04411"></a>04411 <span class="preprocessor"></span>
<a name="l04412"></a>04412 <span class="comment">// Determine edge ring(0 or 1) from face version(Range from 0 to 5).</span>
<a name="l04413"></a>04413 
<a name="l04414"></a>04414 <span class="preprocessor">#define EdgeRing(V) ((V) Mod2)</span>
<a name="l04415"></a>04415 <span class="preprocessor"></span>
<a name="l04416"></a>04416 <span class="comment">//</span>
<a name="l04417"></a>04417 <span class="comment">// Begin of primitives for tetrahedra</span>
<a name="l04418"></a>04418 <span class="comment">//</span>
<a name="l04419"></a>04419 
<a name="l04420"></a>04420 <span class="comment">// Each tetrahedron contains four pointers to its neighboring tetrahedra,</span>
<a name="l04421"></a>04421 <span class="comment">//   with face indices.  To save memory, both information are kept in a</span>
<a name="l04422"></a>04422 <span class="comment">//   single pointer. To make this possible, all tetrahedra are aligned to</span>
<a name="l04423"></a>04423 <span class="comment">//   eight-byte boundaries, so that the last three bits of each pointer are</span>
<a name="l04424"></a>04424 <span class="comment">//   zeros. A face index (in the range 0 to 3) is compressed into the last</span>
<a name="l04425"></a>04425 <span class="comment">//   two bits of each pointer by the function &#39;encode()&#39;.  The function</span>
<a name="l04426"></a>04426 <span class="comment">//   &#39;decode()&#39; decodes a pointer, extracting a face index and a pointer to</span>
<a name="l04427"></a>04427 <span class="comment">//   the beginning of a tetrahedron.</span>
<a name="l04428"></a>04428 
<a name="l04429"></a>04429 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::decode(tetrahedron ptr, triface&amp; t) {
<a name="l04430"></a>04430   t.loc = (int) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (ptr) &amp; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) 3l);
<a name="l04431"></a>04431   t.tet = (tetrahedron *) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (ptr) &amp; ~(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) 7l);
<a name="l04432"></a>04432 }
<a name="l04433"></a>04433 
<a name="l04434"></a>04434 <span class="keyword">inline</span> tetgenmesh::tetrahedron tetgenmesh::encode(triface&amp; t) {
<a name="l04435"></a>04435   <span class="keywordflow">return</span> (tetrahedron) ((<span class="keywordtype">unsigned</span> long) t.tet | (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) t.loc);
<a name="l04436"></a>04436 }
<a name="l04437"></a>04437 
<a name="l04438"></a>04438 <span class="comment">// sym() finds the abutting tetrahedron on the same face.</span>
<a name="l04439"></a>04439 
<a name="l04440"></a>04440 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sym(triface&amp; t1, triface&amp; t2) {
<a name="l04441"></a>04441   tetrahedron ptr = t1.tet[t1.loc];
<a name="l04442"></a>04442   decode(ptr, t2);
<a name="l04443"></a>04443 }
<a name="l04444"></a>04444 
<a name="l04445"></a>04445 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::symself(triface&amp; t) {
<a name="l04446"></a>04446   tetrahedron ptr = t.tet[t.loc];
<a name="l04447"></a>04447   decode(ptr, t);
<a name="l04448"></a>04448 }
<a name="l04449"></a>04449 
<a name="l04450"></a>04450 <span class="comment">// Bond two tetrahedra together at their faces.</span>
<a name="l04451"></a>04451 
<a name="l04452"></a>04452 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::bond(triface&amp; t1, triface&amp; t2) {
<a name="l04453"></a>04453   t1.tet[t1.loc] = encode(t2);
<a name="l04454"></a>04454   t2.tet[t2.loc] = encode(t1);
<a name="l04455"></a>04455 }
<a name="l04456"></a>04456 
<a name="l04457"></a>04457 <span class="comment">// Dissolve a bond (from one side).  Note that the other tetrahedron will</span>
<a name="l04458"></a>04458 <span class="comment">//   still think it is connected to this tetrahedron.  Usually, however,</span>
<a name="l04459"></a>04459 <span class="comment">//   the other tetrahedron is being deleted entirely, or bonded to another</span>
<a name="l04460"></a>04460 <span class="comment">//   tetrahedron, so it doesn&#39;t matter.</span>
<a name="l04461"></a>04461 
<a name="l04462"></a>04462 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::dissolve(triface&amp; t) {
<a name="l04463"></a>04463   t.tet[t.loc] = (tetrahedron) dummytet;
<a name="l04464"></a>04464 }
<a name="l04465"></a>04465 
<a name="l04466"></a>04466 <span class="comment">// These primitives determine or set the origin, destination, apex or</span>
<a name="l04467"></a>04467 <span class="comment">//   opposition of a tetrahedron with respect to &#39;loc&#39; and &#39;ver&#39;.</span>
<a name="l04468"></a>04468 
<a name="l04469"></a>04469 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::org(triface&amp; t) {
<a name="l04470"></a>04470   <span class="keywordflow">return</span> (point) t.tet[locver2org[t.loc][t.ver] + 4];
<a name="l04471"></a>04471 }
<a name="l04472"></a>04472 
<a name="l04473"></a>04473 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::dest(triface&amp; t) {
<a name="l04474"></a>04474   <span class="keywordflow">return</span> (point) t.tet[locver2dest[t.loc][t.ver] + 4];
<a name="l04475"></a>04475 }
<a name="l04476"></a>04476 
<a name="l04477"></a>04477 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::apex(triface&amp; t) {
<a name="l04478"></a>04478   <span class="keywordflow">return</span> (point) t.tet[locver2apex[t.loc][t.ver] + 4];
<a name="l04479"></a>04479 }
<a name="l04480"></a>04480 
<a name="l04481"></a>04481 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::oppo(triface&amp; t) {
<a name="l04482"></a>04482   <span class="keywordflow">return</span> (point) t.tet[loc2oppo[t.loc] + 4];
<a name="l04483"></a>04483 }
<a name="l04484"></a>04484 
<a name="l04485"></a>04485 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setorg(triface&amp; t, point pointptr) {
<a name="l04486"></a>04486   t.tet[locver2org[t.loc][t.ver] + 4] = (tetrahedron) pointptr;
<a name="l04487"></a>04487 }
<a name="l04488"></a>04488 
<a name="l04489"></a>04489 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setdest(triface&amp; t, point pointptr) {
<a name="l04490"></a>04490   t.tet[locver2dest[t.loc][t.ver] + 4] = (tetrahedron) pointptr;
<a name="l04491"></a>04491 }
<a name="l04492"></a>04492 
<a name="l04493"></a>04493 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setapex(triface&amp; t, point pointptr) {
<a name="l04494"></a>04494   t.tet[locver2apex[t.loc][t.ver] + 4] = (tetrahedron) pointptr;
<a name="l04495"></a>04495 }
<a name="l04496"></a>04496 
<a name="l04497"></a>04497 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setoppo(triface&amp; t, point pointptr) {
<a name="l04498"></a>04498   t.tet[loc2oppo[t.loc] + 4] = (tetrahedron) pointptr;
<a name="l04499"></a>04499 }
<a name="l04500"></a>04500 
<a name="l04501"></a>04501 <span class="comment">// These primitives were drived from Mucke&#39;s triangle-edge data structure</span>
<a name="l04502"></a>04502 <span class="comment">//   to change face-edge relation in a tetrahedron (esym, enext and enext2)</span>
<a name="l04503"></a>04503 <span class="comment">//   or between two tetrahedra (fnext).</span>
<a name="l04504"></a>04504 
<a name="l04505"></a>04505 <span class="comment">// If e0 = e(i, j), e1 = e(j, i), that is e0 and e1 are the two directions</span>
<a name="l04506"></a>04506 <span class="comment">//   of the same undirected edge of a face. e0.sym() = e1 and vice versa.</span>
<a name="l04507"></a>04507 
<a name="l04508"></a>04508 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::esym(triface&amp; t1, triface&amp; t2) {
<a name="l04509"></a>04509   t2.tet = t1.tet;
<a name="l04510"></a>04510   t2.loc = t1.loc;
<a name="l04511"></a>04511   t2.ver = t1.ver + (EdgeRing(t1.ver) ? -1 : 1);
<a name="l04512"></a>04512 }
<a name="l04513"></a>04513 
<a name="l04514"></a>04514 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::esymself(triface&amp; t) {
<a name="l04515"></a>04515   t.ver += (EdgeRing(t.ver) ? -1 : 1);
<a name="l04516"></a>04516 }
<a name="l04517"></a>04517 
<a name="l04518"></a>04518 <span class="comment">// If e0 and e1 are both in the same edge ring of a face, e1 = e0.enext().</span>
<a name="l04519"></a>04519 
<a name="l04520"></a>04520 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::enext(triface&amp; t1, triface&amp; t2) {
<a name="l04521"></a>04521   t2.tet = t1.tet;
<a name="l04522"></a>04522   t2.loc = t1.loc;
<a name="l04523"></a>04523   t2.ver = ve[t1.ver];
<a name="l04524"></a>04524 }
<a name="l04525"></a>04525 
<a name="l04526"></a>04526 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::enextself(triface&amp; t) {
<a name="l04527"></a>04527   t.ver = ve[t.ver];
<a name="l04528"></a>04528 }
<a name="l04529"></a>04529 
<a name="l04530"></a>04530 <span class="comment">// enext2() is equal to e2 = e0.enext().enext()</span>
<a name="l04531"></a>04531 
<a name="l04532"></a>04532 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::enext2(triface&amp; t1, triface&amp; t2) {
<a name="l04533"></a>04533   t2.tet = t1.tet;
<a name="l04534"></a>04534   t2.loc = t1.loc;
<a name="l04535"></a>04535   t2.ver = ve[ve[t1.ver]];
<a name="l04536"></a>04536 }
<a name="l04537"></a>04537 
<a name="l04538"></a>04538 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::enext2self(triface&amp; t) {
<a name="l04539"></a>04539   t.ver = ve[ve[t.ver]];
<a name="l04540"></a>04540 }
<a name="l04541"></a>04541 
<a name="l04542"></a>04542 <span class="comment">// If f0 and f1 are both in the same face ring of a face, f1 = f0.fnext().</span>
<a name="l04543"></a>04543 <span class="comment">//   If f1 exists, return true. Otherwise, return false, i.e., f0 is a</span>
<a name="l04544"></a>04544 <span class="comment">//   boundary or hull face.</span>
<a name="l04545"></a>04545 
<a name="l04546"></a>04546 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::fnext(triface&amp; t1, triface&amp; t2)
<a name="l04547"></a>04547 {
<a name="l04548"></a>04548   <span class="comment">// Get the next face.</span>
<a name="l04549"></a>04549   t2.loc = locver2nextf[t1.loc][t1.ver][0];
<a name="l04550"></a>04550   <span class="comment">// Is the next face in the same tet?</span>
<a name="l04551"></a>04551   <span class="keywordflow">if</span> (t2.loc != -1) {
<a name="l04552"></a>04552     <span class="comment">// It&#39;s in the same tet. Get the edge version.</span>
<a name="l04553"></a>04553     t2.ver = locver2nextf[t1.loc][t1.ver][1];
<a name="l04554"></a>04554     t2.tet = t1.tet;
<a name="l04555"></a>04555   } <span class="keywordflow">else</span> {
<a name="l04556"></a>04556     <span class="comment">// The next face is in the neigbhour of &#39;t1&#39;.</span>
<a name="l04557"></a>04557     sym(t1, t2);
<a name="l04558"></a>04558     <span class="keywordflow">if</span> (t2.tet != dummytet) {
<a name="l04559"></a>04559       <span class="comment">// Find the corresponding edge in t2.</span>
<a name="l04560"></a>04560       point torg;
<a name="l04561"></a>04561       <span class="keywordtype">int</span> tloc, tver, i;
<a name="l04562"></a>04562       t2.ver = 0;
<a name="l04563"></a>04563       torg = org(t1);
<a name="l04564"></a>04564       <span class="keywordflow">for</span> (i = 0; (i &lt; 3) &amp;&amp; (org(t2) != torg); i++) {
<a name="l04565"></a>04565         enextself(t2);
<a name="l04566"></a>04566       }
<a name="l04567"></a>04567       <span class="comment">// Go to the next face in t2.</span>
<a name="l04568"></a>04568       tloc = t2.loc;
<a name="l04569"></a>04569       tver = t2.ver;
<a name="l04570"></a>04570       t2.loc = locver2nextf[tloc][tver][0];
<a name="l04571"></a>04571       t2.ver = locver2nextf[tloc][tver][1];
<a name="l04572"></a>04572     }
<a name="l04573"></a>04573   }
<a name="l04574"></a>04574   <span class="keywordflow">return</span> t2.tet != dummytet;
<a name="l04575"></a>04575 }
<a name="l04576"></a>04576 
<a name="l04577"></a>04577 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::fnextself(triface&amp; t1)
<a name="l04578"></a>04578 {
<a name="l04579"></a>04579   triface t2;
<a name="l04580"></a>04580 
<a name="l04581"></a>04581   <span class="comment">// Get the next face.</span>
<a name="l04582"></a>04582   t2.loc = locver2nextf[t1.loc][t1.ver][0];
<a name="l04583"></a>04583   <span class="comment">// Is the next face in the same tet?</span>
<a name="l04584"></a>04584   <span class="keywordflow">if</span> (t2.loc != -1) {
<a name="l04585"></a>04585     <span class="comment">// It&#39;s in the same tet. Get the edge version.</span>
<a name="l04586"></a>04586     t2.ver = locver2nextf[t1.loc][t1.ver][1];
<a name="l04587"></a>04587     t1.loc = t2.loc;
<a name="l04588"></a>04588     t1.ver = t2.ver;
<a name="l04589"></a>04589   } <span class="keywordflow">else</span> {
<a name="l04590"></a>04590     <span class="comment">// The next face is in the neigbhour of &#39;t1&#39;.</span>
<a name="l04591"></a>04591     sym(t1, t2);
<a name="l04592"></a>04592     <span class="keywordflow">if</span> (t2.tet != dummytet) {
<a name="l04593"></a>04593       <span class="comment">// Find the corresponding edge in t2.</span>
<a name="l04594"></a>04594       point torg;
<a name="l04595"></a>04595       <span class="keywordtype">int</span> i;
<a name="l04596"></a>04596       t2.ver = 0;
<a name="l04597"></a>04597       torg = org(t1);
<a name="l04598"></a>04598       <span class="keywordflow">for</span> (i = 0; (i &lt; 3) &amp;&amp; (org(t2) != torg); i++) {
<a name="l04599"></a>04599         enextself(t2);
<a name="l04600"></a>04600       }
<a name="l04601"></a>04601       t1.loc = locver2nextf[t2.loc][t2.ver][0];
<a name="l04602"></a>04602       t1.ver = locver2nextf[t2.loc][t2.ver][1];
<a name="l04603"></a>04603       t1.tet = t2.tet;
<a name="l04604"></a>04604     }
<a name="l04605"></a>04605   }
<a name="l04606"></a>04606   <span class="keywordflow">return</span> t2.tet != dummytet;
<a name="l04607"></a>04607 }
<a name="l04608"></a>04608 
<a name="l04609"></a>04609 <span class="comment">// enextfnext() and enext2fnext() are combination primitives of enext(),</span>
<a name="l04610"></a>04610 <span class="comment">//   enext2() and fnext().</span>
<a name="l04611"></a>04611 
<a name="l04612"></a>04612 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::enextfnext(triface&amp; t1, triface&amp; t2) {
<a name="l04613"></a>04613   enext(t1, t2);
<a name="l04614"></a>04614   fnextself(t2);
<a name="l04615"></a>04615 }
<a name="l04616"></a>04616 
<a name="l04617"></a>04617 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::enextfnextself(triface&amp; t) {
<a name="l04618"></a>04618   enextself(t);
<a name="l04619"></a>04619   fnextself(t);
<a name="l04620"></a>04620 }
<a name="l04621"></a>04621 
<a name="l04622"></a>04622 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::enext2fnext(triface&amp; t1, triface&amp; t2) {
<a name="l04623"></a>04623   enext2(t1, t2);
<a name="l04624"></a>04624   fnextself(t2);
<a name="l04625"></a>04625 }
<a name="l04626"></a>04626 
<a name="l04627"></a>04627 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::enext2fnextself(triface&amp; t) {
<a name="l04628"></a>04628   enext2self(t);
<a name="l04629"></a>04629   fnextself(t);
<a name="l04630"></a>04630 }
<a name="l04631"></a>04631 
<a name="l04632"></a>04632 <span class="comment">// Primitives to infect or cure a tetrahedron with the virus.   The last</span>
<a name="l04633"></a>04633 <span class="comment">//   third bit of the pointer is marked for infection.  These rely on the</span>
<a name="l04634"></a>04634 <span class="comment">//   assumption that all tetrahedron are aligned to eight-byte boundaries.</span>
<a name="l04635"></a>04635 
<a name="l04636"></a>04636 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::infect(triface&amp; t) {
<a name="l04637"></a>04637   t.tet[0] = (tetrahedron) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) t.tet[0] | (<span class="keywordtype">unsigned</span> long) 4l);
<a name="l04638"></a>04638 }
<a name="l04639"></a>04639 
<a name="l04640"></a>04640 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::uninfect(triface&amp; t) {
<a name="l04641"></a>04641   t.tet[0] = (tetrahedron) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) t.tet[0] &amp; ~ (<span class="keywordtype">unsigned</span> long) 4l);
<a name="l04642"></a>04642 }
<a name="l04643"></a>04643 
<a name="l04644"></a>04644 <span class="comment">// Test a tetrahedron for viral infection.</span>
<a name="l04645"></a>04645 
<a name="l04646"></a>04646 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::infected(triface&amp; t) {
<a name="l04647"></a>04647   <span class="keywordflow">return</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) t.tet[0] &amp; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) 4l) != 0);
<a name="l04648"></a>04648 }
<a name="l04649"></a>04649 
<a name="l04650"></a>04650 <span class="comment">// Check or set a tetrahedron&#39;s attributes.</span>
<a name="l04651"></a>04651 
<a name="l04652"></a>04652 <span class="keyword">inline</span> REAL tetgenmesh::elemattribute(tetrahedron* ptr, <span class="keywordtype">int</span> attnum) {
<a name="l04653"></a>04653   <span class="keywordflow">return</span> ((REAL *) (ptr))[elemattribindex + attnum];
<a name="l04654"></a>04654 }
<a name="l04655"></a>04655 
<a name="l04656"></a>04656 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::
<a name="l04657"></a>04657 setelemattribute(tetrahedron* ptr, <span class="keywordtype">int</span> attnum, REAL value){
<a name="l04658"></a>04658   ((REAL *) (ptr))[elemattribindex + attnum] = value;
<a name="l04659"></a>04659 }
<a name="l04660"></a>04660 
<a name="l04661"></a>04661 <span class="comment">// Check or set a tetrahedron&#39;s maximum volume bound.</span>
<a name="l04662"></a>04662 
<a name="l04663"></a>04663 <span class="keyword">inline</span> REAL tetgenmesh::volumebound(tetrahedron* ptr) {
<a name="l04664"></a>04664   <span class="keywordflow">return</span> ((REAL *) (ptr))[volumeboundindex];
<a name="l04665"></a>04665 }
<a name="l04666"></a>04666 
<a name="l04667"></a>04667 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setvolumebound(tetrahedron* ptr, REAL value) {
<a name="l04668"></a>04668   ((REAL *) (ptr))[volumeboundindex] = value;
<a name="l04669"></a>04669 }
<a name="l04670"></a>04670 
<a name="l04671"></a>04671 <span class="comment">//</span>
<a name="l04672"></a>04672 <span class="comment">// End of primitives for tetrahedra</span>
<a name="l04673"></a>04673 <span class="comment">//</span>
<a name="l04674"></a>04674 
<a name="l04675"></a>04675 <span class="comment">//</span>
<a name="l04676"></a>04676 <span class="comment">// Begin of primitives for subfaces/subsegments</span>
<a name="l04677"></a>04677 <span class="comment">//</span>
<a name="l04678"></a>04678 
<a name="l04679"></a>04679 <span class="comment">// Each subface contains three pointers to its neighboring subfaces, with</span>
<a name="l04680"></a>04680 <span class="comment">//   edge versions.  To save memory, both information are kept in a single</span>
<a name="l04681"></a>04681 <span class="comment">//   pointer. To make this possible, all subfaces are aligned to eight-byte</span>
<a name="l04682"></a>04682 <span class="comment">//   boundaries, so that the last three bits of each pointer are zeros. An</span>
<a name="l04683"></a>04683 <span class="comment">//   edge version (in the range 0 to 5) is compressed into the last three</span>
<a name="l04684"></a>04684 <span class="comment">//   bits of each pointer by &#39;sencode()&#39;.  &#39;sdecode()&#39; decodes a pointer,</span>
<a name="l04685"></a>04685 <span class="comment">//   extracting an edge version and a pointer to the beginning of a subface.</span>
<a name="l04686"></a>04686 
<a name="l04687"></a>04687 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sdecode(shellface sptr, face&amp; s) {
<a name="l04688"></a>04688   s.shver = (int) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (sptr) &amp; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) 7l);
<a name="l04689"></a>04689   s.sh = (shellface *) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) (sptr) &amp; ~ (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) 7l);
<a name="l04690"></a>04690 }
<a name="l04691"></a>04691 
<a name="l04692"></a>04692 <span class="keyword">inline</span> tetgenmesh::shellface tetgenmesh::sencode(face&amp; s) {
<a name="l04693"></a>04693   <span class="keywordflow">return</span> (shellface) ((<span class="keywordtype">unsigned</span> long) s.sh | (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) s.shver);
<a name="l04694"></a>04694 }
<a name="l04695"></a>04695 
<a name="l04696"></a>04696 <span class="comment">// spivot() finds the other subface (from this subface) that shares the</span>
<a name="l04697"></a>04697 <span class="comment">//   same edge.</span>
<a name="l04698"></a>04698 
<a name="l04699"></a>04699 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::spivot(face&amp; s1, face&amp; s2) {
<a name="l04700"></a>04700   shellface sptr = s1.sh[Orient(s1.shver)];
<a name="l04701"></a>04701   sdecode(sptr, s2);
<a name="l04702"></a>04702 }
<a name="l04703"></a>04703 
<a name="l04704"></a>04704 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::spivotself(face&amp; s) {
<a name="l04705"></a>04705   shellface sptr = s.sh[Orient(s.shver)];
<a name="l04706"></a>04706   sdecode(sptr, s);
<a name="l04707"></a>04707 }
<a name="l04708"></a>04708 
<a name="l04709"></a>04709 <span class="comment">// sbond() bonds two subfaces together, i.e., after bonding, both faces</span>
<a name="l04710"></a>04710 <span class="comment">//   are pointing to each other.</span>
<a name="l04711"></a>04711 
<a name="l04712"></a>04712 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sbond(face&amp; s1, face&amp; s2) {
<a name="l04713"></a>04713   s1.sh[Orient(s1.shver)] = sencode(s2);
<a name="l04714"></a>04714   s2.sh[Orient(s2.shver)] = sencode(s1);
<a name="l04715"></a>04715 }
<a name="l04716"></a>04716 
<a name="l04717"></a>04717 <span class="comment">// sbond1() only bonds s2 to s1, i.e., after bonding, s1 is pointing to s2,</span>
<a name="l04718"></a>04718 <span class="comment">//   but s2 is not pointing to s1.</span>
<a name="l04719"></a>04719 
<a name="l04720"></a>04720 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sbond1(face&amp; s1, face&amp; s2) {
<a name="l04721"></a>04721   s1.sh[Orient(s1.shver)] = sencode(s2);
<a name="l04722"></a>04722 }
<a name="l04723"></a>04723 
<a name="l04724"></a>04724 <span class="comment">// Dissolve a subface bond (from one side).  Note that the other subface</span>
<a name="l04725"></a>04725 <span class="comment">//   will still think it&#39;s connected to this subface.</span>
<a name="l04726"></a>04726 
<a name="l04727"></a>04727 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sdissolve(face&amp; s) {
<a name="l04728"></a>04728   s.sh[Orient(s.shver)] = (shellface) dummysh;
<a name="l04729"></a>04729 }
<a name="l04730"></a>04730 
<a name="l04731"></a>04731 <span class="comment">// These primitives determine or set the origin, destination, or apex</span>
<a name="l04732"></a>04732 <span class="comment">//   of a subface with respect to the edge version.</span>
<a name="l04733"></a>04733 
<a name="l04734"></a>04734 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::sorg(face&amp; s) {
<a name="l04735"></a>04735   <span class="keywordflow">return</span> (point) s.sh[3 + vo[s.shver]];
<a name="l04736"></a>04736 }
<a name="l04737"></a>04737 
<a name="l04738"></a>04738 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::sdest(face&amp; s) {
<a name="l04739"></a>04739   <span class="keywordflow">return</span> (point) s.sh[3 + vd[s.shver]];
<a name="l04740"></a>04740 }
<a name="l04741"></a>04741 
<a name="l04742"></a>04742 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::sapex(face&amp; s) {
<a name="l04743"></a>04743   <span class="keywordflow">return</span> (point) s.sh[3 + va[s.shver]];
<a name="l04744"></a>04744 }
<a name="l04745"></a>04745 
<a name="l04746"></a>04746 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setsorg(face&amp; s, point pointptr) {
<a name="l04747"></a>04747   s.sh[3 + vo[s.shver]] = (shellface) pointptr;
<a name="l04748"></a>04748 }
<a name="l04749"></a>04749 
<a name="l04750"></a>04750 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setsdest(face&amp; s, point pointptr) {
<a name="l04751"></a>04751   s.sh[3 + vd[s.shver]] = (shellface) pointptr;
<a name="l04752"></a>04752 }
<a name="l04753"></a>04753 
<a name="l04754"></a>04754 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setsapex(face&amp; s, point pointptr) {
<a name="l04755"></a>04755   s.sh[3 + va[s.shver]] = (shellface) pointptr;
<a name="l04756"></a>04756 }
<a name="l04757"></a>04757 
<a name="l04758"></a>04758 <span class="comment">// These primitives were drived from Mucke[2]&#39;s triangle-edge data structure</span>
<a name="l04759"></a>04759 <span class="comment">//   to change face-edge relation in a subface (sesym, senext and senext2).</span>
<a name="l04760"></a>04760 
<a name="l04761"></a>04761 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sesym(face&amp; s1, face&amp; s2) {
<a name="l04762"></a>04762   s2.sh = s1.sh;
<a name="l04763"></a>04763   s2.shver = s1.shver + (EdgeRing(s1.shver) ? -1 : 1);
<a name="l04764"></a>04764 }
<a name="l04765"></a>04765 
<a name="l04766"></a>04766 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sesymself(face&amp; s) {
<a name="l04767"></a>04767   s.shver += (EdgeRing(s.shver) ? -1 : 1);
<a name="l04768"></a>04768 }
<a name="l04769"></a>04769 
<a name="l04770"></a>04770 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::senext(face&amp; s1, face&amp; s2) {
<a name="l04771"></a>04771   s2.sh = s1.sh;
<a name="l04772"></a>04772   s2.shver = ve[s1.shver];
<a name="l04773"></a>04773 }
<a name="l04774"></a>04774 
<a name="l04775"></a>04775 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::senextself(face&amp; s) {
<a name="l04776"></a>04776   s.shver = ve[s.shver];
<a name="l04777"></a>04777 }
<a name="l04778"></a>04778 
<a name="l04779"></a>04779 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::senext2(face&amp; s1, face&amp; s2) {
<a name="l04780"></a>04780   s2.sh = s1.sh;
<a name="l04781"></a>04781   s2.shver = ve[ve[s1.shver]];
<a name="l04782"></a>04782 }
<a name="l04783"></a>04783 
<a name="l04784"></a>04784 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::senext2self(face&amp; s) {
<a name="l04785"></a>04785   s.shver = ve[ve[s.shver]];
<a name="l04786"></a>04786 }
<a name="l04787"></a>04787 
<a name="l04788"></a>04788 <span class="comment">// If f0 and f1 are both in the same face ring, then f1 = f0.fnext(),</span>
<a name="l04789"></a>04789 
<a name="l04790"></a>04790 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sfnext(face&amp; s1, face&amp; s2) {
<a name="l04791"></a>04791   getnextsface(&amp;s1, &amp;s2);
<a name="l04792"></a>04792 }
<a name="l04793"></a>04793 
<a name="l04794"></a>04794 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sfnextself(face&amp; s) {
<a name="l04795"></a>04795   getnextsface(&amp;s, NULL);
<a name="l04796"></a>04796 }
<a name="l04797"></a>04797 
<a name="l04798"></a>04798 <span class="comment">// These primitives read or set a pointer of the badface structure.  The</span>
<a name="l04799"></a>04799 <span class="comment">//   pointer is stored sh[11].</span>
<a name="l04800"></a>04800 
<a name="l04801"></a>04801 <span class="keyword">inline</span> tetgenmesh::badface* tetgenmesh::shell2badface(face&amp; s) {
<a name="l04802"></a>04802   <span class="keywordflow">return</span> (badface*) s.sh[11];
<a name="l04803"></a>04803 }
<a name="l04804"></a>04804 
<a name="l04805"></a>04805 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setshell2badface(face&amp; s, badface* value) {
<a name="l04806"></a>04806   s.sh[11] = (shellface) value;
<a name="l04807"></a>04807 }
<a name="l04808"></a>04808 
<a name="l04809"></a>04809 <span class="comment">// Check or set a subface&#39;s maximum area bound.</span>
<a name="l04810"></a>04810 
<a name="l04811"></a>04811 <span class="keyword">inline</span> REAL tetgenmesh::areabound(face&amp; s) {
<a name="l04812"></a>04812   <span class="keywordflow">return</span> ((REAL *) (s.sh))[areaboundindex];
<a name="l04813"></a>04813 }
<a name="l04814"></a>04814 
<a name="l04815"></a>04815 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setareabound(face&amp; s, REAL value) {
<a name="l04816"></a>04816   ((REAL *) (s.sh))[areaboundindex] = value;
<a name="l04817"></a>04817 }
<a name="l04818"></a>04818 
<a name="l04819"></a>04819 <span class="comment">// These two primitives read or set a shell marker.  Shell markers are used</span>
<a name="l04820"></a>04820 <span class="comment">//   to hold user boundary information.</span>
<a name="l04821"></a>04821 
<a name="l04822"></a>04822 <span class="keyword">inline</span> <span class="keywordtype">int</span> tetgenmesh::shellmark(face&amp; s) {
<a name="l04823"></a>04823   <span class="keywordflow">return</span> ((<span class="keywordtype">int</span> *) (s.sh))[shmarkindex];
<a name="l04824"></a>04824 }
<a name="l04825"></a>04825 
<a name="l04826"></a>04826 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setshellmark(face&amp; s, <span class="keywordtype">int</span> value) {
<a name="l04827"></a>04827   ((<span class="keywordtype">int</span> *) (s.sh))[shmarkindex] = value;
<a name="l04828"></a>04828 }
<a name="l04829"></a>04829 
<a name="l04830"></a>04830 <span class="comment">// These two primitives set or read the type of the subface or subsegment.</span>
<a name="l04831"></a>04831 
<a name="l04832"></a>04832 <span class="keyword">inline</span> <span class="keyword">enum</span> tetgenmesh::shestype tetgenmesh::shelltype(face&amp; s) {
<a name="l04833"></a>04833   <span class="keywordflow">return</span> (<span class="keyword">enum</span> shestype) ((<span class="keywordtype">int</span> *) (s.sh))[shmarkindex + 1];
<a name="l04834"></a>04834 }
<a name="l04835"></a>04835 
<a name="l04836"></a>04836 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setshelltype(face&amp; s, <span class="keyword">enum</span> shestype value) {
<a name="l04837"></a>04837   ((<span class="keywordtype">int</span> *) (s.sh))[shmarkindex + 1] = (<span class="keywordtype">int</span>) value;
<a name="l04838"></a>04838 }
<a name="l04839"></a>04839 
<a name="l04840"></a>04840 <span class="comment">// These two primitives set or read the pbc group of the subface.</span>
<a name="l04841"></a>04841 
<a name="l04842"></a>04842 <span class="keyword">inline</span> <span class="keywordtype">int</span> tetgenmesh::shellpbcgroup(face&amp; s) {
<a name="l04843"></a>04843   <span class="keywordflow">return</span> ((<span class="keywordtype">int</span> *) (s.sh))[shmarkindex + 2];
<a name="l04844"></a>04844 }
<a name="l04845"></a>04845 
<a name="l04846"></a>04846 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setshellpbcgroup(face&amp; s, <span class="keywordtype">int</span> value) {
<a name="l04847"></a>04847   ((<span class="keywordtype">int</span> *) (s.sh))[shmarkindex + 2] = value;
<a name="l04848"></a>04848 }
<a name="l04849"></a>04849 
<a name="l04850"></a>04850 <span class="comment">// Primitives to infect or cure a subface with the virus. These rely on the</span>
<a name="l04851"></a>04851 <span class="comment">//   assumption that all tetrahedra are aligned to eight-byte boundaries.</span>
<a name="l04852"></a>04852 
<a name="l04853"></a>04853 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sinfect(face&amp; s) {
<a name="l04854"></a>04854   s.sh[6] = (shellface) ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) s.sh[6] | (<span class="keywordtype">unsigned</span> long) 4l);
<a name="l04855"></a>04855 }
<a name="l04856"></a>04856 
<a name="l04857"></a>04857 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::suninfect(face&amp; s) {
<a name="l04858"></a>04858   s.sh[6] = (shellface)((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) s.sh[6] &amp; ~(<span class="keywordtype">unsigned</span> long) 4l);
<a name="l04859"></a>04859 }
<a name="l04860"></a>04860 
<a name="l04861"></a>04861 <span class="comment">// Test a subface for viral infection.</span>
<a name="l04862"></a>04862 
<a name="l04863"></a>04863 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::sinfected(face&amp; s) {
<a name="l04864"></a>04864   <span class="keywordflow">return</span> (((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) s.sh[6] &amp; (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) 4l) != 0);
<a name="l04865"></a>04865 }
<a name="l04866"></a>04866 
<a name="l04867"></a>04867 <span class="comment">//</span>
<a name="l04868"></a>04868 <span class="comment">// End of primitives for subfaces/subsegments</span>
<a name="l04869"></a>04869 <span class="comment">//</span>
<a name="l04870"></a>04870 
<a name="l04871"></a>04871 <span class="comment">//</span>
<a name="l04872"></a>04872 <span class="comment">// Begin of primitives for interacting between tetrahedra and subfaces</span>
<a name="l04873"></a>04873 <span class="comment">//</span>
<a name="l04874"></a>04874 
<a name="l04875"></a>04875 <span class="comment">// tspivot() finds a subface abutting on this tetrahdera.</span>
<a name="l04876"></a>04876 
<a name="l04877"></a>04877 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::tspivot(triface&amp; t, face&amp; s) {
<a name="l04878"></a>04878   shellface sptr = (shellface) t.tet[8 + t.loc];
<a name="l04879"></a>04879   sdecode(sptr, s);
<a name="l04880"></a>04880 }
<a name="l04881"></a>04881 
<a name="l04882"></a>04882 <span class="comment">// stpivot() finds a tetrahedron abutting a subface.</span>
<a name="l04883"></a>04883 
<a name="l04884"></a>04884 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::stpivot(face&amp; s, triface&amp; t) {
<a name="l04885"></a>04885   tetrahedron ptr = (tetrahedron) s.sh[6 + EdgeRing(s.shver)];
<a name="l04886"></a>04886   decode(ptr, t);
<a name="l04887"></a>04887 }
<a name="l04888"></a>04888 
<a name="l04889"></a>04889 <span class="comment">// tsbond() bond a tetrahedron to a subface.</span>
<a name="l04890"></a>04890 
<a name="l04891"></a>04891 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::tsbond(triface&amp; t, face&amp; s) {
<a name="l04892"></a>04892   t.tet[8 + t.loc] = (tetrahedron) sencode(s);
<a name="l04893"></a>04893   s.sh[6 + EdgeRing(s.shver)] = (shellface) encode(t);
<a name="l04894"></a>04894 }
<a name="l04895"></a>04895 
<a name="l04896"></a>04896 <span class="comment">// tsdissolve() dissolve a bond (from the tetrahedron side).</span>
<a name="l04897"></a>04897 
<a name="l04898"></a>04898 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::tsdissolve(triface&amp; t) {
<a name="l04899"></a>04899   t.tet[8 + t.loc] = (tetrahedron) dummysh;
<a name="l04900"></a>04900 }
<a name="l04901"></a>04901 
<a name="l04902"></a>04902 <span class="comment">// stdissolve() dissolve a bond (from the subface side).</span>
<a name="l04903"></a>04903 
<a name="l04904"></a>04904 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::stdissolve(face&amp; s) {
<a name="l04905"></a>04905   s.sh[6 + EdgeRing(s.shver)] = (shellface) dummytet;
<a name="l04906"></a>04906 }
<a name="l04907"></a>04907 
<a name="l04908"></a>04908 <span class="comment">//</span>
<a name="l04909"></a>04909 <span class="comment">// End of primitives for interacting between tetrahedra and subfaces</span>
<a name="l04910"></a>04910 <span class="comment">//</span>
<a name="l04911"></a>04911 
<a name="l04912"></a>04912 <span class="comment">//</span>
<a name="l04913"></a>04913 <span class="comment">// Begin of primitives for interacting between subfaces and subsegs</span>
<a name="l04914"></a>04914 <span class="comment">//</span>
<a name="l04915"></a>04915 
<a name="l04916"></a>04916 <span class="comment">// sspivot() finds a subsegment abutting a subface.</span>
<a name="l04917"></a>04917 
<a name="l04918"></a>04918 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::sspivot(face&amp; s, face&amp; edge) {
<a name="l04919"></a>04919   shellface sptr = (shellface) s.sh[8 + Orient(s.shver)];
<a name="l04920"></a>04920   sdecode(sptr, edge);
<a name="l04921"></a>04921 }
<a name="l04922"></a>04922 
<a name="l04923"></a>04923 <span class="comment">// ssbond() bond a subface to a subsegment.</span>
<a name="l04924"></a>04924 
<a name="l04925"></a>04925 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::ssbond(face&amp; s, face&amp; edge) {
<a name="l04926"></a>04926   s.sh[8 + Orient(s.shver)] = sencode(edge);
<a name="l04927"></a>04927   edge.sh[0] = sencode(s);
<a name="l04928"></a>04928 }
<a name="l04929"></a>04929 
<a name="l04930"></a>04930 <span class="comment">// ssdisolve() dissolve a bond (from the subface side)</span>
<a name="l04931"></a>04931 
<a name="l04932"></a>04932 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::ssdissolve(face&amp; s) {
<a name="l04933"></a>04933   s.sh[8 + Orient(s.shver)] = (shellface) dummysh;
<a name="l04934"></a>04934 }
<a name="l04935"></a>04935 
<a name="l04936"></a>04936 <span class="comment">//</span>
<a name="l04937"></a>04937 <span class="comment">// End of primitives for interacting between subfaces and subsegs</span>
<a name="l04938"></a>04938 <span class="comment">//</span>
<a name="l04939"></a>04939 
<a name="l04940"></a>04940 <span class="comment">//</span>
<a name="l04941"></a>04941 <span class="comment">// Begin of primitives for interacting between tet and subsegs.</span>
<a name="l04942"></a>04942 <span class="comment">//</span>
<a name="l04943"></a>04943 
<a name="l04944"></a>04944 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::tsspivot1(triface&amp; t, face&amp; seg)
<a name="l04945"></a>04945 {
<a name="l04946"></a>04946   shellface sptr = (shellface) t.tet[8 + locver2edge[t.loc][t.ver]];
<a name="l04947"></a>04947   sdecode(sptr, seg);
<a name="l04948"></a>04948 }
<a name="l04949"></a>04949 
<a name="l04950"></a>04950 <span class="comment">// Only bond/dissolve at tet&#39;s side, but not vice versa.</span>
<a name="l04951"></a>04951 
<a name="l04952"></a>04952 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::tssbond1(triface&amp; t, face&amp; seg)
<a name="l04953"></a>04953 {
<a name="l04954"></a>04954   t.tet[8 + locver2edge[t.loc][t.ver]] = (tetrahedron) sencode(seg);
<a name="l04955"></a>04955 }
<a name="l04956"></a>04956 
<a name="l04957"></a>04957 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::tssdissolve1(triface&amp; t)
<a name="l04958"></a>04958 {
<a name="l04959"></a>04959   t.tet[8 + locver2edge[t.loc][t.ver]] = (tetrahedron) dummysh;
<a name="l04960"></a>04960 }
<a name="l04961"></a>04961 
<a name="l04962"></a>04962 <span class="comment">//</span>
<a name="l04963"></a>04963 <span class="comment">// End of primitives for interacting between tet and subsegs.</span>
<a name="l04964"></a>04964 <span class="comment">//</span>
<a name="l04965"></a>04965 
<a name="l04966"></a>04966 <span class="comment">//</span>
<a name="l04967"></a>04967 <span class="comment">// Begin of primitives for points</span>
<a name="l04968"></a>04968 <span class="comment">//</span>
<a name="l04969"></a>04969 
<a name="l04970"></a>04970 <span class="keyword">inline</span> <span class="keywordtype">int</span> tetgenmesh::pointmark(point pt) {
<a name="l04971"></a>04971   <span class="keywordflow">return</span> ((<span class="keywordtype">int</span> *) (pt))[pointmarkindex];
<a name="l04972"></a>04972 }
<a name="l04973"></a>04973 
<a name="l04974"></a>04974 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setpointmark(point pt, <span class="keywordtype">int</span> value) {
<a name="l04975"></a>04975   ((<span class="keywordtype">int</span> *) (pt))[pointmarkindex] = value;
<a name="l04976"></a>04976 }
<a name="l04977"></a>04977 
<a name="l04978"></a>04978 <span class="comment">// These two primitives set and read the type of the point.</span>
<a name="l04979"></a>04979 
<a name="l04980"></a>04980 <span class="keyword">inline</span> <span class="keyword">enum</span> tetgenmesh::verttype tetgenmesh::pointtype(point pt) {
<a name="l04981"></a>04981   <span class="keywordflow">return</span> (<span class="keyword">enum</span> verttype) ((<span class="keywordtype">int</span> *) (pt))[pointmarkindex + 1];
<a name="l04982"></a>04982 }
<a name="l04983"></a>04983 
<a name="l04984"></a>04984 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setpointtype(point pt, <span class="keyword">enum</span> verttype value) {
<a name="l04985"></a>04985   ((<span class="keywordtype">int</span> *) (pt))[pointmarkindex + 1] = (<span class="keywordtype">int</span>) value;
<a name="l04986"></a>04986 }
<a name="l04987"></a>04987 
<a name="l04988"></a>04988 <span class="comment">// These following primitives set and read a pointer to a tetrahedron</span>
<a name="l04989"></a>04989 <span class="comment">//   a subface/subsegment, a point, or a tet of background mesh.</span>
<a name="l04990"></a>04990 
<a name="l04991"></a>04991 <span class="keyword">inline</span> tetgenmesh::tetrahedron tetgenmesh::point2tet(point pt) {
<a name="l04992"></a>04992   <span class="keywordflow">return</span> ((tetrahedron *) (pt))[point2simindex];
<a name="l04993"></a>04993 }
<a name="l04994"></a>04994 
<a name="l04995"></a>04995 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setpoint2tet(point pt, tetrahedron value) {
<a name="l04996"></a>04996   ((tetrahedron *) (pt))[point2simindex] = value;
<a name="l04997"></a>04997 }
<a name="l04998"></a>04998 
<a name="l04999"></a>04999 <span class="keyword">inline</span> tetgenmesh::shellface tetgenmesh::point2sh(point pt) {
<a name="l05000"></a>05000   <span class="keywordflow">return</span> (shellface) ((tetrahedron *) (pt))[point2simindex + 1];
<a name="l05001"></a>05001 }
<a name="l05002"></a>05002 
<a name="l05003"></a>05003 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setpoint2sh(point pt, shellface value) {
<a name="l05004"></a>05004   ((tetrahedron *) (pt))[point2simindex + 1] = (tetrahedron) value;
<a name="l05005"></a>05005 }
<a name="l05006"></a>05006 
<a name="l05007"></a>05007 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::point2ppt(point pt) {
<a name="l05008"></a>05008   <span class="keywordflow">return</span> (point) ((tetrahedron *) (pt))[point2simindex + 2];
<a name="l05009"></a>05009 }
<a name="l05010"></a>05010 
<a name="l05011"></a>05011 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setpoint2ppt(point pt, point value) {
<a name="l05012"></a>05012   ((tetrahedron *) (pt))[point2simindex + 2] = (tetrahedron) value;
<a name="l05013"></a>05013 }
<a name="l05014"></a>05014 
<a name="l05015"></a>05015 <span class="keyword">inline</span> tetgenmesh::tetrahedron tetgenmesh::point2bgmtet(point pt) {
<a name="l05016"></a>05016   <span class="keywordflow">return</span> ((tetrahedron *) (pt))[point2simindex + 3];
<a name="l05017"></a>05017 }
<a name="l05018"></a>05018 
<a name="l05019"></a>05019 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setpoint2bgmtet(point pt, tetrahedron value) {
<a name="l05020"></a>05020   ((tetrahedron *) (pt))[point2simindex + 3] = value;
<a name="l05021"></a>05021 }
<a name="l05022"></a>05022 
<a name="l05023"></a>05023 <span class="comment">// These primitives set and read a pointer to its pbc point.</span>
<a name="l05024"></a>05024 
<a name="l05025"></a>05025 <span class="keyword">inline</span> tetgenmesh::point tetgenmesh::point2pbcpt(point pt) {
<a name="l05026"></a>05026   <span class="keywordflow">return</span> (point) ((tetrahedron *) (pt))[point2pbcptindex];
<a name="l05027"></a>05027 }
<a name="l05028"></a>05028 
<a name="l05029"></a>05029 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::setpoint2pbcpt(point pt, point value) {
<a name="l05030"></a>05030   ((tetrahedron *) (pt))[point2pbcptindex] = (tetrahedron) value;
<a name="l05031"></a>05031 }
<a name="l05032"></a>05032 
<a name="l05033"></a>05033 <span class="comment">//</span>
<a name="l05034"></a>05034 <span class="comment">// End of primitives for points</span>
<a name="l05035"></a>05035 <span class="comment">//</span>
<a name="l05036"></a>05036 
<a name="l05037"></a>05037 <span class="comment">//</span>
<a name="l05038"></a>05038 <span class="comment">// Begin of advanced primitives</span>
<a name="l05039"></a>05039 <span class="comment">//</span>
<a name="l05040"></a>05040 
<a name="l05041"></a>05041 <span class="comment">// adjustedgering() adjusts the edge version so that it belongs to the</span>
<a name="l05042"></a>05042 <span class="comment">//   indicated edge ring.  The &#39;direction&#39; only can be 0(CCW) or 1(CW).</span>
<a name="l05043"></a>05043 <span class="comment">//   If the edge is not in the wanted edge ring, reverse it.</span>
<a name="l05044"></a>05044 
<a name="l05045"></a>05045 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::adjustedgering(triface&amp; t, <span class="keywordtype">int</span> direction) {
<a name="l05046"></a>05046   <span class="keywordflow">if</span> (EdgeRing(t.ver) != direction) {
<a name="l05047"></a>05047     esymself(t);
<a name="l05048"></a>05048   }
<a name="l05049"></a>05049 }
<a name="l05050"></a>05050 
<a name="l05051"></a>05051 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::adjustedgering(face&amp; s, <span class="keywordtype">int</span> direction) {
<a name="l05052"></a>05052   <span class="keywordflow">if</span> (EdgeRing(s.shver) != direction) {
<a name="l05053"></a>05053     sesymself(s);
<a name="l05054"></a>05054   }
<a name="l05055"></a>05055 }
<a name="l05056"></a>05056 
<a name="l05057"></a>05057 <span class="comment">// isdead() returns TRUE if the tetrahedron or subface has been dealloced.</span>
<a name="l05058"></a>05058 
<a name="l05059"></a>05059 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::isdead(triface* t) {
<a name="l05060"></a>05060   <span class="keywordflow">if</span> (t-&gt;tet == (tetrahedron *) NULL) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05061"></a>05061   <span class="keywordflow">else</span> <span class="keywordflow">return</span> t-&gt;tet[4] == (tetrahedron) NULL;
<a name="l05062"></a>05062 }
<a name="l05063"></a>05063 
<a name="l05064"></a>05064 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::isdead(face* s) {
<a name="l05065"></a>05065   <span class="keywordflow">if</span> (s-&gt;sh == (shellface *) NULL) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05066"></a>05066   <span class="keywordflow">else</span> <span class="keywordflow">return</span> s-&gt;sh[3] == (shellface) NULL;
<a name="l05067"></a>05067 }
<a name="l05068"></a>05068 
<a name="l05069"></a>05069 <span class="comment">// isfacehaspoint() returns TRUE if the &#39;testpoint&#39; is one of the vertices</span>
<a name="l05070"></a>05070 <span class="comment">//   of the tetface &#39;t&#39; subface &#39;s&#39;.</span>
<a name="l05071"></a>05071 
<a name="l05072"></a>05072 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::isfacehaspoint(triface* t, point testpoint) {
<a name="l05073"></a>05073   <span class="keywordflow">return</span> ((org(*t) == testpoint) || (dest(*t) == testpoint) ||
<a name="l05074"></a>05074           (apex(*t) == testpoint));
<a name="l05075"></a>05075 }
<a name="l05076"></a>05076 
<a name="l05077"></a>05077 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::isfacehaspoint(face* s, point testpoint) {
<a name="l05078"></a>05078   <span class="keywordflow">return</span> (s-&gt;sh[3] == (shellface) testpoint) ||
<a name="l05079"></a>05079          (s-&gt;sh[4] == (shellface) testpoint) ||
<a name="l05080"></a>05080          (s-&gt;sh[5] == (shellface) testpoint);
<a name="l05081"></a>05081 }
<a name="l05082"></a>05082 
<a name="l05083"></a>05083 <span class="comment">// isfacehasedge() returns TRUE if the edge (given by its two endpoints) is</span>
<a name="l05084"></a>05084 <span class="comment">//   one of the three edges of the subface &#39;s&#39;.</span>
<a name="l05085"></a>05085 
<a name="l05086"></a>05086 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::isfacehasedge(face* s, point tend1, point tend2) {
<a name="l05087"></a>05087   <span class="keywordflow">return</span> (isfacehaspoint(s, tend1) &amp;&amp; isfacehaspoint(s, tend2));
<a name="l05088"></a>05088 }
<a name="l05089"></a>05089 
<a name="l05090"></a>05090 <span class="comment">// issymexist() returns TRUE if the adjoining tetrahedron is not &#39;duumytet&#39;.</span>
<a name="l05091"></a>05091 
<a name="l05092"></a>05092 <span class="keyword">inline</span> <span class="keywordtype">bool</span> tetgenmesh::issymexist(triface* t) {
<a name="l05093"></a>05093   tetrahedron *ptr = (tetrahedron *)
<a name="l05094"></a>05094     ((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(t-&gt;tet[t-&gt;loc]) &amp; ~(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)7l);
<a name="l05095"></a>05095   <span class="keywordflow">return</span> ptr != dummytet;
<a name="l05096"></a>05096 }
<a name="l05097"></a>05097 
<a name="l05099"></a>05099 <span class="comment">//                                                                           //</span>
<a name="l05100"></a>05100 <span class="comment">// getnextsface()    Finds the next subface in the face ring.                //</span>
<a name="l05101"></a>05101 <span class="comment">//                                                                           //</span>
<a name="l05102"></a>05102 <span class="comment">// For saving space in the data structure of subface, there only exists one  //</span>
<a name="l05103"></a>05103 <span class="comment">// face ring around a segment (see programming manual).  This routine imple- //</span>
<a name="l05104"></a>05104 <span class="comment">// ments the double face ring as desired in Muecke&#39;s data structure.         //</span>
<a name="l05105"></a>05105 <span class="comment">//                                                                           //</span>
<a name="l05107"></a>05107 <span class="comment"></span>
<a name="l05108"></a>05108 <span class="keywordtype">void</span> tetgenmesh::getnextsface(face* s1, face* s2)
<a name="l05109"></a>05109 {
<a name="l05110"></a>05110   face neighsh, spinsh;
<a name="l05111"></a>05111   face testseg;
<a name="l05112"></a>05112 
<a name="l05113"></a>05113   sspivot(*s1, testseg);
<a name="l05114"></a>05114   <span class="keywordflow">if</span> (testseg.sh != dummysh) {
<a name="l05115"></a>05115     testseg.shver = 0;
<a name="l05116"></a>05116     <span class="keywordflow">if</span> (sorg(testseg) == sorg(*s1)) {
<a name="l05117"></a>05117       spivot(*s1, neighsh);
<a name="l05118"></a>05118     } <span class="keywordflow">else</span> {
<a name="l05119"></a>05119       spinsh = *s1;
<a name="l05120"></a>05120       <span class="keywordflow">do</span> {
<a name="l05121"></a>05121         neighsh = spinsh;
<a name="l05122"></a>05122         spivotself(spinsh);
<a name="l05123"></a>05123       } <span class="keywordflow">while</span> (spinsh.sh != s1-&gt;sh);
<a name="l05124"></a>05124     }
<a name="l05125"></a>05125   } <span class="keywordflow">else</span> {
<a name="l05126"></a>05126     spivot(*s1, neighsh);
<a name="l05127"></a>05127   }
<a name="l05128"></a>05128   <span class="keywordflow">if</span> (sorg(neighsh) != sorg(*s1)) {
<a name="l05129"></a>05129     sesymself(neighsh);
<a name="l05130"></a>05130   }
<a name="l05131"></a>05131   <span class="keywordflow">if</span> (s2 != (face *) NULL) {
<a name="l05132"></a>05132     *s2 = neighsh;
<a name="l05133"></a>05133   } <span class="keywordflow">else</span> {
<a name="l05134"></a>05134     *s1 = neighsh;
<a name="l05135"></a>05135   }
<a name="l05136"></a>05136 }
<a name="l05137"></a>05137 
<a name="l05139"></a>05139 <span class="comment">//                                                                           //</span>
<a name="l05140"></a>05140 <span class="comment">// tsspivot()    Finds a subsegment abutting on a tetrahderon&#39;s edge.        //</span>
<a name="l05141"></a>05141 <span class="comment">//                                                                           //</span>
<a name="l05142"></a>05142 <span class="comment">// The edge is represented in the primary edge of &#39;checkedge&#39;. If there is a //</span>
<a name="l05143"></a>05143 <span class="comment">// subsegment bonded at this edge, it is returned in handle &#39;checkseg&#39;, the  //</span>
<a name="l05144"></a>05144 <span class="comment">// edge direction of &#39;checkseg&#39; is conformed to &#39;checkedge&#39;. If there isn&#39;t, //</span>
<a name="l05145"></a>05145 <span class="comment">// set &#39;checkseg.sh = dummysh&#39; to indicate it is not a subsegment.           //</span>
<a name="l05146"></a>05146 <span class="comment">//                                                                           //</span>
<a name="l05147"></a>05147 <span class="comment">// To find whether an edge of a tetrahedron is a subsegment or not. First we //</span>
<a name="l05148"></a>05148 <span class="comment">// need find a subface around this edge to see if it contains a subsegment.  //</span>
<a name="l05149"></a>05149 <span class="comment">// The reason is there is no direct connection between a tetrahedron and its //</span>
<a name="l05150"></a>05150 <span class="comment">// adjoining subsegments.                                                    //</span>
<a name="l05151"></a>05151 <span class="comment">//                                                                           //</span>
<a name="l05153"></a>05153 <span class="comment"></span>
<a name="l05154"></a>05154 <span class="keywordtype">void</span> tetgenmesh::tsspivot(triface* checkedge, face* checkseg)
<a name="l05155"></a>05155 {
<a name="l05156"></a>05156   triface spintet;
<a name="l05157"></a>05157   face parentsh;
<a name="l05158"></a>05158   point tapex;
<a name="l05159"></a>05159   <span class="keywordtype">int</span> hitbdry;
<a name="l05160"></a>05160 
<a name="l05161"></a>05161   spintet = *checkedge;
<a name="l05162"></a>05162   tapex = apex(*checkedge);
<a name="l05163"></a>05163   hitbdry = 0;
<a name="l05164"></a>05164   <span class="keywordflow">do</span> {
<a name="l05165"></a>05165     tspivot(spintet, parentsh);
<a name="l05166"></a>05166     <span class="comment">// Does spintet have a (non-fake) subface attached?</span>
<a name="l05167"></a>05167     <span class="keywordflow">if</span> ((parentsh.sh != dummysh) &amp;&amp; (sapex(parentsh) != NULL)) {
<a name="l05168"></a>05168       <span class="comment">// Find a subface! Find the edge in it.</span>
<a name="l05169"></a>05169       findedge(&amp;parentsh, org(*checkedge), dest(*checkedge));
<a name="l05170"></a>05170       sspivot(parentsh, *checkseg);
<a name="l05171"></a>05171       <span class="keywordflow">if</span> (checkseg-&gt;sh != dummysh) {
<a name="l05172"></a>05172         <span class="comment">// Find a subsegment! Correct its edge direction before return.</span>
<a name="l05173"></a>05173         <span class="keywordflow">if</span> (sorg(*checkseg) != org(*checkedge)) {
<a name="l05174"></a>05174           sesymself(*checkseg);
<a name="l05175"></a>05175         }
<a name="l05176"></a>05176       }
<a name="l05177"></a>05177       <span class="keywordflow">return</span>;
<a name="l05178"></a>05178     }
<a name="l05179"></a>05179     <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l05180"></a>05180       hitbdry++;
<a name="l05181"></a>05181       <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l05182"></a>05182         esym(*checkedge, spintet);
<a name="l05183"></a>05183         <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l05184"></a>05184           hitbdry++;
<a name="l05185"></a>05185         }
<a name="l05186"></a>05186       }
<a name="l05187"></a>05187     }
<a name="l05188"></a>05188   } <span class="keywordflow">while</span> ((apex(spintet) != tapex) &amp;&amp; (hitbdry &lt; 2));
<a name="l05189"></a>05189   <span class="comment">// Not find.</span>
<a name="l05190"></a>05190   checkseg-&gt;sh = dummysh;
<a name="l05191"></a>05191 }
<a name="l05192"></a>05192 
<a name="l05194"></a>05194 <span class="comment">//                                                                           //</span>
<a name="l05195"></a>05195 <span class="comment">// sstpivot()    Finds a tetrahedron abutting a subsegment.                  //</span>
<a name="l05196"></a>05196 <span class="comment">//                                                                           //</span>
<a name="l05197"></a>05197 <span class="comment">// This is the inverse operation of &#39;tsspivot()&#39;.  One subsegment shared by  //</span>
<a name="l05198"></a>05198 <span class="comment">// arbitrary number of tetrahedron, the returned tetrahedron is not unique.  //</span>
<a name="l05199"></a>05199 <span class="comment">// The edge direction of the returned tetrahedron is conformed to the given  //</span>
<a name="l05200"></a>05200 <span class="comment">// subsegment.                                                               //</span>
<a name="l05201"></a>05201 <span class="comment">//                                                                           //</span>
<a name="l05203"></a>05203 <span class="comment"></span>
<a name="l05204"></a>05204 <span class="keywordtype">void</span> tetgenmesh::sstpivot(face* checkseg, triface* retedge)
<a name="l05205"></a>05205 {
<a name="l05206"></a>05206   face parentsh;
<a name="l05207"></a>05207 
<a name="l05208"></a>05208   <span class="comment">// Get the subface which holds the subsegment.</span>
<a name="l05209"></a>05209   sdecode(checkseg-&gt;sh[0], parentsh);
<a name="l05210"></a>05210 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l05211"></a>05211 <span class="preprocessor"></span>  assert(parentsh.sh != dummysh);
<a name="l05212"></a>05212 <span class="preprocessor">#endif</span>
<a name="l05213"></a>05213 <span class="preprocessor"></span>  <span class="comment">// Get a tetraheron to which the subface attches.</span>
<a name="l05214"></a>05214   stpivot(parentsh, *retedge);
<a name="l05215"></a>05215   <span class="keywordflow">if</span> (retedge-&gt;tet == dummytet) {
<a name="l05216"></a>05216     sesymself(parentsh);
<a name="l05217"></a>05217     stpivot(parentsh, *retedge);
<a name="l05218"></a>05218 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l05219"></a>05219 <span class="preprocessor"></span>    assert(retedge-&gt;tet != dummytet);
<a name="l05220"></a>05220 <span class="preprocessor">#endif</span>
<a name="l05221"></a>05221 <span class="preprocessor"></span>  }
<a name="l05222"></a>05222   <span class="comment">// Correct the edge direction before return.</span>
<a name="l05223"></a>05223   findedge(retedge, sorg(*checkseg), sdest(*checkseg));
<a name="l05224"></a>05224 }
<a name="l05225"></a>05225 
<a name="l05227"></a>05227 <span class="comment">//                                                                           //</span>
<a name="l05228"></a>05228 <span class="comment">// findorg()    Finds a point in the given handle (tetrahedron or subface).  //</span>
<a name="l05229"></a>05229 <span class="comment">//                                                                           //</span>
<a name="l05230"></a>05230 <span class="comment">// If &#39;dorg&#39; is a one of vertices of the given handle,  set the origin of    //</span>
<a name="l05231"></a>05231 <span class="comment">// this handle be that point and return TRUE.  Otherwise, return FALSE and   //</span>
<a name="l05232"></a>05232 <span class="comment">// &#39;tface&#39; remains unchanged.                                                //</span>
<a name="l05233"></a>05233 <span class="comment">//                                                                           //</span>
<a name="l05235"></a>05235 <span class="comment"></span>
<a name="l05236"></a>05236 <span class="keywordtype">bool</span> tetgenmesh::findorg(triface* tface, point dorg)
<a name="l05237"></a>05237 {
<a name="l05238"></a>05238   <span class="keywordflow">if</span> (org(*tface) == dorg) {
<a name="l05239"></a>05239     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05240"></a>05240   } <span class="keywordflow">else</span> {
<a name="l05241"></a>05241     <span class="keywordflow">if</span> (dest(*tface) == dorg) {
<a name="l05242"></a>05242       enextself(*tface);
<a name="l05243"></a>05243       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05244"></a>05244     } <span class="keywordflow">else</span> {
<a name="l05245"></a>05245       <span class="keywordflow">if</span> (apex(*tface) == dorg) {
<a name="l05246"></a>05246         enext2self(*tface);
<a name="l05247"></a>05247         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05248"></a>05248       } <span class="keywordflow">else</span> {
<a name="l05249"></a>05249         <span class="keywordflow">if</span> (oppo(*tface) == dorg) {
<a name="l05250"></a>05250           <span class="comment">// Keep &#39;tface&#39; referring to the same tet after fnext().</span>
<a name="l05251"></a>05251           adjustedgering(*tface, CCW);
<a name="l05252"></a>05252           fnextself(*tface);
<a name="l05253"></a>05253           enext2self(*tface);
<a name="l05254"></a>05254           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05255"></a>05255         }
<a name="l05256"></a>05256       }
<a name="l05257"></a>05257     }
<a name="l05258"></a>05258   }
<a name="l05259"></a>05259   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05260"></a>05260 }
<a name="l05261"></a>05261 
<a name="l05262"></a>05262 <span class="keywordtype">bool</span> tetgenmesh::findorg(face* sface, point dorg)
<a name="l05263"></a>05263 {
<a name="l05264"></a>05264   <span class="keywordflow">if</span> (sorg(*sface) == dorg) {
<a name="l05265"></a>05265     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05266"></a>05266   } <span class="keywordflow">else</span> {
<a name="l05267"></a>05267     <span class="keywordflow">if</span> (sdest(*sface) == dorg) {
<a name="l05268"></a>05268       senextself(*sface);
<a name="l05269"></a>05269       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05270"></a>05270     } <span class="keywordflow">else</span> {
<a name="l05271"></a>05271       <span class="keywordflow">if</span> (sapex(*sface) == dorg) {
<a name="l05272"></a>05272         senext2self(*sface);
<a name="l05273"></a>05273         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l05274"></a>05274       }
<a name="l05275"></a>05275     }
<a name="l05276"></a>05276   }
<a name="l05277"></a>05277   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l05278"></a>05278 }
<a name="l05279"></a>05279 
<a name="l05281"></a>05281 <span class="comment">//                                                                           //</span>
<a name="l05282"></a>05282 <span class="comment">// findedge()    Find an edge in the given handle (tetrahedron or subface).  //</span>
<a name="l05283"></a>05283 <span class="comment">//                                                                           //</span>
<a name="l05284"></a>05284 <span class="comment">// The edge is given in two points &#39;eorg&#39; and &#39;edest&#39;.  It is assumed that   //</span>
<a name="l05285"></a>05285 <span class="comment">// the edge must exist in the given handle (tetrahedron or subface).  This   //</span>
<a name="l05286"></a>05286 <span class="comment">// routine sets the right edge version for the input handle.                 //</span>
<a name="l05287"></a>05287 <span class="comment">//                                                                           //</span>
<a name="l05289"></a>05289 <span class="comment"></span>
<a name="l05290"></a>05290 <span class="keywordtype">void</span> tetgenmesh::findedge(triface* tface, point eorg, point edest)
<a name="l05291"></a>05291 {
<a name="l05292"></a>05292   <span class="keywordtype">int</span> i;
<a name="l05293"></a>05293 
<a name="l05294"></a>05294   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l05295"></a>05295     <span class="keywordflow">if</span> (org(*tface) == eorg) {
<a name="l05296"></a>05296       <span class="keywordflow">if</span> (dest(*tface) == edest) {
<a name="l05297"></a>05297         <span class="comment">// Edge is found, return.</span>
<a name="l05298"></a>05298         <span class="keywordflow">return</span>;
<a name="l05299"></a>05299       }
<a name="l05300"></a>05300     } <span class="keywordflow">else</span> {
<a name="l05301"></a>05301       <span class="keywordflow">if</span> (org(*tface) == edest) {
<a name="l05302"></a>05302         <span class="keywordflow">if</span> (dest(*tface) == eorg) {
<a name="l05303"></a>05303           <span class="comment">// Edge is found, inverse the direction and return.</span>
<a name="l05304"></a>05304           esymself(*tface);
<a name="l05305"></a>05305           <span class="keywordflow">return</span>;
<a name="l05306"></a>05306         }
<a name="l05307"></a>05307       }
<a name="l05308"></a>05308     }
<a name="l05309"></a>05309     enextself(*tface);
<a name="l05310"></a>05310   }
<a name="l05311"></a>05311   <span class="comment">// It should never be here.</span>
<a name="l05312"></a>05312   printf(<span class="stringliteral">&quot;Internalerror in findedge():  Unable to find an edge in tet.\n&quot;</span>);
<a name="l05313"></a>05313   internalerror();
<a name="l05314"></a>05314 }
<a name="l05315"></a>05315 
<a name="l05316"></a>05316 <span class="keywordtype">void</span> tetgenmesh::findedge(face* sface, point eorg, point edest)
<a name="l05317"></a>05317 {
<a name="l05318"></a>05318   <span class="keywordtype">int</span> i;
<a name="l05319"></a>05319 
<a name="l05320"></a>05320   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l05321"></a>05321     <span class="keywordflow">if</span> (sorg(*sface) == eorg) {
<a name="l05322"></a>05322       <span class="keywordflow">if</span> (sdest(*sface) == edest) {
<a name="l05323"></a>05323         <span class="comment">// Edge is found, return.</span>
<a name="l05324"></a>05324         <span class="keywordflow">return</span>;
<a name="l05325"></a>05325       }
<a name="l05326"></a>05326     } <span class="keywordflow">else</span> {
<a name="l05327"></a>05327       <span class="keywordflow">if</span> (sorg(*sface) == edest) {
<a name="l05328"></a>05328         <span class="keywordflow">if</span> (sdest(*sface) == eorg) {
<a name="l05329"></a>05329           <span class="comment">// Edge is found, inverse the direction and return.</span>
<a name="l05330"></a>05330           sesymself(*sface);
<a name="l05331"></a>05331           <span class="keywordflow">return</span>;
<a name="l05332"></a>05332         }
<a name="l05333"></a>05333       }
<a name="l05334"></a>05334     }
<a name="l05335"></a>05335     senextself(*sface);
<a name="l05336"></a>05336   }
<a name="l05337"></a>05337   printf(<span class="stringliteral">&quot;Internalerror in findedge():  Unable to find an edge in subface.\n&quot;</span>);
<a name="l05338"></a>05338   internalerror();
<a name="l05339"></a>05339 }
<a name="l05340"></a>05340 
<a name="l05342"></a>05342 <span class="comment">//                                                                           //</span>
<a name="l05343"></a>05343 <span class="comment">// findface()    Find the face has the given origin, destination and apex.   //</span>
<a name="l05344"></a>05344 <span class="comment">//                                                                           //</span>
<a name="l05345"></a>05345 <span class="comment">// On input, &#39;fface&#39; is a handle which may contain the three corners or may  //</span>
<a name="l05346"></a>05346 <span class="comment">// not or may be dead.  On return, it represents exactly the face with the   //</span>
<a name="l05347"></a>05347 <span class="comment">// given origin, destination and apex.                                       //</span>
<a name="l05348"></a>05348 <span class="comment">//                                                                           //</span>
<a name="l05350"></a>05350 <span class="comment"></span>
<a name="l05351"></a>05351 <span class="keywordtype">void</span> tetgenmesh::findface(triface *fface, point forg, point fdest, point fapex)
<a name="l05352"></a>05352 {
<a name="l05353"></a>05353   triface spintet;
<a name="l05354"></a>05354   <span class="keyword">enum</span> finddirectionresult collinear;
<a name="l05355"></a>05355   <span class="keywordtype">int</span> hitbdry;
<a name="l05356"></a>05356 
<a name="l05357"></a>05357   <span class="keywordflow">if</span> (!isdead(fface)) {
<a name="l05358"></a>05358     <span class="comment">// First check the easiest case, that &#39;fface&#39; is just the right one.</span>
<a name="l05359"></a>05359     <span class="keywordflow">if</span> (org(*fface) == forg &amp;&amp; dest(*fface) == fdest &amp;&amp;
<a name="l05360"></a>05360         apex(*fface) == fapex) <span class="keywordflow">return</span>;
<a name="l05361"></a>05361   } <span class="keywordflow">else</span> {
<a name="l05362"></a>05362     <span class="comment">// The input handle is dead, use the &#39;recenttet&#39; if it is alive.</span>
<a name="l05363"></a>05363     <span class="keywordflow">if</span> (!isdead(&amp;recenttet)) *fface = recenttet;
<a name="l05364"></a>05364   }
<a name="l05365"></a>05365 
<a name="l05366"></a>05366   <span class="keywordflow">if</span> (!isdead(fface)) {
<a name="l05367"></a>05367     <span class="keywordflow">if</span> (!findorg(fface, forg)) {
<a name="l05368"></a>05368       <span class="comment">// &#39;forg&#39; is not a corner of &#39;fface&#39;, locate it.</span>
<a name="l05369"></a>05369       preciselocate(forg, fface, tetrahedrons-&gt;items);
<a name="l05370"></a>05370     }
<a name="l05371"></a>05371     <span class="comment">// It is possible that forg is not found in a non-convex mesh.</span>
<a name="l05372"></a>05372     <span class="keywordflow">if</span> (org(*fface) == forg) {
<a name="l05373"></a>05373       collinear = finddirection(fface, fdest, tetrahedrons-&gt;items);
<a name="l05374"></a>05374       <span class="keywordflow">if</span> (collinear == RIGHTCOLLINEAR) {
<a name="l05375"></a>05375         <span class="comment">// fdest is just the destination.</span>
<a name="l05376"></a>05376       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == LEFTCOLLINEAR) {
<a name="l05377"></a>05377         enext2self(*fface);
<a name="l05378"></a>05378         esymself(*fface);
<a name="l05379"></a>05379       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == TOPCOLLINEAR) {
<a name="l05380"></a>05380         fnextself(*fface);
<a name="l05381"></a>05381         enext2self(*fface);
<a name="l05382"></a>05382         esymself(*fface);
<a name="l05383"></a>05383       }
<a name="l05384"></a>05384     }
<a name="l05385"></a>05385     <span class="comment">// It is possible taht fdest is not found in a non-convex mesh.</span>
<a name="l05386"></a>05386     <span class="keywordflow">if</span> ((org(*fface) == forg) &amp;&amp; (dest(*fface) == fdest)) {
<a name="l05387"></a>05387       <span class="comment">// Find the apex of &#39;fapex&#39;.</span>
<a name="l05388"></a>05388       spintet = *fface;
<a name="l05389"></a>05389       hitbdry = 0;
<a name="l05390"></a>05390       <span class="keywordflow">do</span> {
<a name="l05391"></a>05391         <span class="keywordflow">if</span> (apex(spintet) == fapex) {
<a name="l05392"></a>05392           <span class="comment">// We have done. Be careful the edge direction of &#39;spintet&#39;,</span>
<a name="l05393"></a>05393           <span class="comment">//   it may reversed because of hitting boundary once.</span>
<a name="l05394"></a>05394           <span class="keywordflow">if</span> (org(spintet) != org(*fface)) {
<a name="l05395"></a>05395             esymself(spintet);
<a name="l05396"></a>05396           }
<a name="l05397"></a>05397           *fface = spintet;
<a name="l05398"></a>05398           <span class="keywordflow">return</span>;
<a name="l05399"></a>05399         }
<a name="l05400"></a>05400         <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l05401"></a>05401           hitbdry ++;
<a name="l05402"></a>05402           <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l05403"></a>05403             esym(*fface, spintet);
<a name="l05404"></a>05404             <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l05405"></a>05405               hitbdry ++;
<a name="l05406"></a>05406             }
<a name="l05407"></a>05407           }
<a name="l05408"></a>05408         }
<a name="l05409"></a>05409       } <span class="keywordflow">while</span> (hitbdry &lt; 2 &amp;&amp; apex(spintet) != apex(*fface));
<a name="l05410"></a>05410       <span class="comment">// It is possible that fapex is not found in a non-convex mesh.</span>
<a name="l05411"></a>05411     }
<a name="l05412"></a>05412   }
<a name="l05413"></a>05413 
<a name="l05414"></a>05414   <span class="keywordflow">if</span> (isdead(fface) || (org(*fface) != forg) || (dest(*fface) != fdest) ||
<a name="l05415"></a>05415       (apex(*fface) != fapex)) {
<a name="l05416"></a>05416     <span class="comment">// Too bad, the input handle is useless. We have to find a handle</span>
<a name="l05417"></a>05417     <span class="comment">//   for &#39;fface&#39; contains the &#39;forg&#39; and &#39;fdest&#39;. Here a brute force</span>
<a name="l05418"></a>05418     <span class="comment">//   search is performed.</span>
<a name="l05419"></a>05419     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l05420"></a>05420       printf(<span class="stringliteral">&quot;Warning in findface():  Perform a brute-force searching.\n&quot;</span>);
<a name="l05421"></a>05421     }
<a name="l05422"></a>05422     <span class="keyword">enum</span> verttype forgty, fdestty, fapexty;
<a name="l05423"></a>05423     <span class="keywordtype">int</span> share, i;
<a name="l05424"></a>05424     forgty = pointtype(forg);
<a name="l05425"></a>05425     fdestty = pointtype(fdest);
<a name="l05426"></a>05426     fapexty = pointtype(fapex);
<a name="l05427"></a>05427     setpointtype(forg, DEADVERTEX);
<a name="l05428"></a>05428     setpointtype(fdest, DEADVERTEX);
<a name="l05429"></a>05429     setpointtype(fapex, DEADVERTEX);
<a name="l05430"></a>05430     tetrahedrons-&gt;traversalinit();
<a name="l05431"></a>05431     fface-&gt;tet = tetrahedrontraverse();
<a name="l05432"></a>05432     <span class="keywordflow">while</span> (fface-&gt;tet != (tetrahedron *) NULL) {
<a name="l05433"></a>05433       share = 0;
<a name="l05434"></a>05434       <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l05435"></a>05435         <span class="keywordflow">if</span> (pointtype((point) fface-&gt;tet[4 + i]) == DEADVERTEX) share ++;
<a name="l05436"></a>05436       }
<a name="l05437"></a>05437       <span class="keywordflow">if</span> (share == 3) {
<a name="l05438"></a>05438         <span class="comment">// Found! Set the correct face and desired corners.</span>
<a name="l05439"></a>05439         <span class="keywordflow">if</span> (pointtype((point) fface-&gt;tet[4]) != DEADVERTEX) {
<a name="l05440"></a>05440           fface-&gt;loc = 2;
<a name="l05441"></a>05441         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pointtype((point) fface-&gt;tet[5]) != DEADVERTEX) {
<a name="l05442"></a>05442           fface-&gt;loc = 3;
<a name="l05443"></a>05443         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pointtype((point) fface-&gt;tet[6]) != DEADVERTEX) {
<a name="l05444"></a>05444           fface-&gt;loc = 1;
<a name="l05445"></a>05445         } <span class="keywordflow">else</span> { <span class="comment">// pointtype((point) fface-&gt;tet[7]) != DEADVERTEX</span>
<a name="l05446"></a>05446           fface-&gt;loc = 0;
<a name="l05447"></a>05447         }
<a name="l05448"></a>05448         findedge(fface, forg, fdest);
<a name="l05449"></a>05449         <span class="keywordflow">break</span>;
<a name="l05450"></a>05450       }
<a name="l05451"></a>05451       fface-&gt;tet = tetrahedrontraverse();
<a name="l05452"></a>05452     }
<a name="l05453"></a>05453     setpointtype(forg, forgty);
<a name="l05454"></a>05454     setpointtype(fdest, fdestty);
<a name="l05455"></a>05455     setpointtype(fapex, fapexty);
<a name="l05456"></a>05456     <span class="keywordflow">if</span> (fface-&gt;tet == (tetrahedron *) NULL) {
<a name="l05457"></a>05457       <span class="comment">// It is impossible to reach here.</span>
<a name="l05458"></a>05458       printf(<span class="stringliteral">&quot;Internal error:  Fail to find the indicated face.\n&quot;</span>);
<a name="l05459"></a>05459       internalerror();
<a name="l05460"></a>05460     }
<a name="l05461"></a>05461   }
<a name="l05462"></a>05462 }
<a name="l05463"></a>05463 
<a name="l05465"></a>05465 <span class="comment">//                                                                           //</span>
<a name="l05466"></a>05466 <span class="comment">// getonextseg()    Get the next SEGMENT counterclockwise with the same org. //</span>
<a name="l05467"></a>05467 <span class="comment">//                                                                           //</span>
<a name="l05468"></a>05468 <span class="comment">// &#39;s&#39; is a subface. This routine reteuns the segment which is counterclock- //</span>
<a name="l05469"></a>05469 <span class="comment">// wise with the origin of s.                                                //</span>
<a name="l05470"></a>05470 <span class="comment">//                                                                           //</span>
<a name="l05472"></a>05472 <span class="comment"></span>
<a name="l05473"></a>05473 <span class="keywordtype">void</span> tetgenmesh::getonextseg(face* s, face* lseg)
<a name="l05474"></a>05474 {
<a name="l05475"></a>05475   face checksh, checkseg;
<a name="l05476"></a>05476   point forg;
<a name="l05477"></a>05477 
<a name="l05478"></a>05478   forg = sorg(*s);
<a name="l05479"></a>05479   checksh = *s;
<a name="l05480"></a>05480   <span class="keywordflow">do</span> {
<a name="l05481"></a>05481     <span class="comment">// Go to the edge at forg&#39;s left side.</span>
<a name="l05482"></a>05482     senext2self(checksh);
<a name="l05483"></a>05483     <span class="comment">// Check if there is a segment attaching this edge.</span>
<a name="l05484"></a>05484     sspivot(checksh, checkseg);
<a name="l05485"></a>05485     <span class="keywordflow">if</span> (checkseg.sh != dummysh) <span class="keywordflow">break</span>;
<a name="l05486"></a>05486     <span class="comment">// No segment! Go to the neighbor of this subface.</span>
<a name="l05487"></a>05487     spivotself(checksh);
<a name="l05488"></a>05488 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l05489"></a>05489 <span class="preprocessor"></span>    <span class="comment">// It should always meet a segment before come back.</span>
<a name="l05490"></a>05490     assert(checksh.sh != s-&gt;sh);
<a name="l05491"></a>05491 <span class="preprocessor">#endif</span>
<a name="l05492"></a>05492 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (sorg(checksh) != forg) {
<a name="l05493"></a>05493       sesymself(checksh);
<a name="l05494"></a>05494 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l05495"></a>05495 <span class="preprocessor"></span>      assert(sorg(checksh) == forg);
<a name="l05496"></a>05496 <span class="preprocessor">#endif</span>
<a name="l05497"></a>05497 <span class="preprocessor"></span>    }
<a name="l05498"></a>05498   } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l05499"></a>05499   <span class="keywordflow">if</span> (sorg(checkseg) != forg) sesymself(checkseg);
<a name="l05500"></a>05500   *lseg = checkseg;
<a name="l05501"></a>05501 }
<a name="l05502"></a>05502 
<a name="l05504"></a>05504 <span class="comment">//                                                                           //</span>
<a name="l05505"></a>05505 <span class="comment">// getseghasorg()    Get the segment containing the given point.             //</span>
<a name="l05506"></a>05506 <span class="comment">//                                                                           //</span>
<a name="l05507"></a>05507 <span class="comment">// &#39;dorg&#39; is an endpoint of a segment S. &#39;sseg&#39; is a subsegment of S. This   //</span>
<a name="l05508"></a>05508 <span class="comment">// routine search a subsegment (along sseg) of S containing dorg. On return, //</span>
<a name="l05509"></a>05509 <span class="comment">// &#39;sseg&#39; contains &#39;dorg&#39; as its origin.                                     //</span>
<a name="l05510"></a>05510 <span class="comment">//                                                                           //</span>
<a name="l05512"></a>05512 <span class="comment"></span>
<a name="l05513"></a>05513 <span class="keywordtype">void</span> tetgenmesh::getseghasorg(face* sseg, point dorg)
<a name="l05514"></a>05514 {
<a name="l05515"></a>05515   face nextseg;
<a name="l05516"></a>05516   point checkpt;
<a name="l05517"></a>05517 
<a name="l05518"></a>05518   nextseg = *sseg;
<a name="l05519"></a>05519   checkpt = sorg(nextseg);
<a name="l05520"></a>05520   <span class="keywordflow">while</span> ((checkpt != dorg) &amp;&amp; (pointtype(checkpt) == FREESEGVERTEX)) {
<a name="l05521"></a>05521     <span class="comment">// Search dorg along the original direction of sseg.</span>
<a name="l05522"></a>05522     senext2self(nextseg);
<a name="l05523"></a>05523     spivotself(nextseg);
<a name="l05524"></a>05524     nextseg.shver = 0;
<a name="l05525"></a>05525     <span class="keywordflow">if</span> (sdest(nextseg) != checkpt) sesymself(nextseg);
<a name="l05526"></a>05526     checkpt = sorg(nextseg);
<a name="l05527"></a>05527   }
<a name="l05528"></a>05528   <span class="keywordflow">if</span> (checkpt == dorg) {
<a name="l05529"></a>05529     *sseg = nextseg;
<a name="l05530"></a>05530     <span class="keywordflow">return</span>;
<a name="l05531"></a>05531   }
<a name="l05532"></a>05532   nextseg = *sseg;
<a name="l05533"></a>05533   checkpt = sdest(nextseg);
<a name="l05534"></a>05534   <span class="keywordflow">while</span> ((checkpt != dorg) &amp;&amp; (pointtype(checkpt) == FREESEGVERTEX)) {
<a name="l05535"></a>05535     <span class="comment">// Search dorg along the destinational direction of sseg.</span>
<a name="l05536"></a>05536     senextself(nextseg);
<a name="l05537"></a>05537     spivotself(nextseg);
<a name="l05538"></a>05538     nextseg.shver = 0;
<a name="l05539"></a>05539     <span class="keywordflow">if</span> (sorg(nextseg) != checkpt) sesymself(nextseg);
<a name="l05540"></a>05540     checkpt = sdest(nextseg);
<a name="l05541"></a>05541   }
<a name="l05542"></a>05542   <span class="keywordflow">if</span> (checkpt == dorg) {
<a name="l05543"></a>05543     sesym(nextseg, *sseg);
<a name="l05544"></a>05544     <span class="keywordflow">return</span>;
<a name="l05545"></a>05545   }
<a name="l05546"></a>05546   <span class="comment">// Should never be here.</span>
<a name="l05547"></a>05547   printf(<span class="stringliteral">&quot;Internalerror in getseghasorg():  Unable to find the subseg.\n&quot;</span>);
<a name="l05548"></a>05548   internalerror();
<a name="l05549"></a>05549 }
<a name="l05550"></a>05550 
<a name="l05552"></a>05552 <span class="comment">//                                                                           //</span>
<a name="l05553"></a>05553 <span class="comment">// getsubsegfarorg()    Get the origin of the parent segment of a subseg.    //</span>
<a name="l05554"></a>05554 <span class="comment">//                                                                           //</span>
<a name="l05556"></a>05556 <span class="comment"></span>
<a name="l05557"></a>05557 tetgenmesh::point tetgenmesh::getsubsegfarorg(face* sseg)
<a name="l05558"></a>05558 {
<a name="l05559"></a>05559   face prevseg;
<a name="l05560"></a>05560   point checkpt;
<a name="l05561"></a>05561 
<a name="l05562"></a>05562   checkpt = sorg(*sseg);
<a name="l05563"></a>05563   senext2(*sseg, prevseg);
<a name="l05564"></a>05564   spivotself(prevseg);
<a name="l05565"></a>05565   <span class="comment">// Search dorg along the original direction of sseg.</span>
<a name="l05566"></a>05566   <span class="keywordflow">while</span> (prevseg.sh != dummysh) {
<a name="l05567"></a>05567     prevseg.shver = 0;
<a name="l05568"></a>05568     <span class="keywordflow">if</span> (sdest(prevseg) != checkpt) sesymself(prevseg);
<a name="l05569"></a>05569     checkpt = sorg(prevseg);
<a name="l05570"></a>05570     senext2self(prevseg);
<a name="l05571"></a>05571     spivotself(prevseg);
<a name="l05572"></a>05572   }
<a name="l05573"></a>05573   <span class="keywordflow">return</span> checkpt;
<a name="l05574"></a>05574 }
<a name="l05575"></a>05575 
<a name="l05577"></a>05577 <span class="comment">//                                                                           //</span>
<a name="l05578"></a>05578 <span class="comment">// getsubsegfardest()    Get the dest. of the parent segment of a subseg.    //</span>
<a name="l05579"></a>05579 <span class="comment">//                                                                           //</span>
<a name="l05581"></a>05581 <span class="comment"></span>
<a name="l05582"></a>05582 tetgenmesh::point tetgenmesh::getsubsegfardest(face* sseg)
<a name="l05583"></a>05583 {
<a name="l05584"></a>05584   face nextseg;
<a name="l05585"></a>05585   point checkpt;
<a name="l05586"></a>05586 
<a name="l05587"></a>05587   checkpt = sdest(*sseg);
<a name="l05588"></a>05588   senext(*sseg, nextseg);
<a name="l05589"></a>05589   spivotself(nextseg);
<a name="l05590"></a>05590   <span class="comment">// Search dorg along the destinational direction of sseg.</span>
<a name="l05591"></a>05591   <span class="keywordflow">while</span> (nextseg.sh != dummysh) {
<a name="l05592"></a>05592     nextseg.shver = 0;
<a name="l05593"></a>05593     <span class="keywordflow">if</span> (sorg(nextseg) != checkpt) sesymself(nextseg);
<a name="l05594"></a>05594     checkpt = sdest(nextseg);
<a name="l05595"></a>05595     senextself(nextseg);
<a name="l05596"></a>05596     spivotself(nextseg);
<a name="l05597"></a>05597   }
<a name="l05598"></a>05598   <span class="keywordflow">return</span> checkpt;
<a name="l05599"></a>05599 }
<a name="l05600"></a>05600 
<a name="l05602"></a>05602 <span class="comment">//                                                                           //</span>
<a name="l05603"></a>05603 <span class="comment">// printtet()    Print out the details of a tetrahedron on screen.           //</span>
<a name="l05604"></a>05604 <span class="comment">//                                                                           //</span>
<a name="l05605"></a>05605 <span class="comment">// It&#39;s also used when the highest level of verbosity (`-VVV&#39;) is specified. //</span>
<a name="l05606"></a>05606 <span class="comment">//                                                                           //</span>
<a name="l05608"></a>05608 <span class="comment"></span>
<a name="l05609"></a>05609 <span class="keywordtype">void</span> tetgenmesh::printtet(triface* tface)
<a name="l05610"></a>05610 {
<a name="l05611"></a>05611   triface tmpface, prtface;
<a name="l05612"></a>05612   point tmppt;
<a name="l05613"></a>05613   face tmpsh;
<a name="l05614"></a>05614   <span class="keywordtype">int</span> facecount;
<a name="l05615"></a>05615 
<a name="l05616"></a>05616   printf(<span class="stringliteral">&quot;Tetra x%lx with loc(%i) and ver(%i):&quot;</span>,
<a name="l05617"></a>05617          (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(tface-&gt;tet), tface-&gt;loc, tface-&gt;ver);
<a name="l05618"></a>05618   <span class="keywordflow">if</span> (infected(*tface)) {
<a name="l05619"></a>05619     printf(<span class="stringliteral">&quot; (infected)&quot;</span>);
<a name="l05620"></a>05620   }
<a name="l05621"></a>05621   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l05622"></a>05622 
<a name="l05623"></a>05623   tmpface = *tface;
<a name="l05624"></a>05624   facecount = 0;
<a name="l05625"></a>05625   <span class="keywordflow">while</span>(facecount &lt; 4) {
<a name="l05626"></a>05626     tmpface.loc = facecount;
<a name="l05627"></a>05627     sym(tmpface, prtface);
<a name="l05628"></a>05628     <span class="keywordflow">if</span>(prtface.tet == dummytet) {
<a name="l05629"></a>05629       printf(<span class="stringliteral">&quot;      [%i] Outer space.\n&quot;</span>, facecount);
<a name="l05630"></a>05630     } <span class="keywordflow">else</span> {
<a name="l05631"></a>05631       printf(<span class="stringliteral">&quot;      [%i] x%lx  loc(%i).&quot;</span>, facecount,
<a name="l05632"></a>05632              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prtface.tet), prtface.loc);
<a name="l05633"></a>05633       <span class="keywordflow">if</span> (infected(prtface)) {
<a name="l05634"></a>05634         printf(<span class="stringliteral">&quot; (infected)&quot;</span>);
<a name="l05635"></a>05635       }
<a name="l05636"></a>05636       printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l05637"></a>05637     }
<a name="l05638"></a>05638     facecount ++;
<a name="l05639"></a>05639   }
<a name="l05640"></a>05640 
<a name="l05641"></a>05641   tmppt = org(*tface);
<a name="l05642"></a>05642   <span class="keywordflow">if</span>(tmppt == (point) NULL) {
<a name="l05643"></a>05643     printf(<span class="stringliteral">&quot;      Org [%i] NULL\n&quot;</span>, locver2org[tface-&gt;loc][tface-&gt;ver]);
<a name="l05644"></a>05644   } <span class="keywordflow">else</span> {
<a name="l05645"></a>05645     printf(<span class="stringliteral">&quot;      Org [%i] x%lx (%.12g,%.12g,%.12g) %d\n&quot;</span>,
<a name="l05646"></a>05646            locver2org[tface-&gt;loc][tface-&gt;ver], (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(tmppt),
<a name="l05647"></a>05647            tmppt[0], tmppt[1], tmppt[2], pointmark(tmppt));
<a name="l05648"></a>05648   }
<a name="l05649"></a>05649   tmppt = dest(*tface);
<a name="l05650"></a>05650   <span class="keywordflow">if</span>(tmppt == (point) NULL) {
<a name="l05651"></a>05651     printf(<span class="stringliteral">&quot;      Dest[%i] NULL\n&quot;</span>, locver2dest[tface-&gt;loc][tface-&gt;ver]);
<a name="l05652"></a>05652   } <span class="keywordflow">else</span> {
<a name="l05653"></a>05653     printf(<span class="stringliteral">&quot;      Dest[%i] x%lx (%.12g,%.12g,%.12g) %d\n&quot;</span>,
<a name="l05654"></a>05654            locver2dest[tface-&gt;loc][tface-&gt;ver], (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(tmppt),
<a name="l05655"></a>05655            tmppt[0], tmppt[1], tmppt[2], pointmark(tmppt));
<a name="l05656"></a>05656   }
<a name="l05657"></a>05657   tmppt = apex(*tface);
<a name="l05658"></a>05658   <span class="keywordflow">if</span>(tmppt == (point) NULL) {
<a name="l05659"></a>05659     printf(<span class="stringliteral">&quot;      Apex[%i] NULL\n&quot;</span>, locver2apex[tface-&gt;loc][tface-&gt;ver]);
<a name="l05660"></a>05660   } <span class="keywordflow">else</span> {
<a name="l05661"></a>05661     printf(<span class="stringliteral">&quot;      Apex[%i] x%lx (%.12g,%.12g,%.12g) %d\n&quot;</span>,
<a name="l05662"></a>05662            locver2apex[tface-&gt;loc][tface-&gt;ver], (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(tmppt),
<a name="l05663"></a>05663            tmppt[0], tmppt[1], tmppt[2], pointmark(tmppt));
<a name="l05664"></a>05664   }
<a name="l05665"></a>05665   tmppt = oppo(*tface);
<a name="l05666"></a>05666   <span class="keywordflow">if</span>(tmppt == (point) NULL) {
<a name="l05667"></a>05667     printf(<span class="stringliteral">&quot;      Oppo[%i] NULL\n&quot;</span>, loc2oppo[tface-&gt;loc]);
<a name="l05668"></a>05668   } <span class="keywordflow">else</span> {
<a name="l05669"></a>05669     printf(<span class="stringliteral">&quot;      Oppo[%i] x%lx (%.12g,%.12g,%.12g) %d\n&quot;</span>,
<a name="l05670"></a>05670            loc2oppo[tface-&gt;loc], (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(tmppt),
<a name="l05671"></a>05671            tmppt[0], tmppt[1], tmppt[2], pointmark(tmppt));
<a name="l05672"></a>05672   }
<a name="l05673"></a>05673 
<a name="l05674"></a>05674   <span class="keywordflow">if</span> (b-&gt;useshelles) {
<a name="l05675"></a>05675     tmpface = *tface;
<a name="l05676"></a>05676     facecount = 0;
<a name="l05677"></a>05677     <span class="keywordflow">while</span>(facecount &lt; 6) {
<a name="l05678"></a>05678       tmpface.loc = facecount;
<a name="l05679"></a>05679       tspivot(tmpface, tmpsh);
<a name="l05680"></a>05680       <span class="keywordflow">if</span>(tmpsh.sh != dummysh) {
<a name="l05681"></a>05681         printf(<span class="stringliteral">&quot;      [%i] x%lx  ID(%i) &quot;</span>, facecount,
<a name="l05682"></a>05682                (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(tmpsh.sh), shellmark(tmpsh));
<a name="l05683"></a>05683         <span class="keywordflow">if</span> (sorg(tmpsh) == (point) NULL) {
<a name="l05684"></a>05684           printf(<span class="stringliteral">&quot;(fake)&quot;</span>);
<a name="l05685"></a>05685         }
<a name="l05686"></a>05686         printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l05687"></a>05687       }
<a name="l05688"></a>05688       facecount ++;
<a name="l05689"></a>05689     }
<a name="l05690"></a>05690   }
<a name="l05691"></a>05691 }
<a name="l05692"></a>05692 
<a name="l05694"></a>05694 <span class="comment">//                                                                           //</span>
<a name="l05695"></a>05695 <span class="comment">// printsh()    Print out the details of a subface or subsegment on screen.  //</span>
<a name="l05696"></a>05696 <span class="comment">//                                                                           //</span>
<a name="l05697"></a>05697 <span class="comment">// It&#39;s also used when the highest level of verbosity (`-VVV&#39;) is specified. //</span>
<a name="l05698"></a>05698 <span class="comment">//                                                                           //</span>
<a name="l05700"></a>05700 <span class="comment"></span>
<a name="l05701"></a>05701 <span class="keywordtype">void</span> tetgenmesh::printsh(face* sface)
<a name="l05702"></a>05702 {
<a name="l05703"></a>05703   face prtsh;
<a name="l05704"></a>05704   triface prttet;
<a name="l05705"></a>05705   point printpoint;
<a name="l05706"></a>05706 
<a name="l05707"></a>05707   <span class="keywordflow">if</span> (sapex(*sface) != NULL) {
<a name="l05708"></a>05708     printf(<span class="stringliteral">&quot;subface x%lx, ver %d, mark %d:&quot;</span>,
<a name="l05709"></a>05709            (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(sface-&gt;sh), sface-&gt;shver, shellmark(*sface));
<a name="l05710"></a>05710   } <span class="keywordflow">else</span> {
<a name="l05711"></a>05711     printf(<span class="stringliteral">&quot;Subsegment x%lx, ver %d, mark %d:&quot;</span>,
<a name="l05712"></a>05712            (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(sface-&gt;sh), sface-&gt;shver, shellmark(*sface));
<a name="l05713"></a>05713   }
<a name="l05714"></a>05714   <span class="keywordflow">if</span> (sinfected(*sface)) {
<a name="l05715"></a>05715     printf(<span class="stringliteral">&quot; (infected)&quot;</span>);
<a name="l05716"></a>05716   }
<a name="l05717"></a>05717   <span class="keywordflow">if</span> (shell2badface(*sface)) {
<a name="l05718"></a>05718     printf(<span class="stringliteral">&quot; (queued)&quot;</span>);
<a name="l05719"></a>05719   }
<a name="l05720"></a>05720   <span class="keywordflow">if</span> (sapex(*sface) != NULL) {
<a name="l05721"></a>05721     <span class="keywordflow">if</span> (shelltype(*sface) == SHARP) {
<a name="l05722"></a>05722       printf(<span class="stringliteral">&quot; (sharp)&quot;</span>);
<a name="l05723"></a>05723     }
<a name="l05724"></a>05724   } <span class="keywordflow">else</span> {
<a name="l05725"></a>05725     <span class="keywordflow">if</span> (shelltype(*sface) == SHARP) {
<a name="l05726"></a>05726       printf(<span class="stringliteral">&quot; (sharp)&quot;</span>);
<a name="l05727"></a>05727     }
<a name="l05728"></a>05728   }
<a name="l05729"></a>05729   <span class="keywordflow">if</span> (checkpbcs) {
<a name="l05730"></a>05730     <span class="keywordflow">if</span> (shellpbcgroup(*sface) &gt;= 0) {
<a name="l05731"></a>05731       printf(<span class="stringliteral">&quot; (pbc %d)&quot;</span>, shellpbcgroup(*sface));
<a name="l05732"></a>05732     }
<a name="l05733"></a>05733   }
<a name="l05734"></a>05734   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l05735"></a>05735 
<a name="l05736"></a>05736   sdecode(sface-&gt;sh[0], prtsh);
<a name="l05737"></a>05737   <span class="keywordflow">if</span> (prtsh.sh == dummysh) {
<a name="l05738"></a>05738     printf(<span class="stringliteral">&quot;      [0] = No shell\n&quot;</span>);
<a name="l05739"></a>05739   } <span class="keywordflow">else</span> {
<a name="l05740"></a>05740     printf(<span class="stringliteral">&quot;      [0] = x%lx  %d\n&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prtsh.sh), prtsh.shver);
<a name="l05741"></a>05741   }
<a name="l05742"></a>05742   sdecode(sface-&gt;sh[1], prtsh);
<a name="l05743"></a>05743   <span class="keywordflow">if</span> (prtsh.sh == dummysh) {
<a name="l05744"></a>05744     printf(<span class="stringliteral">&quot;      [1] = No shell\n&quot;</span>);
<a name="l05745"></a>05745   } <span class="keywordflow">else</span> {
<a name="l05746"></a>05746     printf(<span class="stringliteral">&quot;      [1] = x%lx  %d\n&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prtsh.sh), prtsh.shver);
<a name="l05747"></a>05747   }
<a name="l05748"></a>05748   sdecode(sface-&gt;sh[2], prtsh);
<a name="l05749"></a>05749   <span class="keywordflow">if</span> (prtsh.sh == dummysh) {
<a name="l05750"></a>05750     printf(<span class="stringliteral">&quot;      [2] = No shell\n&quot;</span>);
<a name="l05751"></a>05751   } <span class="keywordflow">else</span> {
<a name="l05752"></a>05752     printf(<span class="stringliteral">&quot;      [2] = x%lx  %d\n&quot;</span>, (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prtsh.sh), prtsh.shver);
<a name="l05753"></a>05753   }
<a name="l05754"></a>05754 
<a name="l05755"></a>05755   printpoint = sorg(*sface);
<a name="l05756"></a>05756   <span class="keywordflow">if</span> (printpoint == (point) NULL)
<a name="l05757"></a>05757     printf(<span class="stringliteral">&quot;      Org [%d] = NULL\n&quot;</span>, vo[sface-&gt;shver]);
<a name="l05758"></a>05758   <span class="keywordflow">else</span>
<a name="l05759"></a>05759     printf(<span class="stringliteral">&quot;      Org [%d] = x%lx  (%.12g,%.12g,%.12g) %d\n&quot;</span>,
<a name="l05760"></a>05760            vo[sface-&gt;shver], (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(printpoint), printpoint[0],
<a name="l05761"></a>05761            printpoint[1], printpoint[2], pointmark(printpoint));
<a name="l05762"></a>05762   printpoint = sdest(*sface);
<a name="l05763"></a>05763   <span class="keywordflow">if</span> (printpoint == (point) NULL)
<a name="l05764"></a>05764     printf(<span class="stringliteral">&quot;      Dest[%d] = NULL\n&quot;</span>, vd[sface-&gt;shver]);
<a name="l05765"></a>05765   <span class="keywordflow">else</span>
<a name="l05766"></a>05766     printf(<span class="stringliteral">&quot;      Dest[%d] = x%lx  (%.12g,%.12g,%.12g) %d\n&quot;</span>,
<a name="l05767"></a>05767             vd[sface-&gt;shver], (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(printpoint), printpoint[0],
<a name="l05768"></a>05768             printpoint[1], printpoint[2], pointmark(printpoint));
<a name="l05769"></a>05769 
<a name="l05770"></a>05770   <span class="keywordflow">if</span> (sapex(*sface) != NULL) {
<a name="l05771"></a>05771     printpoint = sapex(*sface);
<a name="l05772"></a>05772     <span class="keywordflow">if</span> (printpoint == (point) NULL)
<a name="l05773"></a>05773       printf(<span class="stringliteral">&quot;      Apex[%d] = NULL\n&quot;</span>, va[sface-&gt;shver]);
<a name="l05774"></a>05774     <span class="keywordflow">else</span>
<a name="l05775"></a>05775       printf(<span class="stringliteral">&quot;      Apex[%d] = x%lx  (%.12g,%.12g,%.12g) %d\n&quot;</span>,
<a name="l05776"></a>05776              va[sface-&gt;shver], (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(printpoint), printpoint[0],
<a name="l05777"></a>05777              printpoint[1], printpoint[2], pointmark(printpoint));
<a name="l05778"></a>05778 
<a name="l05779"></a>05779     decode(sface-&gt;sh[6], prttet);
<a name="l05780"></a>05780     <span class="keywordflow">if</span> (prttet.tet == dummytet) {
<a name="l05781"></a>05781       printf(<span class="stringliteral">&quot;      [6] = Outer space\n&quot;</span>);
<a name="l05782"></a>05782     } <span class="keywordflow">else</span> {
<a name="l05783"></a>05783       printf(<span class="stringliteral">&quot;      [6] = x%lx  %d\n&quot;</span>,
<a name="l05784"></a>05784              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prttet.tet), prttet.loc);
<a name="l05785"></a>05785     }
<a name="l05786"></a>05786     decode(sface-&gt;sh[7], prttet);
<a name="l05787"></a>05787     <span class="keywordflow">if</span> (prttet.tet == dummytet) {
<a name="l05788"></a>05788       printf(<span class="stringliteral">&quot;      [7] = Outer space\n&quot;</span>);
<a name="l05789"></a>05789     } <span class="keywordflow">else</span> {
<a name="l05790"></a>05790       printf(<span class="stringliteral">&quot;      [7] = x%lx  %d\n&quot;</span>,
<a name="l05791"></a>05791              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prttet.tet), prttet.loc);
<a name="l05792"></a>05792     }
<a name="l05793"></a>05793 
<a name="l05794"></a>05794     sdecode(sface-&gt;sh[8], prtsh);
<a name="l05795"></a>05795     <span class="keywordflow">if</span> (prtsh.sh == dummysh) {
<a name="l05796"></a>05796       printf(<span class="stringliteral">&quot;      [8] = No subsegment\n&quot;</span>);
<a name="l05797"></a>05797     } <span class="keywordflow">else</span> {
<a name="l05798"></a>05798       printf(<span class="stringliteral">&quot;      [8] = x%lx  %d\n&quot;</span>,
<a name="l05799"></a>05799              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prtsh.sh), prtsh.shver);
<a name="l05800"></a>05800     }
<a name="l05801"></a>05801     sdecode(sface-&gt;sh[9], prtsh);
<a name="l05802"></a>05802     <span class="keywordflow">if</span> (prtsh.sh == dummysh) {
<a name="l05803"></a>05803       printf(<span class="stringliteral">&quot;      [9] = No subsegment\n&quot;</span>);
<a name="l05804"></a>05804     } <span class="keywordflow">else</span> {
<a name="l05805"></a>05805       printf(<span class="stringliteral">&quot;      [9] = x%lx  %d\n&quot;</span>,
<a name="l05806"></a>05806              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prtsh.sh), prtsh.shver);
<a name="l05807"></a>05807     }
<a name="l05808"></a>05808     sdecode(sface-&gt;sh[10], prtsh);
<a name="l05809"></a>05809     <span class="keywordflow">if</span> (prtsh.sh == dummysh) {
<a name="l05810"></a>05810       printf(<span class="stringliteral">&quot;      [10]= No subsegment\n&quot;</span>);
<a name="l05811"></a>05811     } <span class="keywordflow">else</span> {
<a name="l05812"></a>05812       printf(<span class="stringliteral">&quot;      [10]= x%lx  %d\n&quot;</span>,
<a name="l05813"></a>05813              (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)(prtsh.sh), prtsh.shver);
<a name="l05814"></a>05814     }
<a name="l05815"></a>05815   }
<a name="l05816"></a>05816 }
<a name="l05817"></a>05817 
<a name="l05818"></a>05818 <span class="comment">//</span>
<a name="l05819"></a>05819 <span class="comment">// End of advanced primitives</span>
<a name="l05820"></a>05820 <span class="comment">//</span>
<a name="l05821"></a>05821 
<a name="l05822"></a>05822 <span class="comment">//</span>
<a name="l05823"></a>05823 <span class="comment">// End of mesh manipulation primitives</span>
<a name="l05824"></a>05824 <span class="comment">//</span>
<a name="l05825"></a>05825 
<a name="l05826"></a>05826 <span class="comment">//</span>
<a name="l05827"></a>05827 <span class="comment">// Begin of mesh items searching routines</span>
<a name="l05828"></a>05828 <span class="comment">//</span>
<a name="l05829"></a>05829 
<a name="l05831"></a>05831 <span class="comment">//                                                                           //</span>
<a name="l05832"></a>05832 <span class="comment">// makepoint2tetmap()    Construct a mapping from points to tetrahedra.      //</span>
<a name="l05833"></a>05833 <span class="comment">//                                                                           //</span>
<a name="l05834"></a>05834 <span class="comment">// Traverses all the tetrahedra,  provides each corner of each tetrahedron   //</span>
<a name="l05835"></a>05835 <span class="comment">// with a pointer to that tetrahedera.  Some pointers will be overwritten by //</span>
<a name="l05836"></a>05836 <span class="comment">// other pointers because each point may be a corner of several tetrahedra,  //</span>
<a name="l05837"></a>05837 <span class="comment">// but in the end every point will point to a tetrahedron that contains it.  //</span>
<a name="l05838"></a>05838 <span class="comment">//                                                                           //</span>
<a name="l05840"></a>05840 <span class="comment"></span>
<a name="l05841"></a>05841 <span class="keywordtype">void</span> tetgenmesh::makepoint2tetmap()
<a name="l05842"></a>05842 {
<a name="l05843"></a>05843   triface tetloop;
<a name="l05844"></a>05844   point pointptr;
<a name="l05845"></a>05845 
<a name="l05846"></a>05846   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l05847"></a>05847     printf(<span class="stringliteral">&quot;  Constructing mapping from points to tetrahedra.\n&quot;</span>);
<a name="l05848"></a>05848   }
<a name="l05849"></a>05849 
<a name="l05850"></a>05850   <span class="comment">// Initialize the point2tet field of each point.</span>
<a name="l05851"></a>05851   points-&gt;traversalinit();
<a name="l05852"></a>05852   pointptr = pointtraverse();
<a name="l05853"></a>05853   <span class="keywordflow">while</span> (pointptr != (point) NULL) {
<a name="l05854"></a>05854     setpoint2tet(pointptr, (tetrahedron) NULL);
<a name="l05855"></a>05855     pointptr = pointtraverse();
<a name="l05856"></a>05856   }
<a name="l05857"></a>05857 
<a name="l05858"></a>05858   tetrahedrons-&gt;traversalinit();
<a name="l05859"></a>05859   tetloop.tet = tetrahedrontraverse();
<a name="l05860"></a>05860   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l05861"></a>05861     <span class="comment">// Check all four points of the tetrahedron.</span>
<a name="l05862"></a>05862     tetloop.loc = 0;
<a name="l05863"></a>05863     pointptr = org(tetloop);
<a name="l05864"></a>05864     setpoint2tet(pointptr, encode(tetloop));
<a name="l05865"></a>05865     pointptr = dest(tetloop);
<a name="l05866"></a>05866     setpoint2tet(pointptr, encode(tetloop));
<a name="l05867"></a>05867     pointptr = apex(tetloop);
<a name="l05868"></a>05868     setpoint2tet(pointptr, encode(tetloop));
<a name="l05869"></a>05869     pointptr = oppo(tetloop);
<a name="l05870"></a>05870     setpoint2tet(pointptr, encode(tetloop));
<a name="l05871"></a>05871     <span class="comment">// Get the next tetrahedron in the list.</span>
<a name="l05872"></a>05872     tetloop.tet = tetrahedrontraverse();
<a name="l05873"></a>05873   }
<a name="l05874"></a>05874 }
<a name="l05875"></a>05875 
<a name="l05877"></a>05877 <span class="comment">//                                                                           //</span>
<a name="l05878"></a>05878 <span class="comment">// makeindex2pointmap()    Create a map from index to vertices.              //</span>
<a name="l05879"></a>05879 <span class="comment">//                                                                           //</span>
<a name="l05880"></a>05880 <span class="comment">// &#39;idx2verlist&#39; returns the created map.  Traverse all vertices, a pointer  //</span>
<a name="l05881"></a>05881 <span class="comment">// to each vertex is set into the array.  The pointer to the first vertex is //</span>
<a name="l05882"></a>05882 <span class="comment">// saved in &#39;idx2verlist[0]&#39;.  Don&#39;t forget to minus &#39;in-&gt;firstnumber&#39; when  //</span>
<a name="l05883"></a>05883 <span class="comment">// to get the vertex form its index.                                         //</span>
<a name="l05884"></a>05884 <span class="comment">//                                                                           //</span>
<a name="l05886"></a>05886 <span class="comment"></span>
<a name="l05887"></a>05887 <span class="keywordtype">void</span> tetgenmesh::makeindex2pointmap(point*&amp; idx2verlist)
<a name="l05888"></a>05888 {
<a name="l05889"></a>05889   point pointloop;
<a name="l05890"></a>05890   <span class="keywordtype">int</span> idx;
<a name="l05891"></a>05891 
<a name="l05892"></a>05892   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l05893"></a>05893     printf(<span class="stringliteral">&quot;  Constructing mapping from indices to points.\n&quot;</span>);
<a name="l05894"></a>05894   }
<a name="l05895"></a>05895 
<a name="l05896"></a>05896   idx2verlist = <span class="keyword">new</span> point[points-&gt;items];
<a name="l05897"></a>05897 
<a name="l05898"></a>05898   points-&gt;traversalinit();
<a name="l05899"></a>05899   pointloop = pointtraverse();
<a name="l05900"></a>05900   idx = 0;
<a name="l05901"></a>05901   <span class="keywordflow">while</span> (pointloop != (point) NULL) {
<a name="l05902"></a>05902     idx2verlist[idx] = pointloop;
<a name="l05903"></a>05903     idx++;
<a name="l05904"></a>05904     pointloop = pointtraverse();
<a name="l05905"></a>05905   }
<a name="l05906"></a>05906 }
<a name="l05907"></a>05907 
<a name="l05909"></a>05909 <span class="comment">//                                                                           //</span>
<a name="l05910"></a>05910 <span class="comment">// makesegmentmap()    Create a map from vertices (their indices) to         //</span>
<a name="l05911"></a>05911 <span class="comment">//                     segments incident at the same vertices.               //</span>
<a name="l05912"></a>05912 <span class="comment">//                                                                           //</span>
<a name="l05913"></a>05913 <span class="comment">// Two arrays &#39;idx2seglist&#39; and &#39;segsperverlist&#39; together return the map.    //</span>
<a name="l05914"></a>05914 <span class="comment">// They form a sparse matrix structure with size (n + 1) x (n + 1), n is the //</span>
<a name="l05915"></a>05915 <span class="comment">// number of segments.  idx2seglist contains row information and             //</span>
<a name="l05916"></a>05916 <span class="comment">// segsperverlist contains all (non-zero) elements.  The i-th entry of       //</span>
<a name="l05917"></a>05917 <span class="comment">// idx2seglist is the starting position of i-th row&#39;s (non-zero) elements in //</span>
<a name="l05918"></a>05918 <span class="comment">// segsperverlist.  The number of elements of i-th row is calculated by the  //</span>
<a name="l05919"></a>05919 <span class="comment">// (i+1)-th entry minus i-th entry of idx2seglist.                           //</span>
<a name="l05920"></a>05920 <span class="comment">//                                                                           //</span>
<a name="l05921"></a>05921 <span class="comment">// NOTE: These two arrays will be created inside this routine, don&#39;t forget  //</span>
<a name="l05922"></a>05922 <span class="comment">// to free them after using.                                                 //</span>
<a name="l05923"></a>05923 <span class="comment">//                                                                           //</span>
<a name="l05925"></a>05925 <span class="comment"></span>
<a name="l05926"></a>05926 <span class="keywordtype">void</span> tetgenmesh::makesegmentmap(<span class="keywordtype">int</span>*&amp; idx2seglist, shellface**&amp; segsperverlist)
<a name="l05927"></a>05927 {
<a name="l05928"></a>05928   shellface *shloop;
<a name="l05929"></a>05929   <span class="keywordtype">int</span> i, j, k;
<a name="l05930"></a>05930 
<a name="l05931"></a>05931   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l05932"></a>05932     printf(<span class="stringliteral">&quot;  Constructing mapping from points to segments.\n&quot;</span>);
<a name="l05933"></a>05933   }
<a name="l05934"></a>05934 
<a name="l05935"></a>05935   <span class="comment">// Create and initialize &#39;idx2seglist&#39;.</span>
<a name="l05936"></a>05936   idx2seglist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l05937"></a>05937   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) idx2seglist[i] = 0;
<a name="l05938"></a>05938 
<a name="l05939"></a>05939   <span class="comment">// Loop the set of segments once, counter the number of segments sharing</span>
<a name="l05940"></a>05940   <span class="comment">//   each vertex.</span>
<a name="l05941"></a>05941   subsegs-&gt;traversalinit();
<a name="l05942"></a>05942   shloop = shellfacetraverse(subsegs);
<a name="l05943"></a>05943   <span class="keywordflow">while</span> (shloop != (shellface *) NULL) {
<a name="l05944"></a>05944     <span class="comment">// Increment the number of sharing segments for each endpoint.</span>
<a name="l05945"></a>05945     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l05946"></a>05946       j = pointmark((point) shloop[3 + i]) - in-&gt;firstnumber;
<a name="l05947"></a>05947       idx2seglist[j]++;
<a name="l05948"></a>05948     }
<a name="l05949"></a>05949     shloop = shellfacetraverse(subsegs);
<a name="l05950"></a>05950   }
<a name="l05951"></a>05951 
<a name="l05952"></a>05952   <span class="comment">// Calculate the total length of array &#39;facesperverlist&#39;.</span>
<a name="l05953"></a>05953   j = idx2seglist[0];
<a name="l05954"></a>05954   idx2seglist[0] = 0;  <span class="comment">// Array starts from 0 element.</span>
<a name="l05955"></a>05955   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items; i++) {
<a name="l05956"></a>05956     k = idx2seglist[i + 1];
<a name="l05957"></a>05957     idx2seglist[i + 1] = idx2seglist[i] + j;
<a name="l05958"></a>05958     j = k;
<a name="l05959"></a>05959   }
<a name="l05960"></a>05960   <span class="comment">// The total length is in the last unit of idx2seglist.</span>
<a name="l05961"></a>05961   segsperverlist = <span class="keyword">new</span> shellface*[idx2seglist[i]];
<a name="l05962"></a>05962   <span class="comment">// Loop the set of segments again, set the info. of segments per vertex.</span>
<a name="l05963"></a>05963   subsegs-&gt;traversalinit();
<a name="l05964"></a>05964   shloop = shellfacetraverse(subsegs);
<a name="l05965"></a>05965   <span class="keywordflow">while</span> (shloop != (shellface *) NULL) {
<a name="l05966"></a>05966     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l05967"></a>05967       j = pointmark((point) shloop[3 + i]) - in-&gt;firstnumber;
<a name="l05968"></a>05968       segsperverlist[idx2seglist[j]] = shloop;
<a name="l05969"></a>05969       idx2seglist[j]++;
<a name="l05970"></a>05970     }
<a name="l05971"></a>05971     shloop = shellfacetraverse(subsegs);
<a name="l05972"></a>05972   }
<a name="l05973"></a>05973   <span class="comment">// Contents in &#39;idx2seglist&#39; are shifted, now shift them back.</span>
<a name="l05974"></a>05974   <span class="keywordflow">for</span> (i = points-&gt;items - 1; i &gt;= 0; i--) {
<a name="l05975"></a>05975     idx2seglist[i + 1] = idx2seglist[i];
<a name="l05976"></a>05976   }
<a name="l05977"></a>05977   idx2seglist[0] = 0;
<a name="l05978"></a>05978 }
<a name="l05979"></a>05979 
<a name="l05981"></a>05981 <span class="comment">//                                                                           //</span>
<a name="l05982"></a>05982 <span class="comment">// makesubfacemap()    Create a map from vertices (their indices) to         //</span>
<a name="l05983"></a>05983 <span class="comment">//                     subfaces incident at the same vertices.               //</span>
<a name="l05984"></a>05984 <span class="comment">//                                                                           //</span>
<a name="l05985"></a>05985 <span class="comment">// Two arrays &#39;idx2facelist&#39; and &#39;facesperverlist&#39; together return the map.  //</span>
<a name="l05986"></a>05986 <span class="comment">// They form a sparse matrix structure with size (n + 1) x (n + 1), n is the //</span>
<a name="l05987"></a>05987 <span class="comment">// number of subfaces.  idx2facelist contains row information and            //</span>
<a name="l05988"></a>05988 <span class="comment">// facesperverlist contains all (non-zero) elements.  The i-th entry of      //</span>
<a name="l05989"></a>05989 <span class="comment">// idx2facelist is the starting position of i-th row&#39;s(non-zero) elements in //</span>
<a name="l05990"></a>05990 <span class="comment">// facesperverlist.  The number of elements of i-th row is calculated by the //</span>
<a name="l05991"></a>05991 <span class="comment">// (i+1)-th entry minus i-th entry of idx2facelist.                          //</span>
<a name="l05992"></a>05992 <span class="comment">//                                                                           //</span>
<a name="l05993"></a>05993 <span class="comment">// NOTE: These two arrays will be created inside this routine, don&#39;t forget  //</span>
<a name="l05994"></a>05994 <span class="comment">// to free them after using.                                                 //</span>
<a name="l05995"></a>05995 <span class="comment">//                                                                           //</span>
<a name="l05997"></a>05997 <span class="comment"></span>
<a name="l05998"></a>05998 <span class="keywordtype">void</span> tetgenmesh::
<a name="l05999"></a>05999 makesubfacemap(<span class="keywordtype">int</span>*&amp; idx2facelist, shellface**&amp; facesperverlist)
<a name="l06000"></a>06000 {
<a name="l06001"></a>06001   shellface *shloop;
<a name="l06002"></a>06002   <span class="keywordtype">int</span> i, j, k;
<a name="l06003"></a>06003 
<a name="l06004"></a>06004   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l06005"></a>06005     printf(<span class="stringliteral">&quot;  Constructing mapping from points to subfaces.\n&quot;</span>);
<a name="l06006"></a>06006   }
<a name="l06007"></a>06007 
<a name="l06008"></a>06008   <span class="comment">// Create and initialize &#39;idx2facelist&#39;.</span>
<a name="l06009"></a>06009   idx2facelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l06010"></a>06010   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) idx2facelist[i] = 0;
<a name="l06011"></a>06011 
<a name="l06012"></a>06012   <span class="comment">// Loop the set of subfaces once, counter the number of subfaces sharing</span>
<a name="l06013"></a>06013   <span class="comment">//   each vertex.</span>
<a name="l06014"></a>06014   subfaces-&gt;traversalinit();
<a name="l06015"></a>06015   shloop = shellfacetraverse(subfaces);
<a name="l06016"></a>06016   <span class="keywordflow">while</span> (shloop != (shellface *) NULL) {
<a name="l06017"></a>06017     <span class="comment">// Increment the number of sharing segments for each endpoint.</span>
<a name="l06018"></a>06018     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l06019"></a>06019       j = pointmark((point) shloop[3 + i]) - in-&gt;firstnumber;
<a name="l06020"></a>06020       idx2facelist[j]++;
<a name="l06021"></a>06021     }
<a name="l06022"></a>06022     shloop = shellfacetraverse(subfaces);
<a name="l06023"></a>06023   }
<a name="l06024"></a>06024 
<a name="l06025"></a>06025   <span class="comment">// Calculate the total length of array &#39;facesperverlist&#39;.</span>
<a name="l06026"></a>06026   j = idx2facelist[0];
<a name="l06027"></a>06027   idx2facelist[0] = 0;  <span class="comment">// Array starts from 0 element.</span>
<a name="l06028"></a>06028   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items; i++) {
<a name="l06029"></a>06029     k = idx2facelist[i + 1];
<a name="l06030"></a>06030     idx2facelist[i + 1] = idx2facelist[i] + j;
<a name="l06031"></a>06031     j = k;
<a name="l06032"></a>06032   }
<a name="l06033"></a>06033   <span class="comment">// The total length is in the last unit of idx2facelist.</span>
<a name="l06034"></a>06034   facesperverlist = <span class="keyword">new</span> shellface*[idx2facelist[i]];
<a name="l06035"></a>06035   <span class="comment">// Loop the set of segments again, set the info. of segments per vertex.</span>
<a name="l06036"></a>06036   subfaces-&gt;traversalinit();
<a name="l06037"></a>06037   shloop = shellfacetraverse(subfaces);
<a name="l06038"></a>06038   <span class="keywordflow">while</span> (shloop != (shellface *) NULL) {
<a name="l06039"></a>06039     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l06040"></a>06040       j = pointmark((point) shloop[3 + i]) - in-&gt;firstnumber;
<a name="l06041"></a>06041       facesperverlist[idx2facelist[j]] = shloop;
<a name="l06042"></a>06042       idx2facelist[j]++;
<a name="l06043"></a>06043     }
<a name="l06044"></a>06044     shloop = shellfacetraverse(subfaces);
<a name="l06045"></a>06045   }
<a name="l06046"></a>06046   <span class="comment">// Contents in &#39;idx2facelist&#39; are shifted, now shift them back.</span>
<a name="l06047"></a>06047   <span class="keywordflow">for</span> (i = points-&gt;items - 1; i &gt;= 0; i--) {
<a name="l06048"></a>06048     idx2facelist[i + 1] = idx2facelist[i];
<a name="l06049"></a>06049   }
<a name="l06050"></a>06050   idx2facelist[0] = 0;
<a name="l06051"></a>06051 }
<a name="l06052"></a>06052 
<a name="l06054"></a>06054 <span class="comment">//                                                                           //</span>
<a name="l06055"></a>06055 <span class="comment">// maketetrahedronmap()    Create a map from vertices (their indices) to     //</span>
<a name="l06056"></a>06056 <span class="comment">//                         tetrahedra incident at the same vertices.         //</span>
<a name="l06057"></a>06057 <span class="comment">//                                                                           //</span>
<a name="l06058"></a>06058 <span class="comment">// Two arrays &#39;idx2tetlist&#39; and &#39;tetsperverlist&#39; together return the map.    //</span>
<a name="l06059"></a>06059 <span class="comment">// They form a sparse matrix structure with size (n + 1) x (n + 1), n is the //</span>
<a name="l06060"></a>06060 <span class="comment">// number of tetrahedra.  idx2tetlist contains row information and           //</span>
<a name="l06061"></a>06061 <span class="comment">// tetsperverlist contains all (non-zero) elements.  The i-th entry of       //</span>
<a name="l06062"></a>06062 <span class="comment">// idx2tetlist is the starting position of i-th row&#39;s (non-zero) elements in //</span>
<a name="l06063"></a>06063 <span class="comment">// tetsperverlist.  The number of elements of i-th row is calculated by the  //</span>
<a name="l06064"></a>06064 <span class="comment">// (i+1)-th entry minus i-th entry of idx2tetlist.                           //</span>
<a name="l06065"></a>06065 <span class="comment">//                                                                           //</span>
<a name="l06066"></a>06066 <span class="comment">// NOTE: These two arrays will be created inside this routine, don&#39;t forget  //</span>
<a name="l06067"></a>06067 <span class="comment">// to free them after using.                                                 //</span>
<a name="l06068"></a>06068 <span class="comment">//                                                                           //</span>
<a name="l06070"></a>06070 <span class="comment"></span>
<a name="l06071"></a>06071 <span class="keywordtype">void</span> tetgenmesh::
<a name="l06072"></a>06072 maketetrahedronmap(<span class="keywordtype">int</span>*&amp; idx2tetlist, tetrahedron**&amp; tetsperverlist)
<a name="l06073"></a>06073 {
<a name="l06074"></a>06074   tetrahedron *tetloop;
<a name="l06075"></a>06075   <span class="keywordtype">int</span> i, j, k;
<a name="l06076"></a>06076 
<a name="l06077"></a>06077   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l06078"></a>06078     printf(<span class="stringliteral">&quot;  Constructing mapping from points to tetrahedra.\n&quot;</span>);
<a name="l06079"></a>06079   }
<a name="l06080"></a>06080 
<a name="l06081"></a>06081   <span class="comment">// Create and initialize &#39;idx2tetlist&#39;.</span>
<a name="l06082"></a>06082   idx2tetlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l06083"></a>06083   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) idx2tetlist[i] = 0;
<a name="l06084"></a>06084 
<a name="l06085"></a>06085   <span class="comment">// Loop the set of tetrahedra once, counter the number of tetrahedra</span>
<a name="l06086"></a>06086   <span class="comment">//   sharing each vertex.</span>
<a name="l06087"></a>06087   tetrahedrons-&gt;traversalinit();
<a name="l06088"></a>06088   tetloop = tetrahedrontraverse();
<a name="l06089"></a>06089   <span class="keywordflow">while</span> (tetloop != (tetrahedron *) NULL) {
<a name="l06090"></a>06090     <span class="comment">// Increment the number of sharing tetrahedra for each endpoint.</span>
<a name="l06091"></a>06091     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l06092"></a>06092       j = pointmark((point) tetloop[4 + i]) - in-&gt;firstnumber;
<a name="l06093"></a>06093       idx2tetlist[j]++;
<a name="l06094"></a>06094     }
<a name="l06095"></a>06095     tetloop = tetrahedrontraverse();
<a name="l06096"></a>06096   }
<a name="l06097"></a>06097 
<a name="l06098"></a>06098   <span class="comment">// Calculate the total length of array &#39;tetsperverlist&#39;.</span>
<a name="l06099"></a>06099   j = idx2tetlist[0];
<a name="l06100"></a>06100   idx2tetlist[0] = 0;  <span class="comment">// Array starts from 0 element.</span>
<a name="l06101"></a>06101   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items; i++) {
<a name="l06102"></a>06102     k = idx2tetlist[i + 1];
<a name="l06103"></a>06103     idx2tetlist[i + 1] = idx2tetlist[i] + j;
<a name="l06104"></a>06104     j = k;
<a name="l06105"></a>06105   }
<a name="l06106"></a>06106   <span class="comment">// The total length is in the last unit of idx2tetlist.</span>
<a name="l06107"></a>06107   tetsperverlist = <span class="keyword">new</span> tetrahedron*[idx2tetlist[i]];
<a name="l06108"></a>06108   <span class="comment">// Loop the set of tetrahedra again, set the info. of tet. per vertex.</span>
<a name="l06109"></a>06109   tetrahedrons-&gt;traversalinit();
<a name="l06110"></a>06110   tetloop = tetrahedrontraverse();
<a name="l06111"></a>06111   <span class="keywordflow">while</span> (tetloop != (tetrahedron *) NULL) {
<a name="l06112"></a>06112     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l06113"></a>06113       j = pointmark((point) tetloop[4 + i]) - in-&gt;firstnumber;
<a name="l06114"></a>06114       tetsperverlist[idx2tetlist[j]] = tetloop;
<a name="l06115"></a>06115       idx2tetlist[j]++;
<a name="l06116"></a>06116     }
<a name="l06117"></a>06117     tetloop = tetrahedrontraverse();
<a name="l06118"></a>06118   }
<a name="l06119"></a>06119   <span class="comment">// Contents in &#39;idx2tetlist&#39; are shifted, now shift them back.</span>
<a name="l06120"></a>06120   <span class="keywordflow">for</span> (i = points-&gt;items - 1; i &gt;= 0; i--) {
<a name="l06121"></a>06121     idx2tetlist[i + 1] = idx2tetlist[i];
<a name="l06122"></a>06122   }
<a name="l06123"></a>06123   idx2tetlist[0] = 0;
<a name="l06124"></a>06124 }
<a name="l06125"></a>06125 
<a name="l06126"></a>06126 <span class="comment">//</span>
<a name="l06127"></a>06127 <span class="comment">// End of mesh items searching routines</span>
<a name="l06128"></a>06128 <span class="comment">//</span>
<a name="l06129"></a>06129 
<a name="l06130"></a>06130 <span class="comment">//</span>
<a name="l06131"></a>06131 <span class="comment">// Begin of linear algebra functions</span>
<a name="l06132"></a>06132 <span class="comment">//</span>
<a name="l06133"></a>06133 
<a name="l06134"></a>06134 <span class="comment">// dot() returns the dot product: v1 dot v2.</span>
<a name="l06135"></a>06135 
<a name="l06136"></a>06136 <span class="keyword">inline</span> REAL tetgenmesh::dot(REAL* v1, REAL* v2)
<a name="l06137"></a>06137 {
<a name="l06138"></a>06138   <span class="keywordflow">return</span> v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
<a name="l06139"></a>06139 }
<a name="l06140"></a>06140 
<a name="l06141"></a>06141 <span class="comment">// cross() computes the cross product: n = v1 cross v2.</span>
<a name="l06142"></a>06142 
<a name="l06143"></a>06143 <span class="keyword">inline</span> <span class="keywordtype">void</span> tetgenmesh::cross(REAL* v1, REAL* v2, REAL* n)
<a name="l06144"></a>06144 {
<a name="l06145"></a>06145   n[0] =   v1[1] * v2[2] - v2[1] * v1[2];
<a name="l06146"></a>06146   n[1] = -(v1[0] * v2[2] - v2[0] * v1[2]);
<a name="l06147"></a>06147   n[2] =   v1[0] * v2[1] - v2[0] * v1[1];
<a name="l06148"></a>06148 }
<a name="l06149"></a>06149 
<a name="l06150"></a>06150 <span class="comment">// initm44() initializes a 4x4 matrix.</span>
<a name="l06151"></a>06151 <span class="keyword">static</span> <span class="keywordtype">void</span> initm44(REAL a00, REAL a01, REAL a02, REAL a03,
<a name="l06152"></a>06152                     REAL a10, REAL a11, REAL a12, REAL a13,
<a name="l06153"></a>06153                     REAL a20, REAL a21, REAL a22, REAL a23,
<a name="l06154"></a>06154                     REAL a30, REAL a31, REAL a32, REAL a33,
<a name="l06155"></a>06155                     REAL M[4][4])
<a name="l06156"></a>06156 {
<a name="l06157"></a>06157   M[0][0] = a00; M[0][1] = a01; M[0][2] = a02; M[0][3] = a03;
<a name="l06158"></a>06158   M[1][0] = a10; M[1][1] = a11; M[1][2] = a12; M[1][3] = a13;
<a name="l06159"></a>06159   M[2][0] = a20; M[2][1] = a21; M[2][2] = a22; M[2][3] = a23;
<a name="l06160"></a>06160   M[3][0] = a30; M[3][1] = a31; M[3][2] = a32; M[3][3] = a33;
<a name="l06161"></a>06161 }
<a name="l06162"></a>06162 
<a name="l06163"></a>06163 <span class="comment">// m4xm4() multiplies 2 4x4 matrics:  m1 = m1 * m2.</span>
<a name="l06164"></a>06164 <span class="keyword">static</span> <span class="keywordtype">void</span> m4xm4(REAL m1[4][4], REAL m2[4][4])
<a name="l06165"></a>06165 {
<a name="l06166"></a>06166   REAL tmp[4];
<a name="l06167"></a>06167   <span class="keywordtype">int</span> i, j;
<a name="l06168"></a>06168 
<a name="l06169"></a>06169   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {   <span class="comment">// i-th row</span>
<a name="l06170"></a>06170     <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) { <span class="comment">// j-th col</span>
<a name="l06171"></a>06171       tmp[j] = m1[i][0] * m2[0][j] + m1[i][1] * m2[1][j]
<a name="l06172"></a>06172              + m1[i][2] * m2[2][j] + m1[i][3] * m2[3][j];
<a name="l06173"></a>06173     }
<a name="l06174"></a>06174     <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++)
<a name="l06175"></a>06175       m1[i][j] = tmp[j];
<a name="l06176"></a>06176   }
<a name="l06177"></a>06177 }
<a name="l06178"></a>06178 
<a name="l06179"></a>06179 <span class="comment">// m4xv4() multiplies a 4x4 matrix and 4x1 vector: v2 = m * v1</span>
<a name="l06180"></a>06180 <span class="keyword">static</span> <span class="keywordtype">void</span> m4xv4(REAL v2[4], REAL m[4][4], REAL v1[4])
<a name="l06181"></a>06181 {
<a name="l06182"></a>06182   v2[0] = m[0][0]*v1[0] + m[0][1]*v1[1] + m[0][2]*v1[2] + m[0][3]*v1[3];
<a name="l06183"></a>06183   v2[1] = m[1][0]*v1[0] + m[1][1]*v1[1] + m[1][2]*v1[2] + m[1][3]*v1[3];
<a name="l06184"></a>06184   v2[2] = m[2][0]*v1[0] + m[2][1]*v1[1] + m[2][2]*v1[2] + m[2][3]*v1[3];
<a name="l06185"></a>06185   v2[3] = m[3][0]*v1[0] + m[3][1]*v1[1] + m[3][2]*v1[2] + m[3][3]*v1[3];
<a name="l06186"></a>06186 }
<a name="l06187"></a>06187 
<a name="l06189"></a>06189 <span class="comment">//                                                                           //</span>
<a name="l06190"></a>06190 <span class="comment">// lu_decmp()    Compute the LU decomposition of a matrix.                   //</span>
<a name="l06191"></a>06191 <span class="comment">//                                                                           //</span>
<a name="l06192"></a>06192 <span class="comment">// Compute the LU decomposition of a (non-singular) square matrix A using    //</span>
<a name="l06193"></a>06193 <span class="comment">// partial pivoting and implicit row exchanges.  The result is:              //</span>
<a name="l06194"></a>06194 <span class="comment">//     A = P * L * U,                                                        //</span>
<a name="l06195"></a>06195 <span class="comment">// where P is a permutation matrix, L is unit lower triangular, and U is     //</span>
<a name="l06196"></a>06196 <span class="comment">// upper triangular.  The factored form of A is used in combination with     //</span>
<a name="l06197"></a>06197 <span class="comment">// &#39;lu_solve()&#39; to solve linear equations: Ax = b, or invert a matrix.       //</span>
<a name="l06198"></a>06198 <span class="comment">//                                                                           //</span>
<a name="l06199"></a>06199 <span class="comment">// The inputs are a square matrix &#39;lu[N..n+N-1][N..n+N-1]&#39;, it&#39;s size is &#39;n&#39;.//</span>
<a name="l06200"></a>06200 <span class="comment">// On output, &#39;lu&#39; is replaced by the LU decomposition of a rowwise permuta- //</span>
<a name="l06201"></a>06201 <span class="comment">// tion of itself, &#39;ps[N..n+N-1]&#39; is an output vector that records the row   //</span>
<a name="l06202"></a>06202 <span class="comment">// permutation effected by the partial pivoting, effectively,  &#39;ps&#39; array    //</span>
<a name="l06203"></a>06203 <span class="comment">// tells the user what the permutation matrix P is; &#39;d&#39; is output as +1/-1   //</span>
<a name="l06204"></a>06204 <span class="comment">// depending on whether the number of row interchanges was even or odd,      //</span>
<a name="l06205"></a>06205 <span class="comment">// respectively.                                                             //</span>
<a name="l06206"></a>06206 <span class="comment">//                                                                           //</span>
<a name="l06207"></a>06207 <span class="comment">// Return true if the LU decomposition is successfully computed, otherwise,  //</span>
<a name="l06208"></a>06208 <span class="comment">// return false in case that A is a singular matrix.                         //</span>
<a name="l06209"></a>06209 <span class="comment">//                                                                           //</span>
<a name="l06211"></a>06211 <span class="comment"></span>
<a name="l06212"></a>06212 <span class="keywordtype">bool</span> tetgenmesh::lu_decmp(REAL lu[4][4], <span class="keywordtype">int</span> n, <span class="keywordtype">int</span>* ps, REAL* d, <span class="keywordtype">int</span> N)
<a name="l06213"></a>06213 {
<a name="l06214"></a>06214   REAL scales[4];
<a name="l06215"></a>06215   REAL pivot, biggest, mult, tempf;
<a name="l06216"></a>06216   <span class="keywordtype">int</span> pivotindex = 0;
<a name="l06217"></a>06217   <span class="keywordtype">int</span> i, j, k;
<a name="l06218"></a>06218 
<a name="l06219"></a>06219   *d = 1.0;                                      <span class="comment">// No row interchanges yet.</span>
<a name="l06220"></a>06220 
<a name="l06221"></a>06221   <span class="keywordflow">for</span> (i = N; i &lt; n + N; i++) {                             <span class="comment">// For each row.</span>
<a name="l06222"></a>06222     <span class="comment">// Find the largest element in each row for row equilibration</span>
<a name="l06223"></a>06223     biggest = 0.0;
<a name="l06224"></a>06224     <span class="keywordflow">for</span> (j = N; j &lt; n + N; j++)
<a name="l06225"></a>06225       <span class="keywordflow">if</span> (biggest &lt; (tempf = fabs(lu[i][j])))
<a name="l06226"></a>06226         biggest  = tempf;
<a name="l06227"></a>06227     <span class="keywordflow">if</span> (biggest != 0.0)
<a name="l06228"></a>06228       scales[i] = 1.0 / biggest;
<a name="l06229"></a>06229     <span class="keywordflow">else</span> {
<a name="l06230"></a>06230       scales[i] = 0.0;
<a name="l06231"></a>06231       <span class="keywordflow">return</span> <span class="keyword">false</span>;                            <span class="comment">// Zero row: singular matrix.</span>
<a name="l06232"></a>06232     }
<a name="l06233"></a>06233     ps[i] = i;                                 <span class="comment">// Initialize pivot sequence.</span>
<a name="l06234"></a>06234   }
<a name="l06235"></a>06235 
<a name="l06236"></a>06236   <span class="keywordflow">for</span> (k = N; k &lt; n + N - 1; k++) {                      <span class="comment">// For each column.</span>
<a name="l06237"></a>06237     <span class="comment">// Find the largest element in each column to pivot around.</span>
<a name="l06238"></a>06238     biggest = 0.0;
<a name="l06239"></a>06239     <span class="keywordflow">for</span> (i = k; i &lt; n + N; i++) {
<a name="l06240"></a>06240       <span class="keywordflow">if</span> (biggest &lt; (tempf = fabs(lu[ps[i]][k]) * scales[ps[i]])) {
<a name="l06241"></a>06241         biggest = tempf;
<a name="l06242"></a>06242         pivotindex = i;
<a name="l06243"></a>06243       }
<a name="l06244"></a>06244     }
<a name="l06245"></a>06245     <span class="keywordflow">if</span> (biggest == 0.0) {
<a name="l06246"></a>06246       <span class="keywordflow">return</span> <span class="keyword">false</span>;                         <span class="comment">// Zero column: singular matrix.</span>
<a name="l06247"></a>06247     }
<a name="l06248"></a>06248     <span class="keywordflow">if</span> (pivotindex != k) {                         <span class="comment">// Update pivot sequence.</span>
<a name="l06249"></a>06249       j = ps[k];
<a name="l06250"></a>06250       ps[k] = ps[pivotindex];
<a name="l06251"></a>06251       ps[pivotindex] = j;
<a name="l06252"></a>06252       *d = -(*d);                          <span class="comment">// ...and change the parity of d.</span>
<a name="l06253"></a>06253     }
<a name="l06254"></a>06254 
<a name="l06255"></a>06255     <span class="comment">// Pivot, eliminating an extra variable  each time</span>
<a name="l06256"></a>06256     pivot = lu[ps[k]][k];
<a name="l06257"></a>06257     <span class="keywordflow">for</span> (i = k + 1; i &lt; n + N; i++) {
<a name="l06258"></a>06258       lu[ps[i]][k] = mult = lu[ps[i]][k] / pivot;
<a name="l06259"></a>06259       <span class="keywordflow">if</span> (mult != 0.0) {
<a name="l06260"></a>06260         <span class="keywordflow">for</span> (j = k + 1; j &lt; n + N; j++)
<a name="l06261"></a>06261           lu[ps[i]][j] -= mult * lu[ps[k]][j];
<a name="l06262"></a>06262       }
<a name="l06263"></a>06263     }
<a name="l06264"></a>06264   }
<a name="l06265"></a>06265 
<a name="l06266"></a>06266   <span class="comment">// (lu[ps[n + N - 1]][n + N - 1] == 0.0) ==&gt; A is singular.</span>
<a name="l06267"></a>06267   <span class="keywordflow">return</span> lu[ps[n + N - 1]][n + N - 1] != 0.0;
<a name="l06268"></a>06268 }
<a name="l06269"></a>06269 
<a name="l06271"></a>06271 <span class="comment">//                                                                           //</span>
<a name="l06272"></a>06272 <span class="comment">// lu_solve()    Solves the linear equation:  Ax = b,  after the matrix A    //</span>
<a name="l06273"></a>06273 <span class="comment">//               has been decomposed into the lower and upper triangular     //</span>
<a name="l06274"></a>06274 <span class="comment">//               matrices L and U, where A = LU.                             //</span>
<a name="l06275"></a>06275 <span class="comment">//                                                                           //</span>
<a name="l06276"></a>06276 <span class="comment">// &#39;lu[N..n+N-1][N..n+N-1]&#39; is input, not as the matrix &#39;A&#39; but rather as    //</span>
<a name="l06277"></a>06277 <span class="comment">// its LU decomposition, computed by the routine &#39;lu_decmp&#39;; &#39;ps[N..n+N-1]&#39;  //</span>
<a name="l06278"></a>06278 <span class="comment">// is input as the permutation vector returned by &#39;lu_decmp&#39;;  &#39;b[N..n+N-1]&#39; //</span>
<a name="l06279"></a>06279 <span class="comment">// is input as the right-hand side vector, and returns with the solution     //</span>
<a name="l06280"></a>06280 <span class="comment">// vector. &#39;lu&#39;, &#39;n&#39;, and &#39;ps&#39; are not modified by this routine and can be   //</span>
<a name="l06281"></a>06281 <span class="comment">// left in place for successive calls with different right-hand sides &#39;b&#39;.   //</span>
<a name="l06282"></a>06282 <span class="comment">//                                                                           //</span>
<a name="l06284"></a>06284 <span class="comment"></span>
<a name="l06285"></a>06285 <span class="keywordtype">void</span> tetgenmesh::lu_solve(REAL lu[4][4], <span class="keywordtype">int</span> n, <span class="keywordtype">int</span>* ps, REAL* b, <span class="keywordtype">int</span> N)
<a name="l06286"></a>06286 {
<a name="l06287"></a>06287   <span class="keywordtype">int</span> i, j;
<a name="l06288"></a>06288   REAL X[4], dot;
<a name="l06289"></a>06289 
<a name="l06290"></a>06290   <span class="keywordflow">for</span> (i = N; i &lt; n + N; i++) X[i] = 0.0;
<a name="l06291"></a>06291 
<a name="l06292"></a>06292   <span class="comment">// Vector reduction using U triangular matrix.</span>
<a name="l06293"></a>06293   <span class="keywordflow">for</span> (i = N; i &lt; n + N; i++) {
<a name="l06294"></a>06294     dot = 0.0;
<a name="l06295"></a>06295     <span class="keywordflow">for</span> (j = N; j &lt; i + N; j++)
<a name="l06296"></a>06296       dot += lu[ps[i]][j] * X[j];
<a name="l06297"></a>06297     X[i] = b[ps[i]] - dot;
<a name="l06298"></a>06298   }
<a name="l06299"></a>06299 
<a name="l06300"></a>06300   <span class="comment">// Back substitution, in L triangular matrix.</span>
<a name="l06301"></a>06301   <span class="keywordflow">for</span> (i = n + N - 1; i &gt;= N; i--) {
<a name="l06302"></a>06302     dot = 0.0;
<a name="l06303"></a>06303     <span class="keywordflow">for</span> (j = i + 1; j &lt; n + N; j++)
<a name="l06304"></a>06304       dot += lu[ps[i]][j] * X[j];
<a name="l06305"></a>06305     X[i] = (X[i] - dot) / lu[ps[i]][i];
<a name="l06306"></a>06306   }
<a name="l06307"></a>06307 
<a name="l06308"></a>06308   <span class="keywordflow">for</span> (i = N; i &lt; n + N; i++) b[i] = X[i];
<a name="l06309"></a>06309 }
<a name="l06310"></a>06310 
<a name="l06311"></a>06311 <span class="comment">//</span>
<a name="l06312"></a>06312 <span class="comment">// End of linear algebra functions</span>
<a name="l06313"></a>06313 <span class="comment">//</span>
<a name="l06314"></a>06314 
<a name="l06315"></a>06315 <span class="comment">//</span>
<a name="l06316"></a>06316 <span class="comment">// Begin of geometric tests</span>
<a name="l06317"></a>06317 <span class="comment">//</span>
<a name="l06318"></a>06318 
<a name="l06319"></a>06319 <span class="comment">// All the following routines require the input objects are not degenerate.</span>
<a name="l06320"></a>06320 <span class="comment">//   i.e., a triangle must has three non-collinear corners; an edge must</span>
<a name="l06321"></a>06321 <span class="comment">//   has two identical endpoints.  Degenerate cases should have to detect</span>
<a name="l06322"></a>06322 <span class="comment">//   first and then handled as special cases.</span>
<a name="l06323"></a>06323 
<a name="l06325"></a>06325 <span class="comment">//                                                                           //</span>
<a name="l06326"></a>06326 <span class="comment">// edge_vert_col_inter()    Test whether an edge (ab) and a collinear vertex //</span>
<a name="l06327"></a>06327 <span class="comment">//                          (p) are intersecting or not.                     //</span>
<a name="l06328"></a>06328 <span class="comment">//                                                                           //</span>
<a name="l06329"></a>06329 <span class="comment">// Possible cases are p is coincident to a (p = a), or to b (p = b), or p is //</span>
<a name="l06330"></a>06330 <span class="comment">// inside ab (a &lt; p &lt; b), or outside ab (p &lt; a or p &gt; b). These cases can be //</span>
<a name="l06331"></a>06331 <span class="comment">// quickly determined by comparing the corresponding coords of a, b, and p   //</span>
<a name="l06332"></a>06332 <span class="comment">// (which are not all equal).                                                //</span>
<a name="l06333"></a>06333 <span class="comment">//                                                                           //</span>
<a name="l06334"></a>06334 <span class="comment">// The return value indicates one of the three cases: DISJOINT, SHAREVERTEX  //</span>
<a name="l06335"></a>06335 <span class="comment">// (p = a or p = b), and INTERSECT (a &lt; p &lt; b).                              //</span>
<a name="l06336"></a>06336 <span class="comment">//                                                                           //</span>
<a name="l06338"></a>06338 <span class="comment"></span>
<a name="l06339"></a>06339 <span class="keyword">enum</span> tetgenmesh::interresult tetgenmesh::edge_vert_col_inter(REAL* A, REAL* B,
<a name="l06340"></a>06340   REAL* P)
<a name="l06341"></a>06341 {
<a name="l06342"></a>06342   <span class="keywordtype">int</span> i = 0;
<a name="l06343"></a>06343   <span class="keywordflow">do</span> {
<a name="l06344"></a>06344     <span class="keywordflow">if</span> (A[i] &lt; B[i]) {
<a name="l06345"></a>06345       <span class="keywordflow">if</span> (P[i] &lt; A[i]) {
<a name="l06346"></a>06346         <span class="keywordflow">return</span> DISJOINT;
<a name="l06347"></a>06347       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P[i] &gt; A[i]) {
<a name="l06348"></a>06348         <span class="keywordflow">if</span> (P[i] &lt; B[i]) {
<a name="l06349"></a>06349           <span class="keywordflow">return</span> INTERSECT;
<a name="l06350"></a>06350         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P[i] &gt; B[i]) {
<a name="l06351"></a>06351           <span class="keywordflow">return</span> DISJOINT;
<a name="l06352"></a>06352         } <span class="keywordflow">else</span> {
<a name="l06353"></a>06353           <span class="comment">// assert(P[i] == B[i]);</span>
<a name="l06354"></a>06354           <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06355"></a>06355         }
<a name="l06356"></a>06356       } <span class="keywordflow">else</span> {
<a name="l06357"></a>06357         <span class="comment">// assert(P[i] == A[i]);</span>
<a name="l06358"></a>06358         <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06359"></a>06359       }
<a name="l06360"></a>06360     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (A[i] &gt; B[i]) {
<a name="l06361"></a>06361       <span class="keywordflow">if</span> (P[i] &lt; B[i]) {
<a name="l06362"></a>06362         <span class="keywordflow">return</span> DISJOINT;
<a name="l06363"></a>06363       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P[i] &gt; B[i]) {
<a name="l06364"></a>06364         <span class="keywordflow">if</span> (P[i] &lt; A[i]) {
<a name="l06365"></a>06365           <span class="keywordflow">return</span> INTERSECT;
<a name="l06366"></a>06366         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (P[i] &gt; A[i]) {
<a name="l06367"></a>06367           <span class="keywordflow">return</span> DISJOINT;
<a name="l06368"></a>06368         } <span class="keywordflow">else</span> {
<a name="l06369"></a>06369           <span class="comment">// assert(P[i] == A[i]);</span>
<a name="l06370"></a>06370           <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06371"></a>06371         }
<a name="l06372"></a>06372       } <span class="keywordflow">else</span> {
<a name="l06373"></a>06373         <span class="comment">// assert(P[i] == B[i]);</span>
<a name="l06374"></a>06374         <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06375"></a>06375       }
<a name="l06376"></a>06376     }
<a name="l06377"></a>06377     <span class="comment">// i-th coordinates are equal, try i+1-th;</span>
<a name="l06378"></a>06378     i++;
<a name="l06379"></a>06379   } <span class="keywordflow">while</span> (i &lt; 3);
<a name="l06380"></a>06380   <span class="comment">// Should never be here.</span>
<a name="l06381"></a>06381   <span class="keywordflow">return</span> DISJOINT;
<a name="l06382"></a>06382 }
<a name="l06383"></a>06383 
<a name="l06385"></a>06385 <span class="comment">//                                                                           //</span>
<a name="l06386"></a>06386 <span class="comment">// edge_edge_cop_inter()    Test whether two coplanar edges (ab, and pq) are //</span>
<a name="l06387"></a>06387 <span class="comment">//                          intersecting or not.                             //</span>
<a name="l06388"></a>06388 <span class="comment">//                                                                           //</span>
<a name="l06389"></a>06389 <span class="comment">// Possible cases are ab and pq are disjointed, or proper intersecting (int- //</span>
<a name="l06390"></a>06390 <span class="comment">// ersect at a point other than their endpoints), or both collinear and int- //</span>
<a name="l06391"></a>06391 <span class="comment">// ersecting, or sharing at a common endpoint, or are coincident.            //</span>
<a name="l06392"></a>06392 <span class="comment">//                                                                           //</span>
<a name="l06393"></a>06393 <span class="comment">// A reference point R is required, which is exactly not coplanar with these //</span>
<a name="l06394"></a>06394 <span class="comment">// two edges.  Since the caller knows these two edges are coplanar, it must  //</span>
<a name="l06395"></a>06395 <span class="comment">// be able to provide (or calculate) such a point.                           //</span>
<a name="l06396"></a>06396 <span class="comment">//                                                                           //</span>
<a name="l06397"></a>06397 <span class="comment">// The return value indicates one of the four cases: DISJOINT, SHAREVERTEX,  //</span>
<a name="l06398"></a>06398 <span class="comment">// SHAREEDGE, and INTERSECT.                                                 //</span>
<a name="l06399"></a>06399 <span class="comment">//                                                                           //</span>
<a name="l06401"></a>06401 <span class="comment"></span>
<a name="l06402"></a>06402 <span class="keyword">enum</span> tetgenmesh::interresult tetgenmesh:: edge_edge_cop_inter(REAL* A, REAL* B,
<a name="l06403"></a>06403   REAL* P, REAL* Q, REAL* R)
<a name="l06404"></a>06404 {
<a name="l06405"></a>06405   REAL s1, s2, s3, s4;
<a name="l06406"></a>06406 
<a name="l06407"></a>06407 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06408"></a>06408 <span class="preprocessor"></span>  assert(R != NULL);
<a name="l06409"></a>06409 <span class="preprocessor">#endif</span>
<a name="l06410"></a>06410 <span class="preprocessor"></span>  s1 = orient3d(A, B, R, P);
<a name="l06411"></a>06411   s2 = orient3d(A, B, R, Q);
<a name="l06412"></a>06412   <span class="keywordflow">if</span> (s1 * s2 &gt; 0.0) {
<a name="l06413"></a>06413     <span class="comment">// Both p and q are at the same side of ab.</span>
<a name="l06414"></a>06414     <span class="keywordflow">return</span> DISJOINT;
<a name="l06415"></a>06415   }
<a name="l06416"></a>06416   s3 = orient3d(P, Q, R, A);
<a name="l06417"></a>06417   s4 = orient3d(P, Q, R, B);
<a name="l06418"></a>06418   <span class="keywordflow">if</span> (s3 * s4 &gt; 0.0) {
<a name="l06419"></a>06419     <span class="comment">// Both a and b are at the same side of pq.</span>
<a name="l06420"></a>06420     <span class="keywordflow">return</span> DISJOINT;
<a name="l06421"></a>06421   }
<a name="l06422"></a>06422 
<a name="l06423"></a>06423   <span class="comment">// Possible degenerate cases are:</span>
<a name="l06424"></a>06424   <span class="comment">//   (1) Only one of p and q is collinear with ab;</span>
<a name="l06425"></a>06425   <span class="comment">//   (2) Both p and q are collinear with ab;</span>
<a name="l06426"></a>06426   <span class="comment">//   (3) Only one of a and b is collinear with pq.</span>
<a name="l06427"></a>06427   <span class="keyword">enum</span> interresult abp, abq;
<a name="l06428"></a>06428   <span class="keyword">enum</span> interresult pqa, pqb;
<a name="l06429"></a>06429 
<a name="l06430"></a>06430   <span class="keywordflow">if</span> (s1 == 0.0) {
<a name="l06431"></a>06431     <span class="comment">// p is collinear with ab.</span>
<a name="l06432"></a>06432     abp = edge_vert_col_inter(A, B, P);
<a name="l06433"></a>06433     <span class="keywordflow">if</span> (abp == INTERSECT) {
<a name="l06434"></a>06434       <span class="comment">// p is inside ab.</span>
<a name="l06435"></a>06435       <span class="keywordflow">return</span> INTERSECT;
<a name="l06436"></a>06436     }
<a name="l06437"></a>06437     <span class="keywordflow">if</span> (s2 == 0.0) {
<a name="l06438"></a>06438       <span class="comment">// q is collinear with ab. Case (2).</span>
<a name="l06439"></a>06439       abq = edge_vert_col_inter(A, B, Q);
<a name="l06440"></a>06440       <span class="keywordflow">if</span> (abq == INTERSECT) {
<a name="l06441"></a>06441         <span class="comment">// q is inside ab.</span>
<a name="l06442"></a>06442         <span class="keywordflow">return</span> INTERSECT;
<a name="l06443"></a>06443       }
<a name="l06444"></a>06444       <span class="keywordflow">if</span> (abp == SHAREVERTEX &amp;&amp; abq == SHAREVERTEX) {
<a name="l06445"></a>06445         <span class="comment">// ab and pq are identical.</span>
<a name="l06446"></a>06446         <span class="keywordflow">return</span> SHAREEDGE;
<a name="l06447"></a>06447       }
<a name="l06448"></a>06448       pqa = edge_vert_col_inter(P, Q, A);
<a name="l06449"></a>06449       <span class="keywordflow">if</span> (pqa == INTERSECT) {
<a name="l06450"></a>06450         <span class="comment">// a is inside pq.</span>
<a name="l06451"></a>06451         <span class="keywordflow">return</span> INTERSECT;
<a name="l06452"></a>06452       }
<a name="l06453"></a>06453       pqb = edge_vert_col_inter(P, Q, B);
<a name="l06454"></a>06454       <span class="keywordflow">if</span> (pqb == INTERSECT) {
<a name="l06455"></a>06455         <span class="comment">// b is inside pq.</span>
<a name="l06456"></a>06456         <span class="keywordflow">return</span> INTERSECT;
<a name="l06457"></a>06457       }
<a name="l06458"></a>06458       <span class="keywordflow">if</span> (abp == SHAREVERTEX || abq == SHAREVERTEX) {
<a name="l06459"></a>06459         <span class="comment">// either p or q is coincident with a or b.</span>
<a name="l06460"></a>06460 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06461"></a>06461 <span class="preprocessor"></span>        <span class="comment">// ONLY one case is possible, otherwise, shoule be SHAREEDGE.</span>
<a name="l06462"></a>06462         assert(abp ^ abq);
<a name="l06463"></a>06463 <span class="preprocessor">#endif</span>
<a name="l06464"></a>06464 <span class="preprocessor"></span>        <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06465"></a>06465       }
<a name="l06466"></a>06466       <span class="comment">// The last case. They are disjointed.</span>
<a name="l06467"></a>06467 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06468"></a>06468 <span class="preprocessor"></span>      assert((abp == DISJOINT) &amp;&amp; (abp == abq &amp;&amp; abq == pqa &amp;&amp; pqa == pqb));
<a name="l06469"></a>06469 <span class="preprocessor">#endif</span>
<a name="l06470"></a>06470 <span class="preprocessor"></span>      <span class="keywordflow">return</span> DISJOINT;
<a name="l06471"></a>06471     } <span class="keywordflow">else</span> {
<a name="l06472"></a>06472       <span class="comment">// p is collinear with ab. Case (1).</span>
<a name="l06473"></a>06473 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06474"></a>06474 <span class="preprocessor"></span>      assert(abp == SHAREVERTEX || abp == DISJOINT);
<a name="l06475"></a>06475 <span class="preprocessor">#endif</span>
<a name="l06476"></a>06476 <span class="preprocessor"></span>      <span class="keywordflow">return</span> abp;
<a name="l06477"></a>06477     }
<a name="l06478"></a>06478   }
<a name="l06479"></a>06479   <span class="comment">// p is NOT collinear with ab.</span>
<a name="l06480"></a>06480   <span class="keywordflow">if</span> (s2 == 0.0) {
<a name="l06481"></a>06481     <span class="comment">// q is collinear with ab. Case (1).</span>
<a name="l06482"></a>06482     abq = edge_vert_col_inter(A, B, Q);
<a name="l06483"></a>06483 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06484"></a>06484 <span class="preprocessor"></span>    assert(abq == SHAREVERTEX || abq == DISJOINT || abq == INTERSECT);
<a name="l06485"></a>06485 <span class="preprocessor">#endif</span>
<a name="l06486"></a>06486 <span class="preprocessor"></span>    <span class="keywordflow">return</span> abq;
<a name="l06487"></a>06487   }
<a name="l06488"></a>06488 
<a name="l06489"></a>06489   <span class="comment">// We have found p and q are not collinear with ab. However, it is still</span>
<a name="l06490"></a>06490   <span class="comment">//   possible that a or b is collinear with pq (ONLY one of a and b).</span>
<a name="l06491"></a>06491   <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l06492"></a>06492     <span class="comment">// a is collinear with pq. Case (3).</span>
<a name="l06493"></a>06493 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06494"></a>06494 <span class="preprocessor"></span>    assert(s4 != 0.0);
<a name="l06495"></a>06495 <span class="preprocessor">#endif</span>
<a name="l06496"></a>06496 <span class="preprocessor"></span>    pqa = edge_vert_col_inter(P, Q, A);
<a name="l06497"></a>06497 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06498"></a>06498 <span class="preprocessor"></span>    <span class="comment">// This case should have been detected in above.</span>
<a name="l06499"></a>06499     assert(pqa != SHAREVERTEX);
<a name="l06500"></a>06500     assert(pqa == INTERSECT || pqa == DISJOINT);
<a name="l06501"></a>06501 <span class="preprocessor">#endif</span>
<a name="l06502"></a>06502 <span class="preprocessor"></span>    <span class="keywordflow">return</span> pqa;
<a name="l06503"></a>06503   }
<a name="l06504"></a>06504   <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l06505"></a>06505     <span class="comment">// b is collinear with pq. Case (3).</span>
<a name="l06506"></a>06506 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06507"></a>06507 <span class="preprocessor"></span>    assert(s3 != 0.0);
<a name="l06508"></a>06508 <span class="preprocessor">#endif</span>
<a name="l06509"></a>06509 <span class="preprocessor"></span>    pqb = edge_vert_col_inter(P, Q, B);
<a name="l06510"></a>06510 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06511"></a>06511 <span class="preprocessor"></span>    <span class="comment">// This case should have been detected in above.</span>
<a name="l06512"></a>06512     assert(pqb != SHAREVERTEX);
<a name="l06513"></a>06513     assert(pqb == INTERSECT || pqb == DISJOINT);
<a name="l06514"></a>06514 <span class="preprocessor">#endif</span>
<a name="l06515"></a>06515 <span class="preprocessor"></span>    <span class="keywordflow">return</span> pqb;
<a name="l06516"></a>06516   }
<a name="l06517"></a>06517 
<a name="l06518"></a>06518   <span class="comment">// ab and pq are intersecting properly.</span>
<a name="l06519"></a>06519   <span class="keywordflow">return</span> INTERSECT;
<a name="l06520"></a>06520 }
<a name="l06521"></a>06521 
<a name="l06523"></a>06523 <span class="comment">//                                                                           //</span>
<a name="l06524"></a>06524 <span class="comment">// Notations                                                                 //</span>
<a name="l06525"></a>06525 <span class="comment">//                                                                           //</span>
<a name="l06526"></a>06526 <span class="comment">// Let ABC be the plane passes through a, b, and c;  ABC+ be the halfspace   //</span>
<a name="l06527"></a>06527 <span class="comment">// including the set of all points x, such that orient3d(a, b, c, x) &gt; 0;    //</span>
<a name="l06528"></a>06528 <span class="comment">// ABC- be the other halfspace, such that for each point x in ABC-,          //</span>
<a name="l06529"></a>06529 <span class="comment">// orient3d(a, b, c, x) &lt; 0.  For the set of x which are on ABC, orient3d(a, //</span>
<a name="l06530"></a>06530 <span class="comment">// b, c, x) = 0.                                                             //</span>
<a name="l06531"></a>06531 <span class="comment">//                                                                           //</span>
<a name="l06533"></a>06533 <span class="comment"></span>
<a name="l06535"></a>06535 <span class="comment">//                                                                           //</span>
<a name="l06536"></a>06536 <span class="comment">// tri_vert_copl_inter()    Test whether a triangle (abc) and a coplanar     //</span>
<a name="l06537"></a>06537 <span class="comment">//                          point (p) are intersecting or not.               //</span>
<a name="l06538"></a>06538 <span class="comment">//                                                                           //</span>
<a name="l06539"></a>06539 <span class="comment">// Possible cases are p is inside abc, or on an edge of, or coincident with  //</span>
<a name="l06540"></a>06540 <span class="comment">// a vertex of, or outside abc.                                              //</span>
<a name="l06541"></a>06541 <span class="comment">//                                                                           //</span>
<a name="l06542"></a>06542 <span class="comment">// A reference point R is required. R is exactly not coplanar with abc and p.//</span>
<a name="l06543"></a>06543 <span class="comment">// Since the caller knows they are coplanar, it must be able to provide (or  //</span>
<a name="l06544"></a>06544 <span class="comment">// calculate) such a point.                                                  //</span>
<a name="l06545"></a>06545 <span class="comment">//                                                                           //</span>
<a name="l06546"></a>06546 <span class="comment">// The return value indicates one of the four cases: DISJOINT, SHAREVERTEX,  //</span>
<a name="l06547"></a>06547 <span class="comment">// and INTERSECT.                                                            //</span>
<a name="l06548"></a>06548 <span class="comment">//                                                                           //</span>
<a name="l06550"></a>06550 <span class="comment"></span>
<a name="l06551"></a>06551 <span class="keyword">enum</span> tetgenmesh::interresult tetgenmesh::tri_vert_cop_inter(REAL* A, REAL* B,
<a name="l06552"></a>06552   REAL* C, REAL* P, REAL* R)
<a name="l06553"></a>06553 {
<a name="l06554"></a>06554   REAL s1, s2, s3;
<a name="l06555"></a>06555   <span class="keywordtype">int</span> sign;
<a name="l06556"></a>06556 
<a name="l06557"></a>06557 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06558"></a>06558 <span class="preprocessor"></span>  assert(R != (REAL *) NULL);
<a name="l06559"></a>06559 <span class="preprocessor">#endif</span>
<a name="l06560"></a>06560 <span class="preprocessor"></span>  <span class="comment">// Adjust the orientation of a, b, c and r, so that we can assume that</span>
<a name="l06561"></a>06561   <span class="comment">//   r is strictly in ABC- (i.e., r is above ABC wrt. right-hand rule).</span>
<a name="l06562"></a>06562   s1 = orient3d(A, B, C, R);
<a name="l06563"></a>06563 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06564"></a>06564 <span class="preprocessor"></span>  assert(s1 != 0.0);
<a name="l06565"></a>06565 <span class="preprocessor">#endif</span>
<a name="l06566"></a>06566 <span class="preprocessor"></span>  sign = s1 &lt; 0.0 ? 1 : -1;
<a name="l06567"></a>06567 
<a name="l06568"></a>06568   <span class="comment">// Test starts from here.</span>
<a name="l06569"></a>06569   s1 = orient3d(A, B, R, P) * sign;
<a name="l06570"></a>06570   <span class="keywordflow">if</span> (s1 &lt; 0.0) {
<a name="l06571"></a>06571     <span class="comment">// p is in ABR-.</span>
<a name="l06572"></a>06572     <span class="keywordflow">return</span> DISJOINT;
<a name="l06573"></a>06573   }
<a name="l06574"></a>06574   s2 = orient3d(B, C, R, P) * sign;
<a name="l06575"></a>06575   <span class="keywordflow">if</span> (s2 &lt; 0.0) {
<a name="l06576"></a>06576     <span class="comment">// p is in BCR-.</span>
<a name="l06577"></a>06577     <span class="keywordflow">return</span> DISJOINT;
<a name="l06578"></a>06578   }
<a name="l06579"></a>06579   s3 = orient3d(C, A, R, P) * sign;
<a name="l06580"></a>06580   <span class="keywordflow">if</span> (s3 &lt; 0.0) {
<a name="l06581"></a>06581     <span class="comment">// p is in CAR-.</span>
<a name="l06582"></a>06582     <span class="keywordflow">return</span> DISJOINT;
<a name="l06583"></a>06583   }
<a name="l06584"></a>06584   <span class="keywordflow">if</span> (s1 == 0.0) {
<a name="l06585"></a>06585     <span class="comment">// p is on ABR.</span>
<a name="l06586"></a>06586     <span class="keywordflow">if</span> (s2 == 0.0) {
<a name="l06587"></a>06587       <span class="comment">// p is on BCR.</span>
<a name="l06588"></a>06588 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06589"></a>06589 <span class="preprocessor"></span>      assert(s3 &gt; 0.0);
<a name="l06590"></a>06590 <span class="preprocessor">#endif</span>
<a name="l06591"></a>06591 <span class="preprocessor"></span>      <span class="comment">// p is coincident with b.</span>
<a name="l06592"></a>06592       <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06593"></a>06593     }
<a name="l06594"></a>06594     <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l06595"></a>06595       <span class="comment">// p is on CAR.</span>
<a name="l06596"></a>06596       <span class="comment">// p is coincident with a.</span>
<a name="l06597"></a>06597       <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06598"></a>06598     }
<a name="l06599"></a>06599     <span class="comment">// p is on edge ab.</span>
<a name="l06600"></a>06600     <span class="keywordflow">return</span> INTERSECT;
<a name="l06601"></a>06601   }
<a name="l06602"></a>06602   <span class="comment">// p is in ABR+.</span>
<a name="l06603"></a>06603   <span class="keywordflow">if</span> (s2 == 0.0) {
<a name="l06604"></a>06604     <span class="comment">// p is on BCR.</span>
<a name="l06605"></a>06605     <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l06606"></a>06606       <span class="comment">// p is on CAR.</span>
<a name="l06607"></a>06607       <span class="comment">// p is coincident with c.</span>
<a name="l06608"></a>06608       <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06609"></a>06609     }
<a name="l06610"></a>06610     <span class="comment">// p is on edge bc.</span>
<a name="l06611"></a>06611     <span class="keywordflow">return</span> INTERSECT;
<a name="l06612"></a>06612   }
<a name="l06613"></a>06613   <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l06614"></a>06614     <span class="comment">// p is on CAR.</span>
<a name="l06615"></a>06615     <span class="comment">// p is on edge ca.</span>
<a name="l06616"></a>06616     <span class="keywordflow">return</span> INTERSECT;
<a name="l06617"></a>06617   }
<a name="l06618"></a>06618 
<a name="l06619"></a>06619   <span class="comment">// p is strictly inside abc.</span>
<a name="l06620"></a>06620   <span class="keywordflow">return</span> INTERSECT;
<a name="l06621"></a>06621 }
<a name="l06622"></a>06622 
<a name="l06624"></a>06624 <span class="comment">//                                                                           //</span>
<a name="l06625"></a>06625 <span class="comment">// tri_edge_cop_inter()    Test whether a triangle (abc) and a coplanar edge //</span>
<a name="l06626"></a>06626 <span class="comment">//                         (pq) are intersecting or not.                     //</span>
<a name="l06627"></a>06627 <span class="comment">//                                                                           //</span>
<a name="l06628"></a>06628 <span class="comment">// A reference point R is required. R is exactly not coplanar with abc and   //</span>
<a name="l06629"></a>06629 <span class="comment">// pq.  Since the caller knows they are coplanar, it must be able to provide //</span>
<a name="l06630"></a>06630 <span class="comment">// (or calculate) such a point.                                              //</span>
<a name="l06631"></a>06631 <span class="comment">//                                                                           //</span>
<a name="l06632"></a>06632 <span class="comment">// The return value indicates one of the four cases: DISJOINT, SHAREVERTEX,  //</span>
<a name="l06633"></a>06633 <span class="comment">// SHAREEDGE, and INTERSECT.                                                 //</span>
<a name="l06634"></a>06634 <span class="comment">//                                                                           //</span>
<a name="l06636"></a>06636 <span class="comment"></span>
<a name="l06637"></a>06637 <span class="keyword">enum</span> tetgenmesh::interresult tetgenmesh::tri_edge_cop_inter(REAL* A, REAL* B,
<a name="l06638"></a>06638   REAL* C, REAL* P, REAL* Q, REAL* R)
<a name="l06639"></a>06639 {
<a name="l06640"></a>06640   <span class="keyword">enum</span> interresult abpq, bcpq, capq;
<a name="l06641"></a>06641   <span class="keyword">enum</span> interresult abcp, abcq;
<a name="l06642"></a>06642 
<a name="l06643"></a>06643   <span class="comment">// Test if pq is intersecting one of edges of abc.</span>
<a name="l06644"></a>06644   abpq = edge_edge_cop_inter(A, B, P, Q, R);
<a name="l06645"></a>06645   <span class="keywordflow">if</span> (abpq == INTERSECT || abpq == SHAREEDGE) {
<a name="l06646"></a>06646     <span class="keywordflow">return</span> abpq;
<a name="l06647"></a>06647   }
<a name="l06648"></a>06648   bcpq = edge_edge_cop_inter(B, C, P, Q, R);
<a name="l06649"></a>06649   <span class="keywordflow">if</span> (bcpq == INTERSECT || bcpq == SHAREEDGE) {
<a name="l06650"></a>06650     <span class="keywordflow">return</span> bcpq;
<a name="l06651"></a>06651   }
<a name="l06652"></a>06652   capq = edge_edge_cop_inter(C, A, P, Q, R);
<a name="l06653"></a>06653   <span class="keywordflow">if</span> (capq == INTERSECT || capq == SHAREEDGE) {
<a name="l06654"></a>06654     <span class="keywordflow">return</span> capq;
<a name="l06655"></a>06655   }
<a name="l06656"></a>06656 
<a name="l06657"></a>06657   <span class="comment">// Test if p and q is inside abc.</span>
<a name="l06658"></a>06658   abcp = tri_vert_cop_inter(A, B, C, P, R);
<a name="l06659"></a>06659   <span class="keywordflow">if</span> (abcp == INTERSECT) {
<a name="l06660"></a>06660     <span class="keywordflow">return</span> INTERSECT;
<a name="l06661"></a>06661   }
<a name="l06662"></a>06662   abcq = tri_vert_cop_inter(A, B, C, Q, R);
<a name="l06663"></a>06663   <span class="keywordflow">if</span> (abcq == INTERSECT) {
<a name="l06664"></a>06664     <span class="keywordflow">return</span> INTERSECT;
<a name="l06665"></a>06665   }
<a name="l06666"></a>06666 
<a name="l06667"></a>06667   <span class="comment">// Combine the test results of edge intersectings and triangle insides</span>
<a name="l06668"></a>06668   <span class="comment">//   to detect whether abc and pq are sharing vertex or disjointed.</span>
<a name="l06669"></a>06669   <span class="keywordflow">if</span> (abpq == SHAREVERTEX) {
<a name="l06670"></a>06670     <span class="comment">// p or q is coincident with a or b.</span>
<a name="l06671"></a>06671 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06672"></a>06672 <span class="preprocessor"></span>    assert(abcp ^ abcq);
<a name="l06673"></a>06673 <span class="preprocessor">#endif</span>
<a name="l06674"></a>06674 <span class="preprocessor"></span>    <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06675"></a>06675   }
<a name="l06676"></a>06676   <span class="keywordflow">if</span> (bcpq == SHAREVERTEX) {
<a name="l06677"></a>06677     <span class="comment">// p or q is coincident with b or c.</span>
<a name="l06678"></a>06678 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06679"></a>06679 <span class="preprocessor"></span>    assert(abcp ^ abcq);
<a name="l06680"></a>06680 <span class="preprocessor">#endif</span>
<a name="l06681"></a>06681 <span class="preprocessor"></span>    <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06682"></a>06682   }
<a name="l06683"></a>06683   <span class="keywordflow">if</span> (capq == SHAREVERTEX) {
<a name="l06684"></a>06684     <span class="comment">// p or q is coincident with c or a.</span>
<a name="l06685"></a>06685 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06686"></a>06686 <span class="preprocessor"></span>    assert(abcp ^ abcq);
<a name="l06687"></a>06687 <span class="preprocessor">#endif</span>
<a name="l06688"></a>06688 <span class="preprocessor"></span>    <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06689"></a>06689   }
<a name="l06690"></a>06690 
<a name="l06691"></a>06691   <span class="comment">// They are disjointed.</span>
<a name="l06692"></a>06692   <span class="keywordflow">return</span> DISJOINT;
<a name="l06693"></a>06693 }
<a name="l06694"></a>06694 
<a name="l06696"></a>06696 <span class="comment">//                                                                           //</span>
<a name="l06697"></a>06697 <span class="comment">// tri_edge_inter_tail()    Test whether a triangle (abc) and an edge (pq)   //</span>
<a name="l06698"></a>06698 <span class="comment">//                          are intersecting or not.                         //</span>
<a name="l06699"></a>06699 <span class="comment">//                                                                           //</span>
<a name="l06700"></a>06700 <span class="comment">// s1 and s2 are results of pre-performed orientation tests. s1 = orient3d(  //</span>
<a name="l06701"></a>06701 <span class="comment">// a, b, c, p); s2 = orient3d(a, b, c, q).  To separate this routine from    //</span>
<a name="l06702"></a>06702 <span class="comment">// tri_edge_inter() can save two orientation tests in tri_tri_inter().       //</span>
<a name="l06703"></a>06703 <span class="comment">//                                                                           //</span>
<a name="l06704"></a>06704 <span class="comment">// The return value indicates one of the four cases: DISJOINT, SHAREVERTEX,  //</span>
<a name="l06705"></a>06705 <span class="comment">// SHAREEDGE, and INTERSECT.                                                 //</span>
<a name="l06706"></a>06706 <span class="comment">//                                                                           //</span>
<a name="l06708"></a>06708 <span class="comment"></span>
<a name="l06709"></a>06709 <span class="keyword">enum</span> tetgenmesh::interresult tetgenmesh::tri_edge_inter_tail(REAL* A, REAL* B,
<a name="l06710"></a>06710   REAL* C, REAL* P, REAL* Q, REAL s1, REAL s2)
<a name="l06711"></a>06711 {
<a name="l06712"></a>06712   REAL s3, s4, s5;
<a name="l06713"></a>06713   <span class="keywordtype">int</span> sign;
<a name="l06714"></a>06714 
<a name="l06715"></a>06715   <span class="keywordflow">if</span> (s1 * s2 &gt; 0.0) {
<a name="l06716"></a>06716     <span class="comment">// p, q are at the same halfspace of ABC, no intersection.</span>
<a name="l06717"></a>06717     <span class="keywordflow">return</span> DISJOINT;
<a name="l06718"></a>06718   }
<a name="l06719"></a>06719 
<a name="l06720"></a>06720   <span class="keywordflow">if</span> (s1 * s2 &lt; 0.0) {
<a name="l06721"></a>06721     <span class="comment">// p, q are both not on ABC (and not sharing vertices, edges of abc).</span>
<a name="l06722"></a>06722     <span class="comment">// Adjust the orientation of a, b, c and p, so that we can assume that</span>
<a name="l06723"></a>06723     <span class="comment">//   p is strictly in ABC-, and q is strictly in ABC+.</span>
<a name="l06724"></a>06724     sign = s1 &lt; 0.0 ? 1 : -1;
<a name="l06725"></a>06725     s3 = orient3d(A, B, P, Q) * sign;
<a name="l06726"></a>06726     <span class="keywordflow">if</span> (s3 &lt; 0.0) {
<a name="l06727"></a>06727       <span class="comment">// q is at ABP-.</span>
<a name="l06728"></a>06728       <span class="keywordflow">return</span> DISJOINT;
<a name="l06729"></a>06729     }
<a name="l06730"></a>06730     s4 = orient3d(B, C, P, Q) * sign;
<a name="l06731"></a>06731     <span class="keywordflow">if</span> (s4 &lt; 0.0) {
<a name="l06732"></a>06732       <span class="comment">// q is at BCP-.</span>
<a name="l06733"></a>06733       <span class="keywordflow">return</span> DISJOINT;
<a name="l06734"></a>06734     }
<a name="l06735"></a>06735     s5 = orient3d(C, A, P, Q) * sign;
<a name="l06736"></a>06736     <span class="keywordflow">if</span> (s5 &lt; 0.0) {
<a name="l06737"></a>06737       <span class="comment">// q is at CAP-.</span>
<a name="l06738"></a>06738       <span class="keywordflow">return</span> DISJOINT;
<a name="l06739"></a>06739     }
<a name="l06740"></a>06740     <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l06741"></a>06741       <span class="comment">// q is on ABP.</span>
<a name="l06742"></a>06742       <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l06743"></a>06743         <span class="comment">// q is on BCP (and q must in CAP+).</span>
<a name="l06744"></a>06744 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06745"></a>06745 <span class="preprocessor"></span>        assert(s5 &gt; 0.0);
<a name="l06746"></a>06746 <span class="preprocessor">#endif</span>
<a name="l06747"></a>06747 <span class="preprocessor"></span>        <span class="comment">// pq intersects abc at vertex b.</span>
<a name="l06748"></a>06748         <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06749"></a>06749       }
<a name="l06750"></a>06750       <span class="keywordflow">if</span> (s5 == 0.0) {
<a name="l06751"></a>06751         <span class="comment">// q is on CAP (and q must in BCP+).</span>
<a name="l06752"></a>06752         <span class="comment">// pq intersects abc at vertex a.</span>
<a name="l06753"></a>06753         <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06754"></a>06754       }
<a name="l06755"></a>06755       <span class="comment">// q in both BCP+ and CAP+.</span>
<a name="l06756"></a>06756       <span class="comment">// pq crosses ab properly.</span>
<a name="l06757"></a>06757       <span class="keywordflow">return</span> INTERSECT;
<a name="l06758"></a>06758     }
<a name="l06759"></a>06759     <span class="comment">// q is in ABP+;</span>
<a name="l06760"></a>06760     <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l06761"></a>06761       <span class="comment">// q is on BCP.</span>
<a name="l06762"></a>06762       <span class="keywordflow">if</span> (s5 == 0.0) {
<a name="l06763"></a>06763         <span class="comment">// q is on CAP.</span>
<a name="l06764"></a>06764         <span class="comment">// pq intersects abc at vertex c.</span>
<a name="l06765"></a>06765         <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06766"></a>06766       }
<a name="l06767"></a>06767       <span class="comment">// pq crosses bc properly.</span>
<a name="l06768"></a>06768       <span class="keywordflow">return</span> INTERSECT;
<a name="l06769"></a>06769     }
<a name="l06770"></a>06770     <span class="comment">// q is in BCP+;</span>
<a name="l06771"></a>06771     <span class="keywordflow">if</span> (s5 == 0.0) {
<a name="l06772"></a>06772       <span class="comment">// q is on CAP.</span>
<a name="l06773"></a>06773       <span class="comment">// pq crosses ca properly.</span>
<a name="l06774"></a>06774       <span class="keywordflow">return</span> INTERSECT;
<a name="l06775"></a>06775     }
<a name="l06776"></a>06776     <span class="comment">// q is in CAP+;</span>
<a name="l06777"></a>06777     <span class="comment">// pq crosses abc properly.</span>
<a name="l06778"></a>06778     <span class="keywordflow">return</span> INTERSECT;
<a name="l06779"></a>06779   }
<a name="l06780"></a>06780 
<a name="l06781"></a>06781   <span class="keywordflow">if</span> (s1 != 0.0 || s2 != 0.0) {
<a name="l06782"></a>06782     <span class="comment">// Either p or q is coplanar with abc. ONLY one of them is possible.</span>
<a name="l06783"></a>06783     <span class="keywordflow">if</span> (s1 == 0.0) {
<a name="l06784"></a>06784       <span class="comment">// p is coplanar with abc, q can be used as reference point.</span>
<a name="l06785"></a>06785 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06786"></a>06786 <span class="preprocessor"></span>      assert(s2 != 0.0);
<a name="l06787"></a>06787 <span class="preprocessor">#endif</span>
<a name="l06788"></a>06788 <span class="preprocessor"></span>      <span class="keywordflow">return</span> tri_vert_cop_inter(A, B, C, P, Q);
<a name="l06789"></a>06789     } <span class="keywordflow">else</span> {
<a name="l06790"></a>06790       <span class="comment">// q is coplanar with abc, p can be used as reference point.</span>
<a name="l06791"></a>06791 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06792"></a>06792 <span class="preprocessor"></span>      assert(s2 == 0.0);
<a name="l06793"></a>06793 <span class="preprocessor">#endif</span>
<a name="l06794"></a>06794 <span class="preprocessor"></span>      <span class="keywordflow">return</span> tri_vert_cop_inter(A, B, C, Q, P);
<a name="l06795"></a>06795     }
<a name="l06796"></a>06796   }
<a name="l06797"></a>06797 
<a name="l06798"></a>06798   <span class="comment">// pq is coplanar with abc.  Calculate a point which is exactly not</span>
<a name="l06799"></a>06799   <span class="comment">//   coplanar with a, b, and c.</span>
<a name="l06800"></a>06800   REAL R[3], N[3];
<a name="l06801"></a>06801   REAL ax, ay, az, bx, by, bz;
<a name="l06802"></a>06802 
<a name="l06803"></a>06803   ax = A[0] - B[0];
<a name="l06804"></a>06804   ay = A[1] - B[1];
<a name="l06805"></a>06805   az = A[2] - B[2];
<a name="l06806"></a>06806   bx = A[0] - C[0];
<a name="l06807"></a>06807   by = A[1] - C[1];
<a name="l06808"></a>06808   bz = A[2] - C[2];
<a name="l06809"></a>06809   N[0] = ay * bz - by * az;
<a name="l06810"></a>06810   N[1] = az * bx - bz * ax;
<a name="l06811"></a>06811   N[2] = ax * by - bx * ay;
<a name="l06812"></a>06812   <span class="comment">// The normal should not be a zero vector (otherwise, abc are collinear).</span>
<a name="l06813"></a>06813 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06814"></a>06814 <span class="preprocessor"></span>  assert((fabs(N[0]) + fabs(N[1]) + fabs(N[2])) &gt; 0.0);
<a name="l06815"></a>06815 <span class="preprocessor">#endif</span>
<a name="l06816"></a>06816 <span class="preprocessor"></span>  <span class="comment">// The reference point R is lifted from A to the normal direction with</span>
<a name="l06817"></a>06817   <span class="comment">//   a distance d = average edge length of the triangle abc.</span>
<a name="l06818"></a>06818   R[0] = N[0] + A[0];
<a name="l06819"></a>06819   R[1] = N[1] + A[1];
<a name="l06820"></a>06820   R[2] = N[2] + A[2];
<a name="l06821"></a>06821   <span class="comment">// Becareful the case: if the non-zero component(s) in N is smaller than</span>
<a name="l06822"></a>06822   <span class="comment">//   the machine epsilon (i.e., 2^(-16) for double), R will exactly equal</span>
<a name="l06823"></a>06823   <span class="comment">//   to A due to the round-off error.  Do check if it is.</span>
<a name="l06824"></a>06824   <span class="keywordflow">if</span> (R[0] == A[0] &amp;&amp; R[1] == A[1] &amp;&amp; R[2] == A[2]) {
<a name="l06825"></a>06825     <span class="keywordtype">int</span> i, j;
<a name="l06826"></a>06826     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l06827"></a>06827 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06828"></a>06828 <span class="preprocessor"></span>      assert (R[i] == A[i]);
<a name="l06829"></a>06829 <span class="preprocessor">#endif</span>
<a name="l06830"></a>06830 <span class="preprocessor"></span>      j = 2;
<a name="l06831"></a>06831       <span class="keywordflow">do</span> {
<a name="l06832"></a>06832         <span class="keywordflow">if</span> (N[i] &gt; 0.0) {
<a name="l06833"></a>06833           N[i] += (j * macheps);
<a name="l06834"></a>06834         } <span class="keywordflow">else</span> {
<a name="l06835"></a>06835           N[i] -= (j * macheps);
<a name="l06836"></a>06836         }
<a name="l06837"></a>06837         R[i] = N[i] + A[i];
<a name="l06838"></a>06838         j *= 2;
<a name="l06839"></a>06839       } <span class="keywordflow">while</span> (R[i] == A[i]);
<a name="l06840"></a>06840     }
<a name="l06841"></a>06841   }
<a name="l06842"></a>06842 
<a name="l06843"></a>06843   <span class="keywordflow">return</span> tri_edge_cop_inter(A, B, C, P, Q, R);
<a name="l06844"></a>06844 }
<a name="l06845"></a>06845 
<a name="l06847"></a>06847 <span class="comment">//                                                                           //</span>
<a name="l06848"></a>06848 <span class="comment">// tri_edge_inter()    Test whether a triangle (abc) and an edge (pq) are    //</span>
<a name="l06849"></a>06849 <span class="comment">//                     intersecting or not.                                  //</span>
<a name="l06850"></a>06850 <span class="comment">//                                                                           //</span>
<a name="l06851"></a>06851 <span class="comment">// The return value indicates one of the four cases: DISJOINT, SHAREVERTEX,  //</span>
<a name="l06852"></a>06852 <span class="comment">// SHAREEDGE, and INTERSECT.                                                 //</span>
<a name="l06853"></a>06853 <span class="comment">//                                                                           //</span>
<a name="l06855"></a>06855 <span class="comment"></span>
<a name="l06856"></a>06856 <span class="keyword">enum</span> tetgenmesh::interresult tetgenmesh::tri_edge_inter(REAL* A, REAL* B,
<a name="l06857"></a>06857   REAL* C, REAL* P, REAL* Q)
<a name="l06858"></a>06858 {
<a name="l06859"></a>06859   REAL s1, s2;
<a name="l06860"></a>06860 
<a name="l06861"></a>06861   <span class="comment">// Test the locations of p and q with respect to ABC.</span>
<a name="l06862"></a>06862   s1 = orient3d(A, B, C, P);
<a name="l06863"></a>06863   s2 = orient3d(A, B, C, Q);
<a name="l06864"></a>06864 
<a name="l06865"></a>06865   <span class="keywordflow">return</span> tri_edge_inter_tail(A, B, C, P, Q, s1, s2);
<a name="l06866"></a>06866 }
<a name="l06867"></a>06867 
<a name="l06869"></a>06869 <span class="comment">//                                                                           //</span>
<a name="l06870"></a>06870 <span class="comment">// tri_tri_inter()    Test whether two triangle (abc) and (opq) are          //</span>
<a name="l06871"></a>06871 <span class="comment">//                    intersecting or not.                                   //</span>
<a name="l06872"></a>06872 <span class="comment">//                                                                           //</span>
<a name="l06873"></a>06873 <span class="comment">// The return value indicates one of the five cases: DISJOINT, SHAREVERTEX,  //</span>
<a name="l06874"></a>06874 <span class="comment">// SHAREEDGE, SHAREFACE, and INTERSECT.                                      //</span>
<a name="l06875"></a>06875 <span class="comment">//                                                                           //</span>
<a name="l06877"></a>06877 <span class="comment"></span>
<a name="l06878"></a>06878 <span class="keyword">enum</span> tetgenmesh::interresult tetgenmesh::tri_tri_inter(REAL* A, REAL* B,
<a name="l06879"></a>06879   REAL* C, REAL* O, REAL* P, REAL* Q)
<a name="l06880"></a>06880 {
<a name="l06881"></a>06881   REAL s_o, s_p, s_q;
<a name="l06882"></a>06882   REAL s_a, s_b, s_c;
<a name="l06883"></a>06883 
<a name="l06884"></a>06884   s_o = orient3d(A, B, C, O);
<a name="l06885"></a>06885   s_p = orient3d(A, B, C, P);
<a name="l06886"></a>06886   s_q = orient3d(A, B, C, Q);
<a name="l06887"></a>06887   <span class="keywordflow">if</span> ((s_o * s_p &gt; 0.0) &amp;&amp; (s_o * s_q &gt; 0.0)) {
<a name="l06888"></a>06888     <span class="comment">// o, p, q are all in the same halfspace of ABC.</span>
<a name="l06889"></a>06889     <span class="keywordflow">return</span> DISJOINT;
<a name="l06890"></a>06890   }
<a name="l06891"></a>06891 
<a name="l06892"></a>06892   s_a = orient3d(O, P, Q, A);
<a name="l06893"></a>06893   s_b = orient3d(O, P, Q, B);
<a name="l06894"></a>06894   s_c = orient3d(O, P, Q, C);
<a name="l06895"></a>06895   <span class="keywordflow">if</span> ((s_a * s_b &gt; 0.0) &amp;&amp; (s_a * s_c &gt; 0.0)) {
<a name="l06896"></a>06896     <span class="comment">// a, b, c are all in the same halfspace of OPQ.</span>
<a name="l06897"></a>06897     <span class="keywordflow">return</span> DISJOINT;
<a name="l06898"></a>06898   }
<a name="l06899"></a>06899 
<a name="l06900"></a>06900   <span class="keyword">enum</span> interresult abcop, abcpq, abcqo;
<a name="l06901"></a>06901   <span class="keywordtype">int</span> shareedge = 0;
<a name="l06902"></a>06902 
<a name="l06903"></a>06903   abcop = tri_edge_inter_tail(A, B, C, O, P, s_o, s_p);
<a name="l06904"></a>06904   <span class="keywordflow">if</span> (abcop == INTERSECT) {
<a name="l06905"></a>06905     <span class="keywordflow">return</span> INTERSECT;
<a name="l06906"></a>06906   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abcop == SHAREEDGE) {
<a name="l06907"></a>06907     shareedge++;
<a name="l06908"></a>06908   }
<a name="l06909"></a>06909   abcpq = tri_edge_inter_tail(A, B, C, P, Q, s_p, s_q);
<a name="l06910"></a>06910   <span class="keywordflow">if</span> (abcpq == INTERSECT) {
<a name="l06911"></a>06911     <span class="keywordflow">return</span> INTERSECT;
<a name="l06912"></a>06912   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abcpq == SHAREEDGE) {
<a name="l06913"></a>06913     shareedge++;
<a name="l06914"></a>06914   }
<a name="l06915"></a>06915   abcqo = tri_edge_inter_tail(A, B, C, Q, O, s_q, s_o);
<a name="l06916"></a>06916   <span class="keywordflow">if</span> (abcqo == INTERSECT) {
<a name="l06917"></a>06917     <span class="keywordflow">return</span> INTERSECT;
<a name="l06918"></a>06918   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (abcqo == SHAREEDGE) {
<a name="l06919"></a>06919     shareedge++;
<a name="l06920"></a>06920   }
<a name="l06921"></a>06921   <span class="keywordflow">if</span> (shareedge == 3) {
<a name="l06922"></a>06922     <span class="comment">// opq are coincident with abc.</span>
<a name="l06923"></a>06923     <span class="keywordflow">return</span> SHAREFACE;
<a name="l06924"></a>06924   }
<a name="l06925"></a>06925 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06926"></a>06926 <span class="preprocessor"></span>  <span class="comment">// It is only possible either no share edge or one.</span>
<a name="l06927"></a>06927   assert(shareedge == 0 || shareedge == 1);
<a name="l06928"></a>06928 <span class="preprocessor">#endif</span>
<a name="l06929"></a>06929 <span class="preprocessor"></span>
<a name="l06930"></a>06930   <span class="comment">// Continue to detect whether opq and abc are intersecting or not.</span>
<a name="l06931"></a>06931   <span class="keyword">enum</span> interresult opqab, opqbc, opqca;
<a name="l06932"></a>06932 
<a name="l06933"></a>06933   opqab = tri_edge_inter_tail(O, P, Q, A, B, s_a, s_b);
<a name="l06934"></a>06934   <span class="keywordflow">if</span> (opqab == INTERSECT) {
<a name="l06935"></a>06935     <span class="keywordflow">return</span> INTERSECT;
<a name="l06936"></a>06936   }
<a name="l06937"></a>06937   opqbc = tri_edge_inter_tail(O, P, Q, B, C, s_b, s_c);
<a name="l06938"></a>06938   <span class="keywordflow">if</span> (opqbc == INTERSECT) {
<a name="l06939"></a>06939     <span class="keywordflow">return</span> INTERSECT;
<a name="l06940"></a>06940   }
<a name="l06941"></a>06941   opqca = tri_edge_inter_tail(O, P, Q, C, A, s_c, s_a);
<a name="l06942"></a>06942   <span class="keywordflow">if</span> (opqca == INTERSECT) {
<a name="l06943"></a>06943     <span class="keywordflow">return</span> INTERSECT;
<a name="l06944"></a>06944   }
<a name="l06945"></a>06945 
<a name="l06946"></a>06946   <span class="comment">// At this point, two triangles are not intersecting and not coincident.</span>
<a name="l06947"></a>06947   <span class="comment">//   They may be share an edge, or share a vertex, or disjoint.</span>
<a name="l06948"></a>06948   <span class="keywordflow">if</span> (abcop == SHAREEDGE) {
<a name="l06949"></a>06949 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06950"></a>06950 <span class="preprocessor"></span>    assert(abcpq == SHAREVERTEX &amp;&amp; abcqo == SHAREVERTEX);
<a name="l06951"></a>06951 <span class="preprocessor">#endif</span>
<a name="l06952"></a>06952 <span class="preprocessor"></span>    <span class="comment">// op is coincident with an edge of abc.</span>
<a name="l06953"></a>06953     <span class="keywordflow">return</span> SHAREEDGE;
<a name="l06954"></a>06954   }
<a name="l06955"></a>06955   <span class="keywordflow">if</span> (abcpq == SHAREEDGE) {
<a name="l06956"></a>06956 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06957"></a>06957 <span class="preprocessor"></span>    assert(abcop == SHAREVERTEX &amp;&amp; abcqo == SHAREVERTEX);
<a name="l06958"></a>06958 <span class="preprocessor">#endif</span>
<a name="l06959"></a>06959 <span class="preprocessor"></span>    <span class="comment">// pq is coincident with an edge of abc.</span>
<a name="l06960"></a>06960     <span class="keywordflow">return</span> SHAREEDGE;
<a name="l06961"></a>06961   }
<a name="l06962"></a>06962   <span class="keywordflow">if</span> (abcqo == SHAREEDGE) {
<a name="l06963"></a>06963 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06964"></a>06964 <span class="preprocessor"></span>    assert(abcop == SHAREVERTEX &amp;&amp; abcpq == SHAREVERTEX);
<a name="l06965"></a>06965 <span class="preprocessor">#endif</span>
<a name="l06966"></a>06966 <span class="preprocessor"></span>    <span class="comment">// qo is coincident with an edge of abc.</span>
<a name="l06967"></a>06967     <span class="keywordflow">return</span> SHAREEDGE;
<a name="l06968"></a>06968   }
<a name="l06969"></a>06969 
<a name="l06970"></a>06970   <span class="comment">// They may share a vertex or disjoint.</span>
<a name="l06971"></a>06971   <span class="keywordflow">if</span> (abcop == SHAREVERTEX) {
<a name="l06972"></a>06972     <span class="comment">// o or p is coincident with a vertex of abc.</span>
<a name="l06973"></a>06973     <span class="keywordflow">if</span> (abcpq == SHAREVERTEX) {
<a name="l06974"></a>06974       <span class="comment">// p is the coincident vertex.</span>
<a name="l06975"></a>06975 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06976"></a>06976 <span class="preprocessor"></span>      assert(abcqo != SHAREVERTEX);
<a name="l06977"></a>06977 <span class="preprocessor">#endif</span>
<a name="l06978"></a>06978 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
<a name="l06979"></a>06979       <span class="comment">// o is the coincident vertex.</span>
<a name="l06980"></a>06980 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06981"></a>06981 <span class="preprocessor"></span>      assert(abcqo == SHAREVERTEX);
<a name="l06982"></a>06982 <span class="preprocessor">#endif</span>
<a name="l06983"></a>06983 <span class="preprocessor"></span>    }
<a name="l06984"></a>06984     <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06985"></a>06985   }
<a name="l06986"></a>06986   <span class="keywordflow">if</span> (abcpq == SHAREVERTEX) {
<a name="l06987"></a>06987     <span class="comment">// q is the coincident vertex.</span>
<a name="l06988"></a>06988 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l06989"></a>06989 <span class="preprocessor"></span>    assert(abcqo == SHAREVERTEX);
<a name="l06990"></a>06990 <span class="preprocessor">#endif</span>
<a name="l06991"></a>06991 <span class="preprocessor"></span>    <span class="keywordflow">return</span> SHAREVERTEX;
<a name="l06992"></a>06992   }
<a name="l06993"></a>06993 
<a name="l06994"></a>06994   <span class="comment">// They are disjoint.</span>
<a name="l06995"></a>06995   <span class="keywordflow">return</span> DISJOINT;
<a name="l06996"></a>06996 }
<a name="l06997"></a>06997 
<a name="l06999"></a>06999 <span class="comment">//                                                                           //</span>
<a name="l07000"></a>07000 <span class="comment">// insphere_sos()    Insphere test with symbolic perturbation.               //</span>
<a name="l07001"></a>07001 <span class="comment">//                                                                           //</span>
<a name="l07002"></a>07002 <span class="comment">// The input points a, b, c, and d should be non-coplanar. They must be ord- //</span>
<a name="l07003"></a>07003 <span class="comment">// ered so that they have a positive orientation (as defined by orient3d()), //</span>
<a name="l07004"></a>07004 <span class="comment">// or the sign of the result will be reversed.                               //</span>
<a name="l07005"></a>07005 <span class="comment">//                                                                           //</span>
<a name="l07006"></a>07006 <span class="comment">// Return a positive value if the point e lies inside the circumsphere of a, //</span>
<a name="l07007"></a>07007 <span class="comment">// b, c, and d; a negative value if it lies outside.                         //</span>
<a name="l07008"></a>07008 <span class="comment">//                                                                           //</span>
<a name="l07010"></a>07010 <span class="comment"></span>
<a name="l07011"></a>07011 REAL tetgenmesh::insphere_sos(REAL* pa, REAL* pb, REAL* pc, REAL* pd, REAL* pe,
<a name="l07012"></a>07012   <span class="keywordtype">int</span> ia, <span class="keywordtype">int</span> ib, <span class="keywordtype">int</span> ic, <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keywordtype">int</span> ie)
<a name="l07013"></a>07013 {
<a name="l07014"></a>07014   REAL det;
<a name="l07015"></a>07015 
<a name="l07016"></a>07016   det = insphere(pa, pb, pc, pd, pe);
<a name="l07017"></a>07017   <span class="keywordflow">if</span> (det != 0.0) {
<a name="l07018"></a>07018     <span class="keywordflow">return</span> det;
<a name="l07019"></a>07019   }
<a name="l07020"></a>07020 
<a name="l07021"></a>07021   <span class="comment">// det = 0.0, use symbolic perturbation.</span>
<a name="l07022"></a>07022   REAL *p[5], *tmpp;
<a name="l07023"></a>07023   REAL sign, det_c, det_d;
<a name="l07024"></a>07024   <span class="keywordtype">int</span> idx[5], perm, tmp;
<a name="l07025"></a>07025   <span class="keywordtype">int</span> n, i, j;
<a name="l07026"></a>07026 
<a name="l07027"></a>07027   p[0] = pa; idx[0] = ia;
<a name="l07028"></a>07028   p[1] = pb; idx[1] = ib;
<a name="l07029"></a>07029   p[2] = pc; idx[2] = ic;
<a name="l07030"></a>07030   p[3] = pd; idx[3] = id;
<a name="l07031"></a>07031   p[4] = pe; idx[4] = ie;
<a name="l07032"></a>07032 
<a name="l07033"></a>07033   <span class="comment">// Bubble sort the points by the increasing order of the indices.</span>
<a name="l07034"></a>07034   n = 5;
<a name="l07035"></a>07035   perm = 0; <span class="comment">// The number of total swaps.</span>
<a name="l07036"></a>07036   <span class="keywordflow">for</span> (i = 0; i &lt; n - 1; i++) {
<a name="l07037"></a>07037     <span class="keywordflow">for</span> (j = 0; j &lt; n - 1 - i; j++) {
<a name="l07038"></a>07038       <span class="keywordflow">if</span> (idx[j + 1] &lt; idx[j]) {  <span class="comment">// compare the two neighbors.</span>
<a name="l07039"></a>07039         tmp = idx[j];         <span class="comment">// swap idx[j] and idx[j + 1]</span>
<a name="l07040"></a>07040         idx[j] = idx[j + 1];
<a name="l07041"></a>07041         idx[j + 1] = tmp;
<a name="l07042"></a>07042         tmpp = p[j];         <span class="comment">// swap p[j] and p[j + 1]</span>
<a name="l07043"></a>07043         p[j] = p[j + 1];
<a name="l07044"></a>07044         p[j + 1] = tmpp;
<a name="l07045"></a>07045         perm++;
<a name="l07046"></a>07046       }
<a name="l07047"></a>07047     }
<a name="l07048"></a>07048   }
<a name="l07049"></a>07049 
<a name="l07050"></a>07050   sign = (perm % 2 == 0) ? 1.0 : -1.0;
<a name="l07051"></a>07051   det_c = orient3d(p[1], p[2], p[3], p[4]); <span class="comment">// orient3d(b, c, d, e)</span>
<a name="l07052"></a>07052   <span class="keywordflow">if</span> (det_c != 0.0) {
<a name="l07053"></a>07053     <span class="keywordflow">return</span> sign * det_c;
<a name="l07054"></a>07054   }
<a name="l07055"></a>07055   det_d = orient3d(p[0], p[2], p[3], p[4]); <span class="comment">// orient3d(a, c, d, e)</span>
<a name="l07056"></a>07056   <span class="keywordflow">return</span> -sign * det_d;
<a name="l07057"></a>07057 }
<a name="l07058"></a>07058 
<a name="l07060"></a>07060 <span class="comment">//                                                                           //</span>
<a name="l07061"></a>07061 <span class="comment">// iscollinear()    Check if three points are approximately collinear.       //</span>
<a name="l07062"></a>07062 <span class="comment">//                                                                           //</span>
<a name="l07063"></a>07063 <span class="comment">// &#39;eps&#39; is a relative error tolerance.  The collinearity is determined by   //</span>
<a name="l07064"></a>07064 <span class="comment">// the value q = cos(theta), where theta is the angle between two vectors    //</span>
<a name="l07065"></a>07065 <span class="comment">// A-&gt;B and A-&gt;C.  They&#39;re collinear if 1.0 - q &lt;= epspp.                    //</span>
<a name="l07066"></a>07066 <span class="comment">//                                                                           //</span>
<a name="l07068"></a>07068 <span class="comment"></span>
<a name="l07069"></a>07069 <span class="keywordtype">bool</span> tetgenmesh::iscollinear(REAL* A, REAL* B, REAL* C, REAL eps)
<a name="l07070"></a>07070 {
<a name="l07071"></a>07071   REAL abx, aby, abz;
<a name="l07072"></a>07072   REAL acx, acy, acz;
<a name="l07073"></a>07073   REAL Lv, Lw, dd;
<a name="l07074"></a>07074   REAL d, q;
<a name="l07075"></a>07075 
<a name="l07076"></a>07076   <span class="comment">// Limit of two closed points.</span>
<a name="l07077"></a>07077   q = longest * eps;
<a name="l07078"></a>07078   q *= q;
<a name="l07079"></a>07079 
<a name="l07080"></a>07080   abx = A[0] - B[0];
<a name="l07081"></a>07081   aby = A[1] - B[1];
<a name="l07082"></a>07082   abz = A[2] - B[2];
<a name="l07083"></a>07083   acx = A[0] - C[0];
<a name="l07084"></a>07084   acy = A[1] - C[1];
<a name="l07085"></a>07085   acz = A[2] - C[2];
<a name="l07086"></a>07086   Lv = abx * abx + aby * aby + abz * abz;
<a name="l07087"></a>07087   <span class="comment">// Is AB (nearly) indentical?</span>
<a name="l07088"></a>07088   <span class="keywordflow">if</span> (Lv &lt; q) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07089"></a>07089   Lw = acx * acx + acy * acy + acz * acz;
<a name="l07090"></a>07090   <span class="comment">// Is AC (nearly) indentical?</span>
<a name="l07091"></a>07091   <span class="keywordflow">if</span> (Lw &lt; q) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07092"></a>07092   dd = abx * acx + aby * acy + abz * acz;
<a name="l07093"></a>07093 
<a name="l07094"></a>07094   d = (dd * dd) / (Lv * Lw);
<a name="l07095"></a>07095   <span class="keywordflow">if</span> (d &gt; 1.0) d = 1.0; <span class="comment">// Rounding.</span>
<a name="l07096"></a>07096   q = 1.0 - sqrt(d); <span class="comment">// Notice 0 &lt; q &lt; 1.0.</span>
<a name="l07097"></a>07097 
<a name="l07098"></a>07098   <span class="keywordflow">return</span> q &lt;= eps;
<a name="l07099"></a>07099 }
<a name="l07100"></a>07100 
<a name="l07102"></a>07102 <span class="comment">//                                                                           //</span>
<a name="l07103"></a>07103 <span class="comment">// iscoplanar()    Check if four points are approximately coplanar.          //</span>
<a name="l07104"></a>07104 <span class="comment">//                                                                           //</span>
<a name="l07105"></a>07105 <span class="comment">// &#39;vol6&#39; is six times of the signed volume of the tetrahedron formed by the //</span>
<a name="l07106"></a>07106 <span class="comment">// four points. &#39;eps&#39; is the relative error tolerance.  The coplanarity is   //</span>
<a name="l07107"></a>07107 <span class="comment">// determined by the value: q = fabs(vol6) / L^3,  where L is the average    //</span>
<a name="l07108"></a>07108 <span class="comment">// edge length of the tet. They&#39;re coplanar if q &lt;= eps.                     //</span>
<a name="l07109"></a>07109 <span class="comment">//                                                                           //</span>
<a name="l07111"></a>07111 <span class="comment"></span>
<a name="l07112"></a>07112 <span class="keywordtype">bool</span> tetgenmesh::
<a name="l07113"></a>07113 iscoplanar(REAL* k, REAL* l, REAL* m, REAL* n, REAL vol6, REAL eps)
<a name="l07114"></a>07114 {
<a name="l07115"></a>07115   REAL L, q;
<a name="l07116"></a>07116   REAL x, y, z;
<a name="l07117"></a>07117 
<a name="l07118"></a>07118   <span class="keywordflow">if</span> (vol6 == 0.0) <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07119"></a>07119 
<a name="l07120"></a>07120   x = k[0] - l[0];
<a name="l07121"></a>07121   y = k[1] - l[1];
<a name="l07122"></a>07122   z = k[2] - l[2];
<a name="l07123"></a>07123   L = sqrt(x * x + y * y + z * z);
<a name="l07124"></a>07124   x = l[0] - m[0];
<a name="l07125"></a>07125   y = l[1] - m[1];
<a name="l07126"></a>07126   z = l[2] - m[2];
<a name="l07127"></a>07127   L += sqrt(x * x + y * y + z * z);
<a name="l07128"></a>07128   x = m[0] - k[0];
<a name="l07129"></a>07129   y = m[1] - k[1];
<a name="l07130"></a>07130   z = m[2] - k[2];
<a name="l07131"></a>07131   L += sqrt(x * x + y * y + z * z);
<a name="l07132"></a>07132   x = k[0] - n[0];
<a name="l07133"></a>07133   y = k[1] - n[1];
<a name="l07134"></a>07134   z = k[2] - n[2];
<a name="l07135"></a>07135   L += sqrt(x * x + y * y + z * z);
<a name="l07136"></a>07136   x = l[0] - n[0];
<a name="l07137"></a>07137   y = l[1] - n[1];
<a name="l07138"></a>07138   z = l[2] - n[2];
<a name="l07139"></a>07139   L += sqrt(x * x + y * y + z * z);
<a name="l07140"></a>07140   x = m[0] - n[0];
<a name="l07141"></a>07141   y = m[1] - n[1];
<a name="l07142"></a>07142   z = m[2] - n[2];
<a name="l07143"></a>07143   L += sqrt(x * x + y * y + z * z);
<a name="l07144"></a>07144 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l07145"></a>07145 <span class="preprocessor"></span>  assert(L &gt; 0.0);
<a name="l07146"></a>07146 <span class="preprocessor">#endif</span>
<a name="l07147"></a>07147 <span class="preprocessor"></span>  L /= 6.0;
<a name="l07148"></a>07148   q = fabs(vol6) / (L * L * L);
<a name="l07149"></a>07149 
<a name="l07150"></a>07150   <span class="keywordflow">return</span> q &lt;= eps;
<a name="l07151"></a>07151 }
<a name="l07152"></a>07152 
<a name="l07154"></a>07154 <span class="comment">//                                                                           //</span>
<a name="l07155"></a>07155 <span class="comment">// iscospheric()    Check if five points are approximately coplanar.         //</span>
<a name="l07156"></a>07156 <span class="comment">//                                                                           //</span>
<a name="l07157"></a>07157 <span class="comment">// &#39;vol24&#39; is the 24 times of the signed volume of the 4-dimensional simplex //</span>
<a name="l07158"></a>07158 <span class="comment">// formed by the five points. &#39;eps&#39; is the relative tolerance. The cosphere  //</span>
<a name="l07159"></a>07159 <span class="comment">// case is determined by the value: q = fabs(vol24) / L^4,  where L is the   //</span>
<a name="l07160"></a>07160 <span class="comment">// average edge length of the simplex. They&#39;re cosphere if q &lt;= eps.         //</span>
<a name="l07161"></a>07161 <span class="comment">//                                                                           //</span>
<a name="l07163"></a>07163 <span class="comment"></span>
<a name="l07164"></a>07164 <span class="keywordtype">bool</span> tetgenmesh::
<a name="l07165"></a>07165 iscospheric(REAL* k, REAL* l, REAL* m, REAL* n, REAL* o, REAL vol24, REAL eps)
<a name="l07166"></a>07166 {
<a name="l07167"></a>07167   REAL L, q;
<a name="l07168"></a>07168 
<a name="l07169"></a>07169   <span class="comment">// A 4D simplex has 10 edges.</span>
<a name="l07170"></a>07170   L = distance(k, l);
<a name="l07171"></a>07171   L += distance(l, m);
<a name="l07172"></a>07172   L += distance(m, k);
<a name="l07173"></a>07173   L += distance(k, n);
<a name="l07174"></a>07174   L += distance(l, n);
<a name="l07175"></a>07175   L += distance(m, n);
<a name="l07176"></a>07176   L += distance(k, o);
<a name="l07177"></a>07177   L += distance(l, o);
<a name="l07178"></a>07178   L += distance(m, o);
<a name="l07179"></a>07179   L += distance(n, o);
<a name="l07180"></a>07180 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l07181"></a>07181 <span class="preprocessor"></span>  assert(L &gt; 0.0);
<a name="l07182"></a>07182 <span class="preprocessor">#endif</span>
<a name="l07183"></a>07183 <span class="preprocessor"></span>  L /= 10.0;
<a name="l07184"></a>07184   q = fabs(vol24) / (L * L * L * L);
<a name="l07185"></a>07185 
<a name="l07186"></a>07186   <span class="keywordflow">return</span> q &lt; eps;
<a name="l07187"></a>07187 }
<a name="l07188"></a>07188 
<a name="l07189"></a>07189 <span class="comment">//</span>
<a name="l07190"></a>07190 <span class="comment">// End of geometric tests</span>
<a name="l07191"></a>07191 <span class="comment">//</span>
<a name="l07192"></a>07192 
<a name="l07193"></a>07193 <span class="comment">//</span>
<a name="l07194"></a>07194 <span class="comment">// Begin of Geometric quantities calculators</span>
<a name="l07195"></a>07195 <span class="comment">//</span>
<a name="l07196"></a>07196 
<a name="l07197"></a>07197 <span class="comment">// distance() computs the Euclidean distance between two points.</span>
<a name="l07198"></a>07198 <span class="keyword">inline</span> REAL tetgenmesh::distance(REAL* p1, REAL* p2)
<a name="l07199"></a>07199 {
<a name="l07200"></a>07200   <span class="keywordflow">return</span> sqrt((p2[0] - p1[0]) * (p2[0] - p1[0]) +
<a name="l07201"></a>07201               (p2[1] - p1[1]) * (p2[1] - p1[1]) +
<a name="l07202"></a>07202               (p2[2] - p1[2]) * (p2[2] - p1[2]));
<a name="l07203"></a>07203 }
<a name="l07204"></a>07204 
<a name="l07206"></a>07206 <span class="comment">//                                                                           //</span>
<a name="l07207"></a>07207 <span class="comment">// shortdistance()    Returns the shortest distance from point p to a line   //</span>
<a name="l07208"></a>07208 <span class="comment">//                    defined by two points e1 and e2.                       //</span>
<a name="l07209"></a>07209 <span class="comment">//                                                                           //</span>
<a name="l07210"></a>07210 <span class="comment">// First compute the projection length l_p of the vector v1 = p - e1 along   //</span>
<a name="l07211"></a>07211 <span class="comment">// the vector v2 = e2 - e1. Then Pythagoras&#39; Theorem is used to compute the  //</span>
<a name="l07212"></a>07212 <span class="comment">// shortest distance.                                                        //</span>
<a name="l07213"></a>07213 <span class="comment">//                                                                           //</span>
<a name="l07214"></a>07214 <span class="comment">// This routine allows that p is collinear with the line. In this case, the  //</span>
<a name="l07215"></a>07215 <span class="comment">// return value is zero. The two points e1 and e2 should not be identical.   //</span>
<a name="l07216"></a>07216 <span class="comment">//                                                                           //</span>
<a name="l07218"></a>07218 <span class="comment"></span>
<a name="l07219"></a>07219 REAL tetgenmesh::shortdistance(REAL* p, REAL* e1, REAL* e2)
<a name="l07220"></a>07220 {
<a name="l07221"></a>07221   REAL v1[3], v2[3];
<a name="l07222"></a>07222   REAL len, l_p;
<a name="l07223"></a>07223 
<a name="l07224"></a>07224   v1[0] = e2[0] - e1[0];
<a name="l07225"></a>07225   v1[1] = e2[1] - e1[1];
<a name="l07226"></a>07226   v1[2] = e2[2] - e1[2];
<a name="l07227"></a>07227   v2[0] = p[0] - e1[0];
<a name="l07228"></a>07228   v2[1] = p[1] - e1[1];
<a name="l07229"></a>07229   v2[2] = p[2] - e1[2];
<a name="l07230"></a>07230 
<a name="l07231"></a>07231   len = sqrt(dot(v1, v1));
<a name="l07232"></a>07232 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l07233"></a>07233 <span class="preprocessor"></span>  assert(len != 0.0);
<a name="l07234"></a>07234 <span class="preprocessor">#endif</span>
<a name="l07235"></a>07235 <span class="preprocessor"></span>  v1[0] /= len;
<a name="l07236"></a>07236   v1[1] /= len;
<a name="l07237"></a>07237   v1[2] /= len;
<a name="l07238"></a>07238   l_p = dot(v1, v2);
<a name="l07239"></a>07239 
<a name="l07240"></a>07240   <span class="keywordflow">return</span> sqrt(dot(v2, v2) - l_p * l_p);
<a name="l07241"></a>07241 }
<a name="l07242"></a>07242 
<a name="l07244"></a>07244 <span class="comment">//                                                                           //</span>
<a name="l07245"></a>07245 <span class="comment">// shortdistance()    Returns the shortest distance from point p to a face.  //</span>
<a name="l07246"></a>07246 <span class="comment">//                                                                           //</span>
<a name="l07248"></a>07248 <span class="comment"></span>
<a name="l07249"></a>07249 REAL tetgenmesh::shortdistance(REAL* p, REAL* e1, REAL* e2, REAL* e3)
<a name="l07250"></a>07250 {
<a name="l07251"></a>07251   REAL prj[3];
<a name="l07252"></a>07252 
<a name="l07253"></a>07253   projpt2face(p, e1, e2, e3, prj);
<a name="l07254"></a>07254   <span class="keywordflow">return</span> distance(p, prj);
<a name="l07255"></a>07255 }
<a name="l07256"></a>07256 
<a name="l07258"></a>07258 <span class="comment">//                                                                           //</span>
<a name="l07259"></a>07259 <span class="comment">// interiorangle()    Return the interior angle (0 - 2 * PI) between vectors //</span>
<a name="l07260"></a>07260 <span class="comment">//                    o-&gt;p1 and o-&gt;p2.                                       //</span>
<a name="l07261"></a>07261 <span class="comment">//                                                                           //</span>
<a name="l07262"></a>07262 <span class="comment">// &#39;n&#39; is the normal of the plane containing face (o, p1, p2).  The interior //</span>
<a name="l07263"></a>07263 <span class="comment">// angle is the total angle rotating from o-&gt;p1 around n to o-&gt;p2.  Exchange //</span>
<a name="l07264"></a>07264 <span class="comment">// the position of p1 and p2 will get the complement angle of the other one. //</span>
<a name="l07265"></a>07265 <span class="comment">// i.e., interiorangle(o, p1, p2) = 2 * PI - interiorangle(o, p2, p1).  Set  //</span>
<a name="l07266"></a>07266 <span class="comment">// &#39;n&#39; be NULL if you only want the interior angle between 0 - PI.           //</span>
<a name="l07267"></a>07267 <span class="comment">//                                                                           //</span>
<a name="l07269"></a>07269 <span class="comment"></span>
<a name="l07270"></a>07270 REAL tetgenmesh::interiorangle(REAL* o, REAL* p1, REAL* p2, REAL* n)
<a name="l07271"></a>07271 {
<a name="l07272"></a>07272   REAL v1[3], v2[3], np[3];
<a name="l07273"></a>07273   REAL theta, costheta, lenlen;
<a name="l07274"></a>07274   REAL ori, len1, len2;
<a name="l07275"></a>07275 
<a name="l07276"></a>07276   <span class="comment">// Get the interior angle (0 - PI) between o-&gt;p1, and o-&gt;p2.</span>
<a name="l07277"></a>07277   v1[0] = p1[0] - o[0];
<a name="l07278"></a>07278   v1[1] = p1[1] - o[1];
<a name="l07279"></a>07279   v1[2] = p1[2] - o[2];
<a name="l07280"></a>07280   v2[0] = p2[0] - o[0];
<a name="l07281"></a>07281   v2[1] = p2[1] - o[1];
<a name="l07282"></a>07282   v2[2] = p2[2] - o[2];
<a name="l07283"></a>07283   len1 = sqrt(dot(v1, v1));
<a name="l07284"></a>07284   len2 = sqrt(dot(v2, v2));
<a name="l07285"></a>07285   lenlen = len1 * len2;
<a name="l07286"></a>07286 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l07287"></a>07287 <span class="preprocessor"></span>  assert(lenlen != 0.0);
<a name="l07288"></a>07288 <span class="preprocessor">#endif</span>
<a name="l07289"></a>07289 <span class="preprocessor"></span>  costheta = dot(v1, v2) / lenlen;
<a name="l07290"></a>07290   <span class="keywordflow">if</span> (costheta &gt; 1.0) {
<a name="l07291"></a>07291     costheta = 1.0; <span class="comment">// Roundoff.</span>
<a name="l07292"></a>07292   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (costheta &lt; -1.0) {
<a name="l07293"></a>07293     costheta = -1.0; <span class="comment">// Roundoff.</span>
<a name="l07294"></a>07294   }
<a name="l07295"></a>07295   theta = acos(costheta);
<a name="l07296"></a>07296   <span class="keywordflow">if</span> (n != NULL) {
<a name="l07297"></a>07297     <span class="comment">// Get a point above the face (o, p1, p2);</span>
<a name="l07298"></a>07298     np[0] = o[0] + n[0];
<a name="l07299"></a>07299     np[1] = o[1] + n[1];
<a name="l07300"></a>07300     np[2] = o[2] + n[2];
<a name="l07301"></a>07301     <span class="comment">// Adjust theta (0 - 2 * PI).</span>
<a name="l07302"></a>07302     ori = orient3d(p1, o, np, p2);
<a name="l07303"></a>07303     <span class="keywordflow">if</span> (ori &gt; 0.0) {
<a name="l07304"></a>07304       theta = 2 * PI - theta;
<a name="l07305"></a>07305     }
<a name="l07306"></a>07306   }
<a name="l07307"></a>07307 
<a name="l07308"></a>07308   <span class="keywordflow">return</span> theta;
<a name="l07309"></a>07309 }
<a name="l07310"></a>07310 
<a name="l07312"></a>07312 <span class="comment">//                                                                           //</span>
<a name="l07313"></a>07313 <span class="comment">// projpt2edge()    Return the projection point from a point to an edge.     //</span>
<a name="l07314"></a>07314 <span class="comment">//                                                                           //</span>
<a name="l07316"></a>07316 <span class="comment"></span>
<a name="l07317"></a>07317 <span class="keywordtype">void</span> tetgenmesh::projpt2edge(REAL* p, REAL* e1, REAL* e2, REAL* prj)
<a name="l07318"></a>07318 {
<a name="l07319"></a>07319   REAL v1[3], v2[3];
<a name="l07320"></a>07320   REAL len, l_p;
<a name="l07321"></a>07321 
<a name="l07322"></a>07322   v1[0] = e2[0] - e1[0];
<a name="l07323"></a>07323   v1[1] = e2[1] - e1[1];
<a name="l07324"></a>07324   v1[2] = e2[2] - e1[2];
<a name="l07325"></a>07325   v2[0] = p[0] - e1[0];
<a name="l07326"></a>07326   v2[1] = p[1] - e1[1];
<a name="l07327"></a>07327   v2[2] = p[2] - e1[2];
<a name="l07328"></a>07328 
<a name="l07329"></a>07329   len = sqrt(dot(v1, v1));
<a name="l07330"></a>07330 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l07331"></a>07331 <span class="preprocessor"></span>  assert(len != 0.0);
<a name="l07332"></a>07332 <span class="preprocessor">#endif</span>
<a name="l07333"></a>07333 <span class="preprocessor"></span>  v1[0] /= len;
<a name="l07334"></a>07334   v1[1] /= len;
<a name="l07335"></a>07335   v1[2] /= len;
<a name="l07336"></a>07336   l_p = dot(v1, v2);
<a name="l07337"></a>07337 
<a name="l07338"></a>07338   prj[0] = e1[0] + l_p * v1[0];
<a name="l07339"></a>07339   prj[1] = e1[1] + l_p * v1[1];
<a name="l07340"></a>07340   prj[2] = e1[2] + l_p * v1[2];
<a name="l07341"></a>07341 }
<a name="l07342"></a>07342 
<a name="l07344"></a>07344 <span class="comment">//                                                                           //</span>
<a name="l07345"></a>07345 <span class="comment">// projpt2face()    Return the projection point from a point to a face.      //</span>
<a name="l07346"></a>07346 <span class="comment">//                                                                           //</span>
<a name="l07348"></a>07348 <span class="comment"></span>
<a name="l07349"></a>07349 <span class="keywordtype">void</span> tetgenmesh::projpt2face(REAL* p, REAL* f1, REAL* f2, REAL* f3, REAL* prj)
<a name="l07350"></a>07350 {
<a name="l07351"></a>07351   REAL fnormal[3], v1[3];
<a name="l07352"></a>07352   REAL len, dist;
<a name="l07353"></a>07353 
<a name="l07354"></a>07354   <span class="comment">// Get the unit face normal.</span>
<a name="l07355"></a>07355   facenormal(f1, f2, f3, fnormal, &amp;len);
<a name="l07356"></a>07356 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l07357"></a>07357 <span class="preprocessor"></span>  assert(len &gt; 0.0);
<a name="l07358"></a>07358 <span class="preprocessor">#endif</span>
<a name="l07359"></a>07359 <span class="preprocessor"></span>  fnormal[0] /= len;
<a name="l07360"></a>07360   fnormal[1] /= len;
<a name="l07361"></a>07361   fnormal[2] /= len;
<a name="l07362"></a>07362   <span class="comment">// Get the vector v1 = |p - f1|.</span>
<a name="l07363"></a>07363   v1[0] = p[0] - f1[0];
<a name="l07364"></a>07364   v1[1] = p[1] - f1[1];
<a name="l07365"></a>07365   v1[2] = p[2] - f1[2];
<a name="l07366"></a>07366   <span class="comment">// Get the project distance.</span>
<a name="l07367"></a>07367   dist = dot(fnormal, v1);
<a name="l07368"></a>07368 
<a name="l07369"></a>07369   <span class="comment">// Get the project point.</span>
<a name="l07370"></a>07370   prj[0] = p[0] - dist * fnormal[0];
<a name="l07371"></a>07371   prj[1] = p[1] - dist * fnormal[1];
<a name="l07372"></a>07372   prj[2] = p[2] - dist * fnormal[2];
<a name="l07373"></a>07373 }
<a name="l07374"></a>07374 
<a name="l07376"></a>07376 <span class="comment">//                                                                           //</span>
<a name="l07377"></a>07377 <span class="comment">// facenormal()    Calculate the normal of a face given by three points.     //</span>
<a name="l07378"></a>07378 <span class="comment">//                                                                           //</span>
<a name="l07379"></a>07379 <span class="comment">// In general, the face normal can be calculate by the cross product of any  //</span>
<a name="l07380"></a>07380 <span class="comment">// pair of the three edge vectors.  However, if the three points are nearly  //</span>
<a name="l07381"></a>07381 <span class="comment">// collinear, the rounding error may harm the result. To choose a good pair  //</span>
<a name="l07382"></a>07382 <span class="comment">// of vectors is helpful to reduce the error.                                //</span>
<a name="l07383"></a>07383 <span class="comment">//                                                                           //</span>
<a name="l07385"></a>07385 <span class="comment"></span>
<a name="l07386"></a>07386 <span class="keywordtype">void</span> tetgenmesh::facenormal(REAL* pa, REAL* pb, REAL* pc, REAL* n, REAL* nlen)
<a name="l07387"></a>07387 {
<a name="l07388"></a>07388   REAL v1[3], v2[3];
<a name="l07389"></a>07389 
<a name="l07390"></a>07390   v1[0] = pb[0] - pa[0];
<a name="l07391"></a>07391   v1[1] = pb[1] - pa[1];
<a name="l07392"></a>07392   v1[2] = pb[2] - pa[2];
<a name="l07393"></a>07393   v2[0] = pc[0] - pa[0];
<a name="l07394"></a>07394   v2[1] = pc[1] - pa[1];
<a name="l07395"></a>07395   v2[2] = pc[2] - pa[2];
<a name="l07396"></a>07396 
<a name="l07397"></a>07397   cross(v1, v2, n);
<a name="l07398"></a>07398   <span class="keywordflow">if</span> (nlen != (REAL *) NULL) {
<a name="l07399"></a>07399     *nlen = sqrt(dot(n, n));
<a name="l07400"></a>07400   }
<a name="l07401"></a>07401 }
<a name="l07402"></a>07402 
<a name="l07404"></a>07404 <span class="comment">//                                                                           //</span>
<a name="l07405"></a>07405 <span class="comment">// edgeorthonormal()    Return the unit normal of an edge in a given plane.  //</span>
<a name="l07406"></a>07406 <span class="comment">//                                                                           //</span>
<a name="l07407"></a>07407 <span class="comment">// The edge is from e1 to e2,  the plane is defined by given an additional   //</span>
<a name="l07408"></a>07408 <span class="comment">// point op, which is non-collinear with the edge.  In addition, the side of //</span>
<a name="l07409"></a>07409 <span class="comment">// the edge in which op lies defines the positive position of the normal.    //</span>
<a name="l07410"></a>07410 <span class="comment">//                                                                           //</span>
<a name="l07411"></a>07411 <span class="comment">// Let v1 be the unit vector from e1 to e2, v2 be the unit edge vector from  //</span>
<a name="l07412"></a>07412 <span class="comment">// e1 to op, fn be the unit face normal calculated by fn = v1 x v2. Then the //</span>
<a name="l07413"></a>07413 <span class="comment">// unit edge normal of e1e2 pointing to op is n = fn x v1.  Note, we should  //</span>
<a name="l07414"></a>07414 <span class="comment">// not change the position of fn and v1, otherwise, we get the edge normal   //</span>
<a name="l07415"></a>07415 <span class="comment">// pointing to the other side of op.                                         //</span>
<a name="l07416"></a>07416 <span class="comment">//                                                                           //</span>
<a name="l07418"></a>07418 <span class="comment"></span>
<a name="l07419"></a>07419 <span class="keywordtype">void</span> tetgenmesh::edgeorthonormal(REAL* e1, REAL* e2, REAL* op, REAL* n)
<a name="l07420"></a>07420 {
<a name="l07421"></a>07421   REAL v1[3], v2[3], fn[3];
<a name="l07422"></a>07422   REAL len;
<a name="l07423"></a>07423 
<a name="l07424"></a>07424   <span class="comment">// Get the edge vector v1.</span>
<a name="l07425"></a>07425   v1[0] = e2[0] - e1[0];
<a name="l07426"></a>07426   v1[1] = e2[1] - e1[1];
<a name="l07427"></a>07427   v1[2] = e2[2] - e1[2];
<a name="l07428"></a>07428   <span class="comment">// Get the edge vector v2.</span>
<a name="l07429"></a>07429   v2[0] = op[0] - e1[0];
<a name="l07430"></a>07430   v2[1] = op[1] - e1[1];
<a name="l07431"></a>07431   v2[2] = op[2] - e1[2];
<a name="l07432"></a>07432   <span class="comment">// Get the face normal fn = v1 x v2.</span>
<a name="l07433"></a>07433   cross(v1, v2, fn);
<a name="l07434"></a>07434   <span class="comment">// Get the edge normal n pointing to op. n = fn x v1.</span>
<a name="l07435"></a>07435   cross(fn, v1, n);
<a name="l07436"></a>07436   <span class="comment">// Normalize the vector.</span>
<a name="l07437"></a>07437   len = sqrt(dot(n, n));
<a name="l07438"></a>07438   n[0] /= len;
<a name="l07439"></a>07439   n[1] /= len;
<a name="l07440"></a>07440   n[2] /= len;
<a name="l07441"></a>07441 }
<a name="l07442"></a>07442 
<a name="l07444"></a>07444 <span class="comment">//                                                                           //</span>
<a name="l07445"></a>07445 <span class="comment">// facedihedral()    Return the dihedral angle (in radian) between two       //</span>
<a name="l07446"></a>07446 <span class="comment">//                   adjoining faces.                                        //</span>
<a name="l07447"></a>07447 <span class="comment">//                                                                           //</span>
<a name="l07448"></a>07448 <span class="comment">// &#39;pa&#39;, &#39;pb&#39; are the shared edge of these two faces, &#39;pc1&#39;, and &#39;pc2&#39; are   //</span>
<a name="l07449"></a>07449 <span class="comment">// apexes of these two faces.  Return the angle (between 0 to 2*pi) between  //</span>
<a name="l07450"></a>07450 <span class="comment">// the normal of face (pa, pb, pc1) and normal of face (pa, pb, pc2).        //</span>
<a name="l07451"></a>07451 <span class="comment">//                                                                           //</span>
<a name="l07453"></a>07453 <span class="comment"></span>
<a name="l07454"></a>07454 REAL tetgenmesh::facedihedral(REAL* pa, REAL* pb, REAL* pc1, REAL* pc2)
<a name="l07455"></a>07455 {
<a name="l07456"></a>07456   REAL n1[3], n2[3];
<a name="l07457"></a>07457   REAL n1len, n2len;
<a name="l07458"></a>07458   REAL costheta, ori;
<a name="l07459"></a>07459   REAL theta;
<a name="l07460"></a>07460 
<a name="l07461"></a>07461   facenormal(pa, pb, pc1, n1, &amp;n1len);
<a name="l07462"></a>07462   facenormal(pa, pb, pc2, n2, &amp;n2len);
<a name="l07463"></a>07463   costheta = dot(n1, n2) / (n1len * n2len);
<a name="l07464"></a>07464   <span class="comment">// Be careful rounding error!</span>
<a name="l07465"></a>07465   <span class="keywordflow">if</span> (costheta &gt; 1.0) {
<a name="l07466"></a>07466     costheta = 1.0;
<a name="l07467"></a>07467   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (costheta &lt; -1.0) {
<a name="l07468"></a>07468     costheta = -1.0;
<a name="l07469"></a>07469   }
<a name="l07470"></a>07470   theta = acos(costheta);
<a name="l07471"></a>07471   ori = orient3d(pa, pb, pc1, pc2);
<a name="l07472"></a>07472   <span class="keywordflow">if</span> (ori &gt; 0.0) {
<a name="l07473"></a>07473     theta = 2 * PI - theta;
<a name="l07474"></a>07474   }
<a name="l07475"></a>07475 
<a name="l07476"></a>07476   <span class="keywordflow">return</span> theta;
<a name="l07477"></a>07477 }
<a name="l07478"></a>07478 
<a name="l07480"></a>07480 <span class="comment">//                                                                           //</span>
<a name="l07481"></a>07481 <span class="comment">// tetalldihedral()    Get all (six) dihedral angles of a tet.               //</span>
<a name="l07482"></a>07482 <span class="comment">//                                                                           //</span>
<a name="l07483"></a>07483 <span class="comment">// The tet is given by its four corners a, b, c, and d. If &#39;cosdd&#39; is not    //</span>
<a name="l07484"></a>07484 <span class="comment">// NULL, it returns the cosines of the 6 dihedral angles, the corresponding  //</span>
<a name="l07485"></a>07485 <span class="comment">// edges are: ab, bc, ca, ad, bd, and cd. If &#39;cosmaxd&#39; (or &#39;cosmind&#39;) is not //</span>
<a name="l07486"></a>07486 <span class="comment">// NULL, it returns the cosine of the maximal (or minimal) dihedral angle.   //</span>
<a name="l07487"></a>07487 <span class="comment">//                                                                           //</span>
<a name="l07489"></a>07489 <span class="comment"></span>
<a name="l07490"></a>07490 <span class="keywordtype">void</span> tetgenmesh::tetalldihedral(point pa, point pb, point pc, point pd,
<a name="l07491"></a>07491   REAL* cosdd, REAL* cosmaxd, REAL* cosmind)
<a name="l07492"></a>07492 {
<a name="l07493"></a>07493   REAL N[4][3], cosd, len;
<a name="l07494"></a>07494   <span class="keywordtype">int</span> f1, f2, i, j;
<a name="l07495"></a>07495 
<a name="l07496"></a>07496   f1=0;
<a name="l07497"></a>07497   f2=0;
<a name="l07498"></a>07498 
<a name="l07499"></a>07499   <span class="comment">// Get four normals of faces of the tet.</span>
<a name="l07500"></a>07500   tetallnormal(pa, pb, pc, pd, N, NULL);
<a name="l07501"></a>07501   <span class="comment">// Normalize the normals.</span>
<a name="l07502"></a>07502   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l07503"></a>07503     len = sqrt(dot(N[i], N[i]));
<a name="l07504"></a>07504     <span class="keywordflow">if</span> (len != 0.0) {
<a name="l07505"></a>07505       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) N[i][j] /= len;
<a name="l07506"></a>07506     }
<a name="l07507"></a>07507   }
<a name="l07508"></a>07508 
<a name="l07509"></a>07509   <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l07510"></a>07510     <span class="keywordflow">switch</span> (i) {
<a name="l07511"></a>07511     <span class="keywordflow">case</span> 0: f1 = 2; f2 = 3; <span class="keywordflow">break</span>; <span class="comment">// edge ab.</span>
<a name="l07512"></a>07512     <span class="keywordflow">case</span> 1: f1 = 0; f2 = 3; <span class="keywordflow">break</span>; <span class="comment">// edge bc.</span>
<a name="l07513"></a>07513     <span class="keywordflow">case</span> 2: f1 = 1; f2 = 3; <span class="keywordflow">break</span>; <span class="comment">// edge ca.</span>
<a name="l07514"></a>07514     <span class="keywordflow">case</span> 3: f1 = 1; f2 = 2; <span class="keywordflow">break</span>; <span class="comment">// edge ad.</span>
<a name="l07515"></a>07515     <span class="keywordflow">case</span> 4: f1 = 2; f2 = 0; <span class="keywordflow">break</span>; <span class="comment">// edge bd.</span>
<a name="l07516"></a>07516     <span class="keywordflow">case</span> 5: f1 = 0; f2 = 1; <span class="keywordflow">break</span>; <span class="comment">// edge cd.</span>
<a name="l07517"></a>07517     }
<a name="l07518"></a>07518     cosd = -dot(N[f1], N[f2]);
<a name="l07519"></a>07519     <span class="keywordflow">if</span> (cosdd) cosdd[i] = cosd;
<a name="l07520"></a>07520     <span class="keywordflow">if</span> (i == 0) {
<a name="l07521"></a>07521       <span class="keywordflow">if</span> (cosmaxd) *cosmaxd = cosd;
<a name="l07522"></a>07522       <span class="keywordflow">if</span> (cosmind) *cosmind = cosd;
<a name="l07523"></a>07523     } <span class="keywordflow">else</span> {
<a name="l07524"></a>07524       <span class="keywordflow">if</span> (cosmaxd) *cosmaxd = cosd &lt; *cosmaxd ? cosd : *cosmaxd;
<a name="l07525"></a>07525       <span class="keywordflow">if</span> (cosmind) *cosmind = cosd &gt; *cosmind ? cosd : *cosmind;
<a name="l07526"></a>07526     }
<a name="l07527"></a>07527   }
<a name="l07528"></a>07528 }
<a name="l07529"></a>07529 
<a name="l07531"></a>07531 <span class="comment">//                                                                           //</span>
<a name="l07532"></a>07532 <span class="comment">// tetallnormal()    Get the in-noramls of the four faces of a given tet.    //</span>
<a name="l07533"></a>07533 <span class="comment">//                                                                           //</span>
<a name="l07534"></a>07534 <span class="comment">// Let tet be abcd. N[4][3] returns the four normals, which are: N[0] cbd,   //</span>
<a name="l07535"></a>07535 <span class="comment">// N[1] acd, N[2] bad, N[3] abc. These normals are unnormalized.             //</span>
<a name="l07536"></a>07536 <span class="comment">//                                                                           //</span>
<a name="l07538"></a>07538 <span class="comment"></span>
<a name="l07539"></a>07539 <span class="keywordtype">void</span> tetgenmesh::tetallnormal(point pa, point pb, point pc, point pd,
<a name="l07540"></a>07540   REAL N[4][3], REAL* volume)
<a name="l07541"></a>07541 {
<a name="l07542"></a>07542   REAL A[4][4], rhs[4], D;
<a name="l07543"></a>07543   <span class="keywordtype">int</span> indx[4];
<a name="l07544"></a>07544   <span class="keywordtype">int</span> i, j;
<a name="l07545"></a>07545 
<a name="l07546"></a>07546   <span class="comment">// get the entries of A[3][3].</span>
<a name="l07547"></a>07547   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[0][i] = pa[i] - pd[i];  <span class="comment">// d-&gt;a vec</span>
<a name="l07548"></a>07548   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[1][i] = pb[i] - pd[i];  <span class="comment">// d-&gt;b vec</span>
<a name="l07549"></a>07549   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[2][i] = pc[i] - pd[i];  <span class="comment">// d-&gt;c vec</span>
<a name="l07550"></a>07550   <span class="comment">// Compute the inverse of matrix A, to get 3 normals of the 4 faces.</span>
<a name="l07551"></a>07551   lu_decmp(A, 3, indx, &amp;D, 0);     <span class="comment">// Decompose the matrix just once.</span>
<a name="l07552"></a>07552   <span class="keywordflow">if</span> (volume != NULL) {
<a name="l07553"></a>07553     <span class="comment">// Get the volume of the tet.</span>
<a name="l07554"></a>07554     *volume = fabs((A[indx[0]][0] * A[indx[1]][1] * A[indx[2]][2])) / 6.0;
<a name="l07555"></a>07555   }
<a name="l07556"></a>07556   <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l07557"></a>07557     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) rhs[i] = 0.0;
<a name="l07558"></a>07558     rhs[j] = 1.0;  <span class="comment">// Positive means the inside direction</span>
<a name="l07559"></a>07559     lu_solve(A, 3, indx, rhs, 0);
<a name="l07560"></a>07560     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) N[j][i] = rhs[i];
<a name="l07561"></a>07561   }
<a name="l07562"></a>07562   <span class="comment">// Get the fourth normal by summing up the first three.</span>
<a name="l07563"></a>07563   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) N[3][i] = - N[0][i] - N[1][i] - N[2][i];
<a name="l07564"></a>07564 }
<a name="l07565"></a>07565 
<a name="l07567"></a>07567 <span class="comment">//                                                                           //</span>
<a name="l07568"></a>07568 <span class="comment">// tetaspectratio()    Calculate the aspect ratio of the tetrahedron.        //</span>
<a name="l07569"></a>07569 <span class="comment">//                                                                           //</span>
<a name="l07570"></a>07570 <span class="comment">// The aspect ratio of a tet is R/h, where R is the circumradius and h is    //</span>
<a name="l07571"></a>07571 <span class="comment">// the shortest height of the tet.                                           //</span>
<a name="l07572"></a>07572 <span class="comment">//                                                                           //</span>
<a name="l07574"></a>07574 <span class="comment"></span>
<a name="l07575"></a>07575 REAL tetgenmesh::tetaspectratio(point pa, point pb, point pc, point pd)
<a name="l07576"></a>07576 {
<a name="l07577"></a>07577   REAL vda[3], vdb[3], vdc[3];
<a name="l07578"></a>07578   REAL N[4][3], A[4][4], rhs[4], D;
<a name="l07579"></a>07579   REAL H[4], volume, radius2, minheightinv;
<a name="l07580"></a>07580   <span class="keywordtype">int</span> indx[4];
<a name="l07581"></a>07581   <span class="keywordtype">int</span> i, j;
<a name="l07582"></a>07582 
<a name="l07583"></a>07583   <span class="comment">// Set the matrix A = [vda, vdb, vdc]^T.</span>
<a name="l07584"></a>07584   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[0][i] = vda[i] = pa[i] - pd[i];
<a name="l07585"></a>07585   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[1][i] = vdb[i] = pb[i] - pd[i];
<a name="l07586"></a>07586   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[2][i] = vdc[i] = pc[i] - pd[i];
<a name="l07587"></a>07587   <span class="comment">// Lu-decompose the matrix A.</span>
<a name="l07588"></a>07588   lu_decmp(A, 3, indx, &amp;D, 0);
<a name="l07589"></a>07589   <span class="comment">// Get the volume of abcd.</span>
<a name="l07590"></a>07590   volume = (A[indx[0]][0] * A[indx[1]][1] * A[indx[2]][2]) / 6.0;
<a name="l07591"></a>07591   <span class="comment">// Check if it is zero.</span>
<a name="l07592"></a>07592   <span class="keywordflow">if</span> (volume == 0.0) <span class="keywordflow">return</span> 1.0e+200; <span class="comment">// A degenerate tet.</span>
<a name="l07593"></a>07593   <span class="comment">// if (volume &lt; 0.0) volume = -volume;</span>
<a name="l07594"></a>07594   <span class="comment">// Check the radiu-edge ratio of the tet.</span>
<a name="l07595"></a>07595   rhs[0] = 0.5 * dot(vda, vda);
<a name="l07596"></a>07596   rhs[1] = 0.5 * dot(vdb, vdb);
<a name="l07597"></a>07597   rhs[2] = 0.5 * dot(vdc, vdc);
<a name="l07598"></a>07598   lu_solve(A, 3, indx, rhs, 0);
<a name="l07599"></a>07599   <span class="comment">// Get the circumcenter.</span>
<a name="l07600"></a>07600   <span class="comment">// for (i = 0; i &lt; 3; i++) circumcent[i] = pd[i] + rhs[i];</span>
<a name="l07601"></a>07601   <span class="comment">// Get the square of the circumradius.</span>
<a name="l07602"></a>07602   radius2 = dot(rhs, rhs);
<a name="l07603"></a>07603 
<a name="l07604"></a>07604   <span class="comment">// Compute the 4 face normals (N[0], ..., N[3]).</span>
<a name="l07605"></a>07605   <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l07606"></a>07606     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) rhs[i] = 0.0;
<a name="l07607"></a>07607     rhs[j] = 1.0;  <span class="comment">// Positive means the inside direction</span>
<a name="l07608"></a>07608     lu_solve(A, 3, indx, rhs, 0);
<a name="l07609"></a>07609     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) N[j][i] = rhs[i];
<a name="l07610"></a>07610   }
<a name="l07611"></a>07611   <span class="comment">// Get the fourth normal by summing up the first three.</span>
<a name="l07612"></a>07612   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) N[3][i] = - N[0][i] - N[1][i] - N[2][i];
<a name="l07613"></a>07613   <span class="comment">// Normalized the normals.</span>
<a name="l07614"></a>07614   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l07615"></a>07615     <span class="comment">// H[i] is the inverse of the height of its corresponding face.</span>
<a name="l07616"></a>07616     H[i] = sqrt(dot(N[i], N[i]));
<a name="l07617"></a>07617     <span class="comment">// if (H[i] &gt; 0.0) {</span>
<a name="l07618"></a>07618     <span class="comment">//   for (j = 0; j &lt; 3; j++) N[i][j] /= H[i];</span>
<a name="l07619"></a>07619     <span class="comment">// }</span>
<a name="l07620"></a>07620   }
<a name="l07621"></a>07621   <span class="comment">// Get the radius of the inscribed sphere.</span>
<a name="l07622"></a>07622   <span class="comment">// insradius = 1.0 / (H[0] + H[1] + H[2] + H[3]);</span>
<a name="l07623"></a>07623   <span class="comment">// Get the biggest H[i] (corresponding to the smallest height).</span>
<a name="l07624"></a>07624   minheightinv = H[0];
<a name="l07625"></a>07625   <span class="keywordflow">for</span> (i = 1; i &lt; 3; i++) {
<a name="l07626"></a>07626     <span class="keywordflow">if</span> (H[i] &gt; minheightinv) minheightinv = H[i];
<a name="l07627"></a>07627   }
<a name="l07628"></a>07628 
<a name="l07629"></a>07629   <span class="keywordflow">return</span> sqrt(radius2) * minheightinv;
<a name="l07630"></a>07630 }
<a name="l07631"></a>07631 
<a name="l07633"></a>07633 <span class="comment">//                                                                           //</span>
<a name="l07634"></a>07634 <span class="comment">// circumsphere()    Calculate the smallest circumsphere (center and radius) //</span>
<a name="l07635"></a>07635 <span class="comment">//                   of the given three or four points.                      //</span>
<a name="l07636"></a>07636 <span class="comment">//                                                                           //</span>
<a name="l07637"></a>07637 <span class="comment">// The circumsphere of four points (a tetrahedron) is unique if they are not //</span>
<a name="l07638"></a>07638 <span class="comment">// degenerate. If &#39;pd = NULL&#39;, the smallest circumsphere of three points is  //</span>
<a name="l07639"></a>07639 <span class="comment">// the diametral sphere of the triangle if they are not degenerate.          //</span>
<a name="l07640"></a>07640 <span class="comment">//                                                                           //</span>
<a name="l07641"></a>07641 <span class="comment">// Return TRUE if the input points are not degenerate and the circumcenter   //</span>
<a name="l07642"></a>07642 <span class="comment">// and circumradius are returned in &#39;cent&#39; and &#39;radius&#39; respectively if they //</span>
<a name="l07643"></a>07643 <span class="comment">// are not NULLs. Otherwise, return FALSE indicated the points are degenrate.//</span>
<a name="l07644"></a>07644 <span class="comment">//                                                                           //</span>
<a name="l07646"></a>07646 <span class="comment"></span>
<a name="l07647"></a>07647 <span class="keywordtype">bool</span> tetgenmesh::
<a name="l07648"></a>07648 circumsphere(REAL* pa, REAL* pb, REAL* pc, REAL* pd, REAL* cent, REAL* radius)
<a name="l07649"></a>07649 {
<a name="l07650"></a>07650   REAL A[4][4], rhs[4], D;
<a name="l07651"></a>07651   <span class="keywordtype">int</span> indx[4];
<a name="l07652"></a>07652 
<a name="l07653"></a>07653   <span class="comment">// Compute the coefficient matrix A (3x3).</span>
<a name="l07654"></a>07654   A[0][0] = pb[0] - pa[0];
<a name="l07655"></a>07655   A[0][1] = pb[1] - pa[1];
<a name="l07656"></a>07656   A[0][2] = pb[2] - pa[2];
<a name="l07657"></a>07657   A[1][0] = pc[0] - pa[0];
<a name="l07658"></a>07658   A[1][1] = pc[1] - pa[1];
<a name="l07659"></a>07659   A[1][2] = pc[2] - pa[2];
<a name="l07660"></a>07660   <span class="keywordflow">if</span> (pd != NULL) {
<a name="l07661"></a>07661     A[2][0] = pd[0] - pa[0];
<a name="l07662"></a>07662     A[2][1] = pd[1] - pa[1];
<a name="l07663"></a>07663     A[2][2] = pd[2] - pa[2];
<a name="l07664"></a>07664   } <span class="keywordflow">else</span> {
<a name="l07665"></a>07665     cross(A[0], A[1], A[2]);
<a name="l07666"></a>07666   }
<a name="l07667"></a>07667 
<a name="l07668"></a>07668   <span class="comment">// Compute the right hand side vector b (3x1).</span>
<a name="l07669"></a>07669   rhs[0] = 0.5 * dot(A[0], A[0]);
<a name="l07670"></a>07670   rhs[1] = 0.5 * dot(A[1], A[1]);
<a name="l07671"></a>07671   <span class="keywordflow">if</span> (pd != NULL) {
<a name="l07672"></a>07672     rhs[2] = 0.5 * dot(A[2], A[2]);
<a name="l07673"></a>07673   } <span class="keywordflow">else</span> {
<a name="l07674"></a>07674     rhs[2] = 0.0;
<a name="l07675"></a>07675   }
<a name="l07676"></a>07676 
<a name="l07677"></a>07677   <span class="comment">// Solve the 3 by 3 equations use LU decomposition with partial pivoting</span>
<a name="l07678"></a>07678   <span class="comment">//   and backward and forward substitute..</span>
<a name="l07679"></a>07679   <span class="keywordflow">if</span> (!lu_decmp(A, 3, indx, &amp;D, 0)) {
<a name="l07680"></a>07680     <span class="keywordflow">if</span> (radius != (REAL *) NULL) *radius = 0.0;
<a name="l07681"></a>07681     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l07682"></a>07682   }
<a name="l07683"></a>07683   lu_solve(A, 3, indx, rhs, 0);
<a name="l07684"></a>07684   <span class="keywordflow">if</span> (cent != (REAL *) NULL) {
<a name="l07685"></a>07685     cent[0] = pa[0] + rhs[0];
<a name="l07686"></a>07686     cent[1] = pa[1] + rhs[1];
<a name="l07687"></a>07687     cent[2] = pa[2] + rhs[2];
<a name="l07688"></a>07688   }
<a name="l07689"></a>07689   <span class="keywordflow">if</span> (radius != (REAL *) NULL) {
<a name="l07690"></a>07690     *radius = sqrt(rhs[0] * rhs[0] + rhs[1] * rhs[1] + rhs[2] * rhs[2]);
<a name="l07691"></a>07691   }
<a name="l07692"></a>07692   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l07693"></a>07693 }
<a name="l07694"></a>07694 
<a name="l07696"></a>07696 <span class="comment">//                                                                           //</span>
<a name="l07697"></a>07697 <span class="comment">// inscribedsphere()    Compute the radius and center of the biggest         //</span>
<a name="l07698"></a>07698 <span class="comment">//                      inscribed sphere of a given tetrahedron.             //</span>
<a name="l07699"></a>07699 <span class="comment">//                                                                           //</span>
<a name="l07700"></a>07700 <span class="comment">// The tetrahedron is given by its four points, it must not be degenerate.   //</span>
<a name="l07701"></a>07701 <span class="comment">// The center and radius are returned in &#39;cent&#39; and &#39;radius&#39; respectively if //</span>
<a name="l07702"></a>07702 <span class="comment">// they are not NULLs.                                                       //</span>
<a name="l07703"></a>07703 <span class="comment">//                                                                           //</span>
<a name="l07704"></a>07704 <span class="comment">// Geometrical fact. For any simplex in d dimension,                         //</span>
<a name="l07705"></a>07705 <span class="comment">//   r/h1 + r/h2 + ... r/hn = 1 (n &lt;= d + 1);                                //</span>
<a name="l07706"></a>07706 <span class="comment">// where r is the radius of inscribed ball, and h is the height of each side //</span>
<a name="l07707"></a>07707 <span class="comment">// of the simplex. The value of &#39;r/h&#39; is just the barycenter coordinates of  //</span>
<a name="l07708"></a>07708 <span class="comment">// each vertex of the simplex. Therefore, we can compute the radius and      //</span>
<a name="l07709"></a>07709 <span class="comment">// center of the smallest inscribed ball as following equations:             //</span>
<a name="l07710"></a>07710 <span class="comment">//   r = 1.0 / (1/h1 + 1/h2 + ... + 1/hn);          (1)                      //</span>
<a name="l07711"></a>07711 <span class="comment">//   C = r/h1 * P1 + r/h2 * P2 + ... + r/hn * Pn;   (2)                      //</span>
<a name="l07712"></a>07712 <span class="comment">// where C is the vector of center, P1, P2, .. Pn are vectors of vertices.   //</span>
<a name="l07713"></a>07713 <span class="comment">// Here (2) contains n linear equations with n variables.  (h, P) must be a  //</span>
<a name="l07714"></a>07714 <span class="comment">// pair, h is the height from P to its opposite face.                        //</span>
<a name="l07715"></a>07715 <span class="comment">//                                                                           //</span>
<a name="l07717"></a>07717 <span class="comment"></span>
<a name="l07718"></a>07718 <span class="keywordtype">void</span> tetgenmesh::inscribedsphere(REAL* pa, REAL* pb, REAL* pc, REAL* pd,
<a name="l07719"></a>07719   REAL* cent, REAL* radius)
<a name="l07720"></a>07720 {
<a name="l07721"></a>07721   REAL N[4][3], H[4]; <span class="comment">// Normals (colume vectors) and heights of each face.</span>
<a name="l07722"></a>07722   REAL rd;
<a name="l07723"></a>07723   <span class="keywordtype">int</span> i;
<a name="l07724"></a>07724 
<a name="l07725"></a>07725   <span class="comment">// Get the all normals of the tet.</span>
<a name="l07726"></a>07726   tetallnormal(pa, pb, pc, pd, N, NULL);
<a name="l07727"></a>07727   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l07728"></a>07728     <span class="comment">// H[i] is the inverse of height of its corresponding face.</span>
<a name="l07729"></a>07729     H[i] = sqrt(dot(N[i], N[i]));
<a name="l07730"></a>07730   }
<a name="l07731"></a>07731   <span class="comment">// Compute the radius use eq. (1).</span>
<a name="l07732"></a>07732   rd = 1.0 / (H[0] + H[1] + H[2] + H[3]);
<a name="l07733"></a>07733   <span class="keywordflow">if</span> (radius != (REAL*) NULL) *radius = rd;
<a name="l07734"></a>07734   <span class="keywordflow">if</span> (cent != (REAL*) NULL) {
<a name="l07735"></a>07735     <span class="comment">// Compute the center use eq. (2).</span>
<a name="l07736"></a>07736     cent[0] = rd * (H[0] * pa[0] + H[1] * pb[0] + H[2] * pc[0] + H[3] * pd[0]);
<a name="l07737"></a>07737     cent[1] = rd * (H[0] * pa[1] + H[1] * pb[1] + H[2] * pc[1] + H[3] * pd[1]);
<a name="l07738"></a>07738     cent[2] = rd * (H[0] * pa[2] + H[1] * pb[2] + H[2] * pc[2] + H[3] * pd[2]);
<a name="l07739"></a>07739   }
<a name="l07740"></a>07740 }
<a name="l07741"></a>07741 
<a name="l07743"></a>07743 <span class="comment">//                                                                           //</span>
<a name="l07744"></a>07744 <span class="comment">// rotatepoint()    Create a point by rotating an existing point.            //</span>
<a name="l07745"></a>07745 <span class="comment">//                                                                           //</span>
<a name="l07746"></a>07746 <span class="comment">// Create a 3D point by rotating point &#39;p&#39; with an angle &#39;rotangle&#39; (in arc  //</span>
<a name="l07747"></a>07747 <span class="comment">// degree) around a rotating axis given by a vector from point &#39;p1&#39; to &#39;p2&#39;. //</span>
<a name="l07748"></a>07748 <span class="comment">// The rotation is according with right-hand rule, i.e., use your right-hand //</span>
<a name="l07749"></a>07749 <span class="comment">// to grab the axis with your thumber pointing to its positive direction,    //</span>
<a name="l07750"></a>07750 <span class="comment">// your fingers indicate the rotating direction.                             //</span>
<a name="l07751"></a>07751 <span class="comment">//                                                                           //</span>
<a name="l07752"></a>07752 <span class="comment">// The rotating steps are the following:                                     //</span>
<a name="l07753"></a>07753 <span class="comment">//   1. Translate vector &#39;p1-&gt;p2&#39; to origin, M1;                             //</span>
<a name="l07754"></a>07754 <span class="comment">//   2. Rotate vector around the Y-axis until it lies in the YZ plane, M2;   //</span>
<a name="l07755"></a>07755 <span class="comment">//   3. Rotate vector around the X-axis until it lies on the Z axis, M3;     //</span>
<a name="l07756"></a>07756 <span class="comment">//   4. Perform the rotation of &#39;p&#39; around the z-axis, M4;                   //</span>
<a name="l07757"></a>07757 <span class="comment">//   5. Undo Step 3, M5;                                                     //</span>
<a name="l07758"></a>07758 <span class="comment">//   6. Undo Step 2, M6;                                                     //</span>
<a name="l07759"></a>07759 <span class="comment">//   7. Undo Step 1, M7;                                                     //</span>
<a name="l07760"></a>07760 <span class="comment">// Use matrix multiplication to combine the above sequences, we get:         //</span>
<a name="l07761"></a>07761 <span class="comment">//   p0&#39; = T * p0, where T = M7 * M6 * M5 * M4 * M3 * M2 * M1                //</span>
<a name="l07762"></a>07762 <span class="comment">//                                                                           //</span>
<a name="l07764"></a>07764 <span class="comment"></span>
<a name="l07765"></a>07765 <span class="keywordtype">void</span> tetgenmesh::rotatepoint(REAL* p, REAL rotangle, REAL* p1, REAL* p2)
<a name="l07766"></a>07766 {
<a name="l07767"></a>07767   REAL T[4][4], pp0[4], p0t[4], p2t[4];
<a name="l07768"></a>07768   REAL roty, rotx, alphaR, projlen;
<a name="l07769"></a>07769   REAL dx, dy, dz;
<a name="l07770"></a>07770 
<a name="l07771"></a>07771   initm44(1, 0, 0, -p1[0],
<a name="l07772"></a>07772           0, 1, 0, -p1[1],
<a name="l07773"></a>07773           0, 0, 1, -p1[2],
<a name="l07774"></a>07774           0, 0, 0, 1, T);
<a name="l07775"></a>07775   pp0[0] = p[0]; pp0[1] = p[1]; pp0[2] = p[2]; pp0[3] = 1.0;
<a name="l07776"></a>07776   m4xv4(p0t, T, pp0); <span class="comment">// Step 1</span>
<a name="l07777"></a>07777   pp0[0] = p2[0]; pp0[1] = p2[1]; pp0[2] = p2[2]; pp0[3] = 1.0;
<a name="l07778"></a>07778   m4xv4(p2t, T, pp0); <span class="comment">// Step 1</span>
<a name="l07779"></a>07779 
<a name="l07780"></a>07780   <span class="comment">// Get the rotation angle around y-axis;</span>
<a name="l07781"></a>07781   dx = p2t[0];
<a name="l07782"></a>07782   dz = p2t[2];
<a name="l07783"></a>07783   projlen = sqrt(dx * dx + dz * dz);
<a name="l07784"></a>07784   <span class="keywordflow">if</span> (projlen &lt;= (b-&gt;epsilon * 1e-2) * longest) {
<a name="l07785"></a>07785     roty = 0;
<a name="l07786"></a>07786   } <span class="keywordflow">else</span> {
<a name="l07787"></a>07787     roty = acos(dz / projlen);
<a name="l07788"></a>07788     <span class="keywordflow">if</span> (dx &lt; 0) {
<a name="l07789"></a>07789       roty = -roty;
<a name="l07790"></a>07790     }
<a name="l07791"></a>07791   }
<a name="l07792"></a>07792 
<a name="l07793"></a>07793   initm44(cos(-roty), 0, sin(-roty), 0,
<a name="l07794"></a>07794           0, 1, 0, 0,
<a name="l07795"></a>07795           -sin(-roty), 0, cos(-roty), 0,
<a name="l07796"></a>07796           0, 0, 0, 1, T);
<a name="l07797"></a>07797   pp0[0] = p0t[0]; pp0[1] = p0t[1]; pp0[2] = p0t[2]; pp0[3] = 1.0;
<a name="l07798"></a>07798   m4xv4(p0t, T, pp0); <span class="comment">// Step 2</span>
<a name="l07799"></a>07799   pp0[0] = p2t[0]; pp0[1] = p2t[1]; pp0[2] = p2t[2]; pp0[3] = 1.0;
<a name="l07800"></a>07800   m4xv4(p2t, T, pp0); <span class="comment">// Step 2</span>
<a name="l07801"></a>07801 
<a name="l07802"></a>07802   <span class="comment">// Get the rotation angle around x-axis</span>
<a name="l07803"></a>07803   dy = p2t[1];
<a name="l07804"></a>07804   dz = p2t[2];
<a name="l07805"></a>07805   projlen = sqrt(dy * dy + dz * dz);
<a name="l07806"></a>07806   <span class="keywordflow">if</span> (projlen &lt;= (b-&gt;epsilon * 1e-2) * longest) {
<a name="l07807"></a>07807     rotx = 0;
<a name="l07808"></a>07808   } <span class="keywordflow">else</span> {
<a name="l07809"></a>07809     rotx = acos(dz / projlen);
<a name="l07810"></a>07810     <span class="keywordflow">if</span> (dy &lt; 0) {
<a name="l07811"></a>07811       rotx = -rotx;
<a name="l07812"></a>07812     }
<a name="l07813"></a>07813   }
<a name="l07814"></a>07814 
<a name="l07815"></a>07815   initm44(1, 0, 0, 0,
<a name="l07816"></a>07816           0, cos(rotx), -sin(rotx), 0,
<a name="l07817"></a>07817           0, sin(rotx), cos(rotx), 0,
<a name="l07818"></a>07818           0, 0, 0, 1, T);
<a name="l07819"></a>07819   pp0[0] = p0t[0]; pp0[1] = p0t[1]; pp0[2] = p0t[2]; pp0[3] = 1.0;
<a name="l07820"></a>07820   m4xv4(p0t, T, pp0); <span class="comment">// Step 3</span>
<a name="l07821"></a>07821   <span class="comment">// pp0[0] = p2t[0]; pp0[1] = p2t[1]; pp0[2] = p2t[2]; pp0[3] = 1.0;</span>
<a name="l07822"></a>07822   <span class="comment">// m4xv4(p2t, T, pp0); // Step 3</span>
<a name="l07823"></a>07823 
<a name="l07824"></a>07824   alphaR = rotangle;
<a name="l07825"></a>07825   initm44(cos(alphaR), -sin(alphaR), 0, 0,
<a name="l07826"></a>07826           sin(alphaR), cos(alphaR), 0, 0,
<a name="l07827"></a>07827           0, 0, 1, 0,
<a name="l07828"></a>07828           0, 0, 0, 1, T);
<a name="l07829"></a>07829   pp0[0] = p0t[0]; pp0[1] = p0t[1]; pp0[2] = p0t[2]; pp0[3] = 1.0;
<a name="l07830"></a>07830   m4xv4(p0t, T, pp0); <span class="comment">// Step 4</span>
<a name="l07831"></a>07831 
<a name="l07832"></a>07832   initm44(1, 0, 0, 0,
<a name="l07833"></a>07833           0, cos(-rotx), -sin(-rotx), 0,
<a name="l07834"></a>07834           0, sin(-rotx), cos(-rotx), 0,
<a name="l07835"></a>07835           0, 0, 0, 1, T);
<a name="l07836"></a>07836   pp0[0] = p0t[0]; pp0[1] = p0t[1]; pp0[2] = p0t[2]; pp0[3] = 1.0;
<a name="l07837"></a>07837   m4xv4(p0t, T, pp0); <span class="comment">// Step 5</span>
<a name="l07838"></a>07838 
<a name="l07839"></a>07839   initm44(cos(roty), 0, sin(roty), 0,
<a name="l07840"></a>07840           0, 1, 0, 0,
<a name="l07841"></a>07841           -sin(roty), 0, cos(roty), 0,
<a name="l07842"></a>07842           0, 0, 0, 1, T);
<a name="l07843"></a>07843   pp0[0] = p0t[0]; pp0[1] = p0t[1]; pp0[2] = p0t[2]; pp0[3] = 1.0;
<a name="l07844"></a>07844   m4xv4(p0t, T, pp0); <span class="comment">// Step 6</span>
<a name="l07845"></a>07845 
<a name="l07846"></a>07846   initm44(1, 0, 0, p1[0],
<a name="l07847"></a>07847           0, 1, 0, p1[1],
<a name="l07848"></a>07848           0, 0, 1, p1[2],
<a name="l07849"></a>07849           0, 0, 0, 1, T);
<a name="l07850"></a>07850   pp0[0] = p0t[0]; pp0[1] = p0t[1]; pp0[2] = p0t[2]; pp0[3] = 1.0;
<a name="l07851"></a>07851   m4xv4(p0t, T, pp0); <span class="comment">// Step 7</span>
<a name="l07852"></a>07852 
<a name="l07853"></a>07853   p[0] = p0t[0];
<a name="l07854"></a>07854   p[1] = p0t[1];
<a name="l07855"></a>07855   p[2] = p0t[2];
<a name="l07856"></a>07856 }
<a name="l07857"></a>07857 
<a name="l07859"></a>07859 <span class="comment">//                                                                           //</span>
<a name="l07860"></a>07860 <span class="comment">// spherelineint()    3D line sphere (or circle) intersection.               //</span>
<a name="l07861"></a>07861 <span class="comment">//                                                                           //</span>
<a name="l07862"></a>07862 <span class="comment">// The line is given by two points p1, and p2, the sphere is centered at c   //</span>
<a name="l07863"></a>07863 <span class="comment">// with radius r.  This function returns a pointer array p which first index //</span>
<a name="l07864"></a>07864 <span class="comment">// indicates the number of intersection point, followed by coordinate pairs. //</span>
<a name="l07865"></a>07865 <span class="comment">//                                                                           //</span>
<a name="l07866"></a>07866 <span class="comment">// The following code are adapted from: http://astronomy.swin.edu.au/pbourke //</span>
<a name="l07867"></a>07867 <span class="comment">// /geometry/sphereline. Paul Bourke pbourke@swin.edu.au                     //</span>
<a name="l07868"></a>07868 <span class="comment">//                                                                           //</span>
<a name="l07870"></a>07870 <span class="comment"></span>
<a name="l07871"></a>07871 <span class="keywordtype">void</span> tetgenmesh::spherelineint(REAL* p1, REAL* p2, REAL* C, REAL R, REAL p[7])
<a name="l07872"></a>07872 {
<a name="l07873"></a>07873   REAL x1, y1, z1; <span class="comment">//  P1 coordinates (point of line)</span>
<a name="l07874"></a>07874   REAL x2, y2, z2; <span class="comment">//  P2 coordinates (point of line)</span>
<a name="l07875"></a>07875   REAL x3, y3, z3, r; <span class="comment">//  P3 coordinates and radius (sphere)</span>
<a name="l07876"></a>07876   REAL a, b, c, mu, i ;
<a name="l07877"></a>07877 
<a name="l07878"></a>07878   x1 = p1[0]; y1 = p1[1]; z1 = p1[2];
<a name="l07879"></a>07879   x2 = p2[0]; y2 = p2[1]; z2 = p2[2];
<a name="l07880"></a>07880   x3 = C[0];  y3 = C[1];  z3 = C[2];
<a name="l07881"></a>07881   r = R;
<a name="l07882"></a>07882 
<a name="l07883"></a>07883   a =   (x2 - x1) * (x2 - x1)
<a name="l07884"></a>07884       + (y2 - y1) * (y2 - y1)
<a name="l07885"></a>07885       + (z2 - z1) * (z2 - z1);
<a name="l07886"></a>07886   b = 2 * ( (x2 - x1) * (x1 - x3)
<a name="l07887"></a>07887           + (y2 - y1) * (y1 - y3)
<a name="l07888"></a>07888           + (z2 - z1) * (z1 - z3) ) ;
<a name="l07889"></a>07889   c =   (x3 * x3) + (y3 * y3) + (z3 * z3)
<a name="l07890"></a>07890       + (x1 * x1) + (y1 * y1) + (z1 * z1)
<a name="l07891"></a>07891       - 2 * (x3 * x1 + y3 * y1 + z3 * z1) - (r * r) ;
<a name="l07892"></a>07892   i = b * b - 4 * a * c ;
<a name="l07893"></a>07893 
<a name="l07894"></a>07894   <span class="keywordflow">if</span> (i &lt; 0.0) {
<a name="l07895"></a>07895     <span class="comment">// no intersection</span>
<a name="l07896"></a>07896     p[0] = 0.0;
<a name="l07897"></a>07897   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i == 0.0) {
<a name="l07898"></a>07898     <span class="comment">// one intersection</span>
<a name="l07899"></a>07899     p[0] = 1.0;
<a name="l07900"></a>07900     mu = -b / (2 * a) ;
<a name="l07901"></a>07901     p[1] = x1 + mu * (x2 - x1);
<a name="l07902"></a>07902     p[2] = y1 + mu * (y2 - y1);
<a name="l07903"></a>07903     p[3] = z1 + mu * (z2 - z1);
<a name="l07904"></a>07904   } <span class="keywordflow">else</span> {
<a name="l07905"></a>07905     <span class="comment">// two intersections</span>
<a name="l07906"></a>07906     p[0] = 2.0;
<a name="l07907"></a>07907     <span class="comment">// first intersection</span>
<a name="l07908"></a>07908     mu = (-b + sqrt((b * b) - 4 * a * c)) / (2 * a);
<a name="l07909"></a>07909     p[1] = x1 + mu * (x2 - x1);
<a name="l07910"></a>07910     p[2] = y1 + mu * (y2 - y1);
<a name="l07911"></a>07911     p[3] = z1 + mu * (z2 - z1);
<a name="l07912"></a>07912     <span class="comment">// second intersection</span>
<a name="l07913"></a>07913     mu = (-b - sqrt((b * b) - 4 * a * c)) / (2 * a);
<a name="l07914"></a>07914     p[4] = x1 + mu * (x2 - x1);
<a name="l07915"></a>07915     p[5] = y1 + mu * (y2 - y1);
<a name="l07916"></a>07916     p[6] = z1 + mu * (z2 - z1);
<a name="l07917"></a>07917   }
<a name="l07918"></a>07918 }
<a name="l07919"></a>07919 
<a name="l07921"></a>07921 <span class="comment">//                                                                           //</span>
<a name="l07922"></a>07922 <span class="comment">// linelineint()    Calculate the shortest line between two lines in 3D.     //</span>
<a name="l07923"></a>07923 <span class="comment">//                                                                           //</span>
<a name="l07924"></a>07924 <span class="comment">// Two 3D lines generally don&#39;t intersect at a point, they may be parallel ( //</span>
<a name="l07925"></a>07925 <span class="comment">// no intersections), or coincident (infinite intersections) but most often  //</span>
<a name="l07926"></a>07926 <span class="comment">// only their projections onto a plane intersect. If they don&#39;t exactly int- //</span>
<a name="l07927"></a>07927 <span class="comment">// ersect at a point they can be connected by a line segment, the shortest   //</span>
<a name="l07928"></a>07928 <span class="comment">// segment is unique and is often considered to be their intersection in 3D. //</span>
<a name="l07929"></a>07929 <span class="comment">//                                                                           //</span>
<a name="l07930"></a>07930 <span class="comment">// The following code are adapted from: http://astronomy.swin.edu.au/pbourke //</span>
<a name="l07931"></a>07931 <span class="comment">// /geometry/lineline3d. Paul Bourke pbourke@swin.edu.au                     //</span>
<a name="l07932"></a>07932 <span class="comment">//                                                                           //</span>
<a name="l07933"></a>07933 <span class="comment">// Calculate the line segment PaPb that is the shortest route between two    //</span>
<a name="l07934"></a>07934 <span class="comment">// lines P1P2 and P3P4. This function returns a pointer array p which first  //</span>
<a name="l07935"></a>07935 <span class="comment">// index indicates there exists solution or not, 0 means no solution, 1 meas //</span>
<a name="l07936"></a>07936 <span class="comment">// has solution followed by two coordinate pairs.                            //</span>
<a name="l07937"></a>07937 <span class="comment">//                                                                           //</span>
<a name="l07939"></a>07939 <span class="comment"></span>
<a name="l07940"></a>07940 <span class="keywordtype">void</span> tetgenmesh::linelineint(REAL *p1,REAL *p2, REAL *p3, REAL *p4, REAL p[7])
<a name="l07941"></a>07941 {
<a name="l07942"></a>07942   REAL p13[3], p43[3], p21[3];
<a name="l07943"></a>07943   REAL d1343, d4321, d1321, d4343, d2121;
<a name="l07944"></a>07944   REAL numer, denom;
<a name="l07945"></a>07945   REAL mua, mub;
<a name="l07946"></a>07946 
<a name="l07947"></a>07947   p13[0] = p1[0] - p3[0];
<a name="l07948"></a>07948   p13[1] = p1[1] - p3[1];
<a name="l07949"></a>07949   p13[2] = p1[2] - p3[2];
<a name="l07950"></a>07950   p43[0] = p4[0] - p3[0];
<a name="l07951"></a>07951   p43[1] = p4[1] - p3[1];
<a name="l07952"></a>07952   p43[2] = p4[2] - p3[2];
<a name="l07953"></a>07953   <span class="keywordflow">if</span> (p43[0] == 0.0 &amp;&amp; p43[1] == 0.0 &amp;&amp; p43[2] == 0.0) {
<a name="l07954"></a>07954     p[0] = 0.0;
<a name="l07955"></a>07955     <span class="keywordflow">return</span>;
<a name="l07956"></a>07956   }
<a name="l07957"></a>07957 
<a name="l07958"></a>07958   p21[0] = p2[0] - p1[0];
<a name="l07959"></a>07959   p21[1] = p2[1] - p1[1];
<a name="l07960"></a>07960   p21[2] = p2[2] - p1[2];
<a name="l07961"></a>07961   <span class="keywordflow">if</span> (p21[0] == 0.0 &amp;&amp; p21[1] == 0.0 &amp;&amp; p21[2] == 0.0) {
<a name="l07962"></a>07962     p[0] = 0.0;
<a name="l07963"></a>07963     <span class="keywordflow">return</span>;
<a name="l07964"></a>07964   }
<a name="l07965"></a>07965 
<a name="l07966"></a>07966   d1343 = p13[0] * p43[0] + p13[1] * p43[1] + p13[2] * p43[2];
<a name="l07967"></a>07967   d4321 = p43[0] * p21[0] + p43[1] * p21[1] + p43[2] * p21[2];
<a name="l07968"></a>07968   d1321 = p13[0] * p21[0] + p13[1] * p21[1] + p13[2] * p21[2];
<a name="l07969"></a>07969   d4343 = p43[0] * p43[0] + p43[1] * p43[1] + p43[2] * p43[2];
<a name="l07970"></a>07970   d2121 = p21[0] * p21[0] + p21[1] * p21[1] + p21[2] * p21[2];
<a name="l07971"></a>07971 
<a name="l07972"></a>07972   denom = d2121 * d4343 - d4321 * d4321;
<a name="l07973"></a>07973   <span class="keywordflow">if</span> (denom == 0.0) {
<a name="l07974"></a>07974     p[0] = 0.0;
<a name="l07975"></a>07975     <span class="keywordflow">return</span>;
<a name="l07976"></a>07976   }
<a name="l07977"></a>07977   numer = d1343 * d4321 - d1321 * d4343;
<a name="l07978"></a>07978   mua = numer / denom;
<a name="l07979"></a>07979   mub = (d1343 + d4321 * mua) / d4343;
<a name="l07980"></a>07980 
<a name="l07981"></a>07981   p[0] = 1.0;
<a name="l07982"></a>07982   p[1] = p1[0] + mua * p21[0];
<a name="l07983"></a>07983   p[2] = p1[1] + mua * p21[1];
<a name="l07984"></a>07984   p[3] = p1[2] + mua * p21[2];
<a name="l07985"></a>07985   p[4] = p3[0] + mub * p43[0];
<a name="l07986"></a>07986   p[5] = p3[1] + mub * p43[1];
<a name="l07987"></a>07987   p[6] = p3[2] + mub * p43[2];
<a name="l07988"></a>07988 }
<a name="l07989"></a>07989 
<a name="l07991"></a>07991 <span class="comment">//                                                                           //</span>
<a name="l07992"></a>07992 <span class="comment">// planelineint()    Calculate the intersection of a line and a plane.       //</span>
<a name="l07993"></a>07993 <span class="comment">//                                                                           //</span>
<a name="l07994"></a>07994 <span class="comment">// The equation of a plane (points P are on the plane with normal N and P3   //</span>
<a name="l07995"></a>07995 <span class="comment">// on the plane) can be written as: N dot (P - P3) = 0. The equation of the  //</span>
<a name="l07996"></a>07996 <span class="comment">// line (points P on the line passing through P1 and P2) can be written as:  //</span>
<a name="l07997"></a>07997 <span class="comment">// P = P1 + u (P2 - P1). The intersection of these two occurs when:          //</span>
<a name="l07998"></a>07998 <span class="comment">//   N dot (P1 + u (P2 - P1)) = N dot P3.                                    //</span>
<a name="l07999"></a>07999 <span class="comment">// Solving for u gives:                                                      //</span>
<a name="l08000"></a>08000 <span class="comment">//         N dot (P3 - P1)                                                   //</span>
<a name="l08001"></a>08001 <span class="comment">//   u = ------------------.                                                 //</span>
<a name="l08002"></a>08002 <span class="comment">//         N dot (P2 - P1)                                                   //</span>
<a name="l08003"></a>08003 <span class="comment">// If the denominator is 0 then N (the normal to the plane) is perpendicular //</span>
<a name="l08004"></a>08004 <span class="comment">// to the line.  Thus the line is either parallel to the plane and there are //</span>
<a name="l08005"></a>08005 <span class="comment">// no solutions or the line is on the plane in which case there are an infi- //</span>
<a name="l08006"></a>08006 <span class="comment">// nite number of solutions.                                                 //</span>
<a name="l08007"></a>08007 <span class="comment">//                                                                           //</span>
<a name="l08008"></a>08008 <span class="comment">// The plane is given by three points pa, pb, and pc, e1 and e2 defines the  //</span>
<a name="l08009"></a>08009 <span class="comment">// line. If u is non-zero, The intersection point (if exists) returns in ip. //</span>
<a name="l08010"></a>08010 <span class="comment">//                                                                           //</span>
<a name="l08012"></a>08012 <span class="comment"></span>
<a name="l08013"></a>08013 <span class="keywordtype">void</span> tetgenmesh::planelineint(REAL* pa, REAL* pb, REAL* pc, REAL* e1, REAL* e2,
<a name="l08014"></a>08014   REAL* ip, REAL* u)
<a name="l08015"></a>08015 {
<a name="l08016"></a>08016   REAL n[3], det, det1;
<a name="l08017"></a>08017 
<a name="l08018"></a>08018   <span class="comment">// Calculate N.</span>
<a name="l08019"></a>08019   facenormal(pa, pb, pc, n, NULL);
<a name="l08020"></a>08020   <span class="comment">// Calculate N dot (e2 - e1).</span>
<a name="l08021"></a>08021   det = n[0] * (e2[0] - e1[0]) + n[1] * (e2[1] - e1[1])
<a name="l08022"></a>08022       + n[2] * (e2[2] - e1[2]);
<a name="l08023"></a>08023   <span class="keywordflow">if</span> (det != 0.0) {
<a name="l08024"></a>08024     <span class="comment">// Calculate N dot (pa - e1)</span>
<a name="l08025"></a>08025     det1 = n[0] * (pa[0] - e1[0]) + n[1] * (pa[1] - e1[1])
<a name="l08026"></a>08026          + n[2] * (pa[2] - e1[2]);
<a name="l08027"></a>08027     *u = det1 / det;
<a name="l08028"></a>08028     ip[0] = e1[0] + *u * (e2[0] - e1[0]);
<a name="l08029"></a>08029     ip[1] = e1[1] + *u * (e2[1] - e1[1]);
<a name="l08030"></a>08030     ip[2] = e1[2] + *u * (e2[2] - e1[2]);
<a name="l08031"></a>08031   } <span class="keywordflow">else</span> {
<a name="l08032"></a>08032     *u = 0.0;
<a name="l08033"></a>08033   }
<a name="l08034"></a>08034 }
<a name="l08035"></a>08035 
<a name="l08036"></a>08036 <span class="comment">//</span>
<a name="l08037"></a>08037 <span class="comment">// End of Geometric quantities calculators</span>
<a name="l08038"></a>08038 <span class="comment">//</span>
<a name="l08039"></a>08039 
<a name="l08040"></a>08040 <span class="comment">//</span>
<a name="l08041"></a>08041 <span class="comment">// Begin of memory management routines</span>
<a name="l08042"></a>08042 <span class="comment">//</span>
<a name="l08043"></a>08043 
<a name="l08045"></a>08045 <span class="comment">//                                                                           //</span>
<a name="l08046"></a>08046 <span class="comment">// dummyinit()    Initialize the tetrahedron that fills &quot;outer space&quot; and    //</span>
<a name="l08047"></a>08047 <span class="comment">//                the omnipresent subface.                                   //</span>
<a name="l08048"></a>08048 <span class="comment">//                                                                           //</span>
<a name="l08049"></a>08049 <span class="comment">// The tetrahedron that fills &quot;outer space&quot; called &#39;dummytet&#39;, is pointed to //</span>
<a name="l08050"></a>08050 <span class="comment">// by every tetrahedron and subface on a boundary (be it outer or inner) of  //</span>
<a name="l08051"></a>08051 <span class="comment">// the tetrahedralization. Also, &#39;dummytet&#39; points to one of the tetrahedron //</span>
<a name="l08052"></a>08052 <span class="comment">// on the convex hull(until the holes and concavities are carved), making it //</span>
<a name="l08053"></a>08053 <span class="comment">// possible to find a starting tetrahedron for point location.               //</span>
<a name="l08054"></a>08054 <span class="comment">//                                                                           //</span>
<a name="l08055"></a>08055 <span class="comment">// The omnipresent subface,&#39;dummysh&#39;, is pointed to by every tetrahedron or  //</span>
<a name="l08056"></a>08056 <span class="comment">// subface that doesn&#39;t have a full complement of real subface to point to.  //</span>
<a name="l08057"></a>08057 <span class="comment">//                                                                           //</span>
<a name="l08059"></a>08059 <span class="comment"></span>
<a name="l08060"></a>08060 <span class="keywordtype">void</span> tetgenmesh::dummyinit(<span class="keywordtype">int</span> tetwords, <span class="keywordtype">int</span> shwords)
<a name="l08061"></a>08061 {
<a name="l08062"></a>08062   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> alignptr;
<a name="l08063"></a>08063 
<a name="l08064"></a>08064   <span class="comment">// Set up &#39;dummytet&#39;, the &#39;tetrahedron&#39; that occupies &quot;outer space&quot;.</span>
<a name="l08065"></a>08065   dummytetbase = (tetrahedron *) <span class="keyword">new</span> <span class="keywordtype">char</span>[tetwords * <span class="keyword">sizeof</span>(tetrahedron)
<a name="l08066"></a>08066                                           + tetrahedrons-&gt;alignbytes];
<a name="l08067"></a>08067   <span class="comment">// Align &#39;dummytet&#39; on a &#39;tetrahedrons-&gt;alignbytes&#39;-byte boundary.</span>
<a name="l08068"></a>08068   alignptr = (<span class="keywordtype">unsigned</span> long) dummytetbase;
<a name="l08069"></a>08069   dummytet = (tetrahedron *)
<a name="l08070"></a>08070     (alignptr + (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) tetrahedrons-&gt;alignbytes
<a name="l08071"></a>08071      - (alignptr % (<span class="keywordtype">unsigned</span> long) tetrahedrons-&gt;alignbytes));
<a name="l08072"></a>08072   <span class="comment">// Initialize the four adjoining tetrahedra to be &quot;outer space&quot;. These</span>
<a name="l08073"></a>08073   <span class="comment">//   will eventually be changed by various bonding operations, but their</span>
<a name="l08074"></a>08074   <span class="comment">//   values don&#39;t really matter, as long as they can legally be</span>
<a name="l08075"></a>08075   <span class="comment">//   dereferenced.</span>
<a name="l08076"></a>08076   dummytet[0] = (tetrahedron) dummytet;
<a name="l08077"></a>08077   dummytet[1] = (tetrahedron) dummytet;
<a name="l08078"></a>08078   dummytet[2] = (tetrahedron) dummytet;
<a name="l08079"></a>08079   dummytet[3] = (tetrahedron) dummytet;
<a name="l08080"></a>08080   <span class="comment">// Four null vertex points.</span>
<a name="l08081"></a>08081   dummytet[4] = (tetrahedron) NULL;
<a name="l08082"></a>08082   dummytet[5] = (tetrahedron) NULL;
<a name="l08083"></a>08083   dummytet[6] = (tetrahedron) NULL;
<a name="l08084"></a>08084   dummytet[7] = (tetrahedron) NULL;
<a name="l08085"></a>08085 
<a name="l08086"></a>08086   <span class="keywordflow">if</span> (b-&gt;useshelles) {
<a name="l08087"></a>08087     <span class="comment">// Set up &#39;dummysh&#39;, the omnipresent &quot;subface&quot; pointed to by any</span>
<a name="l08088"></a>08088     <span class="comment">//   tetrahedron side or subface end that isn&#39;t attached to a real</span>
<a name="l08089"></a>08089     <span class="comment">//   subface.</span>
<a name="l08090"></a>08090     dummyshbase = (shellface *) <span class="keyword">new</span> <span class="keywordtype">char</span>[shwords * <span class="keyword">sizeof</span>(shellface)
<a name="l08091"></a>08091                                          + subfaces-&gt;alignbytes];
<a name="l08092"></a>08092     <span class="comment">// Align &#39;dummysh&#39; on a &#39;subfaces-&gt;alignbytes&#39;-byte boundary.</span>
<a name="l08093"></a>08093     alignptr = (<span class="keywordtype">unsigned</span> long) dummyshbase;
<a name="l08094"></a>08094     dummysh = (shellface *)
<a name="l08095"></a>08095       (alignptr + (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) subfaces-&gt;alignbytes
<a name="l08096"></a>08096        - (alignptr % (<span class="keywordtype">unsigned</span> long) subfaces-&gt;alignbytes));
<a name="l08097"></a>08097     <span class="comment">// Initialize the three adjoining subfaces to be the omnipresent</span>
<a name="l08098"></a>08098     <span class="comment">//   subface. These will eventually be changed by various bonding</span>
<a name="l08099"></a>08099     <span class="comment">//   operations, but their values don&#39;t really matter, as long as they</span>
<a name="l08100"></a>08100     <span class="comment">//   can legally be dereferenced.</span>
<a name="l08101"></a>08101     dummysh[0] = (shellface) dummysh;
<a name="l08102"></a>08102     dummysh[1] = (shellface) dummysh;
<a name="l08103"></a>08103     dummysh[2] = (shellface) dummysh;
<a name="l08104"></a>08104     <span class="comment">// Three null vertex points.</span>
<a name="l08105"></a>08105     dummysh[3] = (shellface) NULL;
<a name="l08106"></a>08106     dummysh[4] = (shellface) NULL;
<a name="l08107"></a>08107     dummysh[5] = (shellface) NULL;
<a name="l08108"></a>08108     <span class="comment">// Initialize the two adjoining tetrahedra to be &quot;outer space&quot;.</span>
<a name="l08109"></a>08109     dummysh[6] = (shellface) dummytet;
<a name="l08110"></a>08110     dummysh[7] = (shellface) dummytet;
<a name="l08111"></a>08111     <span class="comment">// Initialize the three adjoining subsegments to be &quot;out boundary&quot;.</span>
<a name="l08112"></a>08112     dummysh[8]  = (shellface) dummysh;
<a name="l08113"></a>08113     dummysh[9]  = (shellface) dummysh;
<a name="l08114"></a>08114     dummysh[10] = (shellface) dummysh;
<a name="l08115"></a>08115     <span class="comment">// Initialize the pointer to badface structure.</span>
<a name="l08116"></a>08116     dummysh[11] = (shellface) NULL;
<a name="l08117"></a>08117     <span class="comment">// Initialize the four adjoining subfaces of &#39;dummytet&#39; to be the</span>
<a name="l08118"></a>08118     <span class="comment">//   omnipresent subface.</span>
<a name="l08119"></a>08119     dummytet[8 ] = (tetrahedron) dummysh;
<a name="l08120"></a>08120     dummytet[9 ] = (tetrahedron) dummysh;
<a name="l08121"></a>08121     dummytet[10] = (tetrahedron) dummysh;
<a name="l08122"></a>08122     dummytet[11] = (tetrahedron) dummysh;
<a name="l08123"></a>08123   }
<a name="l08124"></a>08124 }
<a name="l08125"></a>08125 
<a name="l08127"></a>08127 <span class="comment">//                                                                           //</span>
<a name="l08128"></a>08128 <span class="comment">// initializepools()    Calculate the sizes of the point, tetrahedron, and   //</span>
<a name="l08129"></a>08129 <span class="comment">//                      subface. Initialize their memory pools.              //</span>
<a name="l08130"></a>08130 <span class="comment">//                                                                           //</span>
<a name="l08131"></a>08131 <span class="comment">// This routine also computes the indices &#39;pointmarkindex&#39;, &#39;point2simindex&#39;,//</span>
<a name="l08132"></a>08132 <span class="comment">// and &#39;point2pbcptindex&#39; used to find values within each point;  computes   //</span>
<a name="l08133"></a>08133 <span class="comment">// indices &#39;highorderindex&#39;, &#39;elemattribindex&#39;, and &#39;volumeboundindex&#39; used  //</span>
<a name="l08134"></a>08134 <span class="comment">// to find values within each tetrahedron.                                   //</span>
<a name="l08135"></a>08135 <span class="comment">//                                                                           //</span>
<a name="l08136"></a>08136 <span class="comment">// There are two types of boundary elements, which are subfaces and subsegs, //</span>
<a name="l08137"></a>08137 <span class="comment">// they are stored in seperate pools. However, the data structures of them   //</span>
<a name="l08138"></a>08138 <span class="comment">// are the same.  A subsegment can be regarded as a degenerate subface, i.e.,//</span>
<a name="l08139"></a>08139 <span class="comment">// one of its three corners is not used. We set the apex of it be &#39;NULL&#39; to  //</span>
<a name="l08140"></a>08140 <span class="comment">// distinguish it&#39;s a subsegment.                                            //</span>
<a name="l08141"></a>08141 <span class="comment">//                                                                           //</span>
<a name="l08143"></a>08143 <span class="comment"></span>
<a name="l08144"></a>08144 <span class="keywordtype">void</span> tetgenmesh::initializepools()
<a name="l08145"></a>08145 {
<a name="l08146"></a>08146   <span class="keyword">enum</span> wordtype wtype;
<a name="l08147"></a>08147   <span class="keywordtype">int</span> pointsize, elesize, shsize;
<a name="l08148"></a>08148 
<a name="l08149"></a>08149   <span class="comment">// Default checkpbc = 0;</span>
<a name="l08150"></a>08150   <span class="keywordflow">if</span> ((b-&gt;plc || b-&gt;refine) &amp;&amp; (in-&gt;pbcgrouplist != NULL)) {
<a name="l08151"></a>08151     checkpbcs = 1;
<a name="l08152"></a>08152   }
<a name="l08153"></a>08153   <span class="comment">// Default varconstraint = 0;</span>
<a name="l08154"></a>08154   <span class="keywordflow">if</span> (in-&gt;segmentconstraintlist || in-&gt;facetconstraintlist) {
<a name="l08155"></a>08155     varconstraint = 1;
<a name="l08156"></a>08156   }
<a name="l08157"></a>08157 
<a name="l08158"></a>08158   <span class="comment">// The index within each point at which its metric tensor is found. It is</span>
<a name="l08159"></a>08159   <span class="comment">//   saved directly after the list of point attributes.</span>
<a name="l08160"></a>08160   pointmtrindex = 3 + in-&gt;numberofpointattributes;
<a name="l08161"></a>08161   <span class="comment">// Decide the size (1, 3, or 6) of the metric tensor.</span>
<a name="l08162"></a>08162   <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l08163"></a>08163     <span class="comment">// For &#39;-m&#39; option. A tensor field is provided (*.mtr or *.b.mtr file).</span>
<a name="l08164"></a>08164     <span class="keywordflow">if</span> (bgm != (tetgenmesh *) NULL) {
<a name="l08165"></a>08165       <span class="comment">// A background mesh is allocated. It may not exist though.</span>
<a name="l08166"></a>08166       sizeoftensor = (bgm-&gt;in != (tetgenio *) NULL) ?
<a name="l08167"></a>08167         bgm-&gt;in-&gt;numberofpointmtrs : in-&gt;numberofpointmtrs;
<a name="l08168"></a>08168     } <span class="keywordflow">else</span> {
<a name="l08169"></a>08169       <span class="comment">// No given background mesh - Itself is a background mesh.</span>
<a name="l08170"></a>08170       sizeoftensor = in-&gt;numberofpointmtrs;
<a name="l08171"></a>08171     }
<a name="l08172"></a>08172     <span class="comment">// Make sure sizeoftensor is at least 1.</span>
<a name="l08173"></a>08173     sizeoftensor = (sizeoftensor &gt; 0) ? sizeoftensor : 1;
<a name="l08174"></a>08174   } <span class="keywordflow">else</span> {
<a name="l08175"></a>08175     <span class="comment">// For &#39;-q&#39; option. Make sure to have space for saving a scalar value.</span>
<a name="l08176"></a>08176     sizeoftensor = b-&gt;quality ? 1 : 0;
<a name="l08177"></a>08177   }
<a name="l08178"></a>08178   <span class="comment">// The index within each point at which an element pointer is found, where</span>
<a name="l08179"></a>08179   <span class="comment">//   the index is measured in pointers. Ensure the index is aligned to a</span>
<a name="l08180"></a>08180   <span class="comment">//   sizeof(tetrahedron)-byte address.</span>
<a name="l08181"></a>08181   point2simindex = ((pointmtrindex + sizeoftensor) * <span class="keyword">sizeof</span>(REAL)
<a name="l08182"></a>08182                  + <span class="keyword">sizeof</span>(tetrahedron) - 1) / <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08183"></a>08183   <span class="keywordflow">if</span> (b-&gt;plc || b-&gt;refine) {
<a name="l08184"></a>08184     <span class="comment">// Increase the point size by three pointers, which are:</span>
<a name="l08185"></a>08185     <span class="comment">//   - a pointer to a tet, read by point2tet();</span>
<a name="l08186"></a>08186     <span class="comment">//   - a pointer to a subface/subsegment , read by point2sh();</span>
<a name="l08187"></a>08187     <span class="comment">//   - a pointer to a parent point, read by point2ppt()).</span>
<a name="l08188"></a>08188     <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l08189"></a>08189       <span class="comment">// Increase one pointer to a tet of the background mesh.</span>
<a name="l08190"></a>08190       pointsize = (point2simindex + 4) * <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08191"></a>08191     } <span class="keywordflow">else</span> {
<a name="l08192"></a>08192       pointsize = (point2simindex + 3) * <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08193"></a>08193     }
<a name="l08194"></a>08194     <span class="comment">// The index within each point at which a pbc point is found.</span>
<a name="l08195"></a>08195     point2pbcptindex = (pointsize + <span class="keyword">sizeof</span>(tetrahedron) - 1)
<a name="l08196"></a>08196                      / <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08197"></a>08197     <span class="keywordflow">if</span> (checkpbcs) {
<a name="l08198"></a>08198       <span class="comment">// Increase the size by one pointer to a corresponding pbc point,</span>
<a name="l08199"></a>08199       <span class="comment">//   read by point2pbcpt().</span>
<a name="l08200"></a>08200       pointsize = (point2pbcptindex + 1) * <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08201"></a>08201     }
<a name="l08202"></a>08202   } <span class="keywordflow">else</span> {
<a name="l08203"></a>08203     pointsize = point2simindex * <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08204"></a>08204   }
<a name="l08205"></a>08205   <span class="comment">// The index within each point at which the boundary marker is found,</span>
<a name="l08206"></a>08206   <span class="comment">//   Ensure the point marker is aligned to a sizeof(int)-byte address.</span>
<a name="l08207"></a>08207   pointmarkindex = (pointsize + <span class="keyword">sizeof</span>(int) - 1) / <span class="keyword">sizeof</span>(int);
<a name="l08208"></a>08208   <span class="comment">// Now point size is the ints (inidcated by pointmarkindex) plus:</span>
<a name="l08209"></a>08209   <span class="comment">//   - an integer for boundary marker;</span>
<a name="l08210"></a>08210   <span class="comment">//   - an integer for vertex type;</span>
<a name="l08211"></a>08211   pointsize = (pointmarkindex + 2) * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
<a name="l08212"></a>08212   <span class="comment">// Decide the wordtype used in vertex pool.</span>
<a name="l08213"></a>08213   wtype = (<span class="keyword">sizeof</span>(REAL) &gt;= <span class="keyword">sizeof</span>(tetrahedron)) ? FLOATINGPOINT : POINTER;
<a name="l08214"></a>08214   <span class="comment">// Initialize the pool of vertices.</span>
<a name="l08215"></a>08215   points = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(pointsize, VERPERBLOCK, wtype, 0);
<a name="l08216"></a>08216 
<a name="l08217"></a>08217   <span class="comment">// The number of bytes occupied by a tetrahedron.  There are four pointers</span>
<a name="l08218"></a>08218   <span class="comment">//   to other tetrahedra, four pointers to corners, and possibly four</span>
<a name="l08219"></a>08219   <span class="comment">//   pointers to subfaces.</span>
<a name="l08220"></a>08220   elesize = (8 + b-&gt;useshelles * 6) * <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08221"></a>08221   <span class="comment">// If Voronoi diagram is wanted, make sure we have additional space.</span>
<a name="l08222"></a>08222   <span class="keywordflow">if</span> (b-&gt;voroout &amp;&amp; (b-&gt;useshelles == 0)) {
<a name="l08223"></a>08223     elesize = (8 + 4) * <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08224"></a>08224   }
<a name="l08225"></a>08225   <span class="comment">// The index within each element at which its attributes are found, where</span>
<a name="l08226"></a>08226   <span class="comment">//   the index is measured in REALs.</span>
<a name="l08227"></a>08227   elemattribindex = (elesize + <span class="keyword">sizeof</span>(REAL) - 1) / <span class="keyword">sizeof</span>(REAL);
<a name="l08228"></a>08228   <span class="comment">// The index within each element at which the maximum voulme bound is</span>
<a name="l08229"></a>08229   <span class="comment">//   found, where the index is measured in REALs.  Note that if the</span>
<a name="l08230"></a>08230   <span class="comment">//   `b-&gt;regionattrib&#39; flag is set, an additional attribute will be added.</span>
<a name="l08231"></a>08231   volumeboundindex = elemattribindex + in-&gt;numberoftetrahedronattributes
<a name="l08232"></a>08232                    + (b-&gt;regionattrib &gt; 0);
<a name="l08233"></a>08233   <span class="comment">// If element attributes or an constraint are needed, increase the number</span>
<a name="l08234"></a>08234   <span class="comment">//   of bytes occupied by an element.</span>
<a name="l08235"></a>08235   <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l08236"></a>08236     elesize = (volumeboundindex + 1) * <span class="keyword">sizeof</span>(REAL);
<a name="l08237"></a>08237   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (in-&gt;numberoftetrahedronattributes + b-&gt;regionattrib &gt; 0) {
<a name="l08238"></a>08238     elesize = volumeboundindex * <span class="keyword">sizeof</span>(REAL);
<a name="l08239"></a>08239   }
<a name="l08240"></a>08240   <span class="comment">// If element neighbor graph is requested (-n switch), an additional</span>
<a name="l08241"></a>08241   <span class="comment">//   integer is allocated for each element.</span>
<a name="l08242"></a>08242   elemmarkerindex = (elesize + <span class="keyword">sizeof</span>(int) - 1) / <span class="keyword">sizeof</span>(int);
<a name="l08243"></a>08243   <span class="keywordflow">if</span> (b-&gt;neighout || b-&gt;voroout) {
<a name="l08244"></a>08244     elesize = (elemmarkerindex + 1) * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
<a name="l08245"></a>08245   }
<a name="l08246"></a>08246   <span class="comment">// If -o2 switch is used, an additional pointer pointed to the list of</span>
<a name="l08247"></a>08247   <span class="comment">//   higher order nodes is allocated for each element.</span>
<a name="l08248"></a>08248   highorderindex = (elesize + <span class="keyword">sizeof</span>(tetrahedron) - 1) / <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08249"></a>08249   <span class="keywordflow">if</span> (b-&gt;order == 2) {
<a name="l08250"></a>08250     elesize = (highorderindex + 1) * <span class="keyword">sizeof</span>(tetrahedron);
<a name="l08251"></a>08251   }
<a name="l08252"></a>08252   <span class="comment">// Having determined the memory size of an element, initialize the pool.</span>
<a name="l08253"></a>08253   tetrahedrons = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(elesize, ELEPERBLOCK, POINTER, 8);
<a name="l08254"></a>08254 
<a name="l08255"></a>08255   <span class="keywordflow">if</span> (b-&gt;useshelles) {
<a name="l08256"></a>08256     <span class="comment">// The number of bytes occupied by a subface.  The list of pointers</span>
<a name="l08257"></a>08257     <span class="comment">//   stored in a subface are: three to other subfaces, three to corners,</span>
<a name="l08258"></a>08258     <span class="comment">//   three to subsegments, two to tetrahedra, and one to a badface.</span>
<a name="l08259"></a>08259     shsize = 12 * <span class="keyword">sizeof</span>(shellface);
<a name="l08260"></a>08260     <span class="comment">// The index within each subface at which the maximum area bound is</span>
<a name="l08261"></a>08261     <span class="comment">//   found, where the index is measured in REALs.</span>
<a name="l08262"></a>08262     areaboundindex = (shsize + <span class="keyword">sizeof</span>(REAL) - 1) / <span class="keyword">sizeof</span>(REAL);
<a name="l08263"></a>08263     <span class="comment">// If -q switch is in use, increase the number of bytes occupied by</span>
<a name="l08264"></a>08264     <span class="comment">//   a subface for saving maximum area bound.</span>
<a name="l08265"></a>08265     <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l08266"></a>08266       shsize = (areaboundindex + 1) * <span class="keyword">sizeof</span>(REAL);
<a name="l08267"></a>08267     } <span class="keywordflow">else</span> {
<a name="l08268"></a>08268       shsize = areaboundindex * <span class="keyword">sizeof</span>(REAL);
<a name="l08269"></a>08269     }
<a name="l08270"></a>08270     <span class="comment">// The index within subface at which the facet marker is found. Ensure</span>
<a name="l08271"></a>08271     <span class="comment">//   the marker is aligned to a sizeof(int)-byte address.</span>
<a name="l08272"></a>08272     shmarkindex = (shsize + <span class="keyword">sizeof</span>(int) - 1) / <span class="keyword">sizeof</span>(int);
<a name="l08273"></a>08273     <span class="comment">// Increase the number of bytes by two or three integers, one for facet</span>
<a name="l08274"></a>08274     <span class="comment">//   marker, one for shellface type, and optionally one for pbc group.</span>
<a name="l08275"></a>08275     shsize = (shmarkindex + 2 + checkpbcs) * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>);
<a name="l08276"></a>08276     <span class="comment">// Initialize the pool of subfaces. Each subface record is eight-byte</span>
<a name="l08277"></a>08277     <span class="comment">//   aligned so it has room to store an edge version (from 0 to 5) in</span>
<a name="l08278"></a>08278     <span class="comment">//   the least three bits.</span>
<a name="l08279"></a>08279     subfaces = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(shsize, SUBPERBLOCK, POINTER, 8);
<a name="l08280"></a>08280     <span class="comment">// Initialize the pool of subsegments. The subsegment&#39;s record is same</span>
<a name="l08281"></a>08281     <span class="comment">//   with subface.</span>
<a name="l08282"></a>08282     subsegs = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(shsize, SUBPERBLOCK, POINTER, 8);
<a name="l08283"></a>08283     <span class="comment">// Initialize the &quot;outer space&quot; tetrahedron and omnipresent subface.</span>
<a name="l08284"></a>08284     dummyinit(tetrahedrons-&gt;itemwords, subfaces-&gt;itemwords);
<a name="l08285"></a>08285   } <span class="keywordflow">else</span> {
<a name="l08286"></a>08286     <span class="comment">// Initialize the &quot;outer space&quot; tetrahedron.</span>
<a name="l08287"></a>08287     dummyinit(tetrahedrons-&gt;itemwords, 0);
<a name="l08288"></a>08288   }
<a name="l08289"></a>08289 }
<a name="l08290"></a>08290 
<a name="l08292"></a>08292 <span class="comment">//                                                                           //</span>
<a name="l08293"></a>08293 <span class="comment">// tetrahedrondealloc()    Deallocate space for a tet., marking it dead.     //</span>
<a name="l08294"></a>08294 <span class="comment">//                                                                           //</span>
<a name="l08296"></a>08296 <span class="comment"></span>
<a name="l08297"></a>08297 <span class="keywordtype">void</span> tetgenmesh::tetrahedrondealloc(tetrahedron *dyingtetrahedron)
<a name="l08298"></a>08298 {
<a name="l08299"></a>08299   <span class="comment">// Set tetrahedron&#39;s vertices to NULL. This makes it possible to detect</span>
<a name="l08300"></a>08300   <span class="comment">//   dead tetrahedra when traversing the list of all tetrahedra.</span>
<a name="l08301"></a>08301   dyingtetrahedron[4] = (tetrahedron) NULL;
<a name="l08302"></a>08302   dyingtetrahedron[5] = (tetrahedron) NULL;
<a name="l08303"></a>08303   dyingtetrahedron[6] = (tetrahedron) NULL;
<a name="l08304"></a>08304   dyingtetrahedron[7] = (tetrahedron) NULL;
<a name="l08305"></a>08305   tetrahedrons-&gt;dealloc((<span class="keywordtype">void</span> *) dyingtetrahedron);
<a name="l08306"></a>08306 }
<a name="l08307"></a>08307 
<a name="l08309"></a>08309 <span class="comment">//                                                                           //</span>
<a name="l08310"></a>08310 <span class="comment">// tetrahedrontraverse()    Traverse the tetrahedra, skipping dead ones.     //</span>
<a name="l08311"></a>08311 <span class="comment">//                                                                           //</span>
<a name="l08313"></a>08313 <span class="comment"></span>
<a name="l08314"></a>08314 tetgenmesh::tetrahedron* tetgenmesh::tetrahedrontraverse()
<a name="l08315"></a>08315 {
<a name="l08316"></a>08316   tetrahedron *newtetrahedron;
<a name="l08317"></a>08317 
<a name="l08318"></a>08318   <span class="keywordflow">do</span> {
<a name="l08319"></a>08319     newtetrahedron = (tetrahedron *) tetrahedrons-&gt;traverse();
<a name="l08320"></a>08320     <span class="keywordflow">if</span> (newtetrahedron == (tetrahedron *) NULL) {
<a name="l08321"></a>08321       <span class="keywordflow">return</span> (tetrahedron *) NULL;
<a name="l08322"></a>08322     }
<a name="l08323"></a>08323   } <span class="keywordflow">while</span> (newtetrahedron[7] == (tetrahedron) NULL);      <span class="comment">// Skip dead ones.</span>
<a name="l08324"></a>08324   <span class="keywordflow">return</span> newtetrahedron;
<a name="l08325"></a>08325 }
<a name="l08326"></a>08326 
<a name="l08328"></a>08328 <span class="comment">//                                                                           //</span>
<a name="l08329"></a>08329 <span class="comment">// shellfacedealloc()    Deallocate space for a shellface, marking it dead.  //</span>
<a name="l08330"></a>08330 <span class="comment">//                       Used both for dealloc a subface and subsegment.     //</span>
<a name="l08331"></a>08331 <span class="comment">//                                                                           //</span>
<a name="l08333"></a>08333 <span class="comment"></span>
<a name="l08334"></a>08334 <span class="keywordtype">void</span> tetgenmesh::shellfacedealloc(<a class="code" href="structmemorypool.html">memorypool</a> *pool, shellface *dyingsh)
<a name="l08335"></a>08335 {
<a name="l08336"></a>08336   <span class="comment">// Set shellface&#39;s vertices to NULL. This makes it possible to detect dead</span>
<a name="l08337"></a>08337   <span class="comment">//   shellfaces when traversing the list of all shellfaces.</span>
<a name="l08338"></a>08338   dyingsh[3] = (shellface) NULL;
<a name="l08339"></a>08339   dyingsh[4] = (shellface) NULL;
<a name="l08340"></a>08340   dyingsh[5] = (shellface) NULL;
<a name="l08341"></a>08341   pool-&gt;dealloc((<span class="keywordtype">void</span> *) dyingsh);
<a name="l08342"></a>08342 }
<a name="l08343"></a>08343 
<a name="l08345"></a>08345 <span class="comment">//                                                                           //</span>
<a name="l08346"></a>08346 <span class="comment">// shellfacetraverse()    Traverse the subfaces, skipping dead ones. Used    //</span>
<a name="l08347"></a>08347 <span class="comment">//                        for both subfaces and subsegments pool traverse.   //</span>
<a name="l08348"></a>08348 <span class="comment">//                                                                           //</span>
<a name="l08350"></a>08350 <span class="comment"></span>
<a name="l08351"></a>08351 tetgenmesh::shellface* tetgenmesh::shellfacetraverse(<a class="code" href="structmemorypool.html">memorypool</a> *pool)
<a name="l08352"></a>08352 {
<a name="l08353"></a>08353   shellface *newshellface;
<a name="l08354"></a>08354 
<a name="l08355"></a>08355   <span class="keywordflow">do</span> {
<a name="l08356"></a>08356     newshellface = (shellface *) pool-&gt;traverse();
<a name="l08357"></a>08357     <span class="keywordflow">if</span> (newshellface == (shellface *) NULL) {
<a name="l08358"></a>08358       <span class="keywordflow">return</span> (shellface *) NULL;
<a name="l08359"></a>08359     }
<a name="l08360"></a>08360   } <span class="keywordflow">while</span> (newshellface[3] == (shellface) NULL);          <span class="comment">// Skip dead ones.</span>
<a name="l08361"></a>08361   <span class="keywordflow">return</span> newshellface;
<a name="l08362"></a>08362 }
<a name="l08363"></a>08363 
<a name="l08365"></a>08365 <span class="comment">//                                                                           //</span>
<a name="l08366"></a>08366 <span class="comment">// badfacedealloc()    Deallocate space for a badface, marking it dead.      //</span>
<a name="l08367"></a>08367 <span class="comment">//                                                                           //</span>
<a name="l08369"></a>08369 <span class="comment"></span>
<a name="l08370"></a>08370 <span class="keywordtype">void</span> tetgenmesh::badfacedealloc(<a class="code" href="structmemorypool.html">memorypool</a> *pool, badface *dying)
<a name="l08371"></a>08371 {
<a name="l08372"></a>08372   <span class="comment">// Set badface&#39;s forg to NULL. This makes it possible to detect dead</span>
<a name="l08373"></a>08373   <span class="comment">//   ones when traversing the list of all items.</span>
<a name="l08374"></a>08374   dying-&gt;forg = (point) NULL;
<a name="l08375"></a>08375   pool-&gt;dealloc((<span class="keywordtype">void</span> *) dying);
<a name="l08376"></a>08376 }
<a name="l08377"></a>08377 
<a name="l08379"></a>08379 <span class="comment">//                                                                           //</span>
<a name="l08380"></a>08380 <span class="comment">// badfacetraverse()    Traverse the pools, skipping dead ones.              //</span>
<a name="l08381"></a>08381 <span class="comment">//                                                                           //</span>
<a name="l08383"></a>08383 <span class="comment"></span>
<a name="l08384"></a>08384 tetgenmesh::badface* tetgenmesh::badfacetraverse(<a class="code" href="structmemorypool.html">memorypool</a> *pool)
<a name="l08385"></a>08385 {
<a name="l08386"></a>08386   badface *newsh;
<a name="l08387"></a>08387 
<a name="l08388"></a>08388   <span class="keywordflow">do</span> {
<a name="l08389"></a>08389     newsh = (badface *) pool-&gt;traverse();
<a name="l08390"></a>08390     <span class="keywordflow">if</span> (newsh == (badface *) NULL) {
<a name="l08391"></a>08391       <span class="keywordflow">return</span> (badface *) NULL;
<a name="l08392"></a>08392     }
<a name="l08393"></a>08393   } <span class="keywordflow">while</span> (newsh-&gt;forg == (point) NULL);               <span class="comment">// Skip dead ones.</span>
<a name="l08394"></a>08394   <span class="keywordflow">return</span> newsh;
<a name="l08395"></a>08395 }
<a name="l08396"></a>08396 
<a name="l08398"></a>08398 <span class="comment">//                                                                           //</span>
<a name="l08399"></a>08399 <span class="comment">// pointdealloc()    Deallocate space for a point, marking it dead.          //</span>
<a name="l08400"></a>08400 <span class="comment">//                                                                           //</span>
<a name="l08402"></a>08402 <span class="comment"></span>
<a name="l08403"></a>08403 <span class="keywordtype">void</span> tetgenmesh::pointdealloc(point dyingpoint)
<a name="l08404"></a>08404 {
<a name="l08405"></a>08405   <span class="comment">// Mark the point as dead. This  makes it possible to detect dead points</span>
<a name="l08406"></a>08406   <span class="comment">//   when traversing the list of all points.</span>
<a name="l08407"></a>08407   setpointtype(dyingpoint, DEADVERTEX);
<a name="l08408"></a>08408   points-&gt;dealloc((<span class="keywordtype">void</span> *) dyingpoint);
<a name="l08409"></a>08409 }
<a name="l08410"></a>08410 
<a name="l08412"></a>08412 <span class="comment">//                                                                           //</span>
<a name="l08413"></a>08413 <span class="comment">// pointtraverse()    Traverse the points, skipping dead ones.               //</span>
<a name="l08414"></a>08414 <span class="comment">//                                                                           //</span>
<a name="l08416"></a>08416 <span class="comment"></span>
<a name="l08417"></a>08417 tetgenmesh::point tetgenmesh::pointtraverse()
<a name="l08418"></a>08418 {
<a name="l08419"></a>08419   point newpoint;
<a name="l08420"></a>08420 
<a name="l08421"></a>08421   <span class="keywordflow">do</span> {
<a name="l08422"></a>08422     newpoint = (point) points-&gt;traverse();
<a name="l08423"></a>08423     <span class="keywordflow">if</span> (newpoint == (point) NULL) {
<a name="l08424"></a>08424       <span class="keywordflow">return</span> (point) NULL;
<a name="l08425"></a>08425     }
<a name="l08426"></a>08426   } <span class="keywordflow">while</span> (pointtype(newpoint) == DEADVERTEX);            <span class="comment">// Skip dead ones.</span>
<a name="l08427"></a>08427   <span class="keywordflow">return</span> newpoint;
<a name="l08428"></a>08428 }
<a name="l08429"></a>08429 
<a name="l08431"></a>08431 <span class="comment">//                                                                           //</span>
<a name="l08432"></a>08432 <span class="comment">// maketetrahedron()    Create a new tetrahedron.                            //</span>
<a name="l08433"></a>08433 <span class="comment">//                                                                           //</span>
<a name="l08435"></a>08435 <span class="comment"></span>
<a name="l08436"></a>08436 <span class="keywordtype">void</span> tetgenmesh::maketetrahedron(triface *newtet)
<a name="l08437"></a>08437 {
<a name="l08438"></a>08438   newtet-&gt;tet = (tetrahedron *) tetrahedrons-&gt;alloc();
<a name="l08439"></a>08439   <span class="comment">// Initialize the four adjoining tetrahedra to be &quot;outer space&quot;.</span>
<a name="l08440"></a>08440   newtet-&gt;tet[0] = (tetrahedron) dummytet;
<a name="l08441"></a>08441   newtet-&gt;tet[1] = (tetrahedron) dummytet;
<a name="l08442"></a>08442   newtet-&gt;tet[2] = (tetrahedron) dummytet;
<a name="l08443"></a>08443   newtet-&gt;tet[3] = (tetrahedron) dummytet;
<a name="l08444"></a>08444   <span class="comment">// Four NULL vertices.</span>
<a name="l08445"></a>08445   newtet-&gt;tet[4] = (tetrahedron) NULL;
<a name="l08446"></a>08446   newtet-&gt;tet[5] = (tetrahedron) NULL;
<a name="l08447"></a>08447   newtet-&gt;tet[6] = (tetrahedron) NULL;
<a name="l08448"></a>08448   newtet-&gt;tet[7] = (tetrahedron) NULL;
<a name="l08449"></a>08449   <span class="comment">// Initialize the four adjoining subfaces to be the omnipresent subface.</span>
<a name="l08450"></a>08450   <span class="keywordflow">if</span> (b-&gt;useshelles) {
<a name="l08451"></a>08451     newtet-&gt;tet[8 ] = (tetrahedron) dummysh;
<a name="l08452"></a>08452     newtet-&gt;tet[9 ] = (tetrahedron) dummysh;
<a name="l08453"></a>08453     newtet-&gt;tet[10] = (tetrahedron) dummysh;
<a name="l08454"></a>08454     newtet-&gt;tet[11] = (tetrahedron) dummysh;
<a name="l08455"></a>08455     newtet-&gt;tet[12] = (tetrahedron) dummysh;
<a name="l08456"></a>08456     newtet-&gt;tet[13] = (tetrahedron) dummysh;
<a name="l08457"></a>08457   }
<a name="l08458"></a>08458   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l08459"></a>08459     setelemattribute(newtet-&gt;tet, i, 0.0);
<a name="l08460"></a>08460   }
<a name="l08461"></a>08461   <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l08462"></a>08462     setvolumebound(newtet-&gt;tet, -1.0);
<a name="l08463"></a>08463   }
<a name="l08464"></a>08464   <span class="comment">// Initialize the location and version to be Zero.</span>
<a name="l08465"></a>08465   newtet-&gt;loc = 0;
<a name="l08466"></a>08466   newtet-&gt;ver = 0;
<a name="l08467"></a>08467 }
<a name="l08468"></a>08468 
<a name="l08470"></a>08470 <span class="comment">//                                                                           //</span>
<a name="l08471"></a>08471 <span class="comment">// makeshellface()    Create a new shellface with version zero. Used for     //</span>
<a name="l08472"></a>08472 <span class="comment">//                    both subfaces and seusegments.                         //</span>
<a name="l08473"></a>08473 <span class="comment">//                                                                           //</span>
<a name="l08475"></a>08475 <span class="comment"></span>
<a name="l08476"></a>08476 <span class="keywordtype">void</span> tetgenmesh::makeshellface(<a class="code" href="structmemorypool.html">memorypool</a> *pool, face *newface)
<a name="l08477"></a>08477 {
<a name="l08478"></a>08478   newface-&gt;sh = (shellface *) pool-&gt;alloc();
<a name="l08479"></a>08479   <span class="comment">//Initialize the three adjoining subfaces to be the omnipresent subface.</span>
<a name="l08480"></a>08480   newface-&gt;sh[0] = (shellface) dummysh;
<a name="l08481"></a>08481   newface-&gt;sh[1] = (shellface) dummysh;
<a name="l08482"></a>08482   newface-&gt;sh[2] = (shellface) dummysh;
<a name="l08483"></a>08483   <span class="comment">// Three NULL vertices.</span>
<a name="l08484"></a>08484   newface-&gt;sh[3] = (shellface) NULL;
<a name="l08485"></a>08485   newface-&gt;sh[4] = (shellface) NULL;
<a name="l08486"></a>08486   newface-&gt;sh[5] = (shellface) NULL;
<a name="l08487"></a>08487   <span class="comment">// Initialize the two adjoining tetrahedra to be &quot;outer space&quot;.</span>
<a name="l08488"></a>08488   newface-&gt;sh[6] = (shellface) dummytet;
<a name="l08489"></a>08489   newface-&gt;sh[7] = (shellface) dummytet;
<a name="l08490"></a>08490   <span class="comment">// Initialize the three adjoining subsegments to be the omnipresent</span>
<a name="l08491"></a>08491   <span class="comment">//   subsegments.</span>
<a name="l08492"></a>08492   newface-&gt;sh [8] = (shellface) dummysh;
<a name="l08493"></a>08493   newface-&gt;sh [9] = (shellface) dummysh;
<a name="l08494"></a>08494   newface-&gt;sh[10] = (shellface) dummysh;
<a name="l08495"></a>08495   <span class="comment">// Initialize the pointer to badface structure.</span>
<a name="l08496"></a>08496   newface-&gt;sh[11] = (shellface) NULL;
<a name="l08497"></a>08497   <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l08498"></a>08498     <span class="comment">// Initialize the maximum area bound.</span>
<a name="l08499"></a>08499     setareabound(*newface, 0.0);
<a name="l08500"></a>08500   }
<a name="l08501"></a>08501   <span class="comment">// Set the boundary marker to zero.</span>
<a name="l08502"></a>08502   setshellmark(*newface, 0);
<a name="l08503"></a>08503   <span class="comment">// Set the type.</span>
<a name="l08504"></a>08504   setshelltype(*newface, NSHARP);
<a name="l08505"></a>08505   <span class="keywordflow">if</span> (checkpbcs) {
<a name="l08506"></a>08506     <span class="comment">// Set the pbcgroup be ivalid.</span>
<a name="l08507"></a>08507     setshellpbcgroup(*newface, -1);
<a name="l08508"></a>08508   }
<a name="l08509"></a>08509   <span class="comment">// Initialize the version to be Zero.</span>
<a name="l08510"></a>08510   newface-&gt;shver = 0;
<a name="l08511"></a>08511 }
<a name="l08512"></a>08512 
<a name="l08514"></a>08514 <span class="comment">//                                                                           //</span>
<a name="l08515"></a>08515 <span class="comment">// makepoint()    Create a new point.                                        //</span>
<a name="l08516"></a>08516 <span class="comment">//                                                                           //</span>
<a name="l08518"></a>08518 <span class="comment"></span>
<a name="l08519"></a>08519 <span class="keywordtype">void</span> tetgenmesh::makepoint(point* pnewpoint)
<a name="l08520"></a>08520 {
<a name="l08521"></a>08521   <span class="keywordtype">int</span> ptmark, i;
<a name="l08522"></a>08522 
<a name="l08523"></a>08523   *pnewpoint = (point) points-&gt;alloc();
<a name="l08524"></a>08524   <span class="comment">// Initialize three coordinates.</span>
<a name="l08525"></a>08525   (*pnewpoint)[0] = 0.0;
<a name="l08526"></a>08526   (*pnewpoint)[1] = 0.0;
<a name="l08527"></a>08527   (*pnewpoint)[2] = 0.0;
<a name="l08528"></a>08528   <span class="comment">// Initialize the list of user-defined attributes.</span>
<a name="l08529"></a>08529   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofpointattributes; i++) {
<a name="l08530"></a>08530     (*pnewpoint)[3 + i] = 0.0;
<a name="l08531"></a>08531   }
<a name="l08532"></a>08532   <span class="comment">// Initialize the metric tensor.</span>
<a name="l08533"></a>08533   <span class="keywordflow">for</span> (i = 0; i &lt; sizeoftensor; i++) {
<a name="l08534"></a>08534     (*pnewpoint)[pointmtrindex + i] = 0.0;
<a name="l08535"></a>08535   }
<a name="l08536"></a>08536   <span class="keywordflow">if</span> (b-&gt;plc || b-&gt;refine) {
<a name="l08537"></a>08537     <span class="comment">// Initialize the point-to-simplex filed.</span>
<a name="l08538"></a>08538     setpoint2tet(*pnewpoint, NULL);
<a name="l08539"></a>08539     setpoint2sh(*pnewpoint, NULL);
<a name="l08540"></a>08540     setpoint2ppt(*pnewpoint, NULL);
<a name="l08541"></a>08541     <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l08542"></a>08542       setpoint2bgmtet(*pnewpoint, NULL);
<a name="l08543"></a>08543     }
<a name="l08544"></a>08544     <span class="keywordflow">if</span> (checkpbcs) {
<a name="l08545"></a>08545       <span class="comment">// Initialize the other pointer to its pbc point.</span>
<a name="l08546"></a>08546       setpoint2pbcpt(*pnewpoint, NULL);
<a name="l08547"></a>08547     }
<a name="l08548"></a>08548   }
<a name="l08549"></a>08549   <span class="comment">// Initialize the point marker (starting from in-&gt;firstnumber).</span>
<a name="l08550"></a>08550   ptmark = (int) points-&gt;items - (in-&gt;firstnumber == 1 ? 0 : 1);
<a name="l08551"></a>08551   setpointmark(*pnewpoint, ptmark);
<a name="l08552"></a>08552   <span class="comment">// Initialize the point type.</span>
<a name="l08553"></a>08553   setpointtype(*pnewpoint, UNUSEDVERTEX);
<a name="l08554"></a>08554 }
<a name="l08555"></a>08555 
<a name="l08556"></a>08556 <span class="comment">//</span>
<a name="l08557"></a>08557 <span class="comment">// End of memory management routines</span>
<a name="l08558"></a>08558 <span class="comment">//</span>
<a name="l08559"></a>08559 
<a name="l08560"></a>08560 <span class="comment">//</span>
<a name="l08561"></a>08561 <span class="comment">// Begin of point location routines</span>
<a name="l08562"></a>08562 <span class="comment">//</span>
<a name="l08563"></a>08563 
<a name="l08565"></a>08565 <span class="comment">//                                                                           //</span>
<a name="l08566"></a>08566 <span class="comment">// randomnation()    Generate a random number between 0 and &#39;choices&#39; - 1.   //</span>
<a name="l08567"></a>08567 <span class="comment">//                                                                           //</span>
<a name="l08569"></a>08569 <span class="comment"></span>
<a name="l08570"></a>08570 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> tetgenmesh::randomnation(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> choices)
<a name="l08571"></a>08571 {
<a name="l08572"></a>08572   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newrandom;
<a name="l08573"></a>08573 
<a name="l08574"></a>08574   <span class="keywordflow">if</span> (choices &gt;= 714025l) {
<a name="l08575"></a>08575     newrandom = (randomseed * 1366l + 150889l) % 714025l;
<a name="l08576"></a>08576     randomseed = (newrandom * 1366l + 150889l) % 714025l;
<a name="l08577"></a>08577     newrandom = newrandom * (choices / 714025l) + randomseed;
<a name="l08578"></a>08578     <span class="keywordflow">if</span> (newrandom &gt;= choices) {
<a name="l08579"></a>08579       <span class="keywordflow">return</span> newrandom - choices;
<a name="l08580"></a>08580     } <span class="keywordflow">else</span> {
<a name="l08581"></a>08581       <span class="keywordflow">return</span> newrandom;
<a name="l08582"></a>08582     }
<a name="l08583"></a>08583   } <span class="keywordflow">else</span> {
<a name="l08584"></a>08584     randomseed = (randomseed * 1366l + 150889l) % 714025l;
<a name="l08585"></a>08585     <span class="keywordflow">return</span> randomseed % choices;
<a name="l08586"></a>08586   }
<a name="l08587"></a>08587   <span class="comment">// Old function.</span>
<a name="l08588"></a>08588   <span class="comment">// randomseed = (randomseed * 1366l + 150889l) % 714025l;</span>
<a name="l08589"></a>08589   <span class="comment">// return randomseed / (714025l / choices + 1);</span>
<a name="l08590"></a>08590 }
<a name="l08591"></a>08591 
<a name="l08593"></a>08593 <span class="comment">//                                                                           //</span>
<a name="l08594"></a>08594 <span class="comment">// distance2()    Returns the square &quot;distance&quot; of a tetrahedron to point p. //</span>
<a name="l08595"></a>08595 <span class="comment">//                                                                           //</span>
<a name="l08597"></a>08597 <span class="comment"></span>
<a name="l08598"></a>08598 REAL tetgenmesh::distance2(tetrahedron* tetptr, point p)
<a name="l08599"></a>08599 {
<a name="l08600"></a>08600   point p1, p2, p3, p4;
<a name="l08601"></a>08601   REAL dx, dy, dz;
<a name="l08602"></a>08602 
<a name="l08603"></a>08603   p1 = (point) tetptr[4];
<a name="l08604"></a>08604   p2 = (point) tetptr[5];
<a name="l08605"></a>08605   p3 = (point) tetptr[6];
<a name="l08606"></a>08606   p4 = (point) tetptr[7];
<a name="l08607"></a>08607 
<a name="l08608"></a>08608   dx = p[0] - 0.25 * (p1[0] + p2[0] + p3[0] + p4[0]);
<a name="l08609"></a>08609   dy = p[1] - 0.25 * (p1[1] + p2[1] + p3[1] + p4[1]);
<a name="l08610"></a>08610   dz = p[2] - 0.25 * (p1[2] + p2[2] + p3[2] + p4[2]);
<a name="l08611"></a>08611 
<a name="l08612"></a>08612   <span class="keywordflow">return</span> dx * dx + dy * dy + dz * dz;
<a name="l08613"></a>08613 }
<a name="l08614"></a>08614 
<a name="l08616"></a>08616 <span class="comment">//                                                                           //</span>
<a name="l08617"></a>08617 <span class="comment">// preciselocate()    Find a simplex containing a given point.               //</span>
<a name="l08618"></a>08618 <span class="comment">//                                                                           //</span>
<a name="l08619"></a>08619 <span class="comment">// This routine implements the simple Walk-through point location algorithm. //</span>
<a name="l08620"></a>08620 <span class="comment">// Begins its search from &#39;searchtet&#39;, assume there is a line segment L from //</span>
<a name="l08621"></a>08621 <span class="comment">// a vertex of &#39;searchtet&#39; to the query point &#39;searchpt&#39;, and simply walk    //</span>
<a name="l08622"></a>08622 <span class="comment">// towards &#39;searchpt&#39; by traversing all faces intersected by L.              //</span>
<a name="l08623"></a>08623 <span class="comment">//                                                                           //</span>
<a name="l08624"></a>08624 <span class="comment">// On completion, &#39;searchtet&#39; is a tetrahedron that contains &#39;searchpt&#39;. The //</span>
<a name="l08625"></a>08625 <span class="comment">// returned value indicates one of the following cases:                      //</span>
<a name="l08626"></a>08626 <span class="comment">//   - Returns ONVERTEX if the point lies on an existing vertex. &#39;searchtet&#39; //</span>
<a name="l08627"></a>08627 <span class="comment">//     is a handle whose origin is the existing vertex.                      //</span>
<a name="l08628"></a>08628 <span class="comment">//   - Returns ONEDGE if the point lies on a mesh edge.  &#39;searchtet&#39; is a    //</span>
<a name="l08629"></a>08629 <span class="comment">//     handle whose primary edge is the edge on which the point lies.        //</span>
<a name="l08630"></a>08630 <span class="comment">//   - Returns ONFACE if the point lies strictly within a face. &#39;searchtet&#39;  //</span>
<a name="l08631"></a>08631 <span class="comment">//     is a handle whose primary face is the face on which the point lies.   //</span>
<a name="l08632"></a>08632 <span class="comment">//   - Returns INTETRAHEDRON if the point lies strictly in a tetrahededron.  //</span>
<a name="l08633"></a>08633 <span class="comment">//     &#39;searchtet&#39; is a handle on the tetrahedron that contains the point.   //</span>
<a name="l08634"></a>08634 <span class="comment">//   - Returns OUTSIDE if the point lies outside the mesh. &#39;searchtet&#39; is a  //</span>
<a name="l08635"></a>08635 <span class="comment">//     handle whose location is the face the point is to &#39;above&#39; of.         //</span>
<a name="l08636"></a>08636 <span class="comment">//                                                                           //</span>
<a name="l08637"></a>08637 <span class="comment">// WARNING: This routine is designed for convex triangulations, and will not //</span>
<a name="l08638"></a>08638 <span class="comment">// generally work after the holes and concavities have been carved.          //</span>
<a name="l08639"></a>08639 <span class="comment">//                                                                           //</span>
<a name="l08640"></a>08640 <span class="comment">// If &#39;maxtetnumber&#39; &gt; 0, stop the searching process if the number of passed //</span>
<a name="l08641"></a>08641 <span class="comment">// tets is larger than it and return OUTSIDE.                                //</span>
<a name="l08642"></a>08642 <span class="comment">//                                                                           //</span>
<a name="l08644"></a>08644 <span class="comment"></span>
<a name="l08645"></a>08645 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::preciselocate(point searchpt,
<a name="l08646"></a>08646   triface* searchtet, <span class="keywordtype">long</span> maxtetnumber)
<a name="l08647"></a>08647 {
<a name="l08648"></a>08648   triface backtracetet;
<a name="l08649"></a>08649   triface walkthroface;
<a name="l08650"></a>08650   point forg, fdest, fapex, toppo;
<a name="l08651"></a>08651   REAL ori1, ori2, ori3, ori4;
<a name="l08652"></a>08652   <span class="keywordtype">long</span> tetnumber;
<a name="l08653"></a>08653   <span class="keywordtype">int</span> side;
<a name="l08654"></a>08654 
<a name="l08655"></a>08655   <span class="keywordflow">if</span> (isdead(searchtet)) searchtet-&gt;tet = dummytet;
<a name="l08656"></a>08656   <span class="keywordflow">if</span> (searchtet-&gt;tet == dummytet) {
<a name="l08657"></a>08657     searchtet-&gt;loc = 0;
<a name="l08658"></a>08658     symself(*searchtet);
<a name="l08659"></a>08659   }
<a name="l08660"></a>08660   <span class="comment">// &#39;searchtet&#39; should be a valid tetrahedron now.</span>
<a name="l08661"></a>08661 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l08662"></a>08662 <span class="preprocessor"></span>  <span class="comment">// assert(!isdead(searchtet) &amp;&amp; (searchtet-&gt;tet != dummytet));</span>
<a name="l08663"></a>08663 <span class="preprocessor">#endif</span>
<a name="l08664"></a>08664 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (isdead(searchtet)) {
<a name="l08665"></a>08665     printf(<span class="stringliteral">&quot;Warning:  Point location failed.\n&quot;</span>);
<a name="l08666"></a>08666     <span class="keywordflow">return</span> OUTSIDE;
<a name="l08667"></a>08667   }
<a name="l08668"></a>08668 
<a name="l08669"></a>08669   searchtet-&gt;ver = 0; <span class="comment">// Keep in CCW edge ring.</span>
<a name="l08670"></a>08670   <span class="comment">// Find a face of &#39;searchtet&#39; such that the &#39;searchpt&#39; lies strictly</span>
<a name="l08671"></a>08671   <span class="comment">//   above it.  Such face should always exist.</span>
<a name="l08672"></a>08672   <span class="keywordflow">for</span> (searchtet-&gt;loc = 0; searchtet-&gt;loc &lt; 4; searchtet-&gt;loc++) {
<a name="l08673"></a>08673     forg = org(*searchtet);
<a name="l08674"></a>08674     fdest = dest(*searchtet);
<a name="l08675"></a>08675     fapex = apex(*searchtet);
<a name="l08676"></a>08676     ori1 = orient3d(forg, fdest, fapex, searchpt);
<a name="l08677"></a>08677     <span class="keywordflow">if</span> (ori1 &lt; 0.0) <span class="keywordflow">break</span>;
<a name="l08678"></a>08678   }
<a name="l08679"></a>08679 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l08680"></a>08680 <span class="preprocessor"></span>  assert(searchtet-&gt;loc &lt; 4);
<a name="l08681"></a>08681 <span class="preprocessor">#endif</span>
<a name="l08682"></a>08682 <span class="preprocessor"></span>
<a name="l08683"></a>08683   <span class="comment">// Define &#39;tetnumber&#39; for exit the loop when it&#39;s running endless.</span>
<a name="l08684"></a>08684   tetnumber = 0l;
<a name="l08685"></a>08685   <span class="keywordflow">while</span> ((maxtetnumber &gt; 0l) &amp;&amp; (tetnumber &lt;= maxtetnumber)) {
<a name="l08686"></a>08686     <span class="comment">// Check if we are reaching the boundary of the triangulation.</span>
<a name="l08687"></a>08687     <span class="keywordflow">if</span> (searchtet-&gt;tet == dummytet) {
<a name="l08688"></a>08688       *searchtet = backtracetet;
<a name="l08689"></a>08689       <span class="keywordflow">return</span> OUTSIDE;
<a name="l08690"></a>08690     }
<a name="l08691"></a>08691     <span class="comment">// Initialize the face for returning the walk-through face.</span>
<a name="l08692"></a>08692     walkthroface.tet = (tetrahedron *) NULL;
<a name="l08693"></a>08693     <span class="comment">// Adjust the edge ring, so that &#39;ori1 &lt; 0.0&#39; holds.</span>
<a name="l08694"></a>08694     searchtet-&gt;ver = 0;
<a name="l08695"></a>08695     <span class="comment">// &#39;toppo&#39; remains unchange for the following orientation tests.</span>
<a name="l08696"></a>08696     toppo = oppo(*searchtet);
<a name="l08697"></a>08697     <span class="comment">// Check the three sides of &#39;searchtet&#39; to find the face through which</span>
<a name="l08698"></a>08698     <span class="comment">//   we can walk next.</span>
<a name="l08699"></a>08699     <span class="keywordflow">for</span> (side = 0; side &lt; 3; side++) {
<a name="l08700"></a>08700       forg = org(*searchtet);
<a name="l08701"></a>08701       fdest = dest(*searchtet);
<a name="l08702"></a>08702       ori2 = orient3d(forg, fdest, toppo, searchpt);
<a name="l08703"></a>08703       <span class="keywordflow">if</span> (ori2 == 0.0) {
<a name="l08704"></a>08704         <span class="comment">// They are coplanar, check if &#39;searchpt&#39; lies inside, or on an edge,</span>
<a name="l08705"></a>08705         <span class="comment">//   or coindice with a vertex of face (forg, fdest, toppo).</span>
<a name="l08706"></a>08706         fapex = apex(*searchtet);
<a name="l08707"></a>08707         ori3 = orient3d(fdest, fapex, toppo, searchpt);
<a name="l08708"></a>08708         <span class="keywordflow">if</span> (ori3 &lt; 0.0) {
<a name="l08709"></a>08709           <span class="comment">// Outside the face (fdest, fapex, toppo), walk through it.</span>
<a name="l08710"></a>08710           enextself(*searchtet);
<a name="l08711"></a>08711           fnext(*searchtet, walkthroface);
<a name="l08712"></a>08712           <span class="keywordflow">break</span>;
<a name="l08713"></a>08713         }
<a name="l08714"></a>08714         ori4 = orient3d(fapex, forg, toppo, searchpt);
<a name="l08715"></a>08715         <span class="keywordflow">if</span> (ori4 &lt; 0.0) {
<a name="l08716"></a>08716           <span class="comment">// Outside the face (fapex, forg, toppo), walk through it.</span>
<a name="l08717"></a>08717           enext2self(*searchtet);
<a name="l08718"></a>08718           fnext(*searchtet, walkthroface);
<a name="l08719"></a>08719           <span class="keywordflow">break</span>;
<a name="l08720"></a>08720         }
<a name="l08721"></a>08721         <span class="comment">// Remember, ori1 &lt; 0.0, which means &#39;searchpt&#39; will not on edge</span>
<a name="l08722"></a>08722         <span class="comment">//   (forg, fdest) or on vertex forg or fdest.</span>
<a name="l08723"></a>08723 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l08724"></a>08724 <span class="preprocessor"></span>        assert(ori1 &lt; 0.0);
<a name="l08725"></a>08725 <span class="preprocessor">#endif</span>
<a name="l08726"></a>08726 <span class="preprocessor"></span>        <span class="comment">// The rest possible cases are:</span>
<a name="l08727"></a>08727         <span class="comment">//   (1) &#39;searchpt&#39; lies on edge (fdest, toppo);</span>
<a name="l08728"></a>08728         <span class="comment">//   (2) &#39;searchpt&#39; lies on edge (toppo, forg);</span>
<a name="l08729"></a>08729         <span class="comment">//   (3) &#39;searchpt&#39; coincident with toppo;</span>
<a name="l08730"></a>08730         <span class="comment">//   (4) &#39;searchpt&#39; lies inside face (forg, fdest, toppo).</span>
<a name="l08731"></a>08731         fnextself(*searchtet);
<a name="l08732"></a>08732         <span class="keywordflow">if</span> (ori3 == 0.0) {
<a name="l08733"></a>08733           <span class="keywordflow">if</span> (ori4 == 0.0) {
<a name="l08734"></a>08734             <span class="comment">// Case (4).</span>
<a name="l08735"></a>08735             enext2self(*searchtet);
<a name="l08736"></a>08736             <span class="keywordflow">return</span> ONVERTEX;
<a name="l08737"></a>08737           } <span class="keywordflow">else</span> {
<a name="l08738"></a>08738             <span class="comment">// Case (1).</span>
<a name="l08739"></a>08739             enextself(*searchtet);
<a name="l08740"></a>08740             <span class="keywordflow">return</span> ONEDGE;
<a name="l08741"></a>08741           }
<a name="l08742"></a>08742         }
<a name="l08743"></a>08743         <span class="keywordflow">if</span> (ori4 == 0.0) {
<a name="l08744"></a>08744           <span class="comment">// Case (2).</span>
<a name="l08745"></a>08745           enext2self(*searchtet);
<a name="l08746"></a>08746           <span class="keywordflow">return</span> ONEDGE;
<a name="l08747"></a>08747         }
<a name="l08748"></a>08748         <span class="comment">// Case (4).</span>
<a name="l08749"></a>08749         <span class="keywordflow">return</span> ONFACE;
<a name="l08750"></a>08750       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori2 &lt; 0.0) {
<a name="l08751"></a>08751         <span class="comment">// Outside the face (forg, fdest, toppo), walk through it.</span>
<a name="l08752"></a>08752         fnext(*searchtet, walkthroface);
<a name="l08753"></a>08753         <span class="keywordflow">break</span>;
<a name="l08754"></a>08754       }
<a name="l08755"></a>08755       <span class="comment">// Go to check next side.</span>
<a name="l08756"></a>08756       enextself(*searchtet);
<a name="l08757"></a>08757     }
<a name="l08758"></a>08758     <span class="keywordflow">if</span> (side &gt;= 3) {
<a name="l08759"></a>08759       <span class="comment">// Found! Inside tetrahedron.</span>
<a name="l08760"></a>08760       <span class="keywordflow">return</span> INTETRAHEDRON;
<a name="l08761"></a>08761     }
<a name="l08762"></a>08762     <span class="comment">// We walk through the face &#39;walkthroface&#39; and continue the searching.</span>
<a name="l08763"></a>08763 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l08764"></a>08764 <span class="preprocessor"></span>    assert(walkthroface.tet != (tetrahedron *) NULL);
<a name="l08765"></a>08765 <span class="preprocessor">#endif</span>
<a name="l08766"></a>08766 <span class="preprocessor"></span>    <span class="comment">// Store the face handle in &#39;backtracetet&#39; before we take the real walk.</span>
<a name="l08767"></a>08767     <span class="comment">//   So we are able to restore the handle to &#39;searchtet&#39; if we are</span>
<a name="l08768"></a>08768     <span class="comment">//   reaching the outer boundary.</span>
<a name="l08769"></a>08769     backtracetet = walkthroface;
<a name="l08770"></a>08770     sym(walkthroface, *searchtet);
<a name="l08771"></a>08771     tetnumber++;
<a name="l08772"></a>08772   }
<a name="l08773"></a>08773 
<a name="l08774"></a>08774   <span class="comment">// Should never be here.</span>
<a name="l08775"></a>08775   <span class="comment">// printf(&quot;Internal error in preciselocate(): Point location failed.\n&quot;);</span>
<a name="l08776"></a>08776   <span class="comment">// internalerror();</span>
<a name="l08777"></a>08777   <span class="keywordflow">return</span> OUTSIDE;
<a name="l08778"></a>08778 }
<a name="l08779"></a>08779 
<a name="l08781"></a>08781 <span class="comment">//                                                                           //</span>
<a name="l08782"></a>08782 <span class="comment">// locate()    Find a simplex containing a given point.                      //</span>
<a name="l08783"></a>08783 <span class="comment">//                                                                           //</span>
<a name="l08784"></a>08784 <span class="comment">// This routine implements Muecke&#39;s Jump-and-walk point location algorithm.  //</span>
<a name="l08785"></a>08785 <span class="comment">// It improves the simple walk-through by &quot;jumping&quot; to a good starting point //</span>
<a name="l08786"></a>08786 <span class="comment">// via random sampling.  Searching begins from one of handles:  the input    //</span>
<a name="l08787"></a>08787 <span class="comment">// &#39;searchtet&#39;, a recently encountered tetrahedron &#39;recenttet&#39;,  or from one //</span>
<a name="l08788"></a>08788 <span class="comment">// chosen from a random sample.  The choice is made by determining which one //</span>
<a name="l08789"></a>08789 <span class="comment">// &#39;s barycenter is closest to the point we are searcing for.  Having chosen //</span>
<a name="l08790"></a>08790 <span class="comment">// the starting tetrahedron, the simple Walk-through algorithm is used to do //</span>
<a name="l08791"></a>08791 <span class="comment">// the real walking.                                                         //</span>
<a name="l08792"></a>08792 <span class="comment">//                                                                           //</span>
<a name="l08793"></a>08793 <span class="comment">// The return value indicates the location of the &#39;searchpt&#39; (INTETRAHEDRON, //</span>
<a name="l08794"></a>08794 <span class="comment">// or ONFACE, ...). &#39;searchtet&#39; is adjusted to a tetrahedron corresponding   //</span>
<a name="l08795"></a>08795 <span class="comment">// to that value. See the introduction part of preciselocate() for detail.   //</span>
<a name="l08796"></a>08796 <span class="comment">//                                                                           //</span>
<a name="l08797"></a>08797 <span class="comment">// WARNING: This routine is designed for convex triangulations, and will not //</span>
<a name="l08798"></a>08798 <span class="comment">// generally work after the holes and concavities have been carved.          //</span>
<a name="l08799"></a>08799 <span class="comment">//                                                                           //</span>
<a name="l08801"></a>08801 <span class="comment"></span>
<a name="l08802"></a>08802 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::locate(point searchpt,
<a name="l08803"></a>08803   triface *searchtet)
<a name="l08804"></a>08804 {
<a name="l08805"></a>08805   tetrahedron *firsttet, *tetptr;
<a name="l08806"></a>08806   <span class="keywordtype">void</span> **sampleblock;
<a name="l08807"></a>08807   <span class="keywordtype">long</span> sampleblocks, samplesperblock, samplenum;
<a name="l08808"></a>08808   <span class="keywordtype">long</span> tetblocks, i, j;
<a name="l08809"></a>08809   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> alignptr;
<a name="l08810"></a>08810   REAL searchdist, dist;
<a name="l08811"></a>08811 
<a name="l08812"></a>08812   <span class="comment">// &#39;searchtet&#39; should be a valid tetrahedron.</span>
<a name="l08813"></a>08813   <span class="keywordflow">if</span> (isdead(searchtet)) {
<a name="l08814"></a>08814     searchtet-&gt;tet = dummytet;
<a name="l08815"></a>08815   }
<a name="l08816"></a>08816   <span class="keywordflow">if</span> (searchtet-&gt;tet == dummytet) {
<a name="l08817"></a>08817     <span class="comment">// This is an &#39;Outer Space&#39; handle, get a hull tetrahedron.</span>
<a name="l08818"></a>08818     searchtet-&gt;loc = 0;
<a name="l08819"></a>08819     symself(*searchtet);
<a name="l08820"></a>08820   }
<a name="l08821"></a>08821 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l08822"></a>08822 <span class="preprocessor"></span>  <span class="comment">// assert(!isdead(searchtet));</span>
<a name="l08823"></a>08823 <span class="preprocessor">#endif</span>
<a name="l08824"></a>08824 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (isdead(searchtet)) {
<a name="l08825"></a>08825     printf(<span class="stringliteral">&quot;Warning:  Point location failed.\n&quot;</span>);
<a name="l08826"></a>08826     <span class="keywordflow">return</span> OUTSIDE;
<a name="l08827"></a>08827   }
<a name="l08828"></a>08828 
<a name="l08829"></a>08829   <span class="comment">// Get the distance from the suggested starting tet to the point we seek.</span>
<a name="l08830"></a>08830   searchdist = distance2(searchtet-&gt;tet, searchpt);
<a name="l08831"></a>08831 
<a name="l08832"></a>08832   <span class="comment">// If a recently encountered tetrahedron has been recorded and has not</span>
<a name="l08833"></a>08833   <span class="comment">//   been deallocated, test it as a good starting point.</span>
<a name="l08834"></a>08834   <span class="keywordflow">if</span> (!isdead(&amp;recenttet) &amp;&amp; (recenttet.tet != searchtet-&gt;tet)) {
<a name="l08835"></a>08835     dist = distance2(recenttet.tet, searchpt);
<a name="l08836"></a>08836     <span class="keywordflow">if</span> (dist &lt; searchdist) {
<a name="l08837"></a>08837       *searchtet = recenttet;
<a name="l08838"></a>08838       searchdist = dist;
<a name="l08839"></a>08839     }
<a name="l08840"></a>08840   }
<a name="l08841"></a>08841 
<a name="l08842"></a>08842   <span class="comment">// Select &quot;good&quot; candidate using k random samples, taking the closest one.</span>
<a name="l08843"></a>08843   <span class="comment">//   The number of random samples taken is proportional to the fourth root</span>
<a name="l08844"></a>08844   <span class="comment">//   of the number of tetrahedra in the mesh. The next bit of code assumes</span>
<a name="l08845"></a>08845   <span class="comment">//   that the number of tetrahedra increases monotonically.</span>
<a name="l08846"></a>08846   <span class="keywordflow">while</span> (SAMPLEFACTOR * samples * samples * samples * samples &lt;
<a name="l08847"></a>08847          tetrahedrons-&gt;items) {
<a name="l08848"></a>08848     samples++;
<a name="l08849"></a>08849   }
<a name="l08850"></a>08850   <span class="comment">// Find how much blocks in current tet pool.</span>
<a name="l08851"></a>08851   tetblocks = (tetrahedrons-&gt;maxitems + ELEPERBLOCK - 1) / ELEPERBLOCK;
<a name="l08852"></a>08852   <span class="comment">// Find the average samles per block. Each block at least have 1 sample.</span>
<a name="l08853"></a>08853   samplesperblock = 1 + (samples / tetblocks);
<a name="l08854"></a>08854   sampleblocks = samples / samplesperblock;
<a name="l08855"></a>08855   sampleblock = tetrahedrons-&gt;firstblock;
<a name="l08856"></a>08856   <span class="keywordflow">for</span> (i = 0; i &lt; sampleblocks; i++) {
<a name="l08857"></a>08857     alignptr = (<span class="keywordtype">unsigned</span> long) (sampleblock + 1);
<a name="l08858"></a>08858     firsttet = (tetrahedron *)
<a name="l08859"></a>08859                (alignptr + (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>) tetrahedrons-&gt;alignbytes
<a name="l08860"></a>08860                - (alignptr % (<span class="keywordtype">unsigned</span> long) tetrahedrons-&gt;alignbytes));
<a name="l08861"></a>08861     <span class="keywordflow">for</span> (j = 0; j &lt; samplesperblock; j++) {
<a name="l08862"></a>08862       <span class="keywordflow">if</span> (i == tetblocks - 1) {
<a name="l08863"></a>08863         <span class="comment">// This is the last block.</span>
<a name="l08864"></a>08864         samplenum = randomnation((<span class="keywordtype">int</span>)
<a name="l08865"></a>08865                       (tetrahedrons-&gt;maxitems - (i * ELEPERBLOCK)));
<a name="l08866"></a>08866       } <span class="keywordflow">else</span> {
<a name="l08867"></a>08867         samplenum = randomnation(ELEPERBLOCK);
<a name="l08868"></a>08868       }
<a name="l08869"></a>08869       tetptr = (tetrahedron *)
<a name="l08870"></a>08870                (firsttet + (samplenum * tetrahedrons-&gt;itemwords));
<a name="l08871"></a>08871       <span class="keywordflow">if</span> (tetptr[4] != (tetrahedron) NULL) {
<a name="l08872"></a>08872         dist = distance2(tetptr, searchpt);
<a name="l08873"></a>08873         <span class="keywordflow">if</span> (dist &lt; searchdist) {
<a name="l08874"></a>08874           searchtet-&gt;tet = tetptr;
<a name="l08875"></a>08875           searchdist = dist;
<a name="l08876"></a>08876         }
<a name="l08877"></a>08877       }
<a name="l08878"></a>08878     }
<a name="l08879"></a>08879     sampleblock = (<span class="keywordtype">void</span> **) *sampleblock;
<a name="l08880"></a>08880   }
<a name="l08881"></a>08881 
<a name="l08882"></a>08882   <span class="comment">// Call simple walk-through to locate the point.</span>
<a name="l08883"></a>08883   <span class="keywordflow">return</span> preciselocate(searchpt, searchtet, tetrahedrons-&gt;items);
<a name="l08884"></a>08884 }
<a name="l08885"></a>08885 
<a name="l08887"></a>08887 <span class="comment">//                                                                           //</span>
<a name="l08888"></a>08888 <span class="comment">// adjustlocate()    Adjust the precise location of a vertex.                //</span>
<a name="l08889"></a>08889 <span class="comment">//                                                                           //</span>
<a name="l08890"></a>08890 <span class="comment">// &#39;precise&#39; is the value returned from preciselocate().  It indicates the   //</span>
<a name="l08891"></a>08891 <span class="comment">// exact location of the point &#39;searchpt&#39; with respect to the tetrahedron    //</span>
<a name="l08892"></a>08892 <span class="comment">// &#39;searchtet&#39;.  &#39;epspp&#39; is a given relative tolerance.                      //</span>
<a name="l08893"></a>08893 <span class="comment">//                                                                           //</span>
<a name="l08894"></a>08894 <span class="comment">// This routine re-evaluates the orientations of searchpt with respect to    //</span>
<a name="l08895"></a>08895 <span class="comment">// the four sides of searchtet. Detects the coplanarities by additinal tests //</span>
<a name="l08896"></a>08896 <span class="comment">// which are based on the given tolerance. If &#39;precise&#39; is ONFACE or ONEDGE, //</span>
<a name="l08897"></a>08897 <span class="comment">// we can save one or two orientation tests.                                 //</span>
<a name="l08898"></a>08898 <span class="comment">//                                                                           //</span>
<a name="l08899"></a>08899 <span class="comment">// The return value indicates the location of the &#39;searchpt&#39; (INTETRAHEDRON, //</span>
<a name="l08900"></a>08900 <span class="comment">// or ONFACE, ...). &#39;searchtet&#39; is adjusted to a tetrahedron corresponding   //</span>
<a name="l08901"></a>08901 <span class="comment">// to that value. See the introduction part of preciselocate() for detail.   //</span>
<a name="l08902"></a>08902 <span class="comment">//                                                                           //</span>
<a name="l08903"></a>08903 <span class="comment">// WARNING:  This routine detect degenerate case using relative tolerance.   //</span>
<a name="l08904"></a>08904 <span class="comment">// It is better used after locate() or preciselocate().  For general inputs, //</span>
<a name="l08905"></a>08905 <span class="comment">// it may not able to tell the correct location.                             //</span>
<a name="l08906"></a>08906 <span class="comment">//                                                                           //</span>
<a name="l08908"></a>08908 <span class="comment"></span>
<a name="l08909"></a>08909 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::adjustlocate(point searchpt,
<a name="l08910"></a>08910   triface* searchtet, <span class="keyword">enum</span> locateresult precise, REAL epspp)
<a name="l08911"></a>08911 {
<a name="l08912"></a>08912   point torg, tdest, tapex, toppo;
<a name="l08913"></a>08913   REAL s1, s2, s3, s4;
<a name="l08914"></a>08914 
<a name="l08915"></a>08915   <span class="comment">// For the given &#39;searchtet&#39;, the orientations tests are:</span>
<a name="l08916"></a>08916   <span class="comment">//  s1: (tdest, torg, tapex, searchpt);</span>
<a name="l08917"></a>08917   <span class="comment">//  s2: (torg, tdest, toppo, searchpt);</span>
<a name="l08918"></a>08918   <span class="comment">//  s3: (tdest, tapex, toppo, searchpt);</span>
<a name="l08919"></a>08919   <span class="comment">//  s4: (tapex, torg, toppo, searchpt);</span>
<a name="l08920"></a>08920   adjustedgering(*searchtet, CCW);
<a name="l08921"></a>08921   torg = org(*searchtet);
<a name="l08922"></a>08922   tdest = dest(*searchtet);
<a name="l08923"></a>08923   tapex = apex(*searchtet);
<a name="l08924"></a>08924   toppo = oppo(*searchtet);
<a name="l08925"></a>08925 
<a name="l08926"></a>08926   <span class="keywordflow">switch</span> (precise) {
<a name="l08927"></a>08927   <span class="keywordflow">case</span> ONVERTEX:
<a name="l08928"></a>08928     <span class="comment">// This case we don&#39;t need do any further test.</span>
<a name="l08929"></a>08929     <span class="keywordflow">return</span> ONVERTEX;
<a name="l08930"></a>08930   <span class="keywordflow">case</span> ONEDGE:
<a name="l08931"></a>08931     <span class="comment">// (torg, tdest);</span>
<a name="l08932"></a>08932     s1 = 0.0;
<a name="l08933"></a>08933     s2 = 0.0;
<a name="l08934"></a>08934     <span class="keywordflow">break</span>;
<a name="l08935"></a>08935   <span class="keywordflow">case</span> ONFACE:
<a name="l08936"></a>08936     <span class="comment">// (tdest, torg, tapex);</span>
<a name="l08937"></a>08937     s1 = 0.0;
<a name="l08938"></a>08938     s2 = orient3d(torg, tdest, toppo, searchpt);
<a name="l08939"></a>08939     <span class="keywordflow">break</span>;
<a name="l08940"></a>08940   <span class="keywordflow">default</span>: <span class="comment">// INTETRAHEDRON or OUTSIDE</span>
<a name="l08941"></a>08941     s1 = orient3d(tdest, torg, tapex, searchpt);
<a name="l08942"></a>08942     s2 = orient3d(torg, tdest, toppo, searchpt);
<a name="l08943"></a>08943   }
<a name="l08944"></a>08944 
<a name="l08945"></a>08945   <span class="keywordflow">if</span> (s1 != 0.0) {
<a name="l08946"></a>08946     <span class="keywordflow">if</span> (iscoplanar(tdest, torg, tapex, searchpt, s1, epspp)) {
<a name="l08947"></a>08947       s1 = 0.0;
<a name="l08948"></a>08948     }
<a name="l08949"></a>08949   }
<a name="l08950"></a>08950   <span class="keywordflow">if</span> (s1 &lt; 0.0) {
<a name="l08951"></a>08951     <span class="keywordflow">return</span> OUTSIDE;
<a name="l08952"></a>08952   }
<a name="l08953"></a>08953 
<a name="l08954"></a>08954   <span class="keywordflow">if</span> (s2 != 0.0) {
<a name="l08955"></a>08955     <span class="keywordflow">if</span> (iscoplanar(torg, tdest, toppo, searchpt, s2, epspp)) {
<a name="l08956"></a>08956       s2 = 0.0;
<a name="l08957"></a>08957     }
<a name="l08958"></a>08958   }
<a name="l08959"></a>08959   <span class="keywordflow">if</span> (s2 &lt; 0.0) {
<a name="l08960"></a>08960     fnextself(*searchtet);
<a name="l08961"></a>08961     <span class="keywordflow">return</span> OUTSIDE;
<a name="l08962"></a>08962   }
<a name="l08963"></a>08963 
<a name="l08964"></a>08964   s3 = orient3d(tdest, tapex, toppo, searchpt);
<a name="l08965"></a>08965   <span class="keywordflow">if</span> (s3 != 0.0) {
<a name="l08966"></a>08966     <span class="keywordflow">if</span> (iscoplanar(tdest, tapex, toppo, searchpt, s3, epspp)) {
<a name="l08967"></a>08967       s3 = 0.0;
<a name="l08968"></a>08968     }
<a name="l08969"></a>08969   }
<a name="l08970"></a>08970   <span class="keywordflow">if</span> (s3 &lt; 0.0) {
<a name="l08971"></a>08971     enextfnextself(*searchtet);
<a name="l08972"></a>08972     <span class="keywordflow">return</span> OUTSIDE;
<a name="l08973"></a>08973   }
<a name="l08974"></a>08974 
<a name="l08975"></a>08975   s4 = orient3d(tapex, torg, toppo, searchpt);
<a name="l08976"></a>08976   <span class="keywordflow">if</span> (s4 != 0.0) {
<a name="l08977"></a>08977     <span class="keywordflow">if</span> (iscoplanar(tapex, torg, toppo, searchpt, s4, epspp)) {
<a name="l08978"></a>08978       s4 = 0.0;
<a name="l08979"></a>08979     }
<a name="l08980"></a>08980   }
<a name="l08981"></a>08981   <span class="keywordflow">if</span> (s4 &lt; 0.0) {
<a name="l08982"></a>08982     enext2fnextself(*searchtet);
<a name="l08983"></a>08983     <span class="keywordflow">return</span> OUTSIDE;
<a name="l08984"></a>08984   }
<a name="l08985"></a>08985 
<a name="l08986"></a>08986   <span class="comment">// Determine degenerate cases.</span>
<a name="l08987"></a>08987   <span class="keywordflow">if</span> (s1 == 0.0) {
<a name="l08988"></a>08988     <span class="keywordflow">if</span> (s2 == 0.0) {
<a name="l08989"></a>08989       <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l08990"></a>08990         <span class="comment">// On tdest.</span>
<a name="l08991"></a>08991         enextself(*searchtet);
<a name="l08992"></a>08992         <span class="keywordflow">return</span> ONVERTEX;
<a name="l08993"></a>08993       }
<a name="l08994"></a>08994       <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l08995"></a>08995         <span class="comment">// On torg.</span>
<a name="l08996"></a>08996         <span class="keywordflow">return</span> ONVERTEX;
<a name="l08997"></a>08997       }
<a name="l08998"></a>08998       <span class="comment">// On edge (torg, tdest).</span>
<a name="l08999"></a>08999       <span class="keywordflow">return</span> ONEDGE;
<a name="l09000"></a>09000     }
<a name="l09001"></a>09001     <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l09002"></a>09002       <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l09003"></a>09003         <span class="comment">// On tapex.</span>
<a name="l09004"></a>09004         enext2self(*searchtet);
<a name="l09005"></a>09005         <span class="keywordflow">return</span> ONVERTEX;
<a name="l09006"></a>09006       }
<a name="l09007"></a>09007       <span class="comment">// On edge (tdest, tapex).</span>
<a name="l09008"></a>09008       enextself(*searchtet);
<a name="l09009"></a>09009       <span class="keywordflow">return</span> ONEDGE;
<a name="l09010"></a>09010     }
<a name="l09011"></a>09011     <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l09012"></a>09012       <span class="comment">// On edge (tapex, torg).</span>
<a name="l09013"></a>09013       enext2self(*searchtet);
<a name="l09014"></a>09014       <span class="keywordflow">return</span> ONEDGE;
<a name="l09015"></a>09015     }
<a name="l09016"></a>09016     <span class="comment">// On face (torg, tdest, tapex).</span>
<a name="l09017"></a>09017     <span class="keywordflow">return</span> ONFACE;
<a name="l09018"></a>09018   }
<a name="l09019"></a>09019   <span class="keywordflow">if</span> (s2 == 0.0) {
<a name="l09020"></a>09020     fnextself(*searchtet);
<a name="l09021"></a>09021     <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l09022"></a>09022       <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l09023"></a>09023         <span class="comment">// On toppo.</span>
<a name="l09024"></a>09024         enext2self(*searchtet);
<a name="l09025"></a>09025         <span class="keywordflow">return</span> ONVERTEX;
<a name="l09026"></a>09026       }
<a name="l09027"></a>09027       <span class="comment">// On edge (tdest, toppo).</span>
<a name="l09028"></a>09028       enextself(*searchtet);
<a name="l09029"></a>09029       <span class="keywordflow">return</span> ONEDGE;
<a name="l09030"></a>09030     }
<a name="l09031"></a>09031     <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l09032"></a>09032       <span class="comment">// On edge (toppo, torg).</span>
<a name="l09033"></a>09033       enext2self(*searchtet);
<a name="l09034"></a>09034       <span class="keywordflow">return</span> ONEDGE;
<a name="l09035"></a>09035     }
<a name="l09036"></a>09036     <span class="comment">// On face (torg, tdest, toppo).</span>
<a name="l09037"></a>09037     <span class="keywordflow">return</span> ONFACE;
<a name="l09038"></a>09038   }
<a name="l09039"></a>09039   <span class="keywordflow">if</span> (s3 == 0.0) {
<a name="l09040"></a>09040     enextfnextself(*searchtet);
<a name="l09041"></a>09041     <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l09042"></a>09042       <span class="comment">// On edge (tapex, toppo).</span>
<a name="l09043"></a>09043       enextself(*searchtet);
<a name="l09044"></a>09044       <span class="keywordflow">return</span> ONEDGE;
<a name="l09045"></a>09045     }
<a name="l09046"></a>09046     <span class="comment">// On face (tdest, tapex, toppo).</span>
<a name="l09047"></a>09047     <span class="keywordflow">return</span> ONFACE;
<a name="l09048"></a>09048   }
<a name="l09049"></a>09049   <span class="keywordflow">if</span> (s4 == 0.0) {
<a name="l09050"></a>09050     enext2fnextself(*searchtet);
<a name="l09051"></a>09051     <span class="comment">// On face (tapex, torg, toppo).</span>
<a name="l09052"></a>09052     <span class="keywordflow">return</span> ONFACE;
<a name="l09053"></a>09053   }
<a name="l09054"></a>09054 
<a name="l09055"></a>09055   <span class="comment">// Inside tetrahedron.</span>
<a name="l09056"></a>09056   <span class="keywordflow">return</span> INTETRAHEDRON;
<a name="l09057"></a>09057 }
<a name="l09058"></a>09058 
<a name="l09060"></a>09060 <span class="comment">//                                                                           //</span>
<a name="l09061"></a>09061 <span class="comment">// hullwalk()    Find a tetrahedron on the hull to continue search.          //</span>
<a name="l09062"></a>09062 <span class="comment">//                                                                           //</span>
<a name="l09064"></a>09064 <span class="comment"></span>
<a name="l09065"></a>09065 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::hullwalk(point searchpt,
<a name="l09066"></a>09066   triface *hulltet)
<a name="l09067"></a>09067 {
<a name="l09068"></a>09068   list* travtetlist;
<a name="l09069"></a>09069   triface travtet, neightet;
<a name="l09070"></a>09070   point pa, pb, pc;
<a name="l09071"></a>09071   <span class="keyword">enum</span> locateresult loc;
<a name="l09072"></a>09072   REAL ori;
<a name="l09073"></a>09073   <span class="keywordtype">int</span> i;
<a name="l09074"></a>09074 
<a name="l09075"></a>09075   travtetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l09076"></a>09076   travtet = *hulltet;
<a name="l09077"></a>09077   infect(travtet);
<a name="l09078"></a>09078   travtetlist-&gt;append(&amp;travtet);
<a name="l09079"></a>09079 
<a name="l09080"></a>09080   loc = OUTSIDE;
<a name="l09081"></a>09081   <span class="keywordflow">for</span> (i = 0; i &lt; travtetlist-&gt;len(); i++) {
<a name="l09082"></a>09082     travtet = * (triface *)(* travtetlist)[i];
<a name="l09083"></a>09083     <span class="comment">// Choose the CCW-edgering in face.</span>
<a name="l09084"></a>09084     travtet.ver = 0;
<a name="l09085"></a>09085     <span class="comment">// Look for a side where pt lies below it.</span>
<a name="l09086"></a>09086     <span class="keywordflow">for</span> (travtet.loc = 0; travtet.loc &lt; 4; travtet.loc++) {
<a name="l09087"></a>09087       pa = org(travtet);
<a name="l09088"></a>09088       pb = dest(travtet);
<a name="l09089"></a>09089       pc = apex(travtet);
<a name="l09090"></a>09090       ori = orient3d(pa, pb, pc, searchpt);
<a name="l09091"></a>09091       <span class="keywordflow">if</span> (ori &gt; 0.0) <span class="keywordflow">break</span>;
<a name="l09092"></a>09092     }
<a name="l09093"></a>09093     <span class="comment">// Is pt above all (or coplanar with some of) the four sides?</span>
<a name="l09094"></a>09094     <span class="keywordflow">if</span> (travtet.loc == 4) {
<a name="l09095"></a>09095       hulltet-&gt;tet = travtet.tet;
<a name="l09096"></a>09096       loc = adjustlocate(searchpt, hulltet, INTETRAHEDRON, b-&gt;epsilon);
<a name="l09097"></a>09097       assert(loc != OUTSIDE);
<a name="l09098"></a>09098     } <span class="keywordflow">else</span> { <span class="comment">// ori &gt; 0.0</span>
<a name="l09099"></a>09099       <span class="comment">// pt is below (behind) this side. We want to walk through it.</span>
<a name="l09100"></a>09100       sym(travtet, neightet);
<a name="l09101"></a>09101       <span class="keywordflow">if</span> (neightet.tet == dummytet) {
<a name="l09102"></a>09102         <span class="comment">// This is a hull side. Is p approximately on this side.</span>
<a name="l09103"></a>09103         loc = adjustlocate(searchpt, &amp;travtet, OUTSIDE, b-&gt;epsilon);
<a name="l09104"></a>09104       }
<a name="l09105"></a>09105       <span class="keywordflow">if</span> (loc == OUTSIDE) {
<a name="l09106"></a>09106         <span class="comment">// Let&#39;s collect all the neighbors for next searching.</span>
<a name="l09107"></a>09107         <span class="keywordflow">for</span> (travtet.loc = 0; travtet.loc &lt; 4; travtet.loc++) {
<a name="l09108"></a>09108           sym(travtet, neightet);
<a name="l09109"></a>09109           <span class="keywordflow">if</span> ((neightet.tet != dummytet) &amp;&amp; !infected(neightet)) {
<a name="l09110"></a>09110             <span class="comment">// Neighbor exists and not visited.</span>
<a name="l09111"></a>09111             infect(neightet);
<a name="l09112"></a>09112             travtetlist-&gt;append(&amp;neightet);
<a name="l09113"></a>09113           }
<a name="l09114"></a>09114         } <span class="comment">// for (travtet.loc = 0;</span>
<a name="l09115"></a>09115       } <span class="comment">// if (loc == OUTSIDE)</span>
<a name="l09116"></a>09116     } <span class="comment">// if (travtet.loc == 4)</span>
<a name="l09117"></a>09117     <span class="keywordflow">if</span> (loc != OUTSIDE) <span class="keywordflow">break</span>;
<a name="l09118"></a>09118   } <span class="comment">// for (i = 0; i &lt; travtetlist-&gt;len(); i++)</span>
<a name="l09119"></a>09119 
<a name="l09120"></a>09120   <span class="comment">// Uninfect traversed tets.</span>
<a name="l09121"></a>09121   <span class="keywordflow">for</span> (i = 0; i &lt; travtetlist-&gt;len(); i++) {
<a name="l09122"></a>09122     travtet = * (triface *)(* travtetlist)[i];
<a name="l09123"></a>09123     uninfect(travtet);
<a name="l09124"></a>09124   }
<a name="l09125"></a>09125 
<a name="l09126"></a>09126   <span class="keyword">delete</span> travtetlist;
<a name="l09127"></a>09127   <span class="keywordflow">return</span> loc;
<a name="l09128"></a>09128 }
<a name="l09129"></a>09129 
<a name="l09131"></a>09131 <span class="comment">//                                                                           //</span>
<a name="l09132"></a>09132 <span class="comment">// locatesub()    Find a point in the surface mesh of a facet.               //</span>
<a name="l09133"></a>09133 <span class="comment">//                                                                           //</span>
<a name="l09134"></a>09134 <span class="comment">// Searching begins from the input &#39;searchsh&#39;, it should be a handle on the  //</span>
<a name="l09135"></a>09135 <span class="comment">// convex hull of the facet triangulation.                                   //</span>
<a name="l09136"></a>09136 <span class="comment">//                                                                           //</span>
<a name="l09137"></a>09137 <span class="comment">// If &#39;stopatseg&#39; is nonzero, the search will stop if it tries to walk       //</span>
<a name="l09138"></a>09138 <span class="comment">// through a subsegment, and will return OUTSIDE.                            //</span>
<a name="l09139"></a>09139 <span class="comment">//                                                                           //</span>
<a name="l09140"></a>09140 <span class="comment">// On completion, &#39;searchsh&#39; is a subface that contains &#39;searchpt&#39;.          //</span>
<a name="l09141"></a>09141 <span class="comment">//   - Returns ONVERTEX if the point lies on an existing vertex. &#39;searchsh&#39;  //</span>
<a name="l09142"></a>09142 <span class="comment">//     is a handle whose origin is the existing vertex.                      //</span>
<a name="l09143"></a>09143 <span class="comment">//   - Returns ONEDGE if the point lies on a mesh edge.  &#39;searchsh&#39; is a     //</span>
<a name="l09144"></a>09144 <span class="comment">//     handle whose primary edge is the edge on which the point lies.        //</span>
<a name="l09145"></a>09145 <span class="comment">//   - Returns ONFACE if the point lies strictly within a subface.           //</span>
<a name="l09146"></a>09146 <span class="comment">//     &#39;searchsh&#39; is a handle on which the point lies.                       //</span>
<a name="l09147"></a>09147 <span class="comment">//   - Returns OUTSIDE if the point lies outside the triangulation.          //</span>
<a name="l09148"></a>09148 <span class="comment">//                                                                           //</span>
<a name="l09149"></a>09149 <span class="comment">// WARNING: This routine is designed for convex triangulations, and will not //</span>
<a name="l09150"></a>09150 <span class="comment">// not generally work after the holes and concavities have been carved.      //</span>
<a name="l09151"></a>09151 <span class="comment">//                                                                           //</span>
<a name="l09153"></a>09153 <span class="comment"></span>
<a name="l09154"></a>09154 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::locatesub(point searchpt,
<a name="l09155"></a>09155   face* searchsh, <span class="keywordtype">int</span> stopatseg, REAL epspp)
<a name="l09156"></a>09156 {
<a name="l09157"></a>09157   face backtracksh, spinsh, checkedge;
<a name="l09158"></a>09158   point forg, fdest, fapex;
<a name="l09159"></a>09159   REAL orgori, destori;
<a name="l09160"></a>09160   REAL ori, sign;
<a name="l09161"></a>09161   <span class="keywordtype">int</span> moveleft, i;
<a name="l09162"></a>09162 
<a name="l09163"></a>09163   <span class="keywordflow">if</span> (searchsh-&gt;sh == dummysh) {
<a name="l09164"></a>09164     searchsh-&gt;shver = 0;
<a name="l09165"></a>09165     spivotself(*searchsh);
<a name="l09166"></a>09166 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09167"></a>09167 <span class="preprocessor"></span>    assert(searchsh-&gt;sh != dummysh);
<a name="l09168"></a>09168 <span class="preprocessor">#endif</span>
<a name="l09169"></a>09169 <span class="preprocessor"></span>  }
<a name="l09170"></a>09170   <span class="comment">// Find the sign to simulate that abovepoint is &#39;above&#39; the facet.</span>
<a name="l09171"></a>09171   adjustedgering(*searchsh, CCW);
<a name="l09172"></a>09172   forg = sorg(*searchsh);
<a name="l09173"></a>09173   fdest = sdest(*searchsh);
<a name="l09174"></a>09174   fapex = sapex(*searchsh);
<a name="l09175"></a>09175   ori = orient3d(forg, fdest, fapex, abovepoint);
<a name="l09176"></a>09176   sign = ori &gt; 0.0 ? -1 : 1;
<a name="l09177"></a>09177 
<a name="l09178"></a>09178   <span class="comment">// Orient &#39;searchsh&#39; so that &#39;searchpt&#39; is below it (i.e., searchpt has</span>
<a name="l09179"></a>09179   <span class="comment">//   CCW orientation with respect to searchsh in plane).  Such edge</span>
<a name="l09180"></a>09180   <span class="comment">//   should always exist. Save it as (forg, fdest).</span>
<a name="l09181"></a>09181   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l09182"></a>09182     forg = sorg(*searchsh);
<a name="l09183"></a>09183     fdest = sdest(*searchsh);
<a name="l09184"></a>09184     ori = orient3d(forg, fdest, abovepoint, searchpt) * sign;
<a name="l09185"></a>09185     <span class="keywordflow">if</span> (ori &gt; 0.0) <span class="keywordflow">break</span>;
<a name="l09186"></a>09186     senextself(*searchsh);
<a name="l09187"></a>09187   }
<a name="l09188"></a>09188 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09189"></a>09189 <span class="preprocessor"></span>  assert(i &lt; 3);
<a name="l09190"></a>09190 <span class="preprocessor">#endif</span>
<a name="l09191"></a>09191 <span class="preprocessor"></span>
<a name="l09192"></a>09192   <span class="keywordflow">while</span> (1) {
<a name="l09193"></a>09193     fapex = sapex(*searchsh);
<a name="l09194"></a>09194     <span class="comment">// Check whether the apex is the point we seek.</span>
<a name="l09195"></a>09195     <span class="keywordflow">if</span> (fapex[0] == searchpt[0] &amp;&amp; fapex[1] == searchpt[1] &amp;&amp;
<a name="l09196"></a>09196         fapex[2] == searchpt[2]) {
<a name="l09197"></a>09197       senext2self(*searchsh);
<a name="l09198"></a>09198       <span class="keywordflow">return</span> ONVERTEX;
<a name="l09199"></a>09199     }
<a name="l09200"></a>09200     <span class="comment">// Does the point lie on the other side of the line defined by the</span>
<a name="l09201"></a>09201     <span class="comment">//   triangle edge opposite the triangle&#39;s destination?</span>
<a name="l09202"></a>09202     destori = orient3d(forg, fapex, abovepoint, searchpt) * sign;
<a name="l09203"></a>09203     <span class="keywordflow">if</span> (epspp &gt; 0.0) {
<a name="l09204"></a>09204       <span class="keywordflow">if</span> (iscoplanar(forg, fapex, abovepoint, searchpt, destori, epspp)) {
<a name="l09205"></a>09205         destori = 0.0;
<a name="l09206"></a>09206       }
<a name="l09207"></a>09207     }
<a name="l09208"></a>09208     <span class="comment">// Does the point lie on the other side of the line defined by the</span>
<a name="l09209"></a>09209     <span class="comment">//   triangle edge opposite the triangle&#39;s origin?</span>
<a name="l09210"></a>09210     orgori = orient3d(fapex, fdest, abovepoint, searchpt) * sign;
<a name="l09211"></a>09211     <span class="keywordflow">if</span> (epspp &gt; 0.0) {
<a name="l09212"></a>09212       <span class="keywordflow">if</span> (iscoplanar(fapex, fdest, abovepoint, searchpt, orgori, epspp)) {
<a name="l09213"></a>09213         orgori = 0.0;
<a name="l09214"></a>09214       }
<a name="l09215"></a>09215     }
<a name="l09216"></a>09216     <span class="keywordflow">if</span> (destori &gt; 0.0) {
<a name="l09217"></a>09217       moveleft = 1;
<a name="l09218"></a>09218     } <span class="keywordflow">else</span> {
<a name="l09219"></a>09219       <span class="keywordflow">if</span> (orgori &gt; 0.0) {
<a name="l09220"></a>09220         moveleft = 0;
<a name="l09221"></a>09221       } <span class="keywordflow">else</span> {
<a name="l09222"></a>09222         <span class="comment">// The point must be on the boundary of or inside this triangle.</span>
<a name="l09223"></a>09223         <span class="keywordflow">if</span> (destori == 0.0) {
<a name="l09224"></a>09224           senext2self(*searchsh);
<a name="l09225"></a>09225           <span class="keywordflow">return</span> ONEDGE;
<a name="l09226"></a>09226         }
<a name="l09227"></a>09227         <span class="keywordflow">if</span> (orgori == 0.0) {
<a name="l09228"></a>09228           senextself(*searchsh);
<a name="l09229"></a>09229           <span class="keywordflow">return</span> ONEDGE;
<a name="l09230"></a>09230         }
<a name="l09231"></a>09231         <span class="keywordflow">return</span> ONFACE;
<a name="l09232"></a>09232       }
<a name="l09233"></a>09233     }
<a name="l09234"></a>09234     <span class="comment">// Move to another triangle.  Leave a trace `backtracksh&#39; in case</span>
<a name="l09235"></a>09235     <span class="comment">//   walking off a boundary of the triangulation.</span>
<a name="l09236"></a>09236     <span class="keywordflow">if</span> (moveleft) {
<a name="l09237"></a>09237       senext2(*searchsh, backtracksh);
<a name="l09238"></a>09238       fdest = fapex;
<a name="l09239"></a>09239     } <span class="keywordflow">else</span> {
<a name="l09240"></a>09240       senext(*searchsh, backtracksh);
<a name="l09241"></a>09241       forg = fapex;
<a name="l09242"></a>09242     }
<a name="l09243"></a>09243     <span class="comment">// Check if we meet a segment.</span>
<a name="l09244"></a>09244     sspivot(backtracksh, checkedge);
<a name="l09245"></a>09245     <span class="keywordflow">if</span> (checkedge.sh != dummysh) {
<a name="l09246"></a>09246       <span class="keywordflow">if</span> (stopatseg) {
<a name="l09247"></a>09247         <span class="comment">// The flag indicates we should not cross a segment. Stop.</span>
<a name="l09248"></a>09248         *searchsh = backtracksh;
<a name="l09249"></a>09249         <span class="keywordflow">return</span> OUTSIDE;
<a name="l09250"></a>09250       }
<a name="l09251"></a>09251       <span class="comment">// Try to walk through a segment. We need to find a coplanar subface</span>
<a name="l09252"></a>09252       <span class="comment">//   sharing this segment to get into.</span>
<a name="l09253"></a>09253       spinsh = backtracksh;
<a name="l09254"></a>09254       <span class="keywordflow">do</span> {
<a name="l09255"></a>09255         spivotself(spinsh);
<a name="l09256"></a>09256         <span class="keywordflow">if</span> (spinsh.sh == backtracksh.sh) {
<a name="l09257"></a>09257           <span class="comment">// Turn back, no coplanar subface is found.</span>
<a name="l09258"></a>09258           <span class="keywordflow">break</span>;
<a name="l09259"></a>09259         }
<a name="l09260"></a>09260         <span class="comment">// Are they belong to the same facet.</span>
<a name="l09261"></a>09261         <span class="keywordflow">if</span> (shellmark(spinsh) == shellmark(backtracksh)) {
<a name="l09262"></a>09262           <span class="comment">// Find a coplanar subface. Walk into it.</span>
<a name="l09263"></a>09263           *searchsh = spinsh;
<a name="l09264"></a>09264           <span class="keywordflow">break</span>;
<a name="l09265"></a>09265         }
<a name="l09266"></a>09266         <span class="comment">// Are they (nearly) coplanar?</span>
<a name="l09267"></a>09267         ori = orient3d(forg, fdest, sapex(backtracksh), sapex(spinsh));
<a name="l09268"></a>09268         <span class="keywordflow">if</span> (iscoplanar(forg, fdest, sapex(backtracksh), sapex(spinsh), ori,
<a name="l09269"></a>09269                        b-&gt;epsilon)) {
<a name="l09270"></a>09270           <span class="comment">// Find a coplanar subface. Walk into it.</span>
<a name="l09271"></a>09271           *searchsh = spinsh;
<a name="l09272"></a>09272           <span class="keywordflow">break</span>;
<a name="l09273"></a>09273         }
<a name="l09274"></a>09274       } <span class="keywordflow">while</span> (spinsh.sh != backtracksh.sh);
<a name="l09275"></a>09275     } <span class="keywordflow">else</span> {
<a name="l09276"></a>09276       spivot(backtracksh, *searchsh);
<a name="l09277"></a>09277     }
<a name="l09278"></a>09278     <span class="comment">// Check for walking right out of the triangulation.</span>
<a name="l09279"></a>09279     <span class="keywordflow">if</span> ((searchsh-&gt;sh == dummysh) || (searchsh-&gt;sh == backtracksh.sh)) {
<a name="l09280"></a>09280       <span class="comment">// Go back to the last triangle.</span>
<a name="l09281"></a>09281       *searchsh = backtracksh;
<a name="l09282"></a>09282       <span class="keywordflow">return</span> OUTSIDE;
<a name="l09283"></a>09283     }
<a name="l09284"></a>09284     <span class="comment">// To keep the same orientation wrt abovepoint.</span>
<a name="l09285"></a>09285     <span class="keywordflow">if</span> (sorg(*searchsh) != forg) sesymself(*searchsh);
<a name="l09286"></a>09286 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09287"></a>09287 <span class="preprocessor"></span>    assert((sorg(*searchsh) == forg) &amp;&amp; (sdest(*searchsh) == fdest));
<a name="l09288"></a>09288 <span class="preprocessor">#endif</span>
<a name="l09289"></a>09289 <span class="preprocessor"></span>  }
<a name="l09290"></a>09290 }
<a name="l09291"></a>09291 
<a name="l09293"></a>09293 <span class="comment">//                                                                           //</span>
<a name="l09294"></a>09294 <span class="comment">// adjustlocatesub()    Adjust the precise location of a vertex.             //</span>
<a name="l09295"></a>09295 <span class="comment">//                                                                           //</span>
<a name="l09296"></a>09296 <span class="comment">// &#39;precise&#39; is the precise location (returned from locatesub()) of &#39;searcht&#39;//</span>
<a name="l09297"></a>09297 <span class="comment">// with respect to &#39;searchsh&#39;. &#39;epspp&#39; is the given relative tolerance.      //</span>
<a name="l09298"></a>09298 <span class="comment">//                                                                           //</span>
<a name="l09299"></a>09299 <span class="comment">// This routine re-evaluates the orientations of &#39;searchpt&#39; with respect to  //</span>
<a name="l09300"></a>09300 <span class="comment">// the three edges of &#39;searchsh&#39;. Detects the collinearities by additinal    //</span>
<a name="l09301"></a>09301 <span class="comment">// tests based on the given tolerance. If &#39;precise&#39; is ONEDGE, one can save  //</span>
<a name="l09302"></a>09302 <span class="comment">// one orientation test for the current edge of &#39;searchsh&#39;.                  //</span>
<a name="l09303"></a>09303 <span class="comment">//                                                                           //</span>
<a name="l09304"></a>09304 <span class="comment">// On completion, &#39;searchsh&#39; is a subface contains &#39;searchpt&#39;. The returned  //</span>
<a name="l09305"></a>09305 <span class="comment">// value indicates one of the following cases:                               //</span>
<a name="l09306"></a>09306 <span class="comment">//   - Returns ONVERTEX if the point lies on an existing vertex. &#39;searchsh&#39;  //</span>
<a name="l09307"></a>09307 <span class="comment">//     is a handle whose origin is the existing vertex.                      //</span>
<a name="l09308"></a>09308 <span class="comment">//   - Returns ONEDGE if the point lies on a mesh edge.  &#39;searchsh&#39; is a     //</span>
<a name="l09309"></a>09309 <span class="comment">//     handle whose primary edge is the edge on which the point lies.        //</span>
<a name="l09310"></a>09310 <span class="comment">//   - Returns ONFACE if the point lies strictly within a subface.           //</span>
<a name="l09311"></a>09311 <span class="comment">//     &#39;searchsh&#39; is a handle on which the point lies.                       //</span>
<a name="l09312"></a>09312 <span class="comment">//   - Returns OUTSIDE if the point lies outside &#39;searchsh&#39;.                 //</span>
<a name="l09313"></a>09313 <span class="comment">//                                                                           //</span>
<a name="l09315"></a>09315 <span class="comment"></span>
<a name="l09316"></a>09316 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::
<a name="l09317"></a>09317 adjustlocatesub(point searchpt, face* searchsh, <span class="keyword">enum</span> locateresult precise,
<a name="l09318"></a>09318                 REAL epspp)
<a name="l09319"></a>09319 {
<a name="l09320"></a>09320   point pa, pb, pc;
<a name="l09321"></a>09321   <span class="keywordtype">bool</span> s1, s2, s3;
<a name="l09322"></a>09322 
<a name="l09323"></a>09323   pa = sorg(*searchsh);
<a name="l09324"></a>09324   pb = sdest(*searchsh);
<a name="l09325"></a>09325   pc = sapex(*searchsh);
<a name="l09326"></a>09326 
<a name="l09327"></a>09327   <span class="keywordflow">if</span> (precise == ONEDGE) {
<a name="l09328"></a>09328     s1 = <span class="keyword">true</span>;
<a name="l09329"></a>09329   } <span class="keywordflow">else</span> {
<a name="l09330"></a>09330     s1 = iscollinear(pa, pb, searchpt, epspp);
<a name="l09331"></a>09331   }
<a name="l09332"></a>09332   s2 = iscollinear(pb, pc, searchpt, epspp);
<a name="l09333"></a>09333   s3 = iscollinear(pc, pa, searchpt, epspp);
<a name="l09334"></a>09334   <span class="keywordflow">if</span> (s1) {
<a name="l09335"></a>09335     <span class="keywordflow">if</span> (s2) {
<a name="l09336"></a>09336       <span class="comment">// on vertex pb.</span>
<a name="l09337"></a>09337 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09338"></a>09338 <span class="preprocessor"></span>      assert(!s3);
<a name="l09339"></a>09339 <span class="preprocessor">#endif</span>
<a name="l09340"></a>09340 <span class="preprocessor"></span>      senextself(*searchsh);
<a name="l09341"></a>09341       <span class="keywordflow">return</span> ONVERTEX;
<a name="l09342"></a>09342     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s3) {
<a name="l09343"></a>09343       <span class="comment">// on vertex pa.</span>
<a name="l09344"></a>09344       <span class="keywordflow">return</span> ONVERTEX;
<a name="l09345"></a>09345     } <span class="keywordflow">else</span> {
<a name="l09346"></a>09346       <span class="comment">// on edge pa-&gt;pb.</span>
<a name="l09347"></a>09347       <span class="keywordflow">return</span> ONEDGE;
<a name="l09348"></a>09348     }
<a name="l09349"></a>09349   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s2) {
<a name="l09350"></a>09350     <span class="keywordflow">if</span> (s3) {
<a name="l09351"></a>09351       <span class="comment">// on vertex pc.</span>
<a name="l09352"></a>09352       senext2self(*searchsh);
<a name="l09353"></a>09353       <span class="keywordflow">return</span> ONVERTEX;
<a name="l09354"></a>09354     } <span class="keywordflow">else</span> {
<a name="l09355"></a>09355       <span class="comment">// on edge pb-&gt;pc.</span>
<a name="l09356"></a>09356       senextself(*searchsh);
<a name="l09357"></a>09357       <span class="keywordflow">return</span> ONEDGE;
<a name="l09358"></a>09358     }
<a name="l09359"></a>09359   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s3) {
<a name="l09360"></a>09360     <span class="comment">// on edge pc-&gt;pa.</span>
<a name="l09361"></a>09361     senext2self(*searchsh);
<a name="l09362"></a>09362     <span class="keywordflow">return</span> ONEDGE;
<a name="l09363"></a>09363   } <span class="keywordflow">else</span> {
<a name="l09364"></a>09364     <span class="keywordflow">return</span> precise;
<a name="l09365"></a>09365   }
<a name="l09366"></a>09366 }
<a name="l09367"></a>09367 
<a name="l09369"></a>09369 <span class="comment">//                                                                           //</span>
<a name="l09370"></a>09370 <span class="comment">// locateseg()    Find a point in subsegments.                               //</span>
<a name="l09371"></a>09371 <span class="comment">//                                                                           //</span>
<a name="l09372"></a>09372 <span class="comment">// Searching begins from the input &#39;searchseg&#39;, it should be a subsegment of //</span>
<a name="l09373"></a>09373 <span class="comment">// the whole segment.                                                        //</span>
<a name="l09374"></a>09374 <span class="comment">//                                                                           //</span>
<a name="l09375"></a>09375 <span class="comment">// On completion, &#39;searchseg&#39; is a subsegment that contains &#39;searchpt&#39;.      //</span>
<a name="l09376"></a>09376 <span class="comment">//   - Returns ONVERTEX if the point lies on an existing vertex. &#39;searchseg&#39; //</span>
<a name="l09377"></a>09377 <span class="comment">//     is a handle whose origin is the existing vertex.                      //</span>
<a name="l09378"></a>09378 <span class="comment">//   - Returns ONEDGE if the point lies inside &#39;searchseg&#39;.                  //</span>
<a name="l09379"></a>09379 <span class="comment">//   - Returns OUTSIDE if the point lies outside the segment.                //</span>
<a name="l09380"></a>09380 <span class="comment">//                                                                           //</span>
<a name="l09382"></a>09382 <span class="comment"></span>
<a name="l09383"></a>09383 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::
<a name="l09384"></a>09384 locateseg(point searchpt, face* searchseg)
<a name="l09385"></a>09385 {
<a name="l09386"></a>09386   face backtraceseg;
<a name="l09387"></a>09387   point pa, pb;
<a name="l09388"></a>09388   REAL dx, dy, dz;
<a name="l09389"></a>09389   <span class="keywordtype">int</span> moveleft;
<a name="l09390"></a>09390   <span class="keywordtype">int</span> i;
<a name="l09391"></a>09391 
<a name="l09392"></a>09392   moveleft = 0;
<a name="l09393"></a>09393   <span class="keywordflow">while</span> (1) {
<a name="l09394"></a>09394     searchseg-&gt;shver = 0;
<a name="l09395"></a>09395     pa = sorg(*searchseg);
<a name="l09396"></a>09396     pb = sdest(*searchseg);
<a name="l09397"></a>09397     <span class="comment">// Find the biggest difference in x, y, and z coordinates of a and b.</span>
<a name="l09398"></a>09398     dx = fabs(pb[0] - pa[0]);
<a name="l09399"></a>09399     dy = fabs(pb[1] - pa[1]);
<a name="l09400"></a>09400     dz = fabs(pb[2] - pa[2]);
<a name="l09401"></a>09401     <span class="keywordflow">if</span> (dx &gt; dy) {
<a name="l09402"></a>09402       <span class="keywordflow">if</span> (dx &gt; dz) {
<a name="l09403"></a>09403         i = 0;
<a name="l09404"></a>09404       } <span class="keywordflow">else</span> {
<a name="l09405"></a>09405         i = 2;
<a name="l09406"></a>09406       }
<a name="l09407"></a>09407     } <span class="keywordflow">else</span> {
<a name="l09408"></a>09408       <span class="keywordflow">if</span> (dy &gt; dz) {
<a name="l09409"></a>09409         i = 1;
<a name="l09410"></a>09410       } <span class="keywordflow">else</span> {
<a name="l09411"></a>09411         i = 2;
<a name="l09412"></a>09412       }
<a name="l09413"></a>09413     }
<a name="l09414"></a>09414     <span class="keywordflow">if</span> (pa[i] &lt; pb[i]) {
<a name="l09415"></a>09415       <span class="keywordflow">if</span> (searchpt[i] &lt; pa[i]) {
<a name="l09416"></a>09416         moveleft = 1;
<a name="l09417"></a>09417       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (searchpt[i] &gt; pa[i]) {
<a name="l09418"></a>09418         <span class="keywordflow">if</span> (searchpt[i] &lt; pb[i]) {
<a name="l09419"></a>09419           <span class="keywordflow">return</span> ONEDGE;
<a name="l09420"></a>09420         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (searchpt[i] &gt; pb[i]) {
<a name="l09421"></a>09421           moveleft = 0;
<a name="l09422"></a>09422         } <span class="keywordflow">else</span> {
<a name="l09423"></a>09423 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09424"></a>09424 <span class="preprocessor"></span>          assert(searchpt[i] == pb[i]);
<a name="l09425"></a>09425 <span class="preprocessor">#endif</span>
<a name="l09426"></a>09426 <span class="preprocessor"></span>          sesymself(*searchseg);
<a name="l09427"></a>09427           <span class="keywordflow">return</span> ONVERTEX;
<a name="l09428"></a>09428         }
<a name="l09429"></a>09429       } <span class="keywordflow">else</span> {
<a name="l09430"></a>09430 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09431"></a>09431 <span class="preprocessor"></span>        assert(searchpt[i] == pa[i]);
<a name="l09432"></a>09432 <span class="preprocessor">#endif</span>
<a name="l09433"></a>09433 <span class="preprocessor"></span>        <span class="keywordflow">return</span> ONVERTEX;
<a name="l09434"></a>09434       }
<a name="l09435"></a>09435     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pa[i] &gt; pb[i]) {
<a name="l09436"></a>09436       <span class="keywordflow">if</span> (searchpt[i] &lt; pb[i]) {
<a name="l09437"></a>09437         moveleft = 0;
<a name="l09438"></a>09438       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (searchpt[i] &gt; pb[i]) {
<a name="l09439"></a>09439         <span class="keywordflow">if</span> (searchpt[i] &lt; pa[i]) {
<a name="l09440"></a>09440           <span class="keywordflow">return</span> ONEDGE;
<a name="l09441"></a>09441         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (searchpt[i] &gt; pa[i]) {
<a name="l09442"></a>09442           moveleft = 1;
<a name="l09443"></a>09443         } <span class="keywordflow">else</span> {
<a name="l09444"></a>09444 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09445"></a>09445 <span class="preprocessor"></span>          assert(searchpt[i] == pa[i]);
<a name="l09446"></a>09446 <span class="preprocessor">#endif</span>
<a name="l09447"></a>09447 <span class="preprocessor"></span>          <span class="keywordflow">return</span> ONVERTEX;
<a name="l09448"></a>09448         }
<a name="l09449"></a>09449       } <span class="keywordflow">else</span> {
<a name="l09450"></a>09450 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09451"></a>09451 <span class="preprocessor"></span>        assert(searchpt[i] == pb[i]);
<a name="l09452"></a>09452 <span class="preprocessor">#endif</span>
<a name="l09453"></a>09453 <span class="preprocessor"></span>        sesymself(*searchseg);
<a name="l09454"></a>09454         <span class="keywordflow">return</span> ONVERTEX;
<a name="l09455"></a>09455       }
<a name="l09456"></a>09456     }
<a name="l09457"></a>09457     backtraceseg = *searchseg;
<a name="l09458"></a>09458     <span class="keywordflow">if</span> (moveleft) {
<a name="l09459"></a>09459       senext2self(*searchseg);
<a name="l09460"></a>09460     } <span class="keywordflow">else</span> {
<a name="l09461"></a>09461       senextself(*searchseg);
<a name="l09462"></a>09462     }
<a name="l09463"></a>09463     spivotself(*searchseg);
<a name="l09464"></a>09464     <span class="keywordflow">if</span> (searchseg-&gt;sh == dummysh) {
<a name="l09465"></a>09465       *searchseg = backtraceseg;
<a name="l09466"></a>09466       <span class="keywordflow">break</span>;
<a name="l09467"></a>09467     }
<a name="l09468"></a>09468   }
<a name="l09469"></a>09469 
<a name="l09470"></a>09470   <span class="keywordflow">return</span> OUTSIDE;
<a name="l09471"></a>09471 }
<a name="l09472"></a>09472 
<a name="l09474"></a>09474 <span class="comment">//                                                                           //</span>
<a name="l09475"></a>09475 <span class="comment">// adjustlocateseg()    Adjust the precise location of a vertex on segment.  //</span>
<a name="l09476"></a>09476 <span class="comment">//                                                                           //</span>
<a name="l09477"></a>09477 <span class="comment">// &#39;searchpt&#39; is either inside or ouside the segment &#39;searchseg&#39;. It will be //</span>
<a name="l09478"></a>09478 <span class="comment">// adjusted to on vertex if it is very close to an endpoint of &#39;searchseg&#39;.  //</span>
<a name="l09479"></a>09479 <span class="comment">// &#39;epspp&#39; is the given relative tolerance.                                  //</span>
<a name="l09480"></a>09480 <span class="comment">//                                                                           //</span>
<a name="l09482"></a>09482 <span class="comment"></span>
<a name="l09483"></a>09483 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::
<a name="l09484"></a>09484 adjustlocateseg(point searchpt, face* searchseg, <span class="keyword">enum</span> locateresult precise,
<a name="l09485"></a>09485                 REAL epspp)
<a name="l09486"></a>09486 {
<a name="l09487"></a>09487   point pa, pb;
<a name="l09488"></a>09488   REAL L, d, r;
<a name="l09489"></a>09489 
<a name="l09490"></a>09490   pa = sorg(*searchseg);
<a name="l09491"></a>09491   pb = sdest(*searchseg);
<a name="l09492"></a>09492   L = distance(pa, pb);
<a name="l09493"></a>09493 
<a name="l09494"></a>09494   <span class="comment">// Is searchpt approximate to pa?</span>
<a name="l09495"></a>09495   d = distance(pa, searchpt);
<a name="l09496"></a>09496   r = d / L;
<a name="l09497"></a>09497   <span class="keywordflow">if</span> (r &lt;= epspp) {
<a name="l09498"></a>09498     <span class="keywordflow">return</span> ONVERTEX;
<a name="l09499"></a>09499   }
<a name="l09500"></a>09500   <span class="comment">// Is searchpt approximate to pb?</span>
<a name="l09501"></a>09501   d = distance(pb, searchpt);
<a name="l09502"></a>09502   r = d / L;
<a name="l09503"></a>09503   <span class="keywordflow">if</span> (r &lt;= epspp) {
<a name="l09504"></a>09504     sesymself(*searchseg);
<a name="l09505"></a>09505     <span class="keywordflow">return</span> ONVERTEX;
<a name="l09506"></a>09506   }
<a name="l09507"></a>09507 
<a name="l09508"></a>09508   <span class="keywordflow">return</span> precise;
<a name="l09509"></a>09509 }
<a name="l09510"></a>09510 
<a name="l09511"></a>09511 <span class="comment">//</span>
<a name="l09512"></a>09512 <span class="comment">// End of point location routines</span>
<a name="l09513"></a>09513 <span class="comment">//</span>
<a name="l09514"></a>09514 
<a name="l09515"></a>09515 <span class="comment">//</span>
<a name="l09516"></a>09516 <span class="comment">// Begin of mesh transformation routines</span>
<a name="l09517"></a>09517 <span class="comment">//</span>
<a name="l09518"></a>09518 
<a name="l09520"></a>09520 <span class="comment">//                                                                           //</span>
<a name="l09521"></a>09521 <span class="comment">// Flip operations                                                           //</span>
<a name="l09522"></a>09522 <span class="comment">//                                                                           //</span>
<a name="l09523"></a>09523 <span class="comment">// If abc is a hull face, it is unflipable, and is locally Delaunay.  In the //</span>
<a name="l09524"></a>09524 <span class="comment">// following, we assume abc is an interior face, and the other tetrahedron   //</span>
<a name="l09525"></a>09525 <span class="comment">// adjoining at abc is bace.                                                 //</span>
<a name="l09526"></a>09526 <span class="comment">//                                                                           //</span>
<a name="l09527"></a>09527 <span class="comment">// If the convex hull CH of the set {a, b, c, d, e} only has four vertices,  //</span>
<a name="l09528"></a>09528 <span class="comment">// i.e., one vertex lies inside CH, then abc is unflipable, and is locally   //</span>
<a name="l09529"></a>09529 <span class="comment">// Delaunay. If CH is the vertex set itself, we have the following cases to  //</span>
<a name="l09530"></a>09530 <span class="comment">// determine whether abc is flipable or not.                                 //</span>
<a name="l09531"></a>09531 <span class="comment">//                                                                           //</span>
<a name="l09532"></a>09532 <span class="comment">// If no four points of {a, b, c, d, e} are coplanar, a 2-to-3 flip can be   //</span>
<a name="l09533"></a>09533 <span class="comment">// applied to abc if the edge de crosses the triangle abc; a 3-to-2 flip can //</span>
<a name="l09534"></a>09534 <span class="comment">// be applied to abc if ab crosses cde, and abde exists, otherwise, face abc //</span>
<a name="l09535"></a>09535 <span class="comment">// is unflipable, i.e., the tetrahedron abde is not present.                 //</span>
<a name="l09536"></a>09536 <span class="comment">//                                                                           //</span>
<a name="l09537"></a>09537 <span class="comment">// If four points of {a, b, c, d, e} are coplanar (two faces are coplanar).  //</span>
<a name="l09538"></a>09538 <span class="comment">// Assume faces abd and abe are coplanar (it is impossible be abc). If a, b, //</span>
<a name="l09539"></a>09539 <span class="comment">// d, e form a non-convex quadrilateral, then abc is unflipable, furthermore,//</span>
<a name="l09540"></a>09540 <span class="comment">// it is locally Delaunay.  Assume they are convex quadrilateral, if abd and //</span>
<a name="l09541"></a>09541 <span class="comment">// abe are hull faces, a 2-to-2 flip can be applied to abc;  if abd and abe  //</span>
<a name="l09542"></a>09542 <span class="comment">// are interior faces,  assume two tetrahedra adjoining abd and abe at the   //</span>
<a name="l09543"></a>09543 <span class="comment">// opposite sides are abdg and abef, respectively.  If g = f, a 4-to-4 flip  //</span>
<a name="l09544"></a>09544 <span class="comment">// can be applied to abc, otherwise, abc is unflipable.                      //</span>
<a name="l09545"></a>09545 <span class="comment">//                                                                           //</span>
<a name="l09546"></a>09546 <span class="comment">// There are other cases which can cause abc unflipable. If abc is a subface,//</span>
<a name="l09547"></a>09547 <span class="comment">// a 2-to-3 flip is forbidden;  if ab is a subsegment, flips 3-to-2, 2-to-2, //</span>
<a name="l09548"></a>09548 <span class="comment">// and 4-to-4 are forbidden.                                                 //</span>
<a name="l09549"></a>09549 <span class="comment">//                                                                           //</span>
<a name="l09551"></a>09551 <span class="comment"></span>
<a name="l09553"></a>09553 <span class="comment">//                                                                           //</span>
<a name="l09554"></a>09554 <span class="comment">// categorizeface()    Determine the flip type of a given face.              //</span>
<a name="l09555"></a>09555 <span class="comment">//                                                                           //</span>
<a name="l09556"></a>09556 <span class="comment">// On input, &#39;horiz&#39; represents the face abc we want to flip (imagine it is  //</span>
<a name="l09557"></a>09557 <span class="comment">// parallel to the horizon).  Let the tet above it be abcd.                  //</span>
<a name="l09558"></a>09558 <span class="comment">//                                                                           //</span>
<a name="l09559"></a>09559 <span class="comment">// This routine determines the suitable type of flip operation for &#39;horiz&#39;.  //</span>
<a name="l09560"></a>09560 <span class="comment">//   - Returns T23 if a 2-to-3 flip is applicable. &#39;horiz&#39; is same as input. //</span>
<a name="l09561"></a>09561 <span class="comment">//   - Returns T32 if a 3-to-2 flip is applicable. &#39;horiz&#39; returns the edge  //</span>
<a name="l09562"></a>09562 <span class="comment">//     of abc which is the flipable.                                         //</span>
<a name="l09563"></a>09563 <span class="comment">//   - Returns T22 if a 2-to-2 or 4-to-4 flip is applicable. &#39;horiz&#39; returns //</span>
<a name="l09564"></a>09564 <span class="comment">//     the edge of abc which is flipable.                                    //</span>
<a name="l09565"></a>09565 <span class="comment">//   - Returns N32 indicates it is unflipable due to the absence of a tet.   //</span>
<a name="l09566"></a>09566 <span class="comment">//     &#39;horize&#39; returns the unflipable edge.                                 //</span>
<a name="l09567"></a>09567 <span class="comment">//   - Returns N40 indicates it is unflipable and is locally Delaunay.       //</span>
<a name="l09568"></a>09568 <span class="comment">//   - Returns FORBIDDENFACE indicates abc is a subface.                     //</span>
<a name="l09569"></a>09569 <span class="comment">//   - Returns FORBIDDENEDGE indicates the flipable edge of abc is a segment.//</span>
<a name="l09570"></a>09570 <span class="comment">//     &#39;horize&#39; returns the flipable edge.                                   //</span>
<a name="l09571"></a>09571 <span class="comment">//                                                                           //</span>
<a name="l09572"></a>09572 <span class="comment">// Given a face abc, with two adjoining tetrahedra abcd and bace.  If abc is //</span>
<a name="l09573"></a>09573 <span class="comment">// flipable, i.e., T23, T32, T22 or T44, its flip type can be determined by  //</span>
<a name="l09574"></a>09574 <span class="comment">// doing five orientation tests: two tests for determining that d, e lie on  //</span>
<a name="l09575"></a>09575 <span class="comment">// the different sides of abc, three tests for determining if the edge de    //</span>
<a name="l09576"></a>09576 <span class="comment">// intersects the face abc.  However, if we use the neighbor information of  //</span>
<a name="l09577"></a>09577 <span class="comment">// the mesh data structure, we can reduce the five orientation tests to at   //</span>
<a name="l09578"></a>09578 <span class="comment">// most three tests, that is, the two tests for determining whether d and e  //</span>
<a name="l09579"></a>09579 <span class="comment">// lie on the different sides of abc can be saved.                           //</span>
<a name="l09580"></a>09580 <span class="comment">//                                                                           //</span>
<a name="l09582"></a>09582 <span class="comment"></span>
<a name="l09583"></a>09583 <span class="keyword">enum</span> tetgenmesh::fliptype tetgenmesh::categorizeface(triface&amp; horiz)
<a name="l09584"></a>09584 {
<a name="l09585"></a>09585   triface symhoriz, casing;
<a name="l09586"></a>09586   face checksh, checkseg;
<a name="l09587"></a>09587   face cassh1, cassh2;
<a name="l09588"></a>09588   point pa, pb, pc, pd, pe, pf, pg;
<a name="l09589"></a>09589   point abdoppo, bcdoppo, cadoppo;
<a name="l09590"></a>09590   REAL ori1, ori2, ori3;
<a name="l09591"></a>09591   <span class="keywordtype">int</span> adjtet;
<a name="l09592"></a>09592 
<a name="l09593"></a>09593   sym(horiz, symhoriz);
<a name="l09594"></a>09594   <span class="keywordflow">if</span> (symhoriz.tet == dummytet) {
<a name="l09595"></a>09595     <span class="comment">// A hull face is unflipable and locally Delaunay.</span>
<a name="l09596"></a>09596     <span class="keywordflow">return</span> N40;
<a name="l09597"></a>09597   }
<a name="l09598"></a>09598 
<a name="l09599"></a>09599   adjustedgering(horiz, CCW);
<a name="l09600"></a>09600   findedge(&amp;symhoriz, dest(horiz), org(horiz));
<a name="l09601"></a>09601   pa = org(horiz);
<a name="l09602"></a>09602   pb = dest(horiz);
<a name="l09603"></a>09603   pc = apex(horiz);
<a name="l09604"></a>09604   pd = oppo(horiz);
<a name="l09605"></a>09605   pe = oppo(symhoriz);
<a name="l09606"></a>09606 
<a name="l09607"></a>09607   <span class="comment">// Find the number of adjacent tetrahedra of abc, which have d, e, and one</span>
<a name="l09608"></a>09608   <span class="comment">//   of corners of abc as their corners. This number can be 0, 1 and 2.</span>
<a name="l09609"></a>09609   abdoppo = bcdoppo = cadoppo = (point) NULL;
<a name="l09610"></a>09610   adjtet = 0;
<a name="l09611"></a>09611   fnext(horiz, casing); <span class="comment">// at edge &#39;ab&#39;.</span>
<a name="l09612"></a>09612   symself(casing);
<a name="l09613"></a>09613   <span class="keywordflow">if</span> (casing.tet != dummytet) {
<a name="l09614"></a>09614     abdoppo = oppo(casing);
<a name="l09615"></a>09615     <span class="keywordflow">if</span> (abdoppo == pe) adjtet++;
<a name="l09616"></a>09616   }
<a name="l09617"></a>09617   enextfnext(horiz, casing); <span class="comment">// at edge &#39;bc&#39;.</span>
<a name="l09618"></a>09618   symself(casing);
<a name="l09619"></a>09619   <span class="keywordflow">if</span> (casing.tet != dummytet) {
<a name="l09620"></a>09620     bcdoppo = oppo(casing);
<a name="l09621"></a>09621     <span class="keywordflow">if</span> (bcdoppo == pe) adjtet++;
<a name="l09622"></a>09622   }
<a name="l09623"></a>09623   enext2fnext(horiz, casing); <span class="comment">// at edge &#39;ca&#39;.</span>
<a name="l09624"></a>09624   symself(casing);
<a name="l09625"></a>09625   <span class="keywordflow">if</span> (casing.tet != dummytet) {
<a name="l09626"></a>09626     cadoppo = oppo(casing);
<a name="l09627"></a>09627     <span class="keywordflow">if</span> (cadoppo == pe) adjtet++;
<a name="l09628"></a>09628   }
<a name="l09629"></a>09629 
<a name="l09630"></a>09630   <span class="keywordflow">if</span> (adjtet == 0) {
<a name="l09631"></a>09631     <span class="comment">// No adjacent tetrahedron. Types T23, T22 and T44 are possible.</span>
<a name="l09632"></a>09632     ori1 = orient3d(pa, pb, pd, pe);
<a name="l09633"></a>09633     <span class="keywordflow">if</span> (checksubfaces &amp;&amp; ori1 != 0.0) {
<a name="l09634"></a>09634       <span class="comment">// Check if abd and abe are both boundary faces?</span>
<a name="l09635"></a>09635       fnext(horiz, casing);
<a name="l09636"></a>09636       tspivot(casing, cassh1);
<a name="l09637"></a>09637       fnext(symhoriz, casing);
<a name="l09638"></a>09638       tspivot(casing, cassh2);
<a name="l09639"></a>09639       <span class="keywordflow">if</span> ((cassh1.sh != dummysh) &amp;&amp; (cassh2.sh != dummysh)) {
<a name="l09640"></a>09640         <span class="comment">// abd and abe are both boundary faces. Check if ab is a segment.</span>
<a name="l09641"></a>09641         findedge(&amp;cassh1, pa, pb);
<a name="l09642"></a>09642         sspivot(cassh1, checkseg);
<a name="l09643"></a>09643         <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l09644"></a>09644           <span class="comment">// ab is not a segment - abd and abe belong to the same facet.</span>
<a name="l09645"></a>09645           <span class="comment">//   The four points are forced to be coplanar.</span>
<a name="l09646"></a>09646           ori1 = 0.0;
<a name="l09647"></a>09647         } <span class="keywordflow">else</span> {
<a name="l09648"></a>09648           <span class="comment">// ab is a segment - abd and abe belong to two different facets.</span>
<a name="l09649"></a>09649           <span class="comment">//   In principle, a, b, c and d can form a tetrahedron (since</span>
<a name="l09650"></a>09650           <span class="comment">//   ori1 != 0.0).  However, we should avoid to create a very</span>
<a name="l09651"></a>09651           <span class="comment">//   flat one which may form a sequence of extremely badly-shaped</span>
<a name="l09652"></a>09652           <span class="comment">//   or even wrong orientational tets. Test with a larger epsilon.</span>
<a name="l09653"></a>09653           <span class="keywordflow">if</span> (iscoplanar(pa, pb, pd, pe, ori1, b-&gt;epsilon * 1e+2)) ori1 = 0.0;
<a name="l09654"></a>09654         }
<a name="l09655"></a>09655       } <span class="keywordflow">else</span> {
<a name="l09656"></a>09656         <span class="comment">// abd and abe are not both boundary faces. Check if abd and bae</span>
<a name="l09657"></a>09657         <span class="comment">//   are approximately coplanar with respect to the epsilon.</span>
<a name="l09658"></a>09658         <span class="keywordflow">if</span> (iscoplanar(pa, pb, pd, pe, ori1, b-&gt;epsilon)) ori1 = 0.0;
<a name="l09659"></a>09659       }
<a name="l09660"></a>09660     }
<a name="l09661"></a>09661     <span class="keywordflow">if</span> (ori1 &lt; 0.0) {
<a name="l09662"></a>09662       <span class="comment">// e lies above abd, unflipable, tet abde is not present.</span>
<a name="l09663"></a>09663 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09664"></a>09664 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (!nonconvex) {
<a name="l09665"></a>09665         <span class="comment">// abd and abe should not be hull faces, check it.</span>
<a name="l09666"></a>09666         fnext(horiz, casing);
<a name="l09667"></a>09667         symself(casing);
<a name="l09668"></a>09668         assert(casing.tet != dummytet);
<a name="l09669"></a>09669         fnext(symhoriz, casing);
<a name="l09670"></a>09670         symself(casing);
<a name="l09671"></a>09671         assert(casing.tet != dummytet);
<a name="l09672"></a>09672       }
<a name="l09673"></a>09673 <span class="preprocessor">#endif</span>
<a name="l09674"></a>09674 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (checksubfaces) {
<a name="l09675"></a>09675         <span class="comment">// The nonconvexbility may be casued by existing an subsegment.</span>
<a name="l09676"></a>09676         tsspivot(&amp;horiz, &amp;checkseg);
<a name="l09677"></a>09677         <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l09678"></a>09678           <span class="keywordflow">return</span> FORBIDDENEDGE;
<a name="l09679"></a>09679         }
<a name="l09680"></a>09680       }
<a name="l09681"></a>09681       <span class="keywordflow">return</span> N32;
<a name="l09682"></a>09682     }
<a name="l09683"></a>09683     ori2 = orient3d(pb, pc, pd, pe);
<a name="l09684"></a>09684     <span class="keywordflow">if</span> (checksubfaces &amp;&amp; ori2 != 0.0) {
<a name="l09685"></a>09685       <span class="comment">// Check if bcd and cbe are both boundary faces.</span>
<a name="l09686"></a>09686       enextfnext(horiz, casing);
<a name="l09687"></a>09687       tspivot(casing, cassh1);
<a name="l09688"></a>09688       enext2fnext(symhoriz, casing);
<a name="l09689"></a>09689       tspivot(casing, cassh2);
<a name="l09690"></a>09690       <span class="keywordflow">if</span> (cassh1.sh != dummysh &amp;&amp; cassh2.sh != dummysh) {
<a name="l09691"></a>09691         <span class="comment">// bcd and cbe are both boundary faces. Check if bc is a segment.</span>
<a name="l09692"></a>09692         findedge(&amp;cassh1, pb, pc);
<a name="l09693"></a>09693         sspivot(cassh1, checkseg);
<a name="l09694"></a>09694         <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l09695"></a>09695           <span class="comment">// bc is not a segment - bcd and cbe belong to the same facet.</span>
<a name="l09696"></a>09696           <span class="comment">//   The four points are forced to be coplanar.</span>
<a name="l09697"></a>09697           ori2 = 0.0;
<a name="l09698"></a>09698         } <span class="keywordflow">else</span> {
<a name="l09699"></a>09699           <span class="keywordflow">if</span> (iscoplanar(pb, pc, pd, pe, ori2, b-&gt;epsilon * 1e+2)) ori2 = 0.0;
<a name="l09700"></a>09700         }
<a name="l09701"></a>09701       } <span class="keywordflow">else</span> {
<a name="l09702"></a>09702         <span class="comment">//  bcd and cbe are not both boundary faces. Check if bcd and cbe</span>
<a name="l09703"></a>09703         <span class="comment">//   are approximately coplanar with respect to the epsilon.</span>
<a name="l09704"></a>09704         <span class="keywordflow">if</span> (iscoplanar(pb, pc, pd, pe, ori2, b-&gt;epsilon)) ori2 = 0.0;
<a name="l09705"></a>09705       }
<a name="l09706"></a>09706     }
<a name="l09707"></a>09707     <span class="keywordflow">if</span> (ori2 &lt; 0.0) {
<a name="l09708"></a>09708       <span class="comment">// e lies above bcd, unflipable, tet bcde is not present.</span>
<a name="l09709"></a>09709 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09710"></a>09710 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (!nonconvex) {
<a name="l09711"></a>09711         <span class="comment">// bcd and cbe should not be hull faces, check it.</span>
<a name="l09712"></a>09712         enextfnext(horiz, casing);
<a name="l09713"></a>09713         symself(casing);
<a name="l09714"></a>09714         assert(casing.tet != dummytet);
<a name="l09715"></a>09715         enext2fnext(symhoriz, casing);
<a name="l09716"></a>09716         symself(casing);
<a name="l09717"></a>09717         assert(casing.tet != dummytet);
<a name="l09718"></a>09718       }
<a name="l09719"></a>09719 <span class="preprocessor">#endif</span>
<a name="l09720"></a>09720 <span class="preprocessor"></span>      enextself(horiz);
<a name="l09721"></a>09721       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l09722"></a>09722         <span class="comment">// The nonconvexbility may be casued by existing an subsegment.</span>
<a name="l09723"></a>09723         tsspivot(&amp;horiz, &amp;checkseg);
<a name="l09724"></a>09724         <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l09725"></a>09725           <span class="keywordflow">return</span> FORBIDDENEDGE;
<a name="l09726"></a>09726         }
<a name="l09727"></a>09727       }
<a name="l09728"></a>09728       <span class="keywordflow">return</span> N32;
<a name="l09729"></a>09729     }
<a name="l09730"></a>09730     ori3 = orient3d(pc, pa, pd, pe);
<a name="l09731"></a>09731     <span class="keywordflow">if</span> (checksubfaces &amp;&amp; ori3 != 0.0) {
<a name="l09732"></a>09732       <span class="comment">// Check if cad and ace are both boundary faces.</span>
<a name="l09733"></a>09733       enext2fnext(horiz, casing);
<a name="l09734"></a>09734       tspivot(casing, cassh1);
<a name="l09735"></a>09735       enextfnext(symhoriz, casing);
<a name="l09736"></a>09736       tspivot(casing, cassh2);
<a name="l09737"></a>09737       <span class="keywordflow">if</span> (cassh1.sh != dummysh &amp;&amp; cassh2.sh != dummysh) {
<a name="l09738"></a>09738         <span class="comment">// cad and ace are both boundary faces. Check if ca is a segment.</span>
<a name="l09739"></a>09739         findedge(&amp;cassh1, pc, pa);
<a name="l09740"></a>09740         sspivot(cassh1, checkseg);
<a name="l09741"></a>09741         <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l09742"></a>09742           <span class="comment">// ca is not a segment - cad and ace belong to the same facet.</span>
<a name="l09743"></a>09743           <span class="comment">//   The four points are forced to be coplanar.</span>
<a name="l09744"></a>09744           ori3 = 0.0;
<a name="l09745"></a>09745         } <span class="keywordflow">else</span> {
<a name="l09746"></a>09746           <span class="comment">// ca is a segment - cad and ace belong to two different facets.</span>
<a name="l09747"></a>09747           <span class="comment">//   In principle, c, a, d and e can form a tetrahedron (since</span>
<a name="l09748"></a>09748           <span class="comment">//   ori3 != 0.0). Use a larger eps to test if they&#39;re coplanar.</span>
<a name="l09749"></a>09749           <span class="keywordflow">if</span> (iscoplanar(pc, pa, pd, pe, ori3, b-&gt;epsilon * 1e+2)) ori3 = 0.0;
<a name="l09750"></a>09750         }
<a name="l09751"></a>09751       } <span class="keywordflow">else</span> {
<a name="l09752"></a>09752         <span class="comment">// cad and ace are not both boundary faces. Check if cad and ace</span>
<a name="l09753"></a>09753         <span class="comment">//   are approximately coplanar with respect to the epsilon.</span>
<a name="l09754"></a>09754         <span class="keywordflow">if</span> (iscoplanar(pc, pa, pd, pe, ori3, b-&gt;epsilon)) ori3 = 0.0;
<a name="l09755"></a>09755       }
<a name="l09756"></a>09756     }
<a name="l09757"></a>09757     <span class="keywordflow">if</span> (ori3 &lt; 0.0) {
<a name="l09758"></a>09758       <span class="comment">// e lies above cad, unflipable, tet cade is not present.</span>
<a name="l09759"></a>09759 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09760"></a>09760 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (!nonconvex) {
<a name="l09761"></a>09761         <span class="comment">// cad and ace should not be hull faces, check it.</span>
<a name="l09762"></a>09762         enext2fnext(horiz, casing);
<a name="l09763"></a>09763         symself(casing);
<a name="l09764"></a>09764         assert(casing.tet != dummytet);
<a name="l09765"></a>09765         enextfnext(symhoriz, casing);
<a name="l09766"></a>09766         symself(casing);
<a name="l09767"></a>09767         assert(casing.tet != dummytet);
<a name="l09768"></a>09768       }
<a name="l09769"></a>09769 <span class="preprocessor">#endif</span>
<a name="l09770"></a>09770 <span class="preprocessor"></span>      enext2self(horiz);
<a name="l09771"></a>09771       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l09772"></a>09772         <span class="comment">// The nonconvexbility may be casued by existing an subsegment.</span>
<a name="l09773"></a>09773         tsspivot(&amp;horiz, &amp;checkseg);
<a name="l09774"></a>09774         <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l09775"></a>09775           <span class="keywordflow">return</span> FORBIDDENEDGE;
<a name="l09776"></a>09776         }
<a name="l09777"></a>09777       }
<a name="l09778"></a>09778       <span class="keywordflow">return</span> N32;
<a name="l09779"></a>09779     }
<a name="l09780"></a>09780     <span class="keywordflow">if</span> (ori1 == 0.0) {
<a name="l09781"></a>09781       <span class="comment">// e is coplanar with abd.</span>
<a name="l09782"></a>09782       <span class="keywordflow">if</span> (ori2 * ori3 == 0.0) {
<a name="l09783"></a>09783         <span class="comment">// only one zero is possible.</span>
<a name="l09784"></a>09784         <span class="comment">// assert(!(ori2 == 0.0 &amp;&amp; ori3 == 0.0));</span>
<a name="l09785"></a>09785         <span class="comment">// Three points (d, e, and a or b) are collinear, abc is unflipable</span>
<a name="l09786"></a>09786         <span class="comment">//   and locally Delaunay.</span>
<a name="l09787"></a>09787         <span class="keywordflow">return</span> N40;
<a name="l09788"></a>09788       }
<a name="l09789"></a>09789     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori2 == 0.0) {
<a name="l09790"></a>09790       <span class="comment">// e is coplanar with bcd.</span>
<a name="l09791"></a>09791       <span class="keywordflow">if</span> (ori1 * ori3 == 0.0) {
<a name="l09792"></a>09792         <span class="comment">// only one zero is possible.</span>
<a name="l09793"></a>09793         <span class="comment">// assert(!(ori1 == 0.0 &amp;&amp; ori3 == 0.0));</span>
<a name="l09794"></a>09794         <span class="comment">// Three points (d, e, and b or c) are collinear, abc is unflipable</span>
<a name="l09795"></a>09795         <span class="comment">//   and locally Delaunay.</span>
<a name="l09796"></a>09796         <span class="keywordflow">return</span> N40;
<a name="l09797"></a>09797       }
<a name="l09798"></a>09798       <span class="comment">// Adjust &#39;horiz&#39; and &#39;symhoriz&#39; be the edge bc.</span>
<a name="l09799"></a>09799       enextself(horiz);
<a name="l09800"></a>09800       enext2self(symhoriz);
<a name="l09801"></a>09801     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori3 == 0.0) {
<a name="l09802"></a>09802       <span class="comment">// e is coplanar with cad.</span>
<a name="l09803"></a>09803       <span class="keywordflow">if</span> (ori1 * ori2 == 0.0) {
<a name="l09804"></a>09804         <span class="comment">// only one zero is possible.</span>
<a name="l09805"></a>09805         <span class="comment">// assert(!(ori1 == 0.0 &amp;&amp; ori2 == 0.0));</span>
<a name="l09806"></a>09806         <span class="comment">// Three points (d, e, and c or a) are collinear, abc is unflipable</span>
<a name="l09807"></a>09807         <span class="comment">//   and locally Delaunay.</span>
<a name="l09808"></a>09808         <span class="keywordflow">return</span> N40;
<a name="l09809"></a>09809       }
<a name="l09810"></a>09810       <span class="comment">// Adjust &#39;horiz&#39; and &#39;symhoriz&#39; be the edge ca.</span>
<a name="l09811"></a>09811       enext2self(horiz);
<a name="l09812"></a>09812       enextself(symhoriz);
<a name="l09813"></a>09813     } <span class="keywordflow">else</span> {
<a name="l09814"></a>09814       <span class="comment">// e lies below all three faces, flipable.</span>
<a name="l09815"></a>09815       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l09816"></a>09816         tspivot(horiz, checksh);
<a name="l09817"></a>09817         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l09818"></a>09818           <span class="comment">// To flip a subface is forbidden.</span>
<a name="l09819"></a>09819           <span class="keywordflow">return</span> FORBIDDENFACE;
<a name="l09820"></a>09820         }
<a name="l09821"></a>09821       }
<a name="l09822"></a>09822       <span class="keywordflow">return</span> T23;
<a name="l09823"></a>09823     }
<a name="l09824"></a>09824     <span class="comment">// Four points are coplanar, T22 or T44 is possible.</span>
<a name="l09825"></a>09825     <span class="keywordflow">if</span> (checksubfaces) {
<a name="l09826"></a>09826       tsspivot(&amp;horiz, &amp;checkseg);
<a name="l09827"></a>09827       <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l09828"></a>09828         <span class="comment">// To flip a subsegment is forbidden.</span>
<a name="l09829"></a>09829         <span class="keywordflow">return</span> FORBIDDENEDGE;
<a name="l09830"></a>09830       }
<a name="l09831"></a>09831       tspivot(horiz, checksh);
<a name="l09832"></a>09832       <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l09833"></a>09833         <span class="comment">// To flip a subface is forbidden.</span>
<a name="l09834"></a>09834         <span class="keywordflow">return</span> FORBIDDENFACE;
<a name="l09835"></a>09835       }
<a name="l09836"></a>09836     }
<a name="l09837"></a>09837     <span class="comment">// Assume the four coplanar points are a, b, d, e, abd and abe are two</span>
<a name="l09838"></a>09838     <span class="comment">//   coplanar faces. If both abd and abe are hull faces, flipable(T22).</span>
<a name="l09839"></a>09839     <span class="comment">//   If they are interior faces, get the opposite tetrahedra abdf and</span>
<a name="l09840"></a>09840     <span class="comment">//   abeg, if f = g, flipable (T44). Otherwise, unflipable.</span>
<a name="l09841"></a>09841     pf = pg = (point) NULL;
<a name="l09842"></a>09842     fnext(horiz, casing);
<a name="l09843"></a>09843     symself(casing);
<a name="l09844"></a>09844     <span class="keywordflow">if</span> (casing.tet != dummytet) {
<a name="l09845"></a>09845       pf = oppo(casing);
<a name="l09846"></a>09846     }
<a name="l09847"></a>09847     fnext(symhoriz, casing);
<a name="l09848"></a>09848     symself(casing);
<a name="l09849"></a>09849     <span class="keywordflow">if</span> (casing.tet != dummytet) {
<a name="l09850"></a>09850       pg = oppo(casing);
<a name="l09851"></a>09851     }
<a name="l09852"></a>09852     <span class="keywordflow">if</span> (pf == pg) {
<a name="l09853"></a>09853       <span class="comment">// Either T22 (pf == pg == NULL) or T44 (pf and pg) is possible.</span>
<a name="l09854"></a>09854       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l09855"></a>09855         <span class="comment">// Retreat the corner points a, b, and c.</span>
<a name="l09856"></a>09856         pa = org(horiz);
<a name="l09857"></a>09857         pb = dest(horiz);
<a name="l09858"></a>09858         pc = apex(horiz);
<a name="l09859"></a>09859         <span class="comment">// Be careful not to create an inverted tetrahedron. Check the case.</span>
<a name="l09860"></a>09860         ori1 = orient3d(pc, pd, pe, pa);
<a name="l09861"></a>09861         <span class="keywordflow">if</span> (ori1 &lt;= 0) <span class="keywordflow">return</span> N40;
<a name="l09862"></a>09862         ori1 = orient3d(pd, pc, pe, pb);
<a name="l09863"></a>09863         <span class="keywordflow">if</span> (ori1 &lt;= 0) <span class="keywordflow">return</span> N40;
<a name="l09864"></a>09864         <span class="keywordflow">if</span> (pf != (point) NULL) {
<a name="l09865"></a>09865           ori1 = orient3d(pd, pf, pe, pa);
<a name="l09866"></a>09866           <span class="keywordflow">if</span> (ori1 &lt;= 0) <span class="keywordflow">return</span> N40;
<a name="l09867"></a>09867           ori1 = orient3d(pf, pd, pe, pb);
<a name="l09868"></a>09868           <span class="keywordflow">if</span> (ori1 &lt;= 0) <span class="keywordflow">return</span> N40;
<a name="l09869"></a>09869         }
<a name="l09870"></a>09870       }
<a name="l09871"></a>09871       <span class="keywordflow">if</span> (pf == (point) NULL) {
<a name="l09872"></a>09872         <span class="comment">// abd and abe are hull faces, flipable.</span>
<a name="l09873"></a>09873         <span class="keywordflow">return</span> T22;
<a name="l09874"></a>09874       } <span class="keywordflow">else</span> {
<a name="l09875"></a>09875         <span class="comment">// abd and abe are interior faces, flipable.</span>
<a name="l09876"></a>09876 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09877"></a>09877 <span class="preprocessor"></span>        assert(pf != (point) NULL);
<a name="l09878"></a>09878 <span class="preprocessor">#endif</span>
<a name="l09879"></a>09879 <span class="preprocessor"></span>        <span class="keywordflow">return</span> T44;
<a name="l09880"></a>09880       }
<a name="l09881"></a>09881     } <span class="keywordflow">else</span> {
<a name="l09882"></a>09882       <span class="comment">// ab has more than four faces around it, unflipable.</span>
<a name="l09883"></a>09883       <span class="keywordflow">return</span> N32;
<a name="l09884"></a>09884     }
<a name="l09885"></a>09885   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adjtet == 1) {
<a name="l09886"></a>09886     <span class="comment">// One of its three edges is locally non-convex. Type T32 is possible.</span>
<a name="l09887"></a>09887     <span class="comment">// Adjust current configuration so that edge ab is non-convex.</span>
<a name="l09888"></a>09888     <span class="keywordflow">if</span> (bcdoppo == pe) {
<a name="l09889"></a>09889       <span class="comment">// Edge bc is non-convex. Adjust &#39;horiz&#39; and &#39;symhoriz&#39; be edge bc.</span>
<a name="l09890"></a>09890       enextself(horiz);
<a name="l09891"></a>09891       enext2self(symhoriz);
<a name="l09892"></a>09892       pa = org(horiz);
<a name="l09893"></a>09893       pb = dest(horiz);
<a name="l09894"></a>09894       pc = apex(horiz);
<a name="l09895"></a>09895     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (cadoppo == pe) {
<a name="l09896"></a>09896       <span class="comment">// Edge ca is non-convex. Adjust &#39;horiz&#39; and &#39;symhoriz&#39; be edge ca.</span>
<a name="l09897"></a>09897       enext2self(horiz);
<a name="l09898"></a>09898       enextself(symhoriz);
<a name="l09899"></a>09899       pa = org(horiz);
<a name="l09900"></a>09900       pb = dest(horiz);
<a name="l09901"></a>09901       pc = apex(horiz);
<a name="l09902"></a>09902     } <span class="keywordflow">else</span> {
<a name="l09903"></a>09903       <span class="comment">// Edge ab is non-convex.</span>
<a name="l09904"></a>09904 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l09905"></a>09905 <span class="preprocessor"></span>      assert(abdoppo == pe);
<a name="l09906"></a>09906 <span class="preprocessor">#endif</span>
<a name="l09907"></a>09907 <span class="preprocessor"></span>    } <span class="comment">// Now ab is the non-convex edge.</span>
<a name="l09908"></a>09908     <span class="comment">// In order to be flipable, ab should cross face cde. Check it.</span>
<a name="l09909"></a>09909     ori1 = orient3d(pc, pd, pe, pa);
<a name="l09910"></a>09910     <span class="keywordflow">if</span> (checksubfaces &amp;&amp; ori1 != 0.0) {
<a name="l09911"></a>09911       <span class="comment">// Check if cad and ace are both boundary faces.</span>
<a name="l09912"></a>09912       enext2fnext(horiz, casing);
<a name="l09913"></a>09913       tspivot(casing, cassh1);
<a name="l09914"></a>09914       enextfnext(symhoriz, casing);
<a name="l09915"></a>09915       tspivot(casing, cassh2);
<a name="l09916"></a>09916       <span class="keywordflow">if</span> (cassh1.sh != dummysh &amp;&amp; cassh2.sh != dummysh) {
<a name="l09917"></a>09917         <span class="comment">// cad and ace are both boundary faces. Check if ca is a segment.</span>
<a name="l09918"></a>09918         findedge(&amp;cassh1, pc, pa);
<a name="l09919"></a>09919         sspivot(cassh1, checkseg);
<a name="l09920"></a>09920         <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l09921"></a>09921           <span class="comment">// ca is not a segment. cad and ace belong to the same facet.</span>
<a name="l09922"></a>09922           <span class="comment">//   The four points are forced to be coplanar.</span>
<a name="l09923"></a>09923           ori1 = 0.0;
<a name="l09924"></a>09924         } <span class="keywordflow">else</span> {
<a name="l09925"></a>09925           <span class="comment">// ca is a segment. cad and ace belong to different facets.</span>
<a name="l09926"></a>09926           <span class="comment">//   In principle, c, d, e, and a can form a tetrahedron (since</span>
<a name="l09927"></a>09927           <span class="comment">//   ori1 != 0.0).  However, we should avoid to create a very</span>
<a name="l09928"></a>09928           <span class="comment">//   flat tet. Use a larger epsilon to test if they&#39;re coplanar.</span>
<a name="l09929"></a>09929           <span class="keywordflow">if</span> (iscoplanar(pc, pd, pe, pa, ori1, b-&gt;epsilon * 1e+2)) ori1 = 0.0;
<a name="l09930"></a>09930         }
<a name="l09931"></a>09931       } <span class="keywordflow">else</span> {
<a name="l09932"></a>09932         <span class="comment">// Check if c, d, e, and a are approximately coplanar.</span>
<a name="l09933"></a>09933         <span class="keywordflow">if</span> (iscoplanar(pc, pd, pe, pa, ori1, b-&gt;epsilon)) ori1 = 0.0;
<a name="l09934"></a>09934       }
<a name="l09935"></a>09935     }
<a name="l09936"></a>09936     <span class="keywordflow">if</span> (ori1 &lt;= 0.0) {
<a name="l09937"></a>09937       <span class="comment">// a lies above or is coplanar cde, abc is locally Delaunay.</span>
<a name="l09938"></a>09938       <span class="keywordflow">return</span> N40;
<a name="l09939"></a>09939     }
<a name="l09940"></a>09940     ori2 = orient3d(pd, pc, pe, pb);
<a name="l09941"></a>09941     <span class="keywordflow">if</span> (checksubfaces &amp;&amp; ori2 != 0.0) {
<a name="l09942"></a>09942       <span class="comment">// Check if bcd and cbe are both boundary faces.</span>
<a name="l09943"></a>09943       enextfnext(horiz, casing);
<a name="l09944"></a>09944       tspivot(casing, cassh1);
<a name="l09945"></a>09945       enext2fnext(symhoriz, casing);
<a name="l09946"></a>09946       tspivot(casing, cassh2);
<a name="l09947"></a>09947       <span class="keywordflow">if</span> (cassh1.sh != dummysh &amp;&amp; cassh2.sh != dummysh) {
<a name="l09948"></a>09948         <span class="comment">// bcd and cbe are both boundary faces. Check if bc is a segment.</span>
<a name="l09949"></a>09949         findedge(&amp;cassh1, pb, pc);
<a name="l09950"></a>09950         sspivot(cassh1, checkseg);
<a name="l09951"></a>09951         <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l09952"></a>09952           <span class="comment">// bc is not a segment. bcd and cbe belong to the same facet.</span>
<a name="l09953"></a>09953           <span class="comment">//   The four points are forced to be coplanar.</span>
<a name="l09954"></a>09954           ori2 = 0.0;
<a name="l09955"></a>09955         } <span class="keywordflow">else</span> {
<a name="l09956"></a>09956           <span class="comment">// bc is a segment. bcd and cbe belong to different facets.</span>
<a name="l09957"></a>09957           <span class="comment">//   In principle, d, c, e, and b can form a tetrahedron (since</span>
<a name="l09958"></a>09958           <span class="comment">//   ori2 != 0.0).  However, we should avoid to create a very</span>
<a name="l09959"></a>09959           <span class="comment">//   flat tet. Use a larger epsilon to test if they&#39;re coplanar.</span>
<a name="l09960"></a>09960           <span class="keywordflow">if</span> (iscoplanar(pd, pc, pe, pb, ori2, b-&gt;epsilon * 1e+2)) ori2 = 0.0;
<a name="l09961"></a>09961         }
<a name="l09962"></a>09962       } <span class="keywordflow">else</span> {
<a name="l09963"></a>09963         <span class="comment">// Check if d, c, e, and b are approximately coplanar.</span>
<a name="l09964"></a>09964         <span class="keywordflow">if</span> (iscoplanar(pd, pc, pe, pb, ori2, b-&gt;epsilon)) ori2 = 0.0;
<a name="l09965"></a>09965       }
<a name="l09966"></a>09966     }
<a name="l09967"></a>09967     <span class="keywordflow">if</span> (ori2 &lt;= 0.0) {
<a name="l09968"></a>09968       <span class="comment">// b lies above dce, unflipable, and abc is locally Delaunay.</span>
<a name="l09969"></a>09969       <span class="keywordflow">return</span> N40;
<a name="l09970"></a>09970     }
<a name="l09971"></a>09971     <span class="comment">// Edge ab crosses face cde properly.</span>
<a name="l09972"></a>09972     <span class="keywordflow">if</span> (checksubfaces) {
<a name="l09973"></a>09973       <span class="comment">// If abc is subface, then ab must be a subsegment (because abde is</span>
<a name="l09974"></a>09974       <span class="comment">//   a tetrahedron and ab crosses cde properly).</span>
<a name="l09975"></a>09975       tsspivot(&amp;horiz, &amp;checkseg);
<a name="l09976"></a>09976       <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l09977"></a>09977         <span class="comment">// To flip a subsegment is forbidden.</span>
<a name="l09978"></a>09978         <span class="keywordflow">return</span> FORBIDDENEDGE;
<a name="l09979"></a>09979       }
<a name="l09980"></a>09980       <span class="comment">// Both abd and bae should not be subfaces (because they&#39;re not</span>
<a name="l09981"></a>09981       <span class="comment">//   coplanar and ab is not a subsegment). However, they may be</span>
<a name="l09982"></a>09982       <span class="comment">//   subfaces and belong to a facet (created during facet recovery),</span>
<a name="l09983"></a>09983       <span class="comment">//   that is, abde is an invalid tetrahedron. Find this case out.</span>
<a name="l09984"></a>09984       fnext(horiz, casing);
<a name="l09985"></a>09985       tspivot(casing, cassh1);
<a name="l09986"></a>09986       fnext(symhoriz, casing);
<a name="l09987"></a>09987       tspivot(casing, cassh2);
<a name="l09988"></a>09988       <span class="keywordflow">if</span> (cassh1.sh != dummysh || cassh2.sh != dummysh) {
<a name="l09989"></a>09989         <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l09990"></a>09990           <span class="comment">// Unfortunately, they&#39;re subfaces. Corrections need be done here.</span>
<a name="l09991"></a>09991           printf(<span class="stringliteral">&quot;Warning:  A tetrahedron spans two subfaces of a facet.\n&quot;</span>);
<a name="l09992"></a>09992         }
<a name="l09993"></a>09993         <span class="comment">// Temporarily, let it be there.</span>
<a name="l09994"></a>09994         <span class="keywordflow">return</span> N32;
<a name="l09995"></a>09995       }
<a name="l09996"></a>09996     }
<a name="l09997"></a>09997     <span class="keywordflow">return</span> T32;
<a name="l09998"></a>09998   } <span class="keywordflow">else</span> {
<a name="l09999"></a>09999     <span class="comment">// The convex hull of {a, b, c, d, e} has only four vertices, abc is</span>
<a name="l10000"></a>10000     <span class="comment">//   unflipable, furthermore, it is locally Delaunay.</span>
<a name="l10001"></a>10001     <span class="keywordflow">return</span> N40;
<a name="l10002"></a>10002   }
<a name="l10003"></a>10003 }
<a name="l10004"></a>10004 
<a name="l10006"></a>10006 <span class="comment">//                                                                           //</span>
<a name="l10007"></a>10007 <span class="comment">// enqueueflipface(), enqueueflipedge()    Queue a face (or an edge).        //</span>
<a name="l10008"></a>10008 <span class="comment">//                                                                           //</span>
<a name="l10009"></a>10009 <span class="comment">// The face (or edge) may be non-locally Delaunay. It is queued for process- //</span>
<a name="l10010"></a>10010 <span class="comment">// ing in flip() (or flipsub()). The vertices of the face (edge) are stored  //</span>
<a name="l10011"></a>10011 <span class="comment">// seperatly to ensure the face (or edge) is still the same one when we save //</span>
<a name="l10012"></a>10012 <span class="comment">// it since other flips will cause this face (or edge) be changed or dead.   //</span>
<a name="l10013"></a>10013 <span class="comment">//                                                                           //</span>
<a name="l10015"></a>10015 <span class="comment"></span>
<a name="l10016"></a>10016 <span class="keywordtype">void</span> tetgenmesh::enqueueflipface(triface&amp; checkface, queue* flipqueue)
<a name="l10017"></a>10017 {
<a name="l10018"></a>10018   badface *queface;
<a name="l10019"></a>10019   triface symface;
<a name="l10020"></a>10020 
<a name="l10021"></a>10021   sym(checkface, symface);
<a name="l10022"></a>10022   <span class="keywordflow">if</span> (symface.tet != dummytet) {
<a name="l10023"></a>10023     queface = (badface *) flipqueue-&gt;push((<span class="keywordtype">void</span> *) NULL);
<a name="l10024"></a>10024     queface-&gt;tt = checkface;
<a name="l10025"></a>10025     queface-&gt;foppo = oppo(symface);
<a name="l10026"></a>10026   }
<a name="l10027"></a>10027 }
<a name="l10028"></a>10028 
<a name="l10029"></a>10029 <span class="keywordtype">void</span> tetgenmesh::enqueueflipedge(face&amp; checkedge, queue* flipqueue)
<a name="l10030"></a>10030 {
<a name="l10031"></a>10031   badface *queface;
<a name="l10032"></a>10032 
<a name="l10033"></a>10033   queface = (badface *) flipqueue-&gt;push((<span class="keywordtype">void</span> *) NULL);
<a name="l10034"></a>10034   queface-&gt;ss = checkedge;
<a name="l10035"></a>10035   queface-&gt;forg = sorg(checkedge);
<a name="l10036"></a>10036   queface-&gt;fdest = sdest(checkedge);
<a name="l10037"></a>10037 }
<a name="l10038"></a>10038 
<a name="l10040"></a>10040 <span class="comment">//                                                                           //</span>
<a name="l10041"></a>10041 <span class="comment">// flip23()    Perform a 2-to-3 flip.                                        //</span>
<a name="l10042"></a>10042 <span class="comment">//                                                                           //</span>
<a name="l10043"></a>10043 <span class="comment">// On input, &#39;flipface&#39; represents the face will be flipped.  Let it is abc, //</span>
<a name="l10044"></a>10044 <span class="comment">// the two tetrahedra sharing abc are abcd, bace. abc is not a subface.      //</span>
<a name="l10045"></a>10045 <span class="comment">//                                                                           //</span>
<a name="l10046"></a>10046 <span class="comment">// A 2-to-3 flip is to change two tetrahedra abcd, bace to three tetrahedra  //</span>
<a name="l10047"></a>10047 <span class="comment">// edab, edbc, and edca.  As a result, face abc has been removed and three   //</span>
<a name="l10048"></a>10048 <span class="comment">// new faces eda, edb and edc have been created.                             //</span>
<a name="l10049"></a>10049 <span class="comment">//                                                                           //</span>
<a name="l10050"></a>10050 <span class="comment">// On completion, &#39;flipface&#39; returns edab.  If &#39;flipqueue&#39; is not NULL, all  //</span>
<a name="l10051"></a>10051 <span class="comment">// possibly non-Delaunay faces are added into it.                            //</span>
<a name="l10052"></a>10052 <span class="comment">//                                                                           //</span>
<a name="l10054"></a>10054 <span class="comment"></span>
<a name="l10055"></a>10055 <span class="keywordtype">void</span> tetgenmesh::flip23(triface* flipface, queue* flipqueue)
<a name="l10056"></a>10056 {
<a name="l10057"></a>10057   triface abcd, bace;                                  <span class="comment">// Old configuration.</span>
<a name="l10058"></a>10058   triface oldabd, oldbcd, oldcad;
<a name="l10059"></a>10059   triface abdcasing, bcdcasing, cadcasing;
<a name="l10060"></a>10060   triface oldbae, oldcbe, oldace;
<a name="l10061"></a>10061   triface baecasing, cbecasing, acecasing;
<a name="l10062"></a>10062   triface worktet;
<a name="l10063"></a>10063   face abdsh, bcdsh, cadsh;                   <span class="comment">// The six subfaces on the CH.</span>
<a name="l10064"></a>10064   face baesh, cbesh, acesh;
<a name="l10065"></a>10065   face abseg, bcseg, caseg;                      <span class="comment">// The nine segs on the CH.</span>
<a name="l10066"></a>10066   face adseg, bdseg, cdseg;
<a name="l10067"></a>10067   face aeseg, beseg, ceseg;
<a name="l10068"></a>10068   triface edab, edbc, edca;                            <span class="comment">// New configuration.</span>
<a name="l10069"></a>10069   point pa, pb, pc, pd, pe;
<a name="l10070"></a>10070   REAL attrib, volume;
<a name="l10071"></a>10071   <span class="keywordtype">int</span> i;
<a name="l10072"></a>10072 
<a name="l10073"></a>10073   abcd = *flipface;
<a name="l10074"></a>10074   adjustedgering(abcd, CCW); <span class="comment">// abcd represents edge ab.</span>
<a name="l10075"></a>10075   pa = org(abcd);
<a name="l10076"></a>10076   pb = dest(abcd);
<a name="l10077"></a>10077   pc = apex(abcd);
<a name="l10078"></a>10078   pd = oppo(abcd);
<a name="l10079"></a>10079   <span class="comment">// sym(abcd, bace);</span>
<a name="l10080"></a>10080   <span class="comment">// findedge(&amp;bace, dest(abcd), org(abcd)); // bace represents edge ba.</span>
<a name="l10081"></a>10081   sym(abcd, bace);
<a name="l10082"></a>10082   bace.ver = 0; <span class="comment">// CCW.</span>
<a name="l10083"></a>10083   <span class="keywordflow">for</span> (i = 0; (i &lt; 3) &amp;&amp; (org(bace) != pb); i++) {
<a name="l10084"></a>10084     enextself(bace);
<a name="l10085"></a>10085   }
<a name="l10086"></a>10086   pe = oppo(bace);
<a name="l10087"></a>10087 
<a name="l10088"></a>10088   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l10089"></a>10089     printf(<span class="stringliteral">&quot;    Do T23 on face (%d, %d, %d) %d, %d.\n&quot;</span>, pointmark(pa),
<a name="l10090"></a>10090            pointmark(pb), pointmark(pc), pointmark(pd), pointmark(pe));
<a name="l10091"></a>10091   }
<a name="l10092"></a>10092   flip23s++;
<a name="l10093"></a>10093 
<a name="l10094"></a>10094   <span class="comment">// Storing the old configuration outside the convex hull.</span>
<a name="l10095"></a>10095   fnext(abcd, oldabd);
<a name="l10096"></a>10096   enextfnext(abcd, oldbcd);
<a name="l10097"></a>10097   enext2fnext(abcd, oldcad);
<a name="l10098"></a>10098   fnext(bace, oldbae);
<a name="l10099"></a>10099   enext2fnext(bace, oldcbe);
<a name="l10100"></a>10100   enextfnext(bace, oldace);
<a name="l10101"></a>10101   sym(oldabd, abdcasing);
<a name="l10102"></a>10102   sym(oldbcd, bcdcasing);
<a name="l10103"></a>10103   sym(oldcad, cadcasing);
<a name="l10104"></a>10104   sym(oldbae, baecasing);
<a name="l10105"></a>10105   sym(oldcbe, cbecasing);
<a name="l10106"></a>10106   sym(oldace, acecasing);
<a name="l10107"></a>10107   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l10108"></a>10108     tspivot(oldabd, abdsh);
<a name="l10109"></a>10109     tspivot(oldbcd, bcdsh);
<a name="l10110"></a>10110     tspivot(oldcad, cadsh);
<a name="l10111"></a>10111     tspivot(oldbae, baesh);
<a name="l10112"></a>10112     tspivot(oldcbe, cbesh);
<a name="l10113"></a>10113     tspivot(oldace, acesh);
<a name="l10114"></a>10114   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l10115"></a>10115     tsspivot1(abcd, abseg);
<a name="l10116"></a>10116     enext(abcd, worktet);
<a name="l10117"></a>10117     tsspivot1(worktet, bcseg);
<a name="l10118"></a>10118     enext2(abcd, worktet);
<a name="l10119"></a>10119     tsspivot1(worktet, caseg);
<a name="l10120"></a>10120     enext2(oldabd, worktet);
<a name="l10121"></a>10121     tsspivot1(worktet, adseg);
<a name="l10122"></a>10122     enext2(oldbcd, worktet);
<a name="l10123"></a>10123     tsspivot1(worktet, bdseg);
<a name="l10124"></a>10124     enext2(oldcad, worktet);
<a name="l10125"></a>10125     tsspivot1(worktet, cdseg);
<a name="l10126"></a>10126     enext(oldbae, worktet);
<a name="l10127"></a>10127     tsspivot1(worktet, aeseg);
<a name="l10128"></a>10128     enext(oldcbe, worktet);
<a name="l10129"></a>10129     tsspivot1(worktet, beseg);
<a name="l10130"></a>10130     enext(oldace, worktet);
<a name="l10131"></a>10131     tsspivot1(worktet, ceseg);
<a name="l10132"></a>10132   }
<a name="l10133"></a>10133 
<a name="l10134"></a>10134   <span class="comment">// Creating the new configuration inside the convex hull.</span>
<a name="l10135"></a>10135   edab.tet = abcd.tet; <span class="comment">// Update abcd to be edab.</span>
<a name="l10136"></a>10136   setorg (edab, pe);
<a name="l10137"></a>10137   setdest(edab, pd);
<a name="l10138"></a>10138   setapex(edab, pa);
<a name="l10139"></a>10139   setoppo(edab, pb);
<a name="l10140"></a>10140   edbc.tet = bace.tet; <span class="comment">// Update bace to be edbc.</span>
<a name="l10141"></a>10141   setorg (edbc, pe);
<a name="l10142"></a>10142   setdest(edbc, pd);
<a name="l10143"></a>10143   setapex(edbc, pb);
<a name="l10144"></a>10144   setoppo(edbc, pc);
<a name="l10145"></a>10145   maketetrahedron(&amp;edca); <span class="comment">// Create edca.</span>
<a name="l10146"></a>10146   setorg (edca, pe);
<a name="l10147"></a>10147   setdest(edca, pd);
<a name="l10148"></a>10148   setapex(edca, pc);
<a name="l10149"></a>10149   setoppo(edca, pa);
<a name="l10150"></a>10150   <span class="comment">// Set the element attributes of the new tetrahedron &#39;edca&#39;.</span>
<a name="l10151"></a>10151   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l10152"></a>10152     attrib = elemattribute(abcd.tet, i);
<a name="l10153"></a>10153     setelemattribute(edca.tet, i, attrib);
<a name="l10154"></a>10154   }
<a name="l10155"></a>10155   <span class="comment">// Set the volume constraint of the new tetrahedron &#39;edca&#39; if the -ra</span>
<a name="l10156"></a>10156   <span class="comment">//   switches are not used together. In -ra case, the various volume</span>
<a name="l10157"></a>10157   <span class="comment">//   constraints can be spreaded very far.</span>
<a name="l10158"></a>10158   <span class="keywordflow">if</span> (b-&gt;varvolume &amp;&amp; !b-&gt;refine) {
<a name="l10159"></a>10159     volume = volumebound(abcd.tet);
<a name="l10160"></a>10160     setvolumebound(edca.tet, volume);
<a name="l10161"></a>10161   }
<a name="l10162"></a>10162 
<a name="l10163"></a>10163   <span class="comment">// Clear old bonds in edab(was abcd) and edbc(was bace).</span>
<a name="l10164"></a>10164   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i ++) {
<a name="l10165"></a>10165     edab.tet[i] = (tetrahedron) dummytet;
<a name="l10166"></a>10166   }
<a name="l10167"></a>10167   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i ++) {
<a name="l10168"></a>10168     edbc.tet[i] = (tetrahedron) dummytet;
<a name="l10169"></a>10169   }
<a name="l10170"></a>10170   <span class="comment">// Bond the faces inside the convex hull.</span>
<a name="l10171"></a>10171   edab.loc = 0;
<a name="l10172"></a>10172   edca.loc = 1;
<a name="l10173"></a>10173   bond(edab, edca);
<a name="l10174"></a>10174   edab.loc = 1;
<a name="l10175"></a>10175   edbc.loc = 0;
<a name="l10176"></a>10176   bond(edab, edbc);
<a name="l10177"></a>10177   edbc.loc = 1;
<a name="l10178"></a>10178   edca.loc = 0;
<a name="l10179"></a>10179   bond(edbc, edca);
<a name="l10180"></a>10180   <span class="comment">// Bond the faces on the convex hull.</span>
<a name="l10181"></a>10181   edab.loc = 2;
<a name="l10182"></a>10182   bond(edab, abdcasing);
<a name="l10183"></a>10183   edab.loc = 3;
<a name="l10184"></a>10184   bond(edab, baecasing);
<a name="l10185"></a>10185   edbc.loc = 2;
<a name="l10186"></a>10186   bond(edbc, bcdcasing);
<a name="l10187"></a>10187   edbc.loc = 3;
<a name="l10188"></a>10188   bond(edbc, cbecasing);
<a name="l10189"></a>10189   edca.loc = 2;
<a name="l10190"></a>10190   bond(edca, cadcasing);
<a name="l10191"></a>10191   edca.loc = 3;
<a name="l10192"></a>10192   bond(edca, acecasing);
<a name="l10193"></a>10193   <span class="comment">// There may exist subfaces that need to be bonded to new configuarton.</span>
<a name="l10194"></a>10194   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l10195"></a>10195     <span class="comment">// Clear old flags in edab(was abcd) and edbc(was bace).</span>
<a name="l10196"></a>10196     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i ++) {
<a name="l10197"></a>10197       edab.loc = i;
<a name="l10198"></a>10198       tsdissolve(edab);
<a name="l10199"></a>10199       edbc.loc = i;
<a name="l10200"></a>10200       tsdissolve(edbc);
<a name="l10201"></a>10201     }
<a name="l10202"></a>10202     <span class="keywordflow">if</span> (abdsh.sh != dummysh) {
<a name="l10203"></a>10203       edab.loc = 2;
<a name="l10204"></a>10204       tsbond(edab, abdsh);
<a name="l10205"></a>10205     }
<a name="l10206"></a>10206     <span class="keywordflow">if</span> (baesh.sh != dummysh) {
<a name="l10207"></a>10207       edab.loc = 3;
<a name="l10208"></a>10208       tsbond(edab, baesh);
<a name="l10209"></a>10209     }
<a name="l10210"></a>10210     <span class="keywordflow">if</span> (bcdsh.sh != dummysh) {
<a name="l10211"></a>10211       edbc.loc = 2;
<a name="l10212"></a>10212       tsbond(edbc, bcdsh);
<a name="l10213"></a>10213     }
<a name="l10214"></a>10214     <span class="keywordflow">if</span> (cbesh.sh != dummysh) {
<a name="l10215"></a>10215       edbc.loc = 3;
<a name="l10216"></a>10216       tsbond(edbc, cbesh);
<a name="l10217"></a>10217     }
<a name="l10218"></a>10218     <span class="keywordflow">if</span> (cadsh.sh != dummysh) {
<a name="l10219"></a>10219       edca.loc = 2;
<a name="l10220"></a>10220       tsbond(edca, cadsh);
<a name="l10221"></a>10221     }
<a name="l10222"></a>10222     <span class="keywordflow">if</span> (acesh.sh != dummysh) {
<a name="l10223"></a>10223       edca.loc = 3;
<a name="l10224"></a>10224       tsbond(edca, acesh);
<a name="l10225"></a>10225     }
<a name="l10226"></a>10226   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l10227"></a>10227     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l10228"></a>10228       edab.tet[8 + i] = (tetrahedron) dummysh;
<a name="l10229"></a>10229     }
<a name="l10230"></a>10230     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l10231"></a>10231       edbc.tet[8 + i] = (tetrahedron) dummysh;
<a name="l10232"></a>10232     }
<a name="l10233"></a>10233     edab.loc = edab.ver = 0;
<a name="l10234"></a>10234     edbc.loc = edab.ver = 0;
<a name="l10235"></a>10235     edca.loc = edab.ver = 0;
<a name="l10236"></a>10236     <span class="comment">// Operate in tet edab (5 edges).</span>
<a name="l10237"></a>10237     enext(edab, worktet);
<a name="l10238"></a>10238     tssbond1(worktet, adseg);
<a name="l10239"></a>10239     enext2(edab, worktet);
<a name="l10240"></a>10240     tssbond1(worktet, aeseg);
<a name="l10241"></a>10241     fnext(edab, worktet);
<a name="l10242"></a>10242     enextself(worktet);
<a name="l10243"></a>10243     tssbond1(worktet, bdseg);
<a name="l10244"></a>10244     enextself(worktet);
<a name="l10245"></a>10245     tssbond1(worktet, beseg);
<a name="l10246"></a>10246     enextfnext(edab, worktet);
<a name="l10247"></a>10247     enextself(worktet);
<a name="l10248"></a>10248     tssbond1(worktet, abseg);
<a name="l10249"></a>10249     <span class="comment">// Operate in tet edbc (5 edges)</span>
<a name="l10250"></a>10250     enext(edbc, worktet);
<a name="l10251"></a>10251     tssbond1(worktet, bdseg);
<a name="l10252"></a>10252     enext2(edbc, worktet);
<a name="l10253"></a>10253     tssbond1(worktet, beseg);
<a name="l10254"></a>10254     fnext(edbc, worktet);
<a name="l10255"></a>10255     enextself(worktet);
<a name="l10256"></a>10256     tssbond1(worktet, cdseg);
<a name="l10257"></a>10257     enextself(worktet);
<a name="l10258"></a>10258     tssbond1(worktet, ceseg);
<a name="l10259"></a>10259     enextfnext(edbc, worktet);
<a name="l10260"></a>10260     enextself(worktet);
<a name="l10261"></a>10261     tssbond1(worktet, bcseg);
<a name="l10262"></a>10262     <span class="comment">// Operate in tet edca (5 edges)</span>
<a name="l10263"></a>10263     enext(edca, worktet);
<a name="l10264"></a>10264     tssbond1(worktet, cdseg);
<a name="l10265"></a>10265     enext2(edca, worktet);
<a name="l10266"></a>10266     tssbond1(worktet, ceseg);
<a name="l10267"></a>10267     fnext(edca, worktet);
<a name="l10268"></a>10268     enextself(worktet);
<a name="l10269"></a>10269     tssbond1(worktet, adseg);
<a name="l10270"></a>10270     enextself(worktet);
<a name="l10271"></a>10271     tssbond1(worktet, aeseg);
<a name="l10272"></a>10272     enextfnext(edca, worktet);
<a name="l10273"></a>10273     enextself(worktet);
<a name="l10274"></a>10274     tssbond1(worktet, caseg);
<a name="l10275"></a>10275   }
<a name="l10276"></a>10276 
<a name="l10277"></a>10277   edab.loc = 0;
<a name="l10278"></a>10278   edbc.loc = 0;
<a name="l10279"></a>10279   edca.loc = 0;
<a name="l10280"></a>10280   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l10281"></a>10281     printf(<span class="stringliteral">&quot;    Updating edab &quot;</span>);
<a name="l10282"></a>10282     printtet(&amp;edab);
<a name="l10283"></a>10283     printf(<span class="stringliteral">&quot;    Updating edbc &quot;</span>);
<a name="l10284"></a>10284     printtet(&amp;edbc);
<a name="l10285"></a>10285     printf(<span class="stringliteral">&quot;    Creating edca &quot;</span>);
<a name="l10286"></a>10286     printtet(&amp;edca);
<a name="l10287"></a>10287   }
<a name="l10288"></a>10288 
<a name="l10289"></a>10289   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l10290"></a>10290     enextfnext(edab, abdcasing);
<a name="l10291"></a>10291     enqueueflipface(abdcasing, flipqueue);
<a name="l10292"></a>10292     enext2fnext(edab, baecasing);
<a name="l10293"></a>10293     enqueueflipface(baecasing, flipqueue);
<a name="l10294"></a>10294     enextfnext(edbc, bcdcasing);
<a name="l10295"></a>10295     enqueueflipface(bcdcasing, flipqueue);
<a name="l10296"></a>10296     enext2fnext(edbc, cbecasing);
<a name="l10297"></a>10297     enqueueflipface(cbecasing, flipqueue);
<a name="l10298"></a>10298     enextfnext(edca, cadcasing);
<a name="l10299"></a>10299     enqueueflipface(cadcasing, flipqueue);
<a name="l10300"></a>10300     enext2fnext(edca, acecasing);
<a name="l10301"></a>10301     enqueueflipface(acecasing, flipqueue);
<a name="l10302"></a>10302   }
<a name="l10303"></a>10303 
<a name="l10304"></a>10304   <span class="comment">// Save a live handle in &#39;recenttet&#39;.</span>
<a name="l10305"></a>10305   recenttet = edbc;
<a name="l10306"></a>10306   <span class="comment">// Set the return handle be edab.</span>
<a name="l10307"></a>10307   *flipface = edab;
<a name="l10308"></a>10308 }
<a name="l10309"></a>10309 
<a name="l10311"></a>10311 <span class="comment">//                                                                           //</span>
<a name="l10312"></a>10312 <span class="comment">// flip32()    Perform a 3-to-2 flip.                                        //</span>
<a name="l10313"></a>10313 <span class="comment">//                                                                           //</span>
<a name="l10314"></a>10314 <span class="comment">// On input, &#39;flipface&#39; represents the face will be flipped.  Let it is eda, //</span>
<a name="l10315"></a>10315 <span class="comment">// where edge ed is locally non-convex. Three tetrahedra sharing ed are edab,//</span>
<a name="l10316"></a>10316 <span class="comment">// edbc, and edca.  ed is not a subsegment.                                  //</span>
<a name="l10317"></a>10317 <span class="comment">//                                                                           //</span>
<a name="l10318"></a>10318 <span class="comment">// A 3-to-2 flip is to change the three tetrahedra edab, edbc, and edca into //</span>
<a name="l10319"></a>10319 <span class="comment">// another two tetrahedra abcd and bace.  As a result, the edge ed has been  //</span>
<a name="l10320"></a>10320 <span class="comment">// removed and the face abc has been created.                                //</span>
<a name="l10321"></a>10321 <span class="comment">//                                                                           //</span>
<a name="l10322"></a>10322 <span class="comment">// On completion, &#39;flipface&#39; returns abcd.  If &#39;flipqueue&#39; is not NULL, all  //</span>
<a name="l10323"></a>10323 <span class="comment">// possibly non-Delaunay faces are added into it.                            //</span>
<a name="l10324"></a>10324 <span class="comment">//                                                                           //</span>
<a name="l10326"></a>10326 <span class="comment"></span>
<a name="l10327"></a>10327 <span class="keywordtype">void</span> tetgenmesh::flip32(triface* flipface, queue* flipqueue)
<a name="l10328"></a>10328 {
<a name="l10329"></a>10329   triface edab, edbc, edca;                            <span class="comment">// Old configuration.</span>
<a name="l10330"></a>10330   triface oldabd, oldbcd, oldcad;
<a name="l10331"></a>10331   triface abdcasing, bcdcasing, cadcasing;
<a name="l10332"></a>10332   triface oldbae, oldcbe, oldace;
<a name="l10333"></a>10333   triface baecasing, cbecasing, acecasing;
<a name="l10334"></a>10334   triface worktet;
<a name="l10335"></a>10335   face abdsh, bcdsh, cadsh;
<a name="l10336"></a>10336   face baesh, cbesh, acesh;
<a name="l10337"></a>10337   face abseg, bcseg, caseg;                      <span class="comment">// The nine segs on the CH.</span>
<a name="l10338"></a>10338   face adseg, bdseg, cdseg;
<a name="l10339"></a>10339   face aeseg, beseg, ceseg;
<a name="l10340"></a>10340   triface abcd, bace;                                  <span class="comment">// New configuration.</span>
<a name="l10341"></a>10341   point pa, pb, pc, pd, pe;
<a name="l10342"></a>10342   <span class="keywordtype">int</span> i;
<a name="l10343"></a>10343 
<a name="l10344"></a>10344   edab = *flipface;
<a name="l10345"></a>10345   adjustedgering(edab, CCW);
<a name="l10346"></a>10346   pa = apex(edab);
<a name="l10347"></a>10347   pb = oppo(edab);
<a name="l10348"></a>10348   pd = dest(edab);
<a name="l10349"></a>10349   pe = org(edab);
<a name="l10350"></a>10350   fnext(edab, edbc);
<a name="l10351"></a>10351   symself(edbc);
<a name="l10352"></a>10352   edbc.ver = 0;
<a name="l10353"></a>10353   <span class="keywordflow">for</span> (i = 0; (i &lt; 3) &amp;&amp; (org(edbc) != pe); i++) {
<a name="l10354"></a>10354     enextself(edbc);
<a name="l10355"></a>10355   }
<a name="l10356"></a>10356   pc = oppo(edbc);
<a name="l10357"></a>10357   fnext(edbc, edca);
<a name="l10358"></a>10358   symself(edca);
<a name="l10359"></a>10359   edca.ver = 0;
<a name="l10360"></a>10360   <span class="keywordflow">for</span> (i = 0; (i &lt; 3) &amp;&amp; (org(edca) != pe); i++) {
<a name="l10361"></a>10361     enextself(edca);
<a name="l10362"></a>10362   }
<a name="l10363"></a>10363 
<a name="l10364"></a>10364   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l10365"></a>10365     printf(<span class="stringliteral">&quot;    Do T32 on edge (%d, %d) %d, %d, %d.\n&quot;</span>, pointmark(pe),
<a name="l10366"></a>10366            pointmark(pd), pointmark(pa), pointmark(pb), pointmark(pc));
<a name="l10367"></a>10367   }
<a name="l10368"></a>10368   flip32s++;
<a name="l10369"></a>10369 
<a name="l10370"></a>10370   <span class="comment">// Storing the old configuration outside the convex hull.</span>
<a name="l10371"></a>10371   enextfnext(edab, oldabd);
<a name="l10372"></a>10372   enext2fnext(edab, oldbae);
<a name="l10373"></a>10373   enextfnext(edbc, oldbcd);
<a name="l10374"></a>10374   enext2fnext(edbc, oldcbe);
<a name="l10375"></a>10375   enextfnext(edca, oldcad);
<a name="l10376"></a>10376   enext2fnext(edca, oldace);
<a name="l10377"></a>10377   sym(oldabd, abdcasing);
<a name="l10378"></a>10378   sym(oldbcd, bcdcasing);
<a name="l10379"></a>10379   sym(oldcad, cadcasing);
<a name="l10380"></a>10380   sym(oldbae, baecasing);
<a name="l10381"></a>10381   sym(oldcbe, cbecasing);
<a name="l10382"></a>10382   sym(oldace, acecasing);
<a name="l10383"></a>10383   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l10384"></a>10384     tspivot(oldabd, abdsh);
<a name="l10385"></a>10385     tspivot(oldbcd, bcdsh);
<a name="l10386"></a>10386     tspivot(oldcad, cadsh);
<a name="l10387"></a>10387     tspivot(oldbae, baesh);
<a name="l10388"></a>10388     tspivot(oldcbe, cbesh);
<a name="l10389"></a>10389     tspivot(oldace, acesh);
<a name="l10390"></a>10390   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l10391"></a>10391     enext(edab, worktet);
<a name="l10392"></a>10392     tsspivot1(worktet, adseg);
<a name="l10393"></a>10393     enext2(edab, worktet);
<a name="l10394"></a>10394     tsspivot1(worktet, aeseg);
<a name="l10395"></a>10395     enext(edbc, worktet);
<a name="l10396"></a>10396     tsspivot1(worktet, bdseg);
<a name="l10397"></a>10397     enext2(edbc, worktet);
<a name="l10398"></a>10398     tsspivot1(worktet, beseg);
<a name="l10399"></a>10399     enext(edca, worktet);
<a name="l10400"></a>10400     tsspivot1(worktet, cdseg);
<a name="l10401"></a>10401     enext2(edca, worktet);
<a name="l10402"></a>10402     tsspivot1(worktet, ceseg);
<a name="l10403"></a>10403     enextfnext(edab, worktet);
<a name="l10404"></a>10404     enextself(worktet);
<a name="l10405"></a>10405     tsspivot1(worktet, abseg);
<a name="l10406"></a>10406     enextfnext(edbc, worktet);
<a name="l10407"></a>10407     enextself(worktet);
<a name="l10408"></a>10408     tsspivot1(worktet, bcseg);
<a name="l10409"></a>10409     enextfnext(edca, worktet);
<a name="l10410"></a>10410     enextself(worktet);
<a name="l10411"></a>10411     tsspivot1(worktet, caseg);
<a name="l10412"></a>10412   }
<a name="l10413"></a>10413 
<a name="l10414"></a>10414   <span class="comment">// Creating the new configuration inside the convex hull.</span>
<a name="l10415"></a>10415   abcd.tet = edab.tet; <span class="comment">// Update edab to be abcd.</span>
<a name="l10416"></a>10416   setorg (abcd, pa);
<a name="l10417"></a>10417   setdest(abcd, pb);
<a name="l10418"></a>10418   setapex(abcd, pc);
<a name="l10419"></a>10419   setoppo(abcd, pd);
<a name="l10420"></a>10420   bace.tet = edbc.tet; <span class="comment">// Update edbc to be bace.</span>
<a name="l10421"></a>10421   setorg (bace, pb);
<a name="l10422"></a>10422   setdest(bace, pa);
<a name="l10423"></a>10423   setapex(bace, pc);
<a name="l10424"></a>10424   setoppo(bace, pe);
<a name="l10425"></a>10425   <span class="comment">// Dealloc a redundant tetrahedron (edca).</span>
<a name="l10426"></a>10426   tetrahedrondealloc(edca.tet);
<a name="l10427"></a>10427 
<a name="l10428"></a>10428   <span class="comment">// Clear the old bonds in abcd (was edab) and bace (was edbc).</span>
<a name="l10429"></a>10429   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i ++) {
<a name="l10430"></a>10430     abcd.tet[i] = (tetrahedron) dummytet;
<a name="l10431"></a>10431   }
<a name="l10432"></a>10432   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i ++) {
<a name="l10433"></a>10433     bace.tet[i] = (tetrahedron) dummytet;
<a name="l10434"></a>10434   }
<a name="l10435"></a>10435   <span class="comment">// Bond the inside face of the convex hull.</span>
<a name="l10436"></a>10436   abcd.loc = 0;
<a name="l10437"></a>10437   bace.loc = 0;
<a name="l10438"></a>10438   bond(abcd, bace);
<a name="l10439"></a>10439   <span class="comment">// Bond the outside faces of the convex hull.</span>
<a name="l10440"></a>10440   abcd.loc = 1;
<a name="l10441"></a>10441   bond(abcd, abdcasing);
<a name="l10442"></a>10442   abcd.loc = 2;
<a name="l10443"></a>10443   bond(abcd, bcdcasing);
<a name="l10444"></a>10444   abcd.loc = 3;
<a name="l10445"></a>10445   bond(abcd, cadcasing);
<a name="l10446"></a>10446   bace.loc = 1;
<a name="l10447"></a>10447   bond(bace, baecasing);
<a name="l10448"></a>10448   bace.loc = 3;
<a name="l10449"></a>10449   bond(bace, cbecasing);
<a name="l10450"></a>10450   bace.loc = 2;
<a name="l10451"></a>10451   bond(bace, acecasing);
<a name="l10452"></a>10452   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l10453"></a>10453     <span class="comment">// Clear old bonds in abcd(was edab) and bace(was edbc).</span>
<a name="l10454"></a>10454     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i ++) {
<a name="l10455"></a>10455       abcd.tet[8 + i] = (tetrahedron) dummysh;
<a name="l10456"></a>10456     }
<a name="l10457"></a>10457     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i ++) {
<a name="l10458"></a>10458       bace.tet[8 + i] = (tetrahedron) dummysh;
<a name="l10459"></a>10459     }
<a name="l10460"></a>10460     <span class="keywordflow">if</span> (abdsh.sh != dummysh) {
<a name="l10461"></a>10461       abcd.loc = 1;
<a name="l10462"></a>10462       tsbond(abcd, abdsh);
<a name="l10463"></a>10463     }
<a name="l10464"></a>10464     <span class="keywordflow">if</span> (bcdsh.sh != dummysh) {
<a name="l10465"></a>10465       abcd.loc = 2;
<a name="l10466"></a>10466       tsbond(abcd, bcdsh);
<a name="l10467"></a>10467     }
<a name="l10468"></a>10468     <span class="keywordflow">if</span> (cadsh.sh != dummysh) {
<a name="l10469"></a>10469       abcd.loc = 3;
<a name="l10470"></a>10470       tsbond(abcd, cadsh);
<a name="l10471"></a>10471     }
<a name="l10472"></a>10472     <span class="keywordflow">if</span> (baesh.sh != dummysh) {
<a name="l10473"></a>10473       bace.loc = 1;
<a name="l10474"></a>10474       tsbond(bace, baesh);
<a name="l10475"></a>10475     }
<a name="l10476"></a>10476     <span class="keywordflow">if</span> (cbesh.sh != dummysh) {
<a name="l10477"></a>10477       bace.loc = 3;
<a name="l10478"></a>10478       tsbond(bace, cbesh);
<a name="l10479"></a>10479     }
<a name="l10480"></a>10480     <span class="keywordflow">if</span> (acesh.sh != dummysh) {
<a name="l10481"></a>10481       bace.loc = 2;
<a name="l10482"></a>10482       tsbond(bace, acesh);
<a name="l10483"></a>10483     }
<a name="l10484"></a>10484   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l10485"></a>10485     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l10486"></a>10486       abcd.tet[8 + i] = (tetrahedron) dummysh;
<a name="l10487"></a>10487     }
<a name="l10488"></a>10488     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l10489"></a>10489       bace.tet[8 + i] = (tetrahedron) dummysh;
<a name="l10490"></a>10490     }
<a name="l10491"></a>10491     abcd.loc = abcd.ver = 0;
<a name="l10492"></a>10492     bace.loc = bace.ver = 0;
<a name="l10493"></a>10493     tssbond1(abcd, abseg);     <span class="comment">// 1</span>
<a name="l10494"></a>10494     enext(abcd, worktet);
<a name="l10495"></a>10495     tssbond1(worktet, bcseg);  <span class="comment">// 2</span>
<a name="l10496"></a>10496     enext2(abcd, worktet);
<a name="l10497"></a>10497     tssbond1(worktet, caseg);  <span class="comment">// 3</span>
<a name="l10498"></a>10498     fnext(abcd, worktet);
<a name="l10499"></a>10499     enext2self(worktet);
<a name="l10500"></a>10500     tssbond1(worktet, adseg);  <span class="comment">// 4</span>
<a name="l10501"></a>10501     enextfnext(abcd, worktet);
<a name="l10502"></a>10502     enext2self(worktet);
<a name="l10503"></a>10503     tssbond1(worktet, bdseg);  <span class="comment">// 5</span>
<a name="l10504"></a>10504     enext2fnext(abcd, worktet);
<a name="l10505"></a>10505     enext2self(worktet);
<a name="l10506"></a>10506     tssbond1(worktet, cdseg);  <span class="comment">// 6</span>
<a name="l10507"></a>10507     tssbond1(bace, abseg);
<a name="l10508"></a>10508     enext2(bace, worktet);
<a name="l10509"></a>10509     tssbond1(worktet, bcseg);
<a name="l10510"></a>10510     enext(bace, worktet);
<a name="l10511"></a>10511     tssbond1(worktet, caseg);
<a name="l10512"></a>10512     fnext(bace, worktet);
<a name="l10513"></a>10513     enextself(worktet);
<a name="l10514"></a>10514     tssbond1(worktet, aeseg);  <span class="comment">// 7</span>
<a name="l10515"></a>10515     enext2fnext(bace, worktet);
<a name="l10516"></a>10516     enextself(worktet);
<a name="l10517"></a>10517     tssbond1(worktet, beseg);  <span class="comment">// 8</span>
<a name="l10518"></a>10518     enextfnext(bace, worktet);
<a name="l10519"></a>10519     enextself(worktet);
<a name="l10520"></a>10520     tssbond1(worktet, ceseg);  <span class="comment">// 9</span>
<a name="l10521"></a>10521   }
<a name="l10522"></a>10522 
<a name="l10523"></a>10523   abcd.loc = 0;
<a name="l10524"></a>10524   bace.loc = 0;
<a name="l10525"></a>10525   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l10526"></a>10526     printf(<span class="stringliteral">&quot;    Updating abcd &quot;</span>);
<a name="l10527"></a>10527     printtet(&amp;abcd);
<a name="l10528"></a>10528     printf(<span class="stringliteral">&quot;    Updating bace &quot;</span>);
<a name="l10529"></a>10529     printtet(&amp;bace);
<a name="l10530"></a>10530     printf(<span class="stringliteral">&quot;    Deleting edca &quot;</span>);
<a name="l10531"></a>10531     <span class="comment">// printtet(&amp;edca);</span>
<a name="l10532"></a>10532   }
<a name="l10533"></a>10533 
<a name="l10534"></a>10534   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l10535"></a>10535     fnext(abcd, abdcasing);
<a name="l10536"></a>10536     enqueueflipface(abdcasing, flipqueue);
<a name="l10537"></a>10537     fnext(bace, baecasing);
<a name="l10538"></a>10538     enqueueflipface(baecasing, flipqueue);
<a name="l10539"></a>10539     enextfnext(abcd, bcdcasing);
<a name="l10540"></a>10540     enqueueflipface(bcdcasing, flipqueue);
<a name="l10541"></a>10541     enextfnext(bace, cbecasing);
<a name="l10542"></a>10542     enqueueflipface(cbecasing, flipqueue);
<a name="l10543"></a>10543     enext2fnext(abcd, cadcasing);
<a name="l10544"></a>10544     enqueueflipface(cadcasing, flipqueue);
<a name="l10545"></a>10545     enext2fnext(bace, acecasing);
<a name="l10546"></a>10546     enqueueflipface(acecasing, flipqueue);
<a name="l10547"></a>10547   }
<a name="l10548"></a>10548 
<a name="l10549"></a>10549   <span class="comment">// Save a live handle in &#39;recenttet&#39;.</span>
<a name="l10550"></a>10550   recenttet = abcd;
<a name="l10551"></a>10551   <span class="comment">// Set the return handle be abcd.</span>
<a name="l10552"></a>10552   *flipface = abcd;
<a name="l10553"></a>10553 }
<a name="l10554"></a>10554 
<a name="l10556"></a>10556 <span class="comment">//                                                                           //</span>
<a name="l10557"></a>10557 <span class="comment">// flip22()    Perform a 2-to-2 (or 4-to-4) flip.                            //</span>
<a name="l10558"></a>10558 <span class="comment">//                                                                           //</span>
<a name="l10559"></a>10559 <span class="comment">// On input, &#39;flipface&#39; represents the face will be flipped.  Let it is abe, //</span>
<a name="l10560"></a>10560 <span class="comment">// ab is the flipable edge, the two tetrahedra sharing abe are abce and bade,//</span>
<a name="l10561"></a>10561 <span class="comment">// hence a, b, c and d are coplanar. If abc, bad are interior faces, the two //</span>
<a name="l10562"></a>10562 <span class="comment">// tetrahedra opposite to e are bacf and abdf.  ab is not a subsegment.      //</span>
<a name="l10563"></a>10563 <span class="comment">//                                                                           //</span>
<a name="l10564"></a>10564 <span class="comment">// A 2-to-2 flip is to change two tetrahedra abce and bade into another two  //</span>
<a name="l10565"></a>10565 <span class="comment">// tetrahedra dcae and cdbe. If bacf and abdf exist, they&#39;re changed to cdaf //</span>
<a name="l10566"></a>10566 <span class="comment">// and dcbf, thus a 4-to-4 flip.  As a result, two or four tetrahedra have   //</span>
<a name="l10567"></a>10567 <span class="comment">// rotated counterclockwise (using right-hand rule with thumb points to e):  //</span>
<a name="l10568"></a>10568 <span class="comment">// abce-&gt;dcae, bade-&gt;cdbe, and bacf-&gt;cdaf, abdf-&gt;dcbf.                       //</span>
<a name="l10569"></a>10569 <span class="comment">//                                                                           //</span>
<a name="l10570"></a>10570 <span class="comment">// If abc and bad are subfaces, a 2-to-2 flip is performed simultaneously by //</span>
<a name="l10571"></a>10571 <span class="comment">// calling routine flip22sub(), hence abc-&gt;dca, bad-&gt;cdb.  The edge rings of //</span>
<a name="l10572"></a>10572 <span class="comment">// the flipped subfaces dca and cdb have the same orientation as abc and bad.//</span>
<a name="l10573"></a>10573 <span class="comment">// Hence, they have the same orientation as other subfaces of the facet with //</span>
<a name="l10574"></a>10574 <span class="comment">// respect to the lift point of this facet.                                  //</span>
<a name="l10575"></a>10575 <span class="comment">//                                                                           //</span>
<a name="l10576"></a>10576 <span class="comment">// On completion, &#39;flipface&#39; holds edge dc of tetrahedron dcae. &#39;flipqueue&#39;  //</span>
<a name="l10577"></a>10577 <span class="comment">// contains all possibly non-Delaunay faces if it is not NULL.               //</span>
<a name="l10578"></a>10578 <span class="comment">//                                                                           //</span>
<a name="l10580"></a>10580 <span class="comment"></span>
<a name="l10581"></a>10581 <span class="keywordtype">void</span> tetgenmesh::flip22(triface* flipface, queue* flipqueue)
<a name="l10582"></a>10582 {
<a name="l10583"></a>10583   triface abce, bade;
<a name="l10584"></a>10584   triface oldbce, oldcae, oldade, olddbe;
<a name="l10585"></a>10585   triface bcecasing, caecasing, adecasing, dbecasing;
<a name="l10586"></a>10586   face bcesh, caesh, adesh, dbesh;
<a name="l10587"></a>10587   triface bacf, abdf;
<a name="l10588"></a>10588   triface oldacf, oldcbf, oldbdf, olddaf;
<a name="l10589"></a>10589   triface acfcasing, cbfcasing, bdfcasing, dafcasing;
<a name="l10590"></a>10590   triface worktet;
<a name="l10591"></a>10591   face acfsh, cbfsh, bdfsh, dafsh;
<a name="l10592"></a>10592   face abc, bad;
<a name="l10593"></a>10593   face adseg, dbseg, bcseg, caseg;  <span class="comment">// Coplanar segs.</span>
<a name="l10594"></a>10594   face aeseg, deseg, beseg, ceseg;  <span class="comment">// Above segs.</span>
<a name="l10595"></a>10595   face afseg, dfseg, bfseg, cfseg;  <span class="comment">// Below segs.</span>
<a name="l10596"></a>10596   point pa, pb, pc, pd;
<a name="l10597"></a>10597 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l10598"></a>10598 <span class="preprocessor"></span>  point pe, pf;
<a name="l10599"></a>10599 <span class="preprocessor">#endif</span>
<a name="l10600"></a>10600 <span class="preprocessor"></span>  <span class="keywordtype">int</span> mirrorflag, i;
<a name="l10601"></a>10601 
<a name="l10602"></a>10602   adjustedgering(*flipface, CCW); <span class="comment">// &#39;flipface&#39; is bae.</span>
<a name="l10603"></a>10603   fnext(*flipface, abce);
<a name="l10604"></a>10604   esymself(abce);
<a name="l10605"></a>10605   adjustedgering(*flipface, CW); <span class="comment">// &#39;flipface&#39; is abe.</span>
<a name="l10606"></a>10606   fnext(*flipface, bade);
<a name="l10607"></a>10607 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l10608"></a>10608 <span class="preprocessor"></span>  assert(bade.tet != dummytet);
<a name="l10609"></a>10609 <span class="preprocessor">#endif</span>
<a name="l10610"></a>10610 <span class="preprocessor"></span>  esymself(bade);
<a name="l10611"></a>10611   pa = org(abce);
<a name="l10612"></a>10612   pb = dest(abce);
<a name="l10613"></a>10613   pc = apex(abce);
<a name="l10614"></a>10614   pd = apex(bade);
<a name="l10615"></a>10615 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l10616"></a>10616 <span class="preprocessor"></span>  pe = oppo(bade);
<a name="l10617"></a>10617   assert(oppo(abce) == pe);
<a name="l10618"></a>10618 <span class="preprocessor">#endif</span>
<a name="l10619"></a>10619 <span class="preprocessor"></span>  sym(abce, bacf);
<a name="l10620"></a>10620   mirrorflag = bacf.tet != dummytet;
<a name="l10621"></a>10621   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l10622"></a>10622     <span class="comment">// findedge(&amp;bacf, pb, pa);</span>
<a name="l10623"></a>10623     bacf.ver = 0;
<a name="l10624"></a>10624     <span class="keywordflow">for</span> (i = 0; (i &lt; 3) &amp;&amp; (org(bacf) != pb); i++) {
<a name="l10625"></a>10625       enextself(bacf);
<a name="l10626"></a>10626     }
<a name="l10627"></a>10627     sym(bade, abdf);
<a name="l10628"></a>10628 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l10629"></a>10629 <span class="preprocessor"></span>    assert(abdf.tet != dummytet);
<a name="l10630"></a>10630 <span class="preprocessor">#endif</span>
<a name="l10631"></a>10631 <span class="preprocessor"></span>    <span class="comment">// findedge(&amp;abdf, pa, pb);</span>
<a name="l10632"></a>10632     abdf.ver = 0;
<a name="l10633"></a>10633     <span class="keywordflow">for</span> (i = 0; (i &lt; 3) &amp;&amp; (org(abdf) != pa); i++) {
<a name="l10634"></a>10634       enextself(abdf);
<a name="l10635"></a>10635     }
<a name="l10636"></a>10636 
<a name="l10637"></a>10637 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l10638"></a>10638 <span class="preprocessor"></span>    pf = oppo(bacf);
<a name="l10639"></a>10639     assert(oppo(abdf) == pf);
<a name="l10640"></a>10640 <span class="preprocessor">#endif</span>
<a name="l10641"></a>10641 <span class="preprocessor"></span>  }
<a name="l10642"></a>10642 
<a name="l10643"></a>10643   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l10644"></a>10644     printf(<span class="stringliteral">&quot;    Do %s on edge (%d, %d).\n&quot;</span>, mirrorflag ? <span class="stringliteral">&quot;T44&quot;</span> : <span class="stringliteral">&quot;T22&quot;</span>,
<a name="l10645"></a>10645            pointmark(pa), pointmark(pb));
<a name="l10646"></a>10646   }
<a name="l10647"></a>10647   mirrorflag ? flip44s++ : flip22s++;
<a name="l10648"></a>10648 
<a name="l10649"></a>10649   <span class="comment">// Save the old configuration at the convex hull.</span>
<a name="l10650"></a>10650   enextfnext(abce, oldbce);
<a name="l10651"></a>10651   enext2fnext(abce, oldcae);
<a name="l10652"></a>10652   enextfnext(bade, oldade);
<a name="l10653"></a>10653   enext2fnext(bade, olddbe);
<a name="l10654"></a>10654   sym(oldbce, bcecasing);
<a name="l10655"></a>10655   sym(oldcae, caecasing);
<a name="l10656"></a>10656   sym(oldade, adecasing);
<a name="l10657"></a>10657   sym(olddbe, dbecasing);
<a name="l10658"></a>10658   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l10659"></a>10659     tspivot(oldbce, bcesh);
<a name="l10660"></a>10660     tspivot(oldcae, caesh);
<a name="l10661"></a>10661     tspivot(oldade, adesh);
<a name="l10662"></a>10662     tspivot(olddbe, dbesh);
<a name="l10663"></a>10663     tspivot(abce, abc);
<a name="l10664"></a>10664     tspivot(bade, bad);
<a name="l10665"></a>10665   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l10666"></a>10666     <span class="comment">// Coplanar segs: a-&gt;d-&gt;b-&gt;c.</span>
<a name="l10667"></a>10667     enext(bade, worktet);
<a name="l10668"></a>10668     tsspivot1(worktet, adseg);
<a name="l10669"></a>10669     enext2(bade, worktet);
<a name="l10670"></a>10670     tsspivot1(worktet, dbseg);
<a name="l10671"></a>10671     enext(abce, worktet);
<a name="l10672"></a>10672     tsspivot1(worktet, bcseg);
<a name="l10673"></a>10673     enext2(abce, worktet);
<a name="l10674"></a>10674     tsspivot1(worktet, caseg);
<a name="l10675"></a>10675     <span class="comment">// Above segs: a-&gt;e, d-&gt;e, b-&gt;e, c-&gt;e.</span>
<a name="l10676"></a>10676     fnext(bade, worktet);
<a name="l10677"></a>10677     enextself(worktet);
<a name="l10678"></a>10678     tsspivot1(worktet, aeseg);
<a name="l10679"></a>10679     enextfnext(bade, worktet);
<a name="l10680"></a>10680     enextself(worktet);
<a name="l10681"></a>10681     tsspivot1(worktet, deseg);
<a name="l10682"></a>10682     enext2fnext(bade, worktet);
<a name="l10683"></a>10683     enextself(worktet);
<a name="l10684"></a>10684     tsspivot1(worktet, beseg);
<a name="l10685"></a>10685     enextfnext(abce, worktet);
<a name="l10686"></a>10686     enextself(worktet);
<a name="l10687"></a>10687     tsspivot1(worktet, ceseg);
<a name="l10688"></a>10688   }
<a name="l10689"></a>10689   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l10690"></a>10690     enextfnext(bacf, oldacf);
<a name="l10691"></a>10691     enext2fnext(bacf, oldcbf);
<a name="l10692"></a>10692     enextfnext(abdf, oldbdf);
<a name="l10693"></a>10693     enext2fnext(abdf, olddaf);
<a name="l10694"></a>10694     sym(oldacf, acfcasing);
<a name="l10695"></a>10695     sym(oldcbf, cbfcasing);
<a name="l10696"></a>10696     sym(oldbdf, bdfcasing);
<a name="l10697"></a>10697     sym(olddaf, dafcasing);
<a name="l10698"></a>10698     <span class="keywordflow">if</span> (checksubfaces) {
<a name="l10699"></a>10699       tspivot(oldacf, acfsh);
<a name="l10700"></a>10700       tspivot(oldcbf, cbfsh);
<a name="l10701"></a>10701       tspivot(oldbdf, bdfsh);
<a name="l10702"></a>10702       tspivot(olddaf, dafsh);
<a name="l10703"></a>10703     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l10704"></a>10704       <span class="comment">// Below segs: a-&gt;f, d-&gt;f, b-&gt;f, c-&gt;f.</span>
<a name="l10705"></a>10705       fnext(abdf, worktet);
<a name="l10706"></a>10706       enext2self(worktet);
<a name="l10707"></a>10707       tsspivot1(worktet, afseg);
<a name="l10708"></a>10708       enext2fnext(abdf, worktet);
<a name="l10709"></a>10709       enext2self(worktet);
<a name="l10710"></a>10710       tsspivot1(worktet, dfseg);
<a name="l10711"></a>10711       enextfnext(abdf, worktet);
<a name="l10712"></a>10712       enext2self(worktet);
<a name="l10713"></a>10713       tsspivot1(worktet, bfseg);
<a name="l10714"></a>10714       enextfnext(bacf, worktet);
<a name="l10715"></a>10715       enextself(worktet);
<a name="l10716"></a>10716       tsspivot1(worktet, cfseg);
<a name="l10717"></a>10717     }
<a name="l10718"></a>10718   }
<a name="l10719"></a>10719 
<a name="l10720"></a>10720   <span class="comment">// Rotate abce, bade one-quarter turn counterclockwise.</span>
<a name="l10721"></a>10721   bond(oldbce, caecasing);
<a name="l10722"></a>10722   bond(oldcae, adecasing);
<a name="l10723"></a>10723   bond(oldade, dbecasing);
<a name="l10724"></a>10724   bond(olddbe, bcecasing);
<a name="l10725"></a>10725   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l10726"></a>10726     <span class="comment">// Check for subfaces and rebond them to the rotated tets.</span>
<a name="l10727"></a>10727     <span class="keywordflow">if</span> (caesh.sh == dummysh) {
<a name="l10728"></a>10728       tsdissolve(oldbce);
<a name="l10729"></a>10729     } <span class="keywordflow">else</span> {
<a name="l10730"></a>10730       tsbond(oldbce, caesh);
<a name="l10731"></a>10731     }
<a name="l10732"></a>10732     <span class="keywordflow">if</span> (adesh.sh == dummysh) {
<a name="l10733"></a>10733       tsdissolve(oldcae);
<a name="l10734"></a>10734     } <span class="keywordflow">else</span> {
<a name="l10735"></a>10735       tsbond(oldcae, adesh);
<a name="l10736"></a>10736     }
<a name="l10737"></a>10737     <span class="keywordflow">if</span> (dbesh.sh == dummysh) {
<a name="l10738"></a>10738       tsdissolve(oldade);
<a name="l10739"></a>10739     } <span class="keywordflow">else</span> {
<a name="l10740"></a>10740       tsbond(oldade, dbesh);
<a name="l10741"></a>10741     }
<a name="l10742"></a>10742     <span class="keywordflow">if</span> (bcesh.sh == dummysh) {
<a name="l10743"></a>10743       tsdissolve(olddbe);
<a name="l10744"></a>10744     } <span class="keywordflow">else</span> {
<a name="l10745"></a>10745       tsbond(olddbe, bcesh);
<a name="l10746"></a>10746     }
<a name="l10747"></a>10747   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l10748"></a>10748     <span class="comment">// 5 edges in abce are changed.</span>
<a name="l10749"></a>10749     enext(abce, worktet);  <span class="comment">// fit b-&gt;c into c-&gt;a.</span>
<a name="l10750"></a>10750     <span class="keywordflow">if</span> (caseg.sh == dummysh) {
<a name="l10751"></a>10751       tssdissolve1(worktet);
<a name="l10752"></a>10752     } <span class="keywordflow">else</span> {
<a name="l10753"></a>10753       tssbond1(worktet, caseg);
<a name="l10754"></a>10754     }
<a name="l10755"></a>10755     enext2(abce, worktet); <span class="comment">// fit c-&gt;a into a-&gt;d.</span>
<a name="l10756"></a>10756     <span class="keywordflow">if</span> (adseg.sh == dummysh) {
<a name="l10757"></a>10757       tssdissolve1(worktet);
<a name="l10758"></a>10758     } <span class="keywordflow">else</span> {
<a name="l10759"></a>10759       tssbond1(worktet, adseg);
<a name="l10760"></a>10760     }
<a name="l10761"></a>10761     fnext(abce, worktet); <span class="comment">// fit b-&gt;e into c-&gt;e.</span>
<a name="l10762"></a>10762     enextself(worktet);
<a name="l10763"></a>10763     <span class="keywordflow">if</span> (ceseg.sh == dummysh) {
<a name="l10764"></a>10764       tssdissolve1(worktet);
<a name="l10765"></a>10765     } <span class="keywordflow">else</span> {
<a name="l10766"></a>10766       tssbond1(worktet, ceseg);
<a name="l10767"></a>10767     }
<a name="l10768"></a>10768     enextfnext(abce, worktet); <span class="comment">// fit c-&gt;e into a-&gt;e.</span>
<a name="l10769"></a>10769     enextself(worktet);
<a name="l10770"></a>10770     <span class="keywordflow">if</span> (aeseg.sh == dummysh) {
<a name="l10771"></a>10771       tssdissolve1(worktet);
<a name="l10772"></a>10772     } <span class="keywordflow">else</span> {
<a name="l10773"></a>10773       tssbond1(worktet, aeseg);
<a name="l10774"></a>10774     }
<a name="l10775"></a>10775     enext2fnext(abce, worktet); <span class="comment">// fit a-&gt;e into d-&gt;e.</span>
<a name="l10776"></a>10776     enextself(worktet);
<a name="l10777"></a>10777     <span class="keywordflow">if</span> (deseg.sh == dummysh) {
<a name="l10778"></a>10778       tssdissolve1(worktet);
<a name="l10779"></a>10779     } <span class="keywordflow">else</span> {
<a name="l10780"></a>10780       tssbond1(worktet, deseg);
<a name="l10781"></a>10781     }
<a name="l10782"></a>10782     <span class="comment">// 5 edges in bade are changed.</span>
<a name="l10783"></a>10783     enext(bade, worktet); <span class="comment">// fit a-&gt;d into d-&gt;b.</span>
<a name="l10784"></a>10784     <span class="keywordflow">if</span> (dbseg.sh == dummysh) {
<a name="l10785"></a>10785       tssdissolve1(worktet);
<a name="l10786"></a>10786     } <span class="keywordflow">else</span> {
<a name="l10787"></a>10787       tssbond1(worktet, dbseg);
<a name="l10788"></a>10788     }
<a name="l10789"></a>10789     enext2(bade, worktet); <span class="comment">// fit d-&gt;b into b-&gt;c.</span>
<a name="l10790"></a>10790     <span class="keywordflow">if</span> (bcseg.sh == dummysh) {
<a name="l10791"></a>10791       tssdissolve1(worktet);
<a name="l10792"></a>10792     } <span class="keywordflow">else</span> {
<a name="l10793"></a>10793       tssbond1(worktet, bcseg);
<a name="l10794"></a>10794     }
<a name="l10795"></a>10795     fnext(bade, worktet); <span class="comment">// fit a-&gt;e into d-&gt;e.</span>
<a name="l10796"></a>10796     enextself(worktet);
<a name="l10797"></a>10797     <span class="keywordflow">if</span> (deseg.sh == dummysh) {
<a name="l10798"></a>10798       tssdissolve1(worktet);
<a name="l10799"></a>10799     } <span class="keywordflow">else</span> {
<a name="l10800"></a>10800       tssbond1(worktet, deseg);
<a name="l10801"></a>10801     }
<a name="l10802"></a>10802     enextfnext(bade, worktet); <span class="comment">// fit d-&gt;e into b-&gt;e.</span>
<a name="l10803"></a>10803     enextself(worktet);
<a name="l10804"></a>10804     <span class="keywordflow">if</span> (beseg.sh == dummysh) {
<a name="l10805"></a>10805       tssdissolve1(worktet);
<a name="l10806"></a>10806     } <span class="keywordflow">else</span> {
<a name="l10807"></a>10807       tssbond1(worktet, beseg);
<a name="l10808"></a>10808     }
<a name="l10809"></a>10809     enext2fnext(bade, worktet); <span class="comment">// fit b-&gt;e into c-&gt;e.</span>
<a name="l10810"></a>10810     enextself(worktet);
<a name="l10811"></a>10811     <span class="keywordflow">if</span> (ceseg.sh == dummysh) {
<a name="l10812"></a>10812       tssdissolve1(worktet);
<a name="l10813"></a>10813     } <span class="keywordflow">else</span> {
<a name="l10814"></a>10814       tssbond1(worktet, ceseg);
<a name="l10815"></a>10815     }
<a name="l10816"></a>10816   }
<a name="l10817"></a>10817   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l10818"></a>10818     <span class="comment">// Rotate bacf, abdf one-quarter turn counterclockwise.</span>
<a name="l10819"></a>10819     bond(oldcbf, acfcasing);
<a name="l10820"></a>10820     bond(oldacf, dafcasing);
<a name="l10821"></a>10821     bond(olddaf, bdfcasing);
<a name="l10822"></a>10822     bond(oldbdf, cbfcasing);
<a name="l10823"></a>10823     <span class="keywordflow">if</span> (checksubfaces) {
<a name="l10824"></a>10824       <span class="comment">// Check for subfaces and rebond them to the rotated tets.</span>
<a name="l10825"></a>10825       <span class="keywordflow">if</span> (acfsh.sh == dummysh) {
<a name="l10826"></a>10826         tsdissolve(oldcbf);
<a name="l10827"></a>10827       } <span class="keywordflow">else</span> {
<a name="l10828"></a>10828         tsbond(oldcbf, acfsh);
<a name="l10829"></a>10829       }
<a name="l10830"></a>10830       <span class="keywordflow">if</span> (dafsh.sh == dummysh) {
<a name="l10831"></a>10831         tsdissolve(oldacf);
<a name="l10832"></a>10832       } <span class="keywordflow">else</span> {
<a name="l10833"></a>10833         tsbond(oldacf, dafsh);
<a name="l10834"></a>10834       }
<a name="l10835"></a>10835       <span class="keywordflow">if</span> (bdfsh.sh == dummysh) {
<a name="l10836"></a>10836         tsdissolve(olddaf);
<a name="l10837"></a>10837       } <span class="keywordflow">else</span> {
<a name="l10838"></a>10838         tsbond(olddaf, bdfsh);
<a name="l10839"></a>10839       }
<a name="l10840"></a>10840       <span class="keywordflow">if</span> (cbfsh.sh == dummysh) {
<a name="l10841"></a>10841         tsdissolve(oldbdf);
<a name="l10842"></a>10842       } <span class="keywordflow">else</span> {
<a name="l10843"></a>10843         tsbond(oldbdf, cbfsh);
<a name="l10844"></a>10844       }
<a name="l10845"></a>10845     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l10846"></a>10846       <span class="comment">// 5 edges in bacf are changed.</span>
<a name="l10847"></a>10847       enext2(bacf, worktet); <span class="comment">// fit b-&gt;c into c-&gt;a.</span>
<a name="l10848"></a>10848       <span class="keywordflow">if</span> (caseg.sh == dummysh) {
<a name="l10849"></a>10849         tssdissolve1(worktet);
<a name="l10850"></a>10850       } <span class="keywordflow">else</span> {
<a name="l10851"></a>10851         tssbond1(worktet, caseg);
<a name="l10852"></a>10852       }
<a name="l10853"></a>10853       enext(bacf, worktet); <span class="comment">// fit c-&gt;a into a-&gt;d.</span>
<a name="l10854"></a>10854       <span class="keywordflow">if</span> (adseg.sh == dummysh) {
<a name="l10855"></a>10855         tssdissolve1(worktet);
<a name="l10856"></a>10856       } <span class="keywordflow">else</span> {
<a name="l10857"></a>10857         tssbond1(worktet, adseg);
<a name="l10858"></a>10858       }
<a name="l10859"></a>10859       fnext(bacf, worktet); <span class="comment">// fit b-&gt;f into c-&gt;f.</span>
<a name="l10860"></a>10860       enext2self(worktet);
<a name="l10861"></a>10861       <span class="keywordflow">if</span> (cfseg.sh == dummysh) {
<a name="l10862"></a>10862         tssdissolve1(worktet);
<a name="l10863"></a>10863       } <span class="keywordflow">else</span> {
<a name="l10864"></a>10864         tssbond1(worktet, cfseg);
<a name="l10865"></a>10865       }
<a name="l10866"></a>10866       enext2fnext(bacf, worktet); <span class="comment">// fit c-&gt;f into a-&gt;f.</span>
<a name="l10867"></a>10867       enext2self(worktet);
<a name="l10868"></a>10868       <span class="keywordflow">if</span> (afseg.sh == dummysh) {
<a name="l10869"></a>10869         tssdissolve1(worktet);
<a name="l10870"></a>10870       } <span class="keywordflow">else</span> {
<a name="l10871"></a>10871         tssbond1(worktet, afseg);
<a name="l10872"></a>10872       }
<a name="l10873"></a>10873       enextfnext(bacf, worktet); <span class="comment">// fit a-&gt;f into d-&gt;f.</span>
<a name="l10874"></a>10874       enext2self(worktet);
<a name="l10875"></a>10875       <span class="keywordflow">if</span> (dfseg.sh == dummysh) {
<a name="l10876"></a>10876         tssdissolve1(worktet);
<a name="l10877"></a>10877       } <span class="keywordflow">else</span> {
<a name="l10878"></a>10878         tssbond1(worktet, dfseg);
<a name="l10879"></a>10879       }
<a name="l10880"></a>10880       <span class="comment">// 5 edges in abdf are changed.</span>
<a name="l10881"></a>10881       enext2(abdf, worktet); <span class="comment">// fit a-&gt;d into d-&gt;b.</span>
<a name="l10882"></a>10882       <span class="keywordflow">if</span> (dbseg.sh == dummysh) {
<a name="l10883"></a>10883         tssdissolve1(worktet);
<a name="l10884"></a>10884       } <span class="keywordflow">else</span> {
<a name="l10885"></a>10885         tssbond1(worktet, dbseg);
<a name="l10886"></a>10886       }
<a name="l10887"></a>10887       enext(abdf, worktet); <span class="comment">// fit d-&gt;b into b-&gt;c.</span>
<a name="l10888"></a>10888       <span class="keywordflow">if</span> (bcseg.sh == dummysh) {
<a name="l10889"></a>10889         tssdissolve1(worktet);
<a name="l10890"></a>10890       } <span class="keywordflow">else</span> {
<a name="l10891"></a>10891         tssbond1(worktet, bcseg);
<a name="l10892"></a>10892       }
<a name="l10893"></a>10893       fnext(abdf, worktet); <span class="comment">// fit a-&gt;f into d-&gt;f.</span>
<a name="l10894"></a>10894       enext2self(worktet);
<a name="l10895"></a>10895       <span class="keywordflow">if</span> (dfseg.sh == dummysh) {
<a name="l10896"></a>10896         tssdissolve1(worktet);
<a name="l10897"></a>10897       } <span class="keywordflow">else</span> {
<a name="l10898"></a>10898         tssbond1(worktet, dfseg);
<a name="l10899"></a>10899       }
<a name="l10900"></a>10900       enext2fnext(abdf, worktet); <span class="comment">// fit d-&gt;f into b-&gt;f.</span>
<a name="l10901"></a>10901       enext2self(worktet);
<a name="l10902"></a>10902       <span class="keywordflow">if</span> (bfseg.sh == dummysh) {
<a name="l10903"></a>10903         tssdissolve1(worktet);
<a name="l10904"></a>10904       } <span class="keywordflow">else</span> {
<a name="l10905"></a>10905         tssbond1(worktet, bfseg);
<a name="l10906"></a>10906       }
<a name="l10907"></a>10907       enextfnext(abdf, worktet); <span class="comment">// fit b-&gt;f into c-&gt;f.</span>
<a name="l10908"></a>10908       enext2self(worktet);
<a name="l10909"></a>10909       <span class="keywordflow">if</span> (cfseg.sh == dummysh) {
<a name="l10910"></a>10910         tssdissolve1(worktet);
<a name="l10911"></a>10911       } <span class="keywordflow">else</span> {
<a name="l10912"></a>10912         tssbond1(worktet, cfseg);
<a name="l10913"></a>10913       }
<a name="l10914"></a>10914     }
<a name="l10915"></a>10915   }
<a name="l10916"></a>10916 
<a name="l10917"></a>10917   <span class="comment">// New vertex assignments for the rotated tetrahedra.</span>
<a name="l10918"></a>10918   setorg(abce, pd); <span class="comment">// Update abce to dcae</span>
<a name="l10919"></a>10919   setdest(abce, pc);
<a name="l10920"></a>10920   setapex(abce, pa);
<a name="l10921"></a>10921   setorg(bade, pc); <span class="comment">// Update bade to cdbe</span>
<a name="l10922"></a>10922   setdest(bade, pd);
<a name="l10923"></a>10923   setapex(bade, pb);
<a name="l10924"></a>10924   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l10925"></a>10925     setorg(bacf, pc); <span class="comment">// Update bacf to cdaf</span>
<a name="l10926"></a>10926     setdest(bacf, pd);
<a name="l10927"></a>10927     setapex(bacf, pa);
<a name="l10928"></a>10928     setorg(abdf, pd); <span class="comment">// Update abdf to dcbf</span>
<a name="l10929"></a>10929     setdest(abdf, pc);
<a name="l10930"></a>10930     setapex(abdf, pb);
<a name="l10931"></a>10931   }
<a name="l10932"></a>10932 
<a name="l10933"></a>10933   <span class="comment">// Are there subfaces need to be flipped?</span>
<a name="l10934"></a>10934   <span class="keywordflow">if</span> (checksubfaces &amp;&amp; abc.sh != dummysh) {
<a name="l10935"></a>10935 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l10936"></a>10936 <span class="preprocessor"></span>    assert(bad.sh != dummysh);
<a name="l10937"></a>10937 <span class="preprocessor">#endif</span>
<a name="l10938"></a>10938 <span class="preprocessor"></span>    <span class="comment">// Adjust the edge be ab, so the rotation of subfaces is according with</span>
<a name="l10939"></a>10939     <span class="comment">//   the rotation of tetrahedra.</span>
<a name="l10940"></a>10940     findedge(&amp;abc, pa, pb);
<a name="l10941"></a>10941     <span class="comment">// Flip an edge of two subfaces, ignore non-Delaunay edges.</span>
<a name="l10942"></a>10942     flip22sub(&amp;abc, NULL);
<a name="l10943"></a>10943   }
<a name="l10944"></a>10944 
<a name="l10945"></a>10945   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l10946"></a>10946     printf(<span class="stringliteral">&quot;    Updating abce &quot;</span>);
<a name="l10947"></a>10947     printtet(&amp;abce);
<a name="l10948"></a>10948     printf(<span class="stringliteral">&quot;    Updating bade &quot;</span>);
<a name="l10949"></a>10949     printtet(&amp;bade);
<a name="l10950"></a>10950     <span class="keywordflow">if</span> (mirrorflag) {
<a name="l10951"></a>10951       printf(<span class="stringliteral">&quot;    Updating bacf &quot;</span>);
<a name="l10952"></a>10952       printtet(&amp;bacf);
<a name="l10953"></a>10953       printf(<span class="stringliteral">&quot;    Updating abdf &quot;</span>);
<a name="l10954"></a>10954       printtet(&amp;abdf);
<a name="l10955"></a>10955     }
<a name="l10956"></a>10956   }
<a name="l10957"></a>10957 
<a name="l10958"></a>10958   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l10959"></a>10959     enextfnext(abce, bcecasing);
<a name="l10960"></a>10960     enqueueflipface(bcecasing, flipqueue);
<a name="l10961"></a>10961     enext2fnext(abce, caecasing);
<a name="l10962"></a>10962     enqueueflipface(caecasing, flipqueue);
<a name="l10963"></a>10963     enextfnext(bade, adecasing);
<a name="l10964"></a>10964     enqueueflipface(adecasing, flipqueue);
<a name="l10965"></a>10965     enext2fnext(bade, dbecasing);
<a name="l10966"></a>10966     enqueueflipface(dbecasing, flipqueue);
<a name="l10967"></a>10967     <span class="keywordflow">if</span> (mirrorflag) {
<a name="l10968"></a>10968       enextfnext(bacf, acfcasing);
<a name="l10969"></a>10969       enqueueflipface(acfcasing, flipqueue);
<a name="l10970"></a>10970       enext2fnext(bacf, cbfcasing);
<a name="l10971"></a>10971       enqueueflipface(cbfcasing, flipqueue);
<a name="l10972"></a>10972       enextfnext(abdf, bdfcasing);
<a name="l10973"></a>10973       enqueueflipface(bdfcasing, flipqueue);
<a name="l10974"></a>10974       enext2fnext(abdf, dafcasing);
<a name="l10975"></a>10975       enqueueflipface(dafcasing, flipqueue);
<a name="l10976"></a>10976     }
<a name="l10977"></a>10977     <span class="comment">// The two new faces dcae (abce), cdbe (bade) may still not be locally</span>
<a name="l10978"></a>10978     <span class="comment">//   Delaunay, and may need be flipped (flip23).  On the other hand, in</span>
<a name="l10979"></a>10979     <span class="comment">//   conforming Delaunay algorithm, two new subfaces dca (abc), and cdb</span>
<a name="l10980"></a>10980     <span class="comment">//   (bad) may be non-conforming Delaunay, they need be queued if they</span>
<a name="l10981"></a>10981     <span class="comment">//   are locally Delaunay but non-conforming Delaunay.</span>
<a name="l10982"></a>10982     enqueueflipface(abce, flipqueue);
<a name="l10983"></a>10983     enqueueflipface(bade, flipqueue);
<a name="l10984"></a>10984   }
<a name="l10985"></a>10985 
<a name="l10986"></a>10986   <span class="comment">// Save a live handle in &#39;recenttet&#39;.</span>
<a name="l10987"></a>10987   recenttet = abce;
<a name="l10988"></a>10988 }
<a name="l10989"></a>10989 
<a name="l10991"></a>10991 <span class="comment">//                                                                           //</span>
<a name="l10992"></a>10992 <span class="comment">// flip22sub()    Perform a 2-to-2 flip on a subface edge.                   //</span>
<a name="l10993"></a>10993 <span class="comment">//                                                                           //</span>
<a name="l10994"></a>10994 <span class="comment">// The flip edge is given by subface &#39;flipedge&#39;.  Let it is abc, where ab is //</span>
<a name="l10995"></a>10995 <span class="comment">// the flipping edge.  The other subface is bad,  where a, b, c, d form a    //</span>
<a name="l10996"></a>10996 <span class="comment">// convex quadrilateral.  ab is not a subsegment.                            //</span>
<a name="l10997"></a>10997 <span class="comment">//                                                                           //</span>
<a name="l10998"></a>10998 <span class="comment">// A 2-to-2 subface flip is to change two subfaces abc and bad to another    //</span>
<a name="l10999"></a>10999 <span class="comment">// two subfaces dca and cdb.  Hence, edge ab has been removed and dc becomes //</span>
<a name="l11000"></a>11000 <span class="comment">// an edge. If a point e is above abc, this flip is equal to rotate abc and  //</span>
<a name="l11001"></a>11001 <span class="comment">// bad counterclockwise using right-hand rule with thumb points to e. It is  //</span>
<a name="l11002"></a>11002 <span class="comment">// important to know that the edge rings of the flipped subfaces dca and cdb //</span>
<a name="l11003"></a>11003 <span class="comment">// are keeping the same orientation as their original subfaces. So they have //</span>
<a name="l11004"></a>11004 <span class="comment">// the same orientation with respect to the lift point of this facet.        //</span>
<a name="l11005"></a>11005 <span class="comment">//                                                                           //</span>
<a name="l11006"></a>11006 <span class="comment">// During rotating, the face rings of the four edges bc, ca, ad, and de need //</span>
<a name="l11007"></a>11007 <span class="comment">// be re-connected. If the edge is not a subsegment, then its face ring has  //</span>
<a name="l11008"></a>11008 <span class="comment">// only two faces, a sbond() will bond them together. If it is a subsegment, //</span>
<a name="l11009"></a>11009 <span class="comment">// one should use sbond1() twice to bond two different handles to the rotat- //</span>
<a name="l11010"></a>11010 <span class="comment">// ing subface, one is predecssor (-casin), another is successor (-casout).  //</span>
<a name="l11011"></a>11011 <span class="comment">//                                                                           //</span>
<a name="l11012"></a>11012 <span class="comment">// If &#39;flipqueue&#39; is not NULL, it returns four edges bc, ca, ad, de, which   //</span>
<a name="l11013"></a>11013 <span class="comment">// may be non-Delaunay.                                                      //</span>
<a name="l11014"></a>11014 <span class="comment">//                                                                           //</span>
<a name="l11016"></a>11016 <span class="comment"></span>
<a name="l11017"></a>11017 <span class="keywordtype">void</span> tetgenmesh::flip22sub(face* flipedge, queue* flipqueue)
<a name="l11018"></a>11018 {
<a name="l11019"></a>11019   face abc, bad;
<a name="l11020"></a>11020   face oldbc, oldca, oldad, olddb;
<a name="l11021"></a>11021   face bccasin, bccasout, cacasin, cacasout;
<a name="l11022"></a>11022   face adcasin, adcasout, dbcasin, dbcasout;
<a name="l11023"></a>11023   face bc, ca, ad, db;
<a name="l11024"></a>11024   face spinsh;
<a name="l11025"></a>11025   point pa, pb, pc, pd;
<a name="l11026"></a>11026 
<a name="l11027"></a>11027   abc = *flipedge;
<a name="l11028"></a>11028   spivot(abc, bad);
<a name="l11029"></a>11029   <span class="keywordflow">if</span> (sorg(bad) != sdest(abc)) {
<a name="l11030"></a>11030     sesymself(bad);
<a name="l11031"></a>11031   }
<a name="l11032"></a>11032   pa = sorg(abc);
<a name="l11033"></a>11033   pb = sdest(abc);
<a name="l11034"></a>11034   pc = sapex(abc);
<a name="l11035"></a>11035   pd = sapex(bad);
<a name="l11036"></a>11036 
<a name="l11037"></a>11037   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l11038"></a>11038     printf(<span class="stringliteral">&quot;    Flip sub edge (%d, %d).\n&quot;</span>, pointmark(pa), pointmark(pb));
<a name="l11039"></a>11039   }
<a name="l11040"></a>11040 
<a name="l11041"></a>11041   <span class="comment">// Save the old configuration outside the quadrilateral.</span>
<a name="l11042"></a>11042   senext(abc, oldbc);
<a name="l11043"></a>11043   senext2(abc, oldca);
<a name="l11044"></a>11044   senext(bad, oldad);
<a name="l11045"></a>11045   senext2(bad, olddb);
<a name="l11046"></a>11046   <span class="comment">// Get the outside connection. Becareful if there is a subsegment on the</span>
<a name="l11047"></a>11047   <span class="comment">//   quadrilateral, two casings (casin and casout) are needed to save for</span>
<a name="l11048"></a>11048   <span class="comment">//   keeping the face link.</span>
<a name="l11049"></a>11049   spivot(oldbc, bccasout);
<a name="l11050"></a>11050   sspivot(oldbc, bc);
<a name="l11051"></a>11051   <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l11052"></a>11052     <span class="comment">// &#39;bc&#39; is a subsegment.</span>
<a name="l11053"></a>11053     <span class="keywordflow">if</span> (bccasout.sh != dummysh) {
<a name="l11054"></a>11054       <span class="keywordflow">if</span> (oldbc.sh != bccasout.sh) {
<a name="l11055"></a>11055         <span class="comment">// &#39;oldbc&#39; is not self-bonded.</span>
<a name="l11056"></a>11056         spinsh = bccasout;
<a name="l11057"></a>11057         <span class="keywordflow">do</span> {
<a name="l11058"></a>11058           bccasin = spinsh;
<a name="l11059"></a>11059           spivotself(spinsh);
<a name="l11060"></a>11060         } <span class="keywordflow">while</span> (spinsh.sh != oldbc.sh);
<a name="l11061"></a>11061       } <span class="keywordflow">else</span> {
<a name="l11062"></a>11062         bccasout.sh = dummysh;
<a name="l11063"></a>11063       }
<a name="l11064"></a>11064     }
<a name="l11065"></a>11065     ssdissolve(oldbc);
<a name="l11066"></a>11066   }
<a name="l11067"></a>11067   spivot(oldca, cacasout);
<a name="l11068"></a>11068   sspivot(oldca, ca);
<a name="l11069"></a>11069   <span class="keywordflow">if</span> (ca.sh != dummysh) {
<a name="l11070"></a>11070     <span class="comment">// &#39;ca&#39; is a subsegment.</span>
<a name="l11071"></a>11071     <span class="keywordflow">if</span> (cacasout.sh != dummysh) {
<a name="l11072"></a>11072       <span class="keywordflow">if</span> (oldca.sh != cacasout.sh) {
<a name="l11073"></a>11073         <span class="comment">// &#39;oldca&#39; is not self-bonded.</span>
<a name="l11074"></a>11074         spinsh = cacasout;
<a name="l11075"></a>11075         <span class="keywordflow">do</span> {
<a name="l11076"></a>11076           cacasin = spinsh;
<a name="l11077"></a>11077           spivotself(spinsh);
<a name="l11078"></a>11078         } <span class="keywordflow">while</span> (spinsh.sh != oldca.sh);
<a name="l11079"></a>11079       } <span class="keywordflow">else</span> {
<a name="l11080"></a>11080         cacasout.sh = dummysh;
<a name="l11081"></a>11081       }
<a name="l11082"></a>11082     }
<a name="l11083"></a>11083     ssdissolve(oldca);
<a name="l11084"></a>11084   }
<a name="l11085"></a>11085   spivot(oldad, adcasout);
<a name="l11086"></a>11086   sspivot(oldad, ad);
<a name="l11087"></a>11087   <span class="keywordflow">if</span> (ad.sh != dummysh) {
<a name="l11088"></a>11088     <span class="comment">// &#39;ad&#39; is a subsegment.</span>
<a name="l11089"></a>11089     <span class="keywordflow">if</span> (adcasout.sh != dummysh) {
<a name="l11090"></a>11090       <span class="keywordflow">if</span> (oldad.sh != adcasout.sh) {
<a name="l11091"></a>11091         <span class="comment">// &#39;adcasout&#39; is not self-bonded.</span>
<a name="l11092"></a>11092         spinsh = adcasout;
<a name="l11093"></a>11093         <span class="keywordflow">do</span> {
<a name="l11094"></a>11094           adcasin = spinsh;
<a name="l11095"></a>11095           spivotself(spinsh);
<a name="l11096"></a>11096         } <span class="keywordflow">while</span> (spinsh.sh != oldad.sh);
<a name="l11097"></a>11097       } <span class="keywordflow">else</span> {
<a name="l11098"></a>11098         adcasout.sh = dummysh;
<a name="l11099"></a>11099       }
<a name="l11100"></a>11100     }
<a name="l11101"></a>11101     ssdissolve(oldad);
<a name="l11102"></a>11102   }
<a name="l11103"></a>11103   spivot(olddb, dbcasout);
<a name="l11104"></a>11104   sspivot(olddb, db);
<a name="l11105"></a>11105   <span class="keywordflow">if</span> (db.sh != dummysh) {
<a name="l11106"></a>11106     <span class="comment">// &#39;db&#39; is a subsegment.</span>
<a name="l11107"></a>11107     <span class="keywordflow">if</span> (dbcasout.sh != dummysh) {
<a name="l11108"></a>11108       <span class="keywordflow">if</span> (olddb.sh != dbcasout.sh) {
<a name="l11109"></a>11109         <span class="comment">// &#39;dbcasout&#39; is not self-bonded.</span>
<a name="l11110"></a>11110         spinsh = dbcasout;
<a name="l11111"></a>11111         <span class="keywordflow">do</span> {
<a name="l11112"></a>11112           dbcasin = spinsh;
<a name="l11113"></a>11113           spivotself(spinsh);
<a name="l11114"></a>11114         } <span class="keywordflow">while</span> (spinsh.sh != olddb.sh);
<a name="l11115"></a>11115       } <span class="keywordflow">else</span> {
<a name="l11116"></a>11116         dbcasout.sh = dummysh;
<a name="l11117"></a>11117       }
<a name="l11118"></a>11118     }
<a name="l11119"></a>11119     ssdissolve(olddb);
<a name="l11120"></a>11120   }
<a name="l11121"></a>11121 
<a name="l11122"></a>11122   <span class="comment">// Rotate abc and bad one-quarter turn counterclockwise.</span>
<a name="l11123"></a>11123   <span class="keywordflow">if</span> (ca.sh != dummysh) {
<a name="l11124"></a>11124     <span class="keywordflow">if</span> (cacasout.sh != dummysh) {
<a name="l11125"></a>11125       sbond1(cacasin, oldbc);
<a name="l11126"></a>11126       sbond1(oldbc, cacasout);
<a name="l11127"></a>11127     } <span class="keywordflow">else</span> {
<a name="l11128"></a>11128       <span class="comment">// Bond &#39;oldbc&#39; to itself.</span>
<a name="l11129"></a>11129       sbond(oldbc, oldbc);
<a name="l11130"></a>11130       <span class="comment">// Make sure that dummysh always correctly bonded.</span>
<a name="l11131"></a>11131       dummysh[0] = sencode(oldbc);
<a name="l11132"></a>11132     }
<a name="l11133"></a>11133     ssbond(oldbc, ca);
<a name="l11134"></a>11134   } <span class="keywordflow">else</span> {
<a name="l11135"></a>11135     sbond(oldbc, cacasout);
<a name="l11136"></a>11136   }
<a name="l11137"></a>11137   <span class="keywordflow">if</span> (ad.sh != dummysh) {
<a name="l11138"></a>11138     <span class="keywordflow">if</span> (adcasout.sh != dummysh) {
<a name="l11139"></a>11139       sbond1(adcasin, oldca);
<a name="l11140"></a>11140       sbond1(oldca, adcasout);
<a name="l11141"></a>11141     } <span class="keywordflow">else</span> {
<a name="l11142"></a>11142       <span class="comment">// Bond &#39;oldca&#39; to itself.</span>
<a name="l11143"></a>11143       sbond(oldca, oldca);
<a name="l11144"></a>11144       <span class="comment">// Make sure that dummysh always correctly bonded.</span>
<a name="l11145"></a>11145       dummysh[0] = sencode(oldca);
<a name="l11146"></a>11146     }
<a name="l11147"></a>11147     ssbond(oldca, ad);
<a name="l11148"></a>11148   } <span class="keywordflow">else</span> {
<a name="l11149"></a>11149     sbond(oldca, adcasout);
<a name="l11150"></a>11150   }
<a name="l11151"></a>11151   <span class="keywordflow">if</span> (db.sh != dummysh) {
<a name="l11152"></a>11152     <span class="keywordflow">if</span> (dbcasout.sh != dummysh) {
<a name="l11153"></a>11153       sbond1(dbcasin, oldad);
<a name="l11154"></a>11154       sbond1(oldad, dbcasout);
<a name="l11155"></a>11155     } <span class="keywordflow">else</span> {
<a name="l11156"></a>11156       <span class="comment">// Bond &#39;oldad&#39; to itself.</span>
<a name="l11157"></a>11157       sbond(oldad, oldad);
<a name="l11158"></a>11158       <span class="comment">// Make sure that dummysh always correctly bonded.</span>
<a name="l11159"></a>11159       dummysh[0] = sencode(oldad);
<a name="l11160"></a>11160     }
<a name="l11161"></a>11161     ssbond(oldad, db);
<a name="l11162"></a>11162   } <span class="keywordflow">else</span> {
<a name="l11163"></a>11163     sbond(oldad, dbcasout);
<a name="l11164"></a>11164   }
<a name="l11165"></a>11165   <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l11166"></a>11166     <span class="keywordflow">if</span> (bccasout.sh != dummysh) {
<a name="l11167"></a>11167       sbond1(bccasin, olddb);
<a name="l11168"></a>11168       sbond1(olddb, bccasout);
<a name="l11169"></a>11169     } <span class="keywordflow">else</span> {
<a name="l11170"></a>11170       <span class="comment">// Bond &#39;olddb&#39; to itself.</span>
<a name="l11171"></a>11171       sbond(olddb, olddb);
<a name="l11172"></a>11172       <span class="comment">// Make sure that dummysh always correctly bonded.</span>
<a name="l11173"></a>11173       dummysh[0] = sencode(olddb);
<a name="l11174"></a>11174     }
<a name="l11175"></a>11175     ssbond(olddb, bc);
<a name="l11176"></a>11176   } <span class="keywordflow">else</span> {
<a name="l11177"></a>11177     sbond(olddb, bccasout);
<a name="l11178"></a>11178   }
<a name="l11179"></a>11179 
<a name="l11180"></a>11180   <span class="comment">// New vertex assignments for the rotated subfaces.</span>
<a name="l11181"></a>11181   setsorg(abc, pd);  <span class="comment">// Update abc to dca.</span>
<a name="l11182"></a>11182   setsdest(abc, pc);
<a name="l11183"></a>11183   setsapex(abc, pa);
<a name="l11184"></a>11184   setsorg(bad, pc);  <span class="comment">// Update bad to cdb.</span>
<a name="l11185"></a>11185   setsdest(bad, pd);
<a name="l11186"></a>11186   setsapex(bad, pb);
<a name="l11187"></a>11187 
<a name="l11188"></a>11188   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l11189"></a>11189     enqueueflipedge(bccasout, flipqueue);
<a name="l11190"></a>11190     enqueueflipedge(cacasout, flipqueue);
<a name="l11191"></a>11191     enqueueflipedge(adcasout, flipqueue);
<a name="l11192"></a>11192     enqueueflipedge(dbcasout, flipqueue);
<a name="l11193"></a>11193   }
<a name="l11194"></a>11194 }
<a name="l11195"></a>11195 
<a name="l11197"></a>11197 <span class="comment">//                                                                           //</span>
<a name="l11198"></a>11198 <span class="comment">// flip()    Flips non-locally Delaunay faces in flipqueue until it is empty.//</span>
<a name="l11199"></a>11199 <span class="comment">//                                                                           //</span>
<a name="l11200"></a>11200 <span class="comment">// Assumpation:  Current tetrahedralization is non-Delaunay after inserting  //</span>
<a name="l11201"></a>11201 <span class="comment">// a point or performing a flip operation, all possibly non-Delaunay faces   //</span>
<a name="l11202"></a>11202 <span class="comment">// are in &#39;flipqueue&#39;.                                                       //</span>
<a name="l11203"></a>11203 <span class="comment">//                                                                           //</span>
<a name="l11204"></a>11204 <span class="comment">// If &#39;plastflip&#39; is not NULL,  it is used to return a stack of recently     //</span>
<a name="l11205"></a>11205 <span class="comment">// flipped faces.  This stack will be used to reverse the flips done in this //</span>
<a name="l11206"></a>11206 <span class="comment">// routine later for removing a newly inserted point because it encroaches   //</span>
<a name="l11207"></a>11207 <span class="comment">// any subfaces or subsegments.                                              //</span>
<a name="l11208"></a>11208 <span class="comment">//                                                                           //</span>
<a name="l11209"></a>11209 <span class="comment">// The return value is the total number of flips done during this invocation.//</span>
<a name="l11210"></a>11210 <span class="comment">//                                                                           //</span>
<a name="l11212"></a>11212 <span class="comment"></span>
<a name="l11213"></a>11213 <span class="keywordtype">long</span> tetgenmesh::flip(queue* flipqueue, badface **plastflip)
<a name="l11214"></a>11214 {
<a name="l11215"></a>11215   badface *qface, *newflip;
<a name="l11216"></a>11216   triface flipface, symface;
<a name="l11217"></a>11217   point pa, pb, pc, pd, pe;
<a name="l11218"></a>11218   <span class="keyword">enum</span> fliptype fc;
<a name="l11219"></a>11219   REAL sign, bakepsilon;
<a name="l11220"></a>11220   <span class="keywordtype">long</span> flipcount; <span class="comment">//, maxfaces; - commented out to get gcc4.6 working</span>
<a name="l11221"></a>11221   <span class="keywordtype">int</span> epscount, fcount;
<a name="l11222"></a>11222   <span class="keywordtype">int</span> ia, ib, ic, id, ie;
<a name="l11223"></a>11223 
<a name="l11224"></a>11224   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l11225"></a>11225     printf(<span class="stringliteral">&quot;    Do flipface queue: %ld faces.\n&quot;</span>, flipqueue-&gt;len());
<a name="l11226"></a>11226   }
<a name="l11227"></a>11227 
<a name="l11228"></a>11228   flipcount = flip23s + flip32s + flip22s + flip44s;
<a name="l11229"></a>11229   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11230"></a>11230     <span class="comment">//maxfaces = (4l * tetrahedrons-&gt;items + hullsize) / 2l; // commented out to get gcc 4.6 working</span>
<a name="l11231"></a>11231     fcount = 0;
<a name="l11232"></a>11232   }
<a name="l11233"></a>11233 
<a name="l11234"></a>11234   <span class="keywordflow">if</span> (plastflip != (badface **) NULL) {
<a name="l11235"></a>11235     <span class="comment">// Initialize the stack of the flip sequence.</span>
<a name="l11236"></a>11236     flipstackers-&gt;restart();
<a name="l11237"></a>11237     *plastflip = (badface *) NULL;
<a name="l11238"></a>11238   }
<a name="l11239"></a>11239 
<a name="l11240"></a>11240   <span class="comment">// Loop until the queue is empty.</span>
<a name="l11241"></a>11241   <span class="keywordflow">while</span> (!flipqueue-&gt;empty()) {
<a name="l11242"></a>11242     qface = (badface *) flipqueue-&gt;pop();
<a name="l11243"></a>11243     flipface = qface-&gt;tt;
<a name="l11244"></a>11244     <span class="keywordflow">if</span> (isdead(&amp;flipface)) <span class="keywordflow">continue</span>;
<a name="l11245"></a>11245     sym(flipface, symface);
<a name="l11246"></a>11246     <span class="comment">// Only do check when the adjacent tet exists and it&#39;s not a &quot;fake&quot; tet.</span>
<a name="l11247"></a>11247     <span class="keywordflow">if</span> ((symface.tet != dummytet) &amp;&amp; (oppo(symface) == qface-&gt;foppo)) {
<a name="l11248"></a>11248       <span class="comment">// For positive orientation that insphere() test requires.</span>
<a name="l11249"></a>11249       adjustedgering(flipface, CW);
<a name="l11250"></a>11250       pa = org(flipface);
<a name="l11251"></a>11251       pb = dest(flipface);
<a name="l11252"></a>11252       pc = apex(flipface);
<a name="l11253"></a>11253       pd = oppo(flipface);
<a name="l11254"></a>11254       pe = oppo(symface);
<a name="l11255"></a>11255       <span class="keywordflow">if</span> (symbolic) {
<a name="l11256"></a>11256         ia = pointmark(pa);
<a name="l11257"></a>11257         ib = pointmark(pb);
<a name="l11258"></a>11258         ic = pointmark(pc);
<a name="l11259"></a>11259         <span class="keywordtype">id</span> = pointmark(pd);
<a name="l11260"></a>11260         ie = pointmark(pe);
<a name="l11261"></a>11261         sign = insphere_sos(pa, pb, pc, pd, pe, ia, ib, ic, <span class="keywordtype">id</span>, ie);
<a name="l11262"></a>11262         assert(sign != 0.0);
<a name="l11263"></a>11263       } <span class="keywordflow">else</span> {
<a name="l11264"></a>11264         sign = insphere(pa, pb, pc, pd, pe);
<a name="l11265"></a>11265       }
<a name="l11266"></a>11266     } <span class="keywordflow">else</span> {
<a name="l11267"></a>11267       sign = -1.0; <span class="comment">// A hull face is locally Delaunay.</span>
<a name="l11268"></a>11268     }
<a name="l11269"></a>11269     <span class="keywordflow">if</span> (sign &gt; 0.0) {
<a name="l11270"></a>11270       <span class="comment">// &#39;flipface&#39; is non-locally Delaunay, try to flip it.</span>
<a name="l11271"></a>11271       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11272"></a>11272         fcount++;
<a name="l11273"></a>11273         bakepsilon = b-&gt;epsilon;
<a name="l11274"></a>11274         epscount = 0;
<a name="l11275"></a>11275         <span class="keywordflow">while</span> (epscount &lt; 32) {
<a name="l11276"></a>11276           fc = categorizeface(flipface);
<a name="l11277"></a>11277           <span class="keywordflow">if</span> (fc == N40) {
<a name="l11278"></a>11278             b-&gt;epsilon *= 1e-1;
<a name="l11279"></a>11279             epscount++;
<a name="l11280"></a>11280             <span class="keywordflow">continue</span>;
<a name="l11281"></a>11281           }
<a name="l11282"></a>11282           <span class="keywordflow">break</span>;
<a name="l11283"></a>11283         }
<a name="l11284"></a>11284         b-&gt;epsilon = bakepsilon;
<a name="l11285"></a>11285         <span class="keywordflow">if</span> (epscount &gt;= 32) {
<a name="l11286"></a>11286           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l11287"></a>11287             printf(<span class="stringliteral">&quot;Warning:  Can&#39;t flip a degenerate tetrahedron.\n&quot;</span>);
<a name="l11288"></a>11288           }
<a name="l11289"></a>11289           fc = N40;
<a name="l11290"></a>11290         }
<a name="l11291"></a>11291       } <span class="keywordflow">else</span> {
<a name="l11292"></a>11292         fc = categorizeface(flipface);
<a name="l11293"></a>11293 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l11294"></a>11294 <span class="preprocessor"></span>        assert(fc != N40);
<a name="l11295"></a>11295 <span class="preprocessor">#endif</span>
<a name="l11296"></a>11296 <span class="preprocessor"></span>      }
<a name="l11297"></a>11297       <span class="keywordflow">switch</span> (fc) {
<a name="l11298"></a>11298       <span class="comment">// The following face types are flipable.</span>
<a name="l11299"></a>11299       <span class="keywordflow">case</span> T44:
<a name="l11300"></a>11300       <span class="keywordflow">case</span> T22:
<a name="l11301"></a>11301         flip22(&amp;flipface, flipqueue);
<a name="l11302"></a>11302         <span class="keywordflow">break</span>;
<a name="l11303"></a>11303       <span class="keywordflow">case</span> T23:
<a name="l11304"></a>11304         flip23(&amp;flipface, flipqueue);
<a name="l11305"></a>11305         <span class="keywordflow">break</span>;
<a name="l11306"></a>11306       <span class="keywordflow">case</span> T32:
<a name="l11307"></a>11307         flip32(&amp;flipface, flipqueue);
<a name="l11308"></a>11308         <span class="keywordflow">break</span>;
<a name="l11309"></a>11309       <span class="comment">// The following face types are unflipable.</span>
<a name="l11310"></a>11310       <span class="keywordflow">case</span> N32:
<a name="l11311"></a>11311         <span class="keywordflow">break</span>;
<a name="l11312"></a>11312       <span class="keywordflow">case</span> FORBIDDENFACE:
<a name="l11313"></a>11313         <span class="keywordflow">break</span>;
<a name="l11314"></a>11314       <span class="keywordflow">case</span> FORBIDDENEDGE:
<a name="l11315"></a>11315         <span class="keywordflow">break</span>;
<a name="l11316"></a>11316       <span class="comment">// This case is only possible when the domain is nonconvex.</span>
<a name="l11317"></a>11317       <span class="keywordflow">case</span> N40:
<a name="l11318"></a>11318         <span class="comment">// assert(nonconvex);</span>
<a name="l11319"></a>11319         <span class="keywordflow">break</span>;
<a name="l11320"></a>11320       }
<a name="l11321"></a>11321       <span class="keywordflow">if</span> (plastflip != (badface **) NULL) {
<a name="l11322"></a>11322         <span class="keywordflow">if</span> ((fc == T44) || (fc == T22) || (fc == T23) || (fc == T32)) {
<a name="l11323"></a>11323           <span class="comment">// Push the flipped face into stack.</span>
<a name="l11324"></a>11324           newflip = (badface *) flipstackers-&gt;alloc();
<a name="l11325"></a>11325           newflip-&gt;tt = flipface;
<a name="l11326"></a>11326           newflip-&gt;key = (REAL) fc;
<a name="l11327"></a>11327           newflip-&gt;forg = org(flipface);
<a name="l11328"></a>11328           newflip-&gt;fdest = dest(flipface);
<a name="l11329"></a>11329           newflip-&gt;fapex = apex(flipface);
<a name="l11330"></a>11330           newflip-&gt;previtem = *plastflip;
<a name="l11331"></a>11331           *plastflip = newflip;
<a name="l11332"></a>11332         }
<a name="l11333"></a>11333       }
<a name="l11334"></a>11334     }
<a name="l11335"></a>11335   }
<a name="l11336"></a>11336 
<a name="l11337"></a>11337   flipcount = flip23s + flip32s + flip22s + flip44s - flipcount;
<a name="l11338"></a>11338   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l11339"></a>11339     printf(<span class="stringliteral">&quot;    %ld flips.\n&quot;</span>, flipcount);
<a name="l11340"></a>11340   }
<a name="l11341"></a>11341 
<a name="l11342"></a>11342   <span class="keywordflow">return</span> flipcount;
<a name="l11343"></a>11343 }
<a name="l11344"></a>11344 
<a name="l11346"></a>11346 <span class="comment">//                                                                           //</span>
<a name="l11347"></a>11347 <span class="comment">// lawson()    Flip locally non-Delaunay faces by Lawson&#39;s algorithm.        //</span>
<a name="l11348"></a>11348 <span class="comment">//                                                                           //</span>
<a name="l11350"></a>11350 <span class="comment"></span>
<a name="l11351"></a>11351 <span class="keywordtype">long</span> tetgenmesh::lawson(list *misseglist, queue* flipqueue)
<a name="l11352"></a>11352 {
<a name="l11353"></a>11353   badface *qface, *misseg;
<a name="l11354"></a>11354   triface flipface, symface;
<a name="l11355"></a>11355   triface starttet, spintet;
<a name="l11356"></a>11356   face checksh, checkseg;
<a name="l11357"></a>11357   point pa, pb, pc, pd, pe;
<a name="l11358"></a>11358   point swappt;
<a name="l11359"></a>11359   REAL sign, ori;
<a name="l11360"></a>11360   <span class="keywordtype">long</span> flipcount;
<a name="l11361"></a>11361   <span class="keywordtype">int</span> ia, ib, ic, id, ie;
<a name="l11362"></a>11362   <span class="keywordtype">int</span> hitbdry, i;
<a name="l11363"></a>11363 
<a name="l11364"></a>11364   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l11365"></a>11365     printf(<span class="stringliteral">&quot;    Do flipface queue: %ld faces.\n&quot;</span>, flipqueue-&gt;len());
<a name="l11366"></a>11366   }
<a name="l11367"></a>11367   flipcount = flip23s + flip32s + flip22s + flip44s;
<a name="l11368"></a>11368 
<a name="l11369"></a>11369   <span class="comment">// Go through the stack of possible flips and decide whether to do them.</span>
<a name="l11370"></a>11370   <span class="comment">//   Note that during the loop new possible flips will be pushed onto</span>
<a name="l11371"></a>11371   <span class="comment">//   this stack, while they popped in this loop.</span>
<a name="l11372"></a>11372   <span class="keywordflow">while</span> (!flipqueue-&gt;empty()) {
<a name="l11373"></a>11373     qface = (badface *) flipqueue-&gt;pop();
<a name="l11374"></a>11374     flipface = qface-&gt;tt;
<a name="l11375"></a>11375     <span class="comment">// Check if tet has already been flipped out of existence.</span>
<a name="l11376"></a>11376     <span class="keywordflow">if</span> (!isdead(&amp;flipface)) {
<a name="l11377"></a>11377       sym(flipface, symface);
<a name="l11378"></a>11378       <span class="comment">// Check if this tet is the same as the one which was stacked.</span>
<a name="l11379"></a>11379       <span class="keywordflow">if</span> ((symface.tet != dummytet) &amp;&amp; (oppo(symface) == qface-&gt;foppo)) {
<a name="l11380"></a>11380         flipface.ver = 0; <span class="comment">// Select the CCW ring.</span>
<a name="l11381"></a>11381         pa = org(flipface);
<a name="l11382"></a>11382         pb = dest(flipface);
<a name="l11383"></a>11383         pc = apex(flipface);
<a name="l11384"></a>11384         pd = oppo(flipface);
<a name="l11385"></a>11385         pe = oppo(symface);
<a name="l11386"></a>11386         <span class="keywordflow">if</span> (symbolic) {
<a name="l11387"></a>11387           ia = pointmark(pa);
<a name="l11388"></a>11388           ib = pointmark(pb);
<a name="l11389"></a>11389           ic = pointmark(pc);
<a name="l11390"></a>11390           <span class="keywordtype">id</span> = pointmark(pd);
<a name="l11391"></a>11391           ie = pointmark(pe);
<a name="l11392"></a>11392           sign = insphere_sos(pb, pa, pc, pd, pe, ib, ia, ic, <span class="keywordtype">id</span>, ie);
<a name="l11393"></a>11393         } <span class="keywordflow">else</span> {
<a name="l11394"></a>11394           sign = insphere(pb, pa, pc, pd, pe);
<a name="l11395"></a>11395         }
<a name="l11396"></a>11396         <span class="keywordflow">if</span> (sign &gt; 0.0) {
<a name="l11397"></a>11397           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l11398"></a>11398             ori = orient3d(pa, pb, pd, pe);
<a name="l11399"></a>11399             <span class="keywordflow">if</span> (ori &gt; 0.0) {
<a name="l11400"></a>11400               <span class="comment">// Goto and check the next edge.</span>
<a name="l11401"></a>11401               swappt = pa;
<a name="l11402"></a>11402               pa = pb;
<a name="l11403"></a>11403               pb = pc;
<a name="l11404"></a>11404               pc = swappt;
<a name="l11405"></a>11405               enextself(flipface);
<a name="l11406"></a>11406             } <span class="keywordflow">else</span> {
<a name="l11407"></a>11407               <span class="keywordflow">break</span>; <span class="comment">// either (ori &lt; 0.0) or (ori == 0.0)</span>
<a name="l11408"></a>11408             }
<a name="l11409"></a>11409           } <span class="comment">// for (i = 0; ....)</span>
<a name="l11410"></a>11410           <span class="keywordflow">if</span> (ori &gt; 0.0) {
<a name="l11411"></a>11411             <span class="comment">// All three edges are convex, a 2-3 flip is possible.</span>
<a name="l11412"></a>11412             <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11413"></a>11413               tspivot(flipface, checksh);
<a name="l11414"></a>11414               <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l11415"></a>11415                 <span class="comment">// A subface is not flipable.</span>
<a name="l11416"></a>11416                 <span class="keywordflow">continue</span>;
<a name="l11417"></a>11417               }
<a name="l11418"></a>11418             }
<a name="l11419"></a>11419             flip23(&amp;flipface, flipqueue);
<a name="l11420"></a>11420           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori &lt; 0.0) {
<a name="l11421"></a>11421             <span class="comment">// The edge (a, b) is non-convex, check for a 3-2 flip.</span>
<a name="l11422"></a>11422             fnext(flipface, symface);
<a name="l11423"></a>11423             symself(symface);
<a name="l11424"></a>11424             <span class="keywordflow">if</span> (oppo(symface) == pe) {
<a name="l11425"></a>11425               <span class="comment">// Only three tets adjoining this edge.</span>
<a name="l11426"></a>11426               <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11427"></a>11427                 tsspivot(&amp;flipface, &amp;checkseg);
<a name="l11428"></a>11428                 <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l11429"></a>11429                   <span class="comment">// A subsegment is not flipable.</span>
<a name="l11430"></a>11430                   <span class="keywordflow">continue</span>;
<a name="l11431"></a>11431                 }
<a name="l11432"></a>11432               } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l11433"></a>11433                 tsspivot1(flipface, checkseg);
<a name="l11434"></a>11434                 <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l11435"></a>11435                   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l11436"></a>11436                     printf(<span class="stringliteral">&quot;    Queuing missing segment (%d, %d).\n&quot;</span>,
<a name="l11437"></a>11437                       pointmark(org(flipface)), pointmark(dest(flipface)));
<a name="l11438"></a>11438                   }
<a name="l11439"></a>11439                   misseg = (badface *) misseglist-&gt;append(NULL);
<a name="l11440"></a>11440                   misseg-&gt;ss = checkseg;
<a name="l11441"></a>11441                   misseg-&gt;forg = sorg(checkseg);
<a name="l11442"></a>11442                   misseg-&gt;fdest = sdest(checkseg);
<a name="l11443"></a>11443                   <span class="comment">// Detach all tets having this seg.</span>
<a name="l11444"></a>11444                   starttet = flipface;
<a name="l11445"></a>11445                   adjustedgering(starttet, CCW);
<a name="l11446"></a>11446                   fnextself(starttet);
<a name="l11447"></a>11447                   spintet = starttet;
<a name="l11448"></a>11448                   hitbdry = 0;
<a name="l11449"></a>11449                   <span class="keywordflow">do</span> {
<a name="l11450"></a>11450                     tssdissolve1(spintet);
<a name="l11451"></a>11451                     <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l11452"></a>11452                       hitbdry++;
<a name="l11453"></a>11453                       <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l11454"></a>11454                         esym(starttet, spintet);
<a name="l11455"></a>11455                         <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l11456"></a>11456                           hitbdry++;
<a name="l11457"></a>11457                         }
<a name="l11458"></a>11458                       }
<a name="l11459"></a>11459                     }
<a name="l11460"></a>11460                   } <span class="keywordflow">while</span> ((apex(spintet) != apex(starttet)) &amp;&amp; (hitbdry &lt; 2));
<a name="l11461"></a>11461                 }
<a name="l11462"></a>11462               } <span class="comment">// if (checksubfaces)</span>
<a name="l11463"></a>11463               flip32(&amp;flipface, flipqueue);
<a name="l11464"></a>11464             }
<a name="l11465"></a>11465           } <span class="keywordflow">else</span> {
<a name="l11466"></a>11466             <span class="comment">// Four points (a, b, d, e) are coplanar.</span>
<a name="l11467"></a>11467             fnext(flipface, symface);
<a name="l11468"></a>11468             <span class="keywordflow">if</span> (fnextself(symface)) {
<a name="l11469"></a>11469               <span class="comment">// Check for a 4-4 flip.</span>
<a name="l11470"></a>11470               fnextself(symface);
<a name="l11471"></a>11471               <span class="keywordflow">if</span> (apex(symface) == pe) {
<a name="l11472"></a>11472                 <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11473"></a>11473                   tsspivot(&amp;flipface, &amp;checkseg);
<a name="l11474"></a>11474                   <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l11475"></a>11475                     <span class="comment">// A subsegment is not flippable.</span>
<a name="l11476"></a>11476                     <span class="keywordflow">continue</span>;
<a name="l11477"></a>11477                   }
<a name="l11478"></a>11478                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l11479"></a>11479                   tsspivot1(flipface, checkseg);
<a name="l11480"></a>11480                   <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l11481"></a>11481                     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l11482"></a>11482                       printf(<span class="stringliteral">&quot;    Queuing missing segment (%d, %d).\n&quot;</span>,
<a name="l11483"></a>11483                         pointmark(org(flipface)), pointmark(dest(flipface)));
<a name="l11484"></a>11484                     }
<a name="l11485"></a>11485                     misseg = (badface *) misseglist-&gt;append(NULL);
<a name="l11486"></a>11486                     misseg-&gt;ss = checkseg;
<a name="l11487"></a>11487                     misseg-&gt;forg = sorg(checkseg);
<a name="l11488"></a>11488                     misseg-&gt;fdest = sdest(checkseg);
<a name="l11489"></a>11489                     <span class="comment">// Detach all tets having this seg.</span>
<a name="l11490"></a>11490                     starttet = flipface;
<a name="l11491"></a>11491                     adjustedgering(starttet, CCW);
<a name="l11492"></a>11492                     fnextself(starttet);
<a name="l11493"></a>11493                     spintet = starttet;
<a name="l11494"></a>11494                     hitbdry = 0;
<a name="l11495"></a>11495                     <span class="keywordflow">do</span> {
<a name="l11496"></a>11496                       tssdissolve1(spintet);
<a name="l11497"></a>11497                       <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l11498"></a>11498                         hitbdry++;
<a name="l11499"></a>11499                         <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l11500"></a>11500                           esym(starttet, spintet);
<a name="l11501"></a>11501                           <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l11502"></a>11502                             hitbdry++;
<a name="l11503"></a>11503                           }
<a name="l11504"></a>11504                         }
<a name="l11505"></a>11505                       }
<a name="l11506"></a>11506                     } <span class="keywordflow">while</span> ((apex(spintet) != apex(starttet)) &amp;&amp;
<a name="l11507"></a>11507                              (hitbdry &lt; 2));
<a name="l11508"></a>11508                   }
<a name="l11509"></a>11509                 } <span class="comment">// if (checksubfaces)</span>
<a name="l11510"></a>11510                 flip22(&amp;flipface, flipqueue);
<a name="l11511"></a>11511               }
<a name="l11512"></a>11512             } <span class="keywordflow">else</span> {
<a name="l11513"></a>11513               <span class="comment">// Check for a 2-2 flip.</span>
<a name="l11514"></a>11514               esym(flipface, symface);
<a name="l11515"></a>11515               fnextself(symface);
<a name="l11516"></a>11516               symself(symface);
<a name="l11517"></a>11517               <span class="keywordflow">if</span> (symface.tet == dummytet) {
<a name="l11518"></a>11518                 <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11519"></a>11519                   tsspivot(&amp;flipface, &amp;checkseg);
<a name="l11520"></a>11520                   <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l11521"></a>11521                     <span class="comment">// A subsegment is not flipable.</span>
<a name="l11522"></a>11522                     <span class="keywordflow">continue</span>;
<a name="l11523"></a>11523                   }
<a name="l11524"></a>11524                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l11525"></a>11525                   tsspivot1(flipface, checkseg);
<a name="l11526"></a>11526                   <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l11527"></a>11527                     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l11528"></a>11528                       printf(<span class="stringliteral">&quot;    Queuing missing segment (%d, %d).\n&quot;</span>,
<a name="l11529"></a>11529                         pointmark(org(flipface)), pointmark(dest(flipface)));
<a name="l11530"></a>11530                     }
<a name="l11531"></a>11531                     misseg = (badface *) misseglist-&gt;append(NULL);
<a name="l11532"></a>11532                     misseg-&gt;ss = checkseg;
<a name="l11533"></a>11533                     misseg-&gt;forg = sorg(checkseg);
<a name="l11534"></a>11534                     misseg-&gt;fdest = sdest(checkseg);
<a name="l11535"></a>11535                     <span class="comment">// Detach all tets having this seg.</span>
<a name="l11536"></a>11536                     starttet = flipface;
<a name="l11537"></a>11537                     adjustedgering(starttet, CCW);
<a name="l11538"></a>11538                     fnextself(starttet);
<a name="l11539"></a>11539                     spintet = starttet;
<a name="l11540"></a>11540                     hitbdry = 0;
<a name="l11541"></a>11541                     <span class="keywordflow">do</span> {
<a name="l11542"></a>11542                       tssdissolve1(spintet);
<a name="l11543"></a>11543                       <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l11544"></a>11544                         hitbdry++;
<a name="l11545"></a>11545                         <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l11546"></a>11546                           esym(starttet, spintet);
<a name="l11547"></a>11547                           <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l11548"></a>11548                             hitbdry++;
<a name="l11549"></a>11549                           }
<a name="l11550"></a>11550                         }
<a name="l11551"></a>11551                       }
<a name="l11552"></a>11552                     } <span class="keywordflow">while</span> ((apex(spintet) != apex(starttet)) &amp;&amp;
<a name="l11553"></a>11553                              (hitbdry &lt; 2));
<a name="l11554"></a>11554                   }
<a name="l11555"></a>11555                 } <span class="comment">// if (checksubfaces)</span>
<a name="l11556"></a>11556                 flip22(&amp;flipface, flipqueue);
<a name="l11557"></a>11557               }
<a name="l11558"></a>11558             }
<a name="l11559"></a>11559           } <span class="comment">// if (ori &gt; 0.0)</span>
<a name="l11560"></a>11560         } <span class="comment">// if (sign &gt; 0.0)</span>
<a name="l11561"></a>11561       }
<a name="l11562"></a>11562     } <span class="comment">// !isdead(&amp;qface-&gt;tt)</span>
<a name="l11563"></a>11563   } <span class="comment">// while (!flipqueue-&gt;empty())</span>
<a name="l11564"></a>11564 
<a name="l11565"></a>11565   flipcount = flip23s + flip32s + flip22s + flip44s - flipcount;
<a name="l11566"></a>11566   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l11567"></a>11567     printf(<span class="stringliteral">&quot;    %ld flips.\n&quot;</span>, flipcount);
<a name="l11568"></a>11568   }
<a name="l11569"></a>11569   <span class="keywordflow">return</span> flipcount;
<a name="l11570"></a>11570 }
<a name="l11571"></a>11571 
<a name="l11573"></a>11573 <span class="comment">//                                                                           //</span>
<a name="l11574"></a>11574 <span class="comment">// undoflip()    Undo the most recent flip sequence induced by flip().       //</span>
<a name="l11575"></a>11575 <span class="comment">//                                                                           //</span>
<a name="l11576"></a>11576 <span class="comment">// &#39;lastflip&#39; is the stack of recently flipped faces. Walks through the list //</span>
<a name="l11577"></a>11577 <span class="comment">// of flips, in the reverse of the order in which they were done, and undoes //</span>
<a name="l11578"></a>11578 <span class="comment">// them.                                                                     //</span>
<a name="l11579"></a>11579 <span class="comment">//                                                                           //</span>
<a name="l11581"></a>11581 <span class="comment"></span>
<a name="l11582"></a>11582 <span class="keywordtype">void</span> tetgenmesh::undoflip(badface *lastflip)
<a name="l11583"></a>11583 {
<a name="l11584"></a>11584   <span class="keyword">enum</span> fliptype fc;
<a name="l11585"></a>11585 
<a name="l11586"></a>11586   <span class="keywordflow">while</span> (lastflip != (badface *) NULL) {
<a name="l11587"></a>11587     <span class="comment">// Get the right flipped face.</span>
<a name="l11588"></a>11588     findface(&amp;lastflip-&gt;tt, lastflip-&gt;forg, lastflip-&gt;fdest, lastflip-&gt;fapex);
<a name="l11589"></a>11589     fc = (<span class="keyword">enum</span> fliptype) (<span class="keywordtype">int</span>) lastflip-&gt;key;
<a name="l11590"></a>11590     <span class="keywordflow">switch</span> (fc) {
<a name="l11591"></a>11591     <span class="keywordflow">case</span> T23:
<a name="l11592"></a>11592       <span class="comment">// The reverse operation of T23 is T32.</span>
<a name="l11593"></a>11593       flip32(&amp;lastflip-&gt;tt, NULL);
<a name="l11594"></a>11594       <span class="keywordflow">break</span>;
<a name="l11595"></a>11595     <span class="keywordflow">case</span> T32:
<a name="l11596"></a>11596       <span class="comment">// The reverse operation of T32 is T23.</span>
<a name="l11597"></a>11597       flip23(&amp;lastflip-&gt;tt, NULL);
<a name="l11598"></a>11598       <span class="keywordflow">break</span>;
<a name="l11599"></a>11599     <span class="keywordflow">case</span> T22:
<a name="l11600"></a>11600     <span class="keywordflow">case</span> T44:
<a name="l11601"></a>11601       <span class="comment">// The reverse operation of T22 or T44 is again T22 or T44.</span>
<a name="l11602"></a>11602       flip22(&amp;lastflip-&gt;tt, NULL);
<a name="l11603"></a>11603       <span class="keywordflow">break</span>;
<a name="l11604"></a>11604     <span class="keywordflow">default</span>: <span class="comment">// To omit compile warnings.</span>
<a name="l11605"></a>11605       <span class="keywordflow">break</span>;
<a name="l11606"></a>11606     }
<a name="l11607"></a>11607     <span class="comment">// Go on and process the next transformation.</span>
<a name="l11608"></a>11608     lastflip = lastflip-&gt;previtem;
<a name="l11609"></a>11609   }
<a name="l11610"></a>11610 }
<a name="l11611"></a>11611 
<a name="l11613"></a>11613 <span class="comment">//                                                                           //</span>
<a name="l11614"></a>11614 <span class="comment">// flipsub()    Flip non-Delaunay edges in a queue of (coplanar) subfaces.   //</span>
<a name="l11615"></a>11615 <span class="comment">//                                                                           //</span>
<a name="l11616"></a>11616 <span class="comment">// Assumpation:  Current triangulation T contains non-Delaunay edges (after  //</span>
<a name="l11617"></a>11617 <span class="comment">// inserting a point or performing a flip). Non-Delaunay edges are queued in //</span>
<a name="l11618"></a>11618 <span class="comment">// &#39;facequeue&#39;. Returns the total number of flips done during this call.     //</span>
<a name="l11619"></a>11619 <span class="comment">//                                                                           //</span>
<a name="l11621"></a>11621 <span class="comment"></span>
<a name="l11622"></a>11622 <span class="keywordtype">long</span> tetgenmesh::flipsub(queue* flipqueue)
<a name="l11623"></a>11623 {
<a name="l11624"></a>11624   badface *qedge;
<a name="l11625"></a>11625   face flipedge, symedge;
<a name="l11626"></a>11626   face checkseg;
<a name="l11627"></a>11627   point pa, pb, pc, pd;
<a name="l11628"></a>11628   REAL vab[3], vac[3], vad[3];
<a name="l11629"></a>11629   REAL dot1, dot2, lac, lad;
<a name="l11630"></a>11630   REAL sign, ori;
<a name="l11631"></a>11631   <span class="keywordtype">int</span> edgeflips;
<a name="l11632"></a>11632   <span class="keywordtype">int</span> i;
<a name="l11633"></a>11633 
<a name="l11634"></a>11634   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l11635"></a>11635     printf(<span class="stringliteral">&quot;  Start do edge queue: %ld edges.\n&quot;</span>, flipqueue-&gt;len());
<a name="l11636"></a>11636   }
<a name="l11637"></a>11637 
<a name="l11638"></a>11638   edgeflips = 0;
<a name="l11639"></a>11639 
<a name="l11640"></a>11640   <span class="keywordflow">while</span> (!flipqueue-&gt;empty()) {
<a name="l11641"></a>11641     qedge = (badface *) flipqueue-&gt;pop();
<a name="l11642"></a>11642     flipedge = qedge-&gt;ss;
<a name="l11643"></a>11643     <span class="keywordflow">if</span> (flipedge.sh == dummysh) <span class="keywordflow">continue</span>;
<a name="l11644"></a>11644     <span class="keywordflow">if</span> ((sorg(flipedge) != qedge-&gt;forg) ||
<a name="l11645"></a>11645         (sdest(flipedge) != qedge-&gt;fdest)) <span class="keywordflow">continue</span>;
<a name="l11646"></a>11646     sspivot(flipedge, checkseg);
<a name="l11647"></a>11647     <span class="keywordflow">if</span> (checkseg.sh != dummysh) <span class="keywordflow">continue</span>;  <span class="comment">// Can&#39;t flip a subsegment.</span>
<a name="l11648"></a>11648     spivot(flipedge, symedge);
<a name="l11649"></a>11649     <span class="keywordflow">if</span> (symedge.sh == dummysh) <span class="keywordflow">continue</span>; <span class="comment">// Can&#39;t flip a hull edge.</span>
<a name="l11650"></a>11650     pa = sorg(flipedge);
<a name="l11651"></a>11651     pb = sdest(flipedge);
<a name="l11652"></a>11652     pc = sapex(flipedge);
<a name="l11653"></a>11653     pd = sapex(symedge);
<a name="l11654"></a>11654     <span class="comment">// Choose the triangle abc or abd as the base depending on the angle1</span>
<a name="l11655"></a>11655     <span class="comment">//   (Vac, Vab) and angle2 (Vad, Vab).</span>
<a name="l11656"></a>11656     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) vab[i] = pb[i] - pa[i];
<a name="l11657"></a>11657     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) vac[i] = pc[i] - pa[i];
<a name="l11658"></a>11658     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) vad[i] = pd[i] - pa[i];
<a name="l11659"></a>11659     dot1 = dot(vac, vab);
<a name="l11660"></a>11660     dot2 = dot(vad, vab);
<a name="l11661"></a>11661     dot1 *= dot1;
<a name="l11662"></a>11662     dot2 *= dot2;
<a name="l11663"></a>11663     lac = dot(vac, vac);
<a name="l11664"></a>11664     lad = dot(vad, vad);
<a name="l11665"></a>11665     <span class="keywordflow">if</span> (lad * dot1 &lt;= lac * dot2) {
<a name="l11666"></a>11666       <span class="comment">// angle1 is closer to 90 than angle2, choose abc (flipedge).</span>
<a name="l11667"></a>11667       abovepoint = facetabovepointarray[shellmark(flipedge)];
<a name="l11668"></a>11668       <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l11669"></a>11669         getfacetabovepoint(&amp;flipedge);
<a name="l11670"></a>11670       }
<a name="l11671"></a>11671       sign = insphere(pa, pb, pc, abovepoint, pd);
<a name="l11672"></a>11672       ori = orient3d(pa, pb, pc, abovepoint);
<a name="l11673"></a>11673     } <span class="keywordflow">else</span> {
<a name="l11674"></a>11674       <span class="comment">// angle2 is closer to 90 than angle1, choose abd (symedge).</span>
<a name="l11675"></a>11675       abovepoint = facetabovepointarray[shellmark(symedge)];
<a name="l11676"></a>11676       <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l11677"></a>11677         getfacetabovepoint(&amp;symedge);
<a name="l11678"></a>11678       }
<a name="l11679"></a>11679       sign = insphere(pa, pb, pd, abovepoint, pc);
<a name="l11680"></a>11680       ori = orient3d(pa, pb, pd, abovepoint);
<a name="l11681"></a>11681     }
<a name="l11682"></a>11682     <span class="comment">// Correct the sign.</span>
<a name="l11683"></a>11683     sign = ori &gt; 0.0 ? sign : -sign;
<a name="l11684"></a>11684     <span class="keywordflow">if</span> (sign &gt; 0.0) {
<a name="l11685"></a>11685       <span class="comment">// Flip the non-Delaunay edge.</span>
<a name="l11686"></a>11686       flip22sub(&amp;flipedge, flipqueue);
<a name="l11687"></a>11687       edgeflips++;
<a name="l11688"></a>11688     }
<a name="l11689"></a>11689   }
<a name="l11690"></a>11690 
<a name="l11691"></a>11691   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l11692"></a>11692     printf(<span class="stringliteral">&quot;  Total %d flips.\n&quot;</span>, edgeflips);
<a name="l11693"></a>11693   }
<a name="l11694"></a>11694 
<a name="l11695"></a>11695   <span class="keywordflow">return</span> edgeflips;
<a name="l11696"></a>11696 }
<a name="l11697"></a>11697 
<a name="l11699"></a>11699 <span class="comment">//                                                                           //</span>
<a name="l11700"></a>11700 <span class="comment">// removetetbypeeloff()    Remove a boundary tet by peeling it off.          //</span>
<a name="l11701"></a>11701 <span class="comment">//                                                                           //</span>
<a name="l11702"></a>11702 <span class="comment">// &#39;striptet&#39; (abcd) is on boundary and can be removed by stripping it off.  //</span>
<a name="l11703"></a>11703 <span class="comment">// Let abc and bad are the external boundary faces.                          //</span>
<a name="l11704"></a>11704 <span class="comment">//                                                                           //</span>
<a name="l11705"></a>11705 <span class="comment">// To strip &#39;abcd&#39; from the mesh is to detach its two interal faces (dca and //</span>
<a name="l11706"></a>11706 <span class="comment">// cdb) from their adjoining tets together with a 2-to-2 flip to transform   //</span>
<a name="l11707"></a>11707 <span class="comment">// two subfaces (abc and bad) into another two (dca and cdb).                //</span>
<a name="l11708"></a>11708 <span class="comment">//                                                                           //</span>
<a name="l11709"></a>11709 <span class="comment">// In mesh optimization. It is possible that ab is a segment and abcd is a   //</span>
<a name="l11710"></a>11710 <span class="comment">// sliver on the hull. Strip abcd will also delete the segment ab.           //</span>
<a name="l11711"></a>11711 <span class="comment">//                                                                           //</span>
<a name="l11713"></a>11713 <span class="comment"></span>
<a name="l11714"></a>11714 <span class="keywordtype">bool</span> tetgenmesh::removetetbypeeloff(triface *striptet)
<a name="l11715"></a>11715 {
<a name="l11716"></a>11716   triface abcd, badc;
<a name="l11717"></a>11717   triface dcacasing, cdbcasing;
<a name="l11718"></a>11718   face abc, bad;
<a name="l11719"></a>11719   face abseg;
<a name="l11720"></a>11720   REAL ang;
<a name="l11721"></a>11721 
<a name="l11722"></a>11722   abcd = *striptet;
<a name="l11723"></a>11723   adjustedgering(abcd, CCW);
<a name="l11724"></a>11724   <span class="comment">// Get the casing tets at the internal sides.</span>
<a name="l11725"></a>11725   enextfnext(abcd, cdbcasing);
<a name="l11726"></a>11726   enext2fnext(abcd, dcacasing);
<a name="l11727"></a>11727   symself(cdbcasing);
<a name="l11728"></a>11728   symself(dcacasing);
<a name="l11729"></a>11729   <span class="comment">// Do the neighboring tets exist?  During optimization. It is possible</span>
<a name="l11730"></a>11730   <span class="comment">//   that the neighboring tets are already dead.</span>
<a name="l11731"></a>11731   <span class="keywordflow">if</span> ((cdbcasing.tet == dummytet) || (dcacasing.tet == dummytet)) {
<a name="l11732"></a>11732     <span class="comment">// Do not strip this tet.</span>
<a name="l11733"></a>11733     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l11734"></a>11734   }
<a name="l11735"></a>11735 
<a name="l11736"></a>11736   <span class="comment">// Are there subfaces?</span>
<a name="l11737"></a>11737   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11738"></a>11738     <span class="comment">// Get the external subfaces abc, bad.</span>
<a name="l11739"></a>11739     fnext(abcd, badc);
<a name="l11740"></a>11740     esymself(badc);
<a name="l11741"></a>11741     tspivot(abcd, abc);
<a name="l11742"></a>11742     tspivot(badc, bad);
<a name="l11743"></a>11743     <span class="keywordflow">if</span> (abc.sh != dummysh) {
<a name="l11744"></a>11744       assert(bad.sh != dummysh);
<a name="l11745"></a>11745       findedge(&amp;abc, org(abcd), dest(abcd));
<a name="l11746"></a>11746       findedge(&amp;bad, org(badc), dest(badc));
<a name="l11747"></a>11747       <span class="comment">// Is ab a segment?</span>
<a name="l11748"></a>11748       sspivot(abc, abseg);
<a name="l11749"></a>11749       <span class="keywordflow">if</span> (abseg.sh != dummysh) {
<a name="l11750"></a>11750         <span class="comment">// Does a segment allow to be removed?</span>
<a name="l11751"></a>11751         <span class="keywordflow">if</span> ((b-&gt;optlevel &gt; 3) &amp;&amp; (b-&gt;nobisect == 0)) {
<a name="l11752"></a>11752           <span class="comment">// Only remove this segment if the dihedal angle at ab is between</span>
<a name="l11753"></a>11753           <span class="comment">//   [b-&gt;maxdihedral-9, 180] (deg).  This avoids mistakely fliping</span>
<a name="l11754"></a>11754           <span class="comment">//   ab when it has actually no big dihedral angle while cd has.</span>
<a name="l11755"></a>11755           ang = facedihedral(org(abcd), dest(abcd), apex(abcd), oppo(abcd));
<a name="l11756"></a>11756           ang = ang * 180.0 / PI;
<a name="l11757"></a>11757           <span class="keywordflow">if</span> ((ang + 9.0) &gt; b-&gt;maxdihedral) {
<a name="l11758"></a>11758             <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l11759"></a>11759               printf(<span class="stringliteral">&quot;    Remove a segment during peeling.\n&quot;</span>);
<a name="l11760"></a>11760             }
<a name="l11761"></a>11761             face prevseg, nextseg;
<a name="l11762"></a>11762             <span class="comment">// It is only shared by abc and bad (abcd is a tet).</span>
<a name="l11763"></a>11763             ssdissolve(abc);
<a name="l11764"></a>11764             ssdissolve(bad);
<a name="l11765"></a>11765             abseg.shver = 0;
<a name="l11766"></a>11766             senext(abseg, nextseg);
<a name="l11767"></a>11767             spivotself(nextseg);
<a name="l11768"></a>11768             <span class="keywordflow">if</span> (nextseg.sh != dummysh) {
<a name="l11769"></a>11769               ssdissolve(nextseg);
<a name="l11770"></a>11770             }
<a name="l11771"></a>11771             senext2(abseg, prevseg);
<a name="l11772"></a>11772             spivotself(prevseg);
<a name="l11773"></a>11773             <span class="keywordflow">if</span> (prevseg.sh != dummysh) {
<a name="l11774"></a>11774               ssdissolve(prevseg);
<a name="l11775"></a>11775             }
<a name="l11776"></a>11776             shellfacedealloc(subsegs, abseg.sh);
<a name="l11777"></a>11777             optcount[1]++;
<a name="l11778"></a>11778           } <span class="keywordflow">else</span> {
<a name="l11779"></a>11779             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l11780"></a>11780           }
<a name="l11781"></a>11781         } <span class="keywordflow">else</span> {
<a name="l11782"></a>11782           <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l11783"></a>11783         }
<a name="l11784"></a>11784       }
<a name="l11785"></a>11785       <span class="comment">// Do a 2-to-2 flip on abc and bad, transform abc-&gt;dca, bad-&gt;cdb.</span>
<a name="l11786"></a>11786       flip22sub(&amp;abc, NULL);
<a name="l11787"></a>11787       <span class="comment">// The two internal faces become boundary faces.</span>
<a name="l11788"></a>11788       tsbond(cdbcasing, bad);
<a name="l11789"></a>11789       tsbond(dcacasing, abc);
<a name="l11790"></a>11790     }
<a name="l11791"></a>11791   }
<a name="l11792"></a>11792 
<a name="l11793"></a>11793   <span class="comment">// Detach abcd from the two internal faces.</span>
<a name="l11794"></a>11794   dissolve(cdbcasing);
<a name="l11795"></a>11795   dissolve(dcacasing);
<a name="l11796"></a>11796   <span class="comment">// Delete abcd.</span>
<a name="l11797"></a>11797   tetrahedrondealloc(abcd.tet);
<a name="l11798"></a>11798   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l11799"></a>11799 }
<a name="l11800"></a>11800 
<a name="l11802"></a>11802 <span class="comment">//                                                                           //</span>
<a name="l11803"></a>11803 <span class="comment">// removeedgebyflip22()    Remove an edge by a 2-to-2 (or 4-to-4) flip.      //</span>
<a name="l11804"></a>11804 <span class="comment">//                                                                           //</span>
<a name="l11805"></a>11805 <span class="comment">// &#39;abtetlist&#39; contains n tets (n is 2 or 4) sharing edge ab,  abtetlist[0]  //</span>
<a name="l11806"></a>11806 <span class="comment">// and abtetlist[1] are tets abec and abde, respectively (NOTE, both are in  //</span>
<a name="l11807"></a>11807 <span class="comment">// CW edge ring), where a, b, c, and d are coplanar.  If n = 4, abtetlist[2] //</span>
<a name="l11808"></a>11808 <span class="comment">// and abtetlist[3] are tets abfd and abcf, respectively.  This routine uses //</span>
<a name="l11809"></a>11809 <span class="comment">// flip22() to replace edge ab with cd, the surrounding tets are rotated.    //</span>
<a name="l11810"></a>11810 <span class="comment">//                                                                           //</span>
<a name="l11811"></a>11811 <span class="comment">// If &#39;key&#39; != NULL.  The old tets are replaced by the new tets only if the  //</span>
<a name="l11812"></a>11812 <span class="comment">// local mesh quality is improved. Current &#39;key&#39; = cos(\theta), where \theta //</span>
<a name="l11813"></a>11813 <span class="comment">// is the maximum dihedral angle in the old tets.                            //</span>
<a name="l11814"></a>11814 <span class="comment">//                                                                           //</span>
<a name="l11816"></a>11816 <span class="comment"></span>
<a name="l11817"></a>11817 <span class="keywordtype">bool</span> tetgenmesh::removeedgebyflip22(REAL *key, <span class="keywordtype">int</span> n, triface *abtetlist,
<a name="l11818"></a>11818   queue *flipque)
<a name="l11819"></a>11819 {
<a name="l11820"></a>11820   point pa, pb, pc, pd, pe, pf;
<a name="l11821"></a>11821   REAL cosmaxd, d1, d2, d3;
<a name="l11822"></a>11822   <span class="keywordtype">bool</span> doflip;
<a name="l11823"></a>11823 
<a name="l11824"></a>11824   cosmaxd = 0.0;
<a name="l11825"></a>11825   pf = apex(abtetlist[2]);
<a name="l11826"></a>11826   doflip = <span class="keyword">true</span>;
<a name="l11827"></a>11827   adjustedgering(abtetlist[0], CW);
<a name="l11828"></a>11828   pa = org(abtetlist[0]);
<a name="l11829"></a>11829   pb = dest(abtetlist[0]);
<a name="l11830"></a>11830   pe = apex(abtetlist[0]);
<a name="l11831"></a>11831   pc = oppo(abtetlist[0]);
<a name="l11832"></a>11832   pd = apex(abtetlist[1]);
<a name="l11833"></a>11833   <span class="keywordflow">if</span> (n == 4) {
<a name="l11834"></a>11834     pf = apex(abtetlist[2]);
<a name="l11835"></a>11835   }
<a name="l11836"></a>11836   <span class="keywordflow">if</span> (key &amp;&amp; (*key &gt; -1.0)) {
<a name="l11837"></a>11837     tetalldihedral(pc, pd, pe, pa, NULL, &amp;d1, NULL);
<a name="l11838"></a>11838     tetalldihedral(pd, pc, pe, pb, NULL, &amp;d2, NULL);
<a name="l11839"></a>11839     cosmaxd = d1 &lt; d2 ? d1 : d2; <span class="comment">// Choose the bigger angle.</span>
<a name="l11840"></a>11840     <span class="keywordflow">if</span> (n == 4) {
<a name="l11841"></a>11841       tetalldihedral(pd, pc, pf, pa, NULL, &amp;d1, NULL);
<a name="l11842"></a>11842       tetalldihedral(pc, pd, pf, pb, NULL, &amp;d2, NULL);
<a name="l11843"></a>11843       d3 = d1 &lt; d2 ? d1 : d2; <span class="comment">// Choose the bigger angle.</span>
<a name="l11844"></a>11844       cosmaxd = cosmaxd &lt; d3 ? cosmaxd : d3; <span class="comment">// Choose the bigger angle.</span>
<a name="l11845"></a>11845     }
<a name="l11846"></a>11846     doflip = (*key &lt; cosmaxd); <span class="comment">// Can local quality be improved?</span>
<a name="l11847"></a>11847   }
<a name="l11848"></a>11848 
<a name="l11849"></a>11849   <span class="keywordflow">if</span> (doflip) {
<a name="l11850"></a>11850     flip22(&amp;abtetlist[0], NULL);
<a name="l11851"></a>11851     <span class="comment">// Return the improved quality value.</span>
<a name="l11852"></a>11852     <span class="keywordflow">if</span> (key) *key = cosmaxd;
<a name="l11853"></a>11853   }
<a name="l11854"></a>11854 
<a name="l11855"></a>11855   <span class="keywordflow">return</span> doflip;
<a name="l11856"></a>11856 }
<a name="l11857"></a>11857 
<a name="l11859"></a>11859 <span class="comment">//                                                                           //</span>
<a name="l11860"></a>11860 <span class="comment">// removefacebyflip23()    Remove a face by a 2-to-3 flip.                   //</span>
<a name="l11861"></a>11861 <span class="comment">//                                                                           //</span>
<a name="l11862"></a>11862 <span class="comment">// &#39;abctetlist&#39; contains 2 tets sharing abc, which are [0]abcd and [1]bace.  //</span>
<a name="l11863"></a>11863 <span class="comment">// This routine forms three new tets that abc is not a face anymore. Save    //</span>
<a name="l11864"></a>11864 <span class="comment">// them in &#39;newtetlist&#39;: [0]edab, [1]edbc, and [2]edca.  Note that the new   //</span>
<a name="l11865"></a>11865 <span class="comment">// tets may not valid if one of them get inverted. return false if so.       //</span>
<a name="l11866"></a>11866 <span class="comment">//                                                                           //</span>
<a name="l11867"></a>11867 <span class="comment">// If &#39;key&#39; != NULL.  The old tets are replaced by the new tets only if the  //</span>
<a name="l11868"></a>11868 <span class="comment">// local mesh quality is improved. Current &#39;key&#39; = cos(\theta), where \theta //</span>
<a name="l11869"></a>11869 <span class="comment">// is the maximum dihedral angle in the old tets.                            //</span>
<a name="l11870"></a>11870 <span class="comment">//                                                                           //</span>
<a name="l11871"></a>11871 <span class="comment">// If the face is flipped, &#39;newtetlist&#39; returns the three new tets. The two  //</span>
<a name="l11872"></a>11872 <span class="comment">// tets in &#39;abctetlist&#39; are NOT deleted.  The caller has the right to either //</span>
<a name="l11873"></a>11873 <span class="comment">// delete them or reverse the operation.                                     //</span>
<a name="l11874"></a>11874 <span class="comment">//                                                                           //</span>
<a name="l11876"></a>11876 <span class="comment"></span>
<a name="l11877"></a>11877 <span class="keywordtype">bool</span> tetgenmesh::removefacebyflip23(REAL *key, triface *abctetlist,
<a name="l11878"></a>11878   triface *newtetlist, queue *flipque)
<a name="l11879"></a>11879 {
<a name="l11880"></a>11880   triface edab, edbc, edca; <span class="comment">// new configuration.</span>
<a name="l11881"></a>11881   triface newfront, oldfront, adjfront;
<a name="l11882"></a>11882   face checksh;
<a name="l11883"></a>11883   point pa, pb, pc, pd, pe;
<a name="l11884"></a>11884   REAL ori, cosmaxd, d1, d2, d3;
<a name="l11885"></a>11885   REAL attrib, volume;
<a name="l11886"></a>11886   <span class="keywordtype">bool</span> doflip;
<a name="l11887"></a>11887   <span class="keywordtype">int</span> i;
<a name="l11888"></a>11888 
<a name="l11889"></a>11889   cosmaxd = 0.0;
<a name="l11890"></a>11890 
<a name="l11891"></a>11891   adjustedgering(abctetlist[0], CCW);
<a name="l11892"></a>11892   pa = org(abctetlist[0]);
<a name="l11893"></a>11893   pb = dest(abctetlist[0]);
<a name="l11894"></a>11894   pc = apex(abctetlist[0]);
<a name="l11895"></a>11895   pd = oppo(abctetlist[0]);
<a name="l11896"></a>11896   pe = oppo(abctetlist[1]);
<a name="l11897"></a>11897 
<a name="l11898"></a>11898   <span class="comment">// Check if the flip creates valid new tets.</span>
<a name="l11899"></a>11899   ori = orient3d(pe, pd, pa, pb);
<a name="l11900"></a>11900   <span class="keywordflow">if</span> (ori &lt; 0.0) {
<a name="l11901"></a>11901     ori = orient3d(pe, pd, pb, pc);
<a name="l11902"></a>11902     <span class="keywordflow">if</span> (ori &lt; 0.0) {
<a name="l11903"></a>11903       ori = orient3d(pe, pd, pc, pa);
<a name="l11904"></a>11904     }
<a name="l11905"></a>11905   }
<a name="l11906"></a>11906   doflip = (ori &lt; 0.0); <span class="comment">// Can abc be flipped away?</span>
<a name="l11907"></a>11907   <span class="keywordflow">if</span> (doflip &amp;&amp; (key != (REAL *) NULL)) {
<a name="l11908"></a>11908     <span class="keywordflow">if</span> (*key &gt; -1.0) {
<a name="l11909"></a>11909       <span class="comment">// Test if the new tets reduce the maximal dihedral angle.</span>
<a name="l11910"></a>11910       tetalldihedral(pe, pd, pa, pb, NULL, &amp;d1, NULL);
<a name="l11911"></a>11911       tetalldihedral(pe, pd, pb, pc, NULL, &amp;d2, NULL);
<a name="l11912"></a>11912       tetalldihedral(pe, pd, pc, pa, NULL, &amp;d3, NULL);
<a name="l11913"></a>11913       cosmaxd = d1 &lt; d2 ? d1 : d2; <span class="comment">// Choose the bigger angle.</span>
<a name="l11914"></a>11914       cosmaxd = cosmaxd &lt; d3 ? cosmaxd : d3; <span class="comment">// Choose the bigger angle.</span>
<a name="l11915"></a>11915       doflip = (*key &lt; cosmaxd); <span class="comment">// Can local quality be improved?</span>
<a name="l11916"></a>11916     }
<a name="l11917"></a>11917   }
<a name="l11918"></a>11918 
<a name="l11919"></a>11919   <span class="keywordflow">if</span> (doflip) {
<a name="l11920"></a>11920     <span class="comment">// A valid (2-to-3) flip is found.</span>
<a name="l11921"></a>11921     flip23s++;
<a name="l11922"></a>11922     <span class="comment">// Create the new tets.</span>
<a name="l11923"></a>11923     maketetrahedron(&amp;edab);
<a name="l11924"></a>11924     setorg(edab, pe);
<a name="l11925"></a>11925     setdest(edab, pd);
<a name="l11926"></a>11926     setapex(edab, pa);
<a name="l11927"></a>11927     setoppo(edab, pb);
<a name="l11928"></a>11928     maketetrahedron(&amp;edbc);
<a name="l11929"></a>11929     setorg(edbc, pe);
<a name="l11930"></a>11930     setdest(edbc, pd);
<a name="l11931"></a>11931     setapex(edbc, pb);
<a name="l11932"></a>11932     setoppo(edbc, pc);
<a name="l11933"></a>11933     maketetrahedron(&amp;edca);
<a name="l11934"></a>11934     setorg(edca, pe);
<a name="l11935"></a>11935     setdest(edca, pd);
<a name="l11936"></a>11936     setapex(edca, pc);
<a name="l11937"></a>11937     setoppo(edca, pa);
<a name="l11938"></a>11938     <span class="comment">// Transfer the element attributes.</span>
<a name="l11939"></a>11939     <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l11940"></a>11940       attrib = elemattribute(abctetlist[0].tet, i);
<a name="l11941"></a>11941       setelemattribute(edab.tet, i, attrib);
<a name="l11942"></a>11942       setelemattribute(edbc.tet, i, attrib);
<a name="l11943"></a>11943       setelemattribute(edca.tet, i, attrib);
<a name="l11944"></a>11944     }
<a name="l11945"></a>11945     <span class="comment">// Transfer the volume constraints.</span>
<a name="l11946"></a>11946     <span class="keywordflow">if</span> (b-&gt;varvolume &amp;&amp; !b-&gt;refine) {
<a name="l11947"></a>11947       volume = volumebound(abctetlist[0].tet);
<a name="l11948"></a>11948       setvolumebound(edab.tet, volume);
<a name="l11949"></a>11949       setvolumebound(edbc.tet, volume);
<a name="l11950"></a>11950       setvolumebound(edca.tet, volume);
<a name="l11951"></a>11951     }
<a name="l11952"></a>11952     <span class="comment">// Return two new tets.</span>
<a name="l11953"></a>11953     newtetlist[0] = edab;
<a name="l11954"></a>11954     newtetlist[1] = edbc;
<a name="l11955"></a>11955     newtetlist[2] = edca;
<a name="l11956"></a>11956     <span class="comment">// Glue the three new tets.</span>
<a name="l11957"></a>11957     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l11958"></a>11958       fnext(newtetlist[i], newfront);
<a name="l11959"></a>11959       bond(newfront, newtetlist[(i + 1) % 3]);
<a name="l11960"></a>11960     }
<a name="l11961"></a>11961     <span class="comment">// Substitute the three new tets into the old cavity.</span>
<a name="l11962"></a>11962     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l11963"></a>11963       fnext(abctetlist[0], oldfront);
<a name="l11964"></a>11964       sym(oldfront, adjfront); <span class="comment">// may be outside.</span>
<a name="l11965"></a>11965       enextfnext(newtetlist[i], newfront);
<a name="l11966"></a>11966       bond(newfront, adjfront);
<a name="l11967"></a>11967       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11968"></a>11968         tspivot(oldfront, checksh);
<a name="l11969"></a>11969         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l11970"></a>11970           tsbond(newfront, checksh);
<a name="l11971"></a>11971         }
<a name="l11972"></a>11972       }
<a name="l11973"></a>11973       <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l11974"></a>11974         enqueueflipface(newfront, flipque);
<a name="l11975"></a>11975       }
<a name="l11976"></a>11976       enextself(abctetlist[0]);
<a name="l11977"></a>11977     }
<a name="l11978"></a>11978     findedge(&amp;(abctetlist[1]), pb, pa);
<a name="l11979"></a>11979     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l11980"></a>11980       fnext(abctetlist[1], oldfront);
<a name="l11981"></a>11981       sym(oldfront, adjfront); <span class="comment">// may be outside.</span>
<a name="l11982"></a>11982       enext2fnext(newtetlist[i], newfront);
<a name="l11983"></a>11983       bond(newfront, adjfront);
<a name="l11984"></a>11984       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l11985"></a>11985         tspivot(oldfront, checksh);
<a name="l11986"></a>11986         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l11987"></a>11987           tsbond(newfront, checksh);
<a name="l11988"></a>11988         }
<a name="l11989"></a>11989       }
<a name="l11990"></a>11990       <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l11991"></a>11991         enqueueflipface(newfront, flipque);
<a name="l11992"></a>11992       }
<a name="l11993"></a>11993       enext2self(abctetlist[1]);
<a name="l11994"></a>11994     }
<a name="l11995"></a>11995     <span class="comment">// Do not delete the old tets.</span>
<a name="l11996"></a>11996     <span class="comment">// for (i = 0; i &lt; 2; i++) {</span>
<a name="l11997"></a>11997     <span class="comment">//   tetrahedrondealloc(abctetlist[i].tet);</span>
<a name="l11998"></a>11998     <span class="comment">// }</span>
<a name="l11999"></a>11999     <span class="comment">// Return the improved quality value.</span>
<a name="l12000"></a>12000     <span class="keywordflow">if</span> (key != (REAL *) NULL) *key = cosmaxd;
<a name="l12001"></a>12001     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12002"></a>12002   }
<a name="l12003"></a>12003 
<a name="l12004"></a>12004   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12005"></a>12005 }
<a name="l12006"></a>12006 
<a name="l12008"></a>12008 <span class="comment">//                                                                           //</span>
<a name="l12009"></a>12009 <span class="comment">// removeedgebyflip32()    Remove an edge by a 3-to-2 flip.                  //</span>
<a name="l12010"></a>12010 <span class="comment">//                                                                           //</span>
<a name="l12011"></a>12011 <span class="comment">// &#39;abtetlist&#39; contains 3 tets sharing ab. Imaging that ab is perpendicular  //</span>
<a name="l12012"></a>12012 <span class="comment">// to the screen, where a lies in front of and b lies behind it. The 3 tets  //</span>
<a name="l12013"></a>12013 <span class="comment">// of the list are: [0]abce, [1]abdc, and [2]abed, respectively.             //</span>
<a name="l12014"></a>12014 <span class="comment">//                                                                           //</span>
<a name="l12015"></a>12015 <span class="comment">// This routine forms two new tets that ab is not an edge of them. Save them //</span>
<a name="l12016"></a>12016 <span class="comment">// in &#39;newtetlist&#39;, [0]dcea, [1]cdeb. Note that the new tets may not valid   //</span>
<a name="l12017"></a>12017 <span class="comment">// if one of them get inverted. return false if so.                          //</span>
<a name="l12018"></a>12018 <span class="comment">//                                                                           //</span>
<a name="l12019"></a>12019 <span class="comment">// If &#39;key&#39; != NULL.  The old tets are replaced by the new tets only if the  //</span>
<a name="l12020"></a>12020 <span class="comment">// local mesh quality is improved. Current &#39;key&#39; = cos(\theta), where \theta //</span>
<a name="l12021"></a>12021 <span class="comment">// is the maximum dihedral angle in the old tets.                            //</span>
<a name="l12022"></a>12022 <span class="comment">//                                                                           //</span>
<a name="l12023"></a>12023 <span class="comment">// If the edge is flipped, &#39;newtetlist&#39; returns the two new tets. The three  //</span>
<a name="l12024"></a>12024 <span class="comment">// tets in &#39;abtetlist&#39; are NOT deleted.  The caller has the right to either  //</span>
<a name="l12025"></a>12025 <span class="comment">// delete them or reverse the operation.                                     //</span>
<a name="l12026"></a>12026 <span class="comment">//                                                                           //</span>
<a name="l12028"></a>12028 <span class="comment"></span>
<a name="l12029"></a>12029 <span class="keywordtype">bool</span> tetgenmesh::removeedgebyflip32(REAL *key, triface *abtetlist,
<a name="l12030"></a>12030   triface *newtetlist, queue *flipque)
<a name="l12031"></a>12031 {
<a name="l12032"></a>12032   triface dcea, cdeb; <span class="comment">// new configuration.</span>
<a name="l12033"></a>12033   triface newfront, oldfront, adjfront;
<a name="l12034"></a>12034   face checksh;
<a name="l12035"></a>12035   point pa, pb, pc, pd, pe;
<a name="l12036"></a>12036   REAL ori, cosmaxd, d1, d2;
<a name="l12037"></a>12037   REAL attrib, volume;
<a name="l12038"></a>12038   <span class="keywordtype">bool</span> doflip;
<a name="l12039"></a>12039   <span class="keywordtype">int</span> i;
<a name="l12040"></a>12040 
<a name="l12041"></a>12041   pa = org(abtetlist[0]);
<a name="l12042"></a>12042   pb = dest(abtetlist[0]);
<a name="l12043"></a>12043   pc = apex(abtetlist[0]);
<a name="l12044"></a>12044   pd = apex(abtetlist[1]);
<a name="l12045"></a>12045   pe = apex(abtetlist[2]);
<a name="l12046"></a>12046 
<a name="l12047"></a>12047   ori = orient3d(pd, pc, pe, pa);
<a name="l12048"></a>12048   <span class="keywordflow">if</span> (ori &lt; 0.0) {
<a name="l12049"></a>12049     ori = orient3d(pc, pd, pe, pb);
<a name="l12050"></a>12050   }
<a name="l12051"></a>12051   doflip = (ori &lt; 0.0); <span class="comment">// Can ab be flipped away?</span>
<a name="l12052"></a>12052 
<a name="l12053"></a>12053   <span class="comment">// Does the caller ensure a valid configuration?</span>
<a name="l12054"></a>12054   <span class="keywordflow">if</span> (doflip &amp;&amp; (key != (REAL *) NULL)) {
<a name="l12055"></a>12055     <span class="keywordflow">if</span> (*key &gt; -1.0) {
<a name="l12056"></a>12056       <span class="comment">// Test if the new tets reduce the maximal dihedral angle.</span>
<a name="l12057"></a>12057       tetalldihedral(pd, pc, pe, pa, NULL, &amp;d1, NULL);
<a name="l12058"></a>12058       tetalldihedral(pc, pd, pe, pb, NULL, &amp;d2, NULL);
<a name="l12059"></a>12059       cosmaxd = d1 &lt; d2 ? d1 : d2; <span class="comment">// Choose the bigger angle.</span>
<a name="l12060"></a>12060       doflip = (*key &lt; cosmaxd); <span class="comment">// Can local quality be improved?</span>
<a name="l12061"></a>12061       <span class="comment">// Return the key</span>
<a name="l12062"></a>12062       *key = cosmaxd;
<a name="l12063"></a>12063     }
<a name="l12064"></a>12064   }
<a name="l12065"></a>12065 
<a name="l12066"></a>12066   <span class="keywordflow">if</span> (doflip) {
<a name="l12067"></a>12067     <span class="comment">// Create the new tets.</span>
<a name="l12068"></a>12068     maketetrahedron(&amp;dcea);
<a name="l12069"></a>12069     setorg(dcea, pd);
<a name="l12070"></a>12070     setdest(dcea, pc);
<a name="l12071"></a>12071     setapex(dcea, pe);
<a name="l12072"></a>12072     setoppo(dcea, pa);
<a name="l12073"></a>12073     maketetrahedron(&amp;cdeb);
<a name="l12074"></a>12074     setorg(cdeb, pc);
<a name="l12075"></a>12075     setdest(cdeb, pd);
<a name="l12076"></a>12076     setapex(cdeb, pe);
<a name="l12077"></a>12077     setoppo(cdeb, pb);
<a name="l12078"></a>12078     <span class="comment">// Transfer the element attributes.</span>
<a name="l12079"></a>12079     <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l12080"></a>12080       attrib = elemattribute(abtetlist[0].tet, i);
<a name="l12081"></a>12081       setelemattribute(dcea.tet, i, attrib);
<a name="l12082"></a>12082       setelemattribute(cdeb.tet, i, attrib);
<a name="l12083"></a>12083     }
<a name="l12084"></a>12084     <span class="comment">// Transfer the volume constraints.</span>
<a name="l12085"></a>12085     <span class="keywordflow">if</span> (b-&gt;varvolume &amp;&amp; !b-&gt;refine) {
<a name="l12086"></a>12086       volume = volumebound(abtetlist[0].tet);
<a name="l12087"></a>12087       setvolumebound(dcea.tet, volume);
<a name="l12088"></a>12088       setvolumebound(cdeb.tet, volume);
<a name="l12089"></a>12089     }
<a name="l12090"></a>12090     <span class="comment">// Return two new tets.</span>
<a name="l12091"></a>12091     newtetlist[0] = dcea;
<a name="l12092"></a>12092     newtetlist[1] = cdeb;
<a name="l12093"></a>12093     <span class="comment">// Glue the two new tets.</span>
<a name="l12094"></a>12094     bond(dcea, cdeb);
<a name="l12095"></a>12095     <span class="comment">// Substitute the two new tets into the old three-tets cavity.</span>
<a name="l12096"></a>12096     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l12097"></a>12097       fnext(dcea, newfront); <span class="comment">// face dca, cea, eda.</span>
<a name="l12098"></a>12098       esym(abtetlist[(i + 1) % 3], oldfront);
<a name="l12099"></a>12099       enextfnextself(oldfront);
<a name="l12100"></a>12100       <span class="comment">// Get the adjacent tet at the face (may be a dummytet).</span>
<a name="l12101"></a>12101       sym(oldfront, adjfront);
<a name="l12102"></a>12102       bond(newfront, adjfront);
<a name="l12103"></a>12103       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12104"></a>12104         tspivot(oldfront, checksh);
<a name="l12105"></a>12105         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12106"></a>12106           tsbond(newfront, checksh);
<a name="l12107"></a>12107         }
<a name="l12108"></a>12108       }
<a name="l12109"></a>12109       <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l12110"></a>12110         enqueueflipface(newfront, flipque);
<a name="l12111"></a>12111       }
<a name="l12112"></a>12112       enext2self(dcea);
<a name="l12113"></a>12113     }
<a name="l12114"></a>12114     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l12115"></a>12115       fnext(cdeb, newfront); <span class="comment">// face cdb, deb, ecb.</span>
<a name="l12116"></a>12116       esym(abtetlist[(i + 1) % 3], oldfront);
<a name="l12117"></a>12117       enext2fnextself(oldfront);
<a name="l12118"></a>12118       <span class="comment">// Get the adjacent tet at the face (may be a dummytet).</span>
<a name="l12119"></a>12119       sym(oldfront, adjfront);
<a name="l12120"></a>12120       bond(newfront, adjfront);
<a name="l12121"></a>12121       <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12122"></a>12122         tspivot(oldfront, checksh);
<a name="l12123"></a>12123         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12124"></a>12124           tsbond(newfront, checksh);
<a name="l12125"></a>12125         }
<a name="l12126"></a>12126       }
<a name="l12127"></a>12127       <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l12128"></a>12128         enqueueflipface(newfront, flipque);
<a name="l12129"></a>12129       }
<a name="l12130"></a>12130       enextself(cdeb);
<a name="l12131"></a>12131     }
<a name="l12132"></a>12132     <span class="comment">// Do not delete the old tets.</span>
<a name="l12133"></a>12133     <span class="comment">// for (i = 0; i &lt; 3; i++) {</span>
<a name="l12134"></a>12134     <span class="comment">//   tetrahedrondealloc(abtetlist[i].tet);</span>
<a name="l12135"></a>12135     <span class="comment">// }</span>
<a name="l12136"></a>12136     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12137"></a>12137   } <span class="comment">// if (doflip)</span>
<a name="l12138"></a>12138 
<a name="l12139"></a>12139   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12140"></a>12140 }
<a name="l12141"></a>12141 
<a name="l12143"></a>12143 <span class="comment">//                                                                           //</span>
<a name="l12144"></a>12144 <span class="comment">// removeedgebytranNM()    Remove an edge by transforming n-to-m tets.       //</span>
<a name="l12145"></a>12145 <span class="comment">//                                                                           //</span>
<a name="l12146"></a>12146 <span class="comment">// This routine attempts to remove a given edge (ab) by transforming the set //</span>
<a name="l12147"></a>12147 <span class="comment">// T of tets surrounding ab into another set T&#39; of tets.  T and T&#39; have the  //</span>
<a name="l12148"></a>12148 <span class="comment">// same outer faces and ab is not an edge of T&#39; anymore. Let |T|=n, and |T&#39;| //</span>
<a name="l12149"></a>12149 <span class="comment">// =m, it is actually a n-to-m flip for n &gt; 3.  The relation between n and m //</span>
<a name="l12150"></a>12150 <span class="comment">// depends on the method, ours is found below.                               //</span>
<a name="l12151"></a>12151 <span class="comment">//                                                                           //</span>
<a name="l12152"></a>12152 <span class="comment">// &#39;abtetlist&#39; contains n tets sharing ab. Imaging that ab is perpendicular  //</span>
<a name="l12153"></a>12153 <span class="comment">// to the screen, where a lies in front of and b lies behind it.  Let the    //</span>
<a name="l12154"></a>12154 <span class="comment">// projections of the n apexes onto screen in clockwise order are: p_0, ...  //</span>
<a name="l12155"></a>12155 <span class="comment">// p_n-1, respectively. The tets in the list are: [0]abp_0p_n-1,[1]abp_1p_0, //</span>
<a name="l12156"></a>12156 <span class="comment">// ..., [n-1]abp_n-1p_n-2, respectively.                                     //</span>
<a name="l12157"></a>12157 <span class="comment">//                                                                           //</span>
<a name="l12158"></a>12158 <span class="comment">// The principle of the approach is: Recursively reduce the link of ab by    //</span>
<a name="l12159"></a>12159 <span class="comment">// using flip23 until only three faces remain, hence a flip32 can be applied //</span>
<a name="l12160"></a>12160 <span class="comment">// to remove ab. For a given face a.b.p_0, check a flip23 can be applied on  //</span>
<a name="l12161"></a>12161 <span class="comment">// it, i.e, edge p_1.p_n-1 crosses it. NOTE*** We do the flip even p_1.p_n-1 //</span>
<a name="l12162"></a>12162 <span class="comment">// intersects with a.b (they are coplanar). If so, a degenerate tet (a.b.p_1.//</span>
<a name="l12163"></a>12163 <span class="comment">// p_n-1) is temporarily created, but it will be eventually removed by the   //</span>
<a name="l12164"></a>12164 <span class="comment">// final flip32. This relaxation splits a flip44 into flip23 + flip32. *NOTE //</span>
<a name="l12165"></a>12165 <span class="comment">// Now suppose a.b.p_0 gets flipped, p_0 is not on the link of ab anymore.   //</span>
<a name="l12166"></a>12166 <span class="comment">// The link is then reduced (by 1). 2 of the 3 new tets, p_n-1.p_1.p_0.a and //</span>
<a name="l12167"></a>12167 <span class="comment">// p_1.p_n-1.p_0.b, will be part of the new configuration.  The left new tet,//</span>
<a name="l12168"></a>12168 <span class="comment">// a.b.p_1.p_n-1, goes into the new link of ab. A recurrence can be applied. //</span>
<a name="l12169"></a>12169 <span class="comment">//                                                                           //</span>
<a name="l12170"></a>12170 <span class="comment">// If &#39;e1&#39; and &#39;e2&#39; are not NULLs, they specify an wanted edge to appear in  //</span>
<a name="l12171"></a>12171 <span class="comment">// the new tet configuration. In such case, only do flip23 if edge e1&lt;-&gt;e2   //</span>
<a name="l12172"></a>12172 <span class="comment">// can be recovered. It is used in removeedgebycombNM().                     //</span>
<a name="l12173"></a>12173 <span class="comment">//                                                                           //</span>
<a name="l12174"></a>12174 <span class="comment">// If ab gets removed. &#39;newtetlist&#39; contains m new tets.  By using the above //</span>
<a name="l12175"></a>12175 <span class="comment">// approach, the pairs (n, m) can be easily enumerated.  For example, (3, 2),//</span>
<a name="l12176"></a>12176 <span class="comment">// (4, 4), (5, 6), (6, 8), (7, 10), (8, 12), (9, 14), (10, 16),  and so on.  //</span>
<a name="l12177"></a>12177 <span class="comment">// It is easy to deduce, that m = (n - 2) * 2, when n &gt;= 3.  The n tets in   //</span>
<a name="l12178"></a>12178 <span class="comment">// &#39;abtetlist&#39; are NOT deleted in this routine. The caller has the right to  //</span>
<a name="l12179"></a>12179 <span class="comment">// either delete them or reverse this operation.                             //</span>
<a name="l12180"></a>12180 <span class="comment">//                                                                           //</span>
<a name="l12182"></a>12182 <span class="comment"></span>
<a name="l12183"></a>12183 <span class="keywordtype">bool</span> tetgenmesh::removeedgebytranNM(REAL *key, <span class="keywordtype">int</span> n, triface *abtetlist,
<a name="l12184"></a>12184   triface *newtetlist, point e1, point e2, queue *flipque)
<a name="l12185"></a>12185 {
<a name="l12186"></a>12186   triface tmpabtetlist[9]; <span class="comment">// Temporary max 9 tets configuration.</span>
<a name="l12187"></a>12187   triface newfront, oldfront, adjfront;
<a name="l12188"></a>12188   face checksh;
<a name="l12189"></a>12189   point pa, pb, p[10];
<a name="l12190"></a>12190   REAL ori, cosmaxd, d1, d2;
<a name="l12191"></a>12191   REAL tmpkey;
<a name="l12192"></a>12192   REAL attrib, volume;
<a name="l12193"></a>12193   <span class="keywordtype">bool</span> doflip, copflag, success;
<a name="l12194"></a>12194   <span class="keywordtype">int</span> i, j, k;
<a name="l12195"></a>12195 
<a name="l12196"></a>12196   cosmaxd = 0.0;
<a name="l12197"></a>12197   <span class="comment">// Maximum 10 tets.</span>
<a name="l12198"></a>12198   assert(n &lt;= 10);
<a name="l12199"></a>12199   <span class="comment">// Two points a and b are fixed.</span>
<a name="l12200"></a>12200   pa = org(abtetlist[0]);
<a name="l12201"></a>12201   pb = dest(abtetlist[0]);
<a name="l12202"></a>12202   <span class="comment">// The points p_0, p_1, ..., p_n-1 are permuted in each new configuration.</span>
<a name="l12203"></a>12203   <span class="comment">//   These permutations can be easily done in the following loop.</span>
<a name="l12204"></a>12204   <span class="comment">// Loop through all the possible new tets configurations. Stop on finding</span>
<a name="l12205"></a>12205   <span class="comment">//   a valid new tet configuration which also immproves the quality value.</span>
<a name="l12206"></a>12206   <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l12207"></a>12207     <span class="comment">// Get other n points for the current configuration.</span>
<a name="l12208"></a>12208     <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l12209"></a>12209       p[j] = apex(abtetlist[(i + j) % n]);
<a name="l12210"></a>12210     }
<a name="l12211"></a>12211     <span class="comment">// Is there a wanted edge?</span>
<a name="l12212"></a>12212     <span class="keywordflow">if</span> ((e1 != (point) NULL) &amp;&amp; (e2 != (point) NULL)) {
<a name="l12213"></a>12213       <span class="comment">// Yes. Skip this face if p[1]&lt;-&gt;p[n-1] is not the edge.</span>
<a name="l12214"></a>12214       <span class="keywordflow">if</span> (!(((p[1] == e1) &amp;&amp; (p[n - 1] == e2)) ||
<a name="l12215"></a>12215         ((p[1] == e2) &amp;&amp; (p[n - 1] == e1)))) <span class="keywordflow">continue</span>;
<a name="l12216"></a>12216     }
<a name="l12217"></a>12217     <span class="comment">// Test if face a.b.p_0 can be flipped (by flip23), ie, to check if the</span>
<a name="l12218"></a>12218     <span class="comment">//   edge p_n-1.p_1 crosses face a.b.p_0 properly.</span>
<a name="l12219"></a>12219     <span class="comment">// Note. It is possible that face a.b.p_0 has type flip44, ie, a,b,p_1,</span>
<a name="l12220"></a>12220     <span class="comment">//   and p_n-1 are coplanar. A trick is to split the flip44 into two</span>
<a name="l12221"></a>12221     <span class="comment">//   steps: frist a flip23, then a flip32. The first step creates a</span>
<a name="l12222"></a>12222     <span class="comment">//   degenerate tet (vol=0) which will be removed by the second flip.</span>
<a name="l12223"></a>12223     ori = orient3d(pa, pb, p[1], p[n - 1]);
<a name="l12224"></a>12224     copflag = (ori == 0.0); <span class="comment">// Are they coplanar?</span>
<a name="l12225"></a>12225     <span class="keywordflow">if</span> (ori &gt;= 0.0) {
<a name="l12226"></a>12226       <span class="comment">// Accept the coplanar case which supports flip44.</span>
<a name="l12227"></a>12227       ori = orient3d(pb, p[0], p[1], p[n - 1]);
<a name="l12228"></a>12228       <span class="keywordflow">if</span> (ori &gt; 0.0) {
<a name="l12229"></a>12229         ori = orient3d(p[0], pa, p[1], p[n - 1]);
<a name="l12230"></a>12230       }
<a name="l12231"></a>12231     }
<a name="l12232"></a>12232     <span class="comment">// Is face abc flipable?</span>
<a name="l12233"></a>12233     <span class="keywordflow">if</span> (ori &gt; 0.0) {
<a name="l12234"></a>12234       <span class="comment">// A valid (2-to-3) flip (or 4-to-4 flip) is found.</span>
<a name="l12235"></a>12235       copflag ? flip44s++ : flip23s++;
<a name="l12236"></a>12236       doflip = <span class="keyword">true</span>;
<a name="l12237"></a>12237       <span class="keywordflow">if</span> (key != (REAL *) NULL) {
<a name="l12238"></a>12238         <span class="keywordflow">if</span> (*key &gt; -1.0) {
<a name="l12239"></a>12239           <span class="comment">// Test if the new tets reduce the maximal dihedral angle. Only 2</span>
<a name="l12240"></a>12240           <span class="comment">//   tets, p_n-1.p_1.p_0.a and p_1.p_n-1.p_0.b, need to be tested</span>
<a name="l12241"></a>12241           <span class="comment">//   The left one a.b.p_n-1.p_1 goes into the new link of ab.</span>
<a name="l12242"></a>12242           tetalldihedral(p[n - 1], p[1], p[0], pa, NULL, &amp;d1, NULL);
<a name="l12243"></a>12243           tetalldihedral(p[1], p[n - 1], p[0], pb, NULL, &amp;d2, NULL);
<a name="l12244"></a>12244           cosmaxd = d1 &lt; d2 ? d1 : d2; <span class="comment">// Choose the bigger angle.</span>
<a name="l12245"></a>12245           doflip = *key &lt; cosmaxd; <span class="comment">// Can the local quality be improved?</span>
<a name="l12246"></a>12246         }
<a name="l12247"></a>12247       }
<a name="l12248"></a>12248       <span class="keywordflow">if</span> (doflip) {
<a name="l12249"></a>12249         tmpkey = key != NULL ? *key : -1.0;
<a name="l12250"></a>12250         <span class="comment">// Create the two new tets.</span>
<a name="l12251"></a>12251         maketetrahedron(&amp;(newtetlist[0]));
<a name="l12252"></a>12252         setorg(newtetlist[0], p[n - 1]);
<a name="l12253"></a>12253         setdest(newtetlist[0], p[1]);
<a name="l12254"></a>12254         setapex(newtetlist[0], p[0]);
<a name="l12255"></a>12255         setoppo(newtetlist[0], pa);
<a name="l12256"></a>12256         maketetrahedron(&amp;(newtetlist[1]));
<a name="l12257"></a>12257         setorg(newtetlist[1], p[1]);
<a name="l12258"></a>12258         setdest(newtetlist[1], p[n - 1]);
<a name="l12259"></a>12259         setapex(newtetlist[1], p[0]);
<a name="l12260"></a>12260         setoppo(newtetlist[1], pb);
<a name="l12261"></a>12261         <span class="comment">// Create the n - 1 temporary new tets (the new Star(ab)).</span>
<a name="l12262"></a>12262         maketetrahedron(&amp;(tmpabtetlist[0]));
<a name="l12263"></a>12263         setorg(tmpabtetlist[0], pa);
<a name="l12264"></a>12264         setdest(tmpabtetlist[0], pb);
<a name="l12265"></a>12265         setapex(tmpabtetlist[0], p[n - 1]);
<a name="l12266"></a>12266         setoppo(tmpabtetlist[0], p[1]);
<a name="l12267"></a>12267         <span class="keywordflow">for</span> (j = 1; j &lt; n - 1; j++) {
<a name="l12268"></a>12268           maketetrahedron(&amp;(tmpabtetlist[j]));
<a name="l12269"></a>12269           setorg(tmpabtetlist[j], pa);
<a name="l12270"></a>12270           setdest(tmpabtetlist[j], pb);
<a name="l12271"></a>12271           setapex(tmpabtetlist[j], p[j]);
<a name="l12272"></a>12272           setoppo(tmpabtetlist[j], p[j + 1]);
<a name="l12273"></a>12273         }
<a name="l12274"></a>12274         <span class="comment">// Transfer the element attributes.</span>
<a name="l12275"></a>12275         <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberoftetrahedronattributes; j++) {
<a name="l12276"></a>12276           attrib = elemattribute(abtetlist[0].tet, j);
<a name="l12277"></a>12277           setelemattribute(newtetlist[0].tet, j, attrib);
<a name="l12278"></a>12278           setelemattribute(newtetlist[1].tet, j, attrib);
<a name="l12279"></a>12279           <span class="keywordflow">for</span> (k = 0; k &lt; n - 1; k++) {
<a name="l12280"></a>12280             setelemattribute(tmpabtetlist[k].tet, j, attrib);
<a name="l12281"></a>12281           }
<a name="l12282"></a>12282         }
<a name="l12283"></a>12283         <span class="comment">// Transfer the volume constraints.</span>
<a name="l12284"></a>12284         <span class="keywordflow">if</span> (b-&gt;varvolume &amp;&amp; !b-&gt;refine) {
<a name="l12285"></a>12285           volume = volumebound(abtetlist[0].tet);
<a name="l12286"></a>12286           setvolumebound(newtetlist[0].tet, volume);
<a name="l12287"></a>12287           setvolumebound(newtetlist[1].tet, volume);
<a name="l12288"></a>12288           <span class="keywordflow">for</span> (k = 0; k &lt; n - 1; k++) {
<a name="l12289"></a>12289             setvolumebound(tmpabtetlist[k].tet, volume);
<a name="l12290"></a>12290           }
<a name="l12291"></a>12291         }
<a name="l12292"></a>12292         <span class="comment">// Glue the new tets at their internal faces: 2 + (n - 1).</span>
<a name="l12293"></a>12293         bond(newtetlist[0], newtetlist[1]); <span class="comment">// p_n-1.p_1.p_0.</span>
<a name="l12294"></a>12294         fnext(newtetlist[0], newfront);
<a name="l12295"></a>12295         enext2fnext(tmpabtetlist[0], adjfront);
<a name="l12296"></a>12296         bond(newfront, adjfront); <span class="comment">// p_n-1.p_1.a.</span>
<a name="l12297"></a>12297         fnext(newtetlist[1], newfront);
<a name="l12298"></a>12298         enextfnext(tmpabtetlist[0], adjfront);
<a name="l12299"></a>12299         bond(newfront, adjfront); <span class="comment">// p_n-1.p_1.b.</span>
<a name="l12300"></a>12300         <span class="comment">// Glue n - 1 internal faces around ab.</span>
<a name="l12301"></a>12301         <span class="keywordflow">for</span> (j = 0; j &lt; n - 1; j++) {
<a name="l12302"></a>12302           fnext(tmpabtetlist[j], newfront);
<a name="l12303"></a>12303           bond(newfront, tmpabtetlist[(j + 1) % (n - 1)]); <span class="comment">// a.b.p_j+1</span>
<a name="l12304"></a>12304         }
<a name="l12305"></a>12305         <span class="comment">// Substitute the old tets with the new tets by connecting the new</span>
<a name="l12306"></a>12306         <span class="comment">//   tets to the adjacent tets in the mesh. There are n * 2 (outer)</span>
<a name="l12307"></a>12307         <span class="comment">//   faces of the new tets need to be operated.</span>
<a name="l12308"></a>12308         <span class="comment">// Note, after the substitution, the old tets still have pointers to</span>
<a name="l12309"></a>12309         <span class="comment">//   their adjacent tets in the mesh.  These pointers can be re-used</span>
<a name="l12310"></a>12310         <span class="comment">//   to inverse the substitution.</span>
<a name="l12311"></a>12311         <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l12312"></a>12312           <span class="comment">// Get an old tet: [0]a.b.p_0.p_n-1 or [j]a.b.p_j.p_j-1, (j &gt; 0).</span>
<a name="l12313"></a>12313           oldfront = abtetlist[(i + j) % n];
<a name="l12314"></a>12314           esymself(oldfront);
<a name="l12315"></a>12315           enextfnextself(oldfront);
<a name="l12316"></a>12316           <span class="comment">// Get an adjacent tet at face: [0]a.p_0.p_n-1 or [j]a.p_j.p_j-1.</span>
<a name="l12317"></a>12317           sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy.</span>
<a name="l12318"></a>12318           <span class="comment">// Get the corresponding face from the new tets.</span>
<a name="l12319"></a>12319           <span class="keywordflow">if</span> (j == 0) {
<a name="l12320"></a>12320             enext2fnext(newtetlist[0], newfront); <span class="comment">// a.p_0.n_n-1</span>
<a name="l12321"></a>12321           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j == 1) {
<a name="l12322"></a>12322             enextfnext(newtetlist[0], newfront); <span class="comment">// a.p_1.p_0</span>
<a name="l12323"></a>12323           } <span class="keywordflow">else</span> { <span class="comment">// j &gt;= 2.</span>
<a name="l12324"></a>12324             enext2fnext(tmpabtetlist[j - 1], newfront); <span class="comment">// a.p_j.p_j-1</span>
<a name="l12325"></a>12325           }
<a name="l12326"></a>12326           bond(newfront, adjfront);
<a name="l12327"></a>12327           <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12328"></a>12328             tspivot(oldfront, checksh);
<a name="l12329"></a>12329             <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12330"></a>12330               tsbond(newfront, checksh);
<a name="l12331"></a>12331             }
<a name="l12332"></a>12332           }
<a name="l12333"></a>12333           <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l12334"></a>12334             <span class="comment">// Only queue the faces of the two new tets.</span>
<a name="l12335"></a>12335             <span class="keywordflow">if</span> (j &lt; 2) enqueueflipface(newfront, flipque);
<a name="l12336"></a>12336           }
<a name="l12337"></a>12337         }
<a name="l12338"></a>12338         <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l12339"></a>12339           <span class="comment">// Get an old tet: [0]a.b.p_0.p_n-1 or [j]a.b.p_j.p_j-1, (j &gt; 0).</span>
<a name="l12340"></a>12340           oldfront = abtetlist[(i + j) % n];
<a name="l12341"></a>12341           esymself(oldfront);
<a name="l12342"></a>12342           enext2fnextself(oldfront);
<a name="l12343"></a>12343           <span class="comment">// Get an adjacent tet at face: [0]b.p_0.p_n-1 or [j]b.p_j.p_j-1.</span>
<a name="l12344"></a>12344           sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy.</span>
<a name="l12345"></a>12345           <span class="comment">// Get the corresponding face from the new tets.</span>
<a name="l12346"></a>12346           <span class="keywordflow">if</span> (j == 0) {
<a name="l12347"></a>12347             enextfnext(newtetlist[1], newfront); <span class="comment">// b.p_0.n_n-1</span>
<a name="l12348"></a>12348           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (j == 1) {
<a name="l12349"></a>12349             enext2fnext(newtetlist[1], newfront); <span class="comment">// b.p_1.p_0</span>
<a name="l12350"></a>12350           } <span class="keywordflow">else</span> { <span class="comment">// j &gt;= 2.</span>
<a name="l12351"></a>12351             enextfnext(tmpabtetlist[j - 1], newfront); <span class="comment">// b.p_j.p_j-1</span>
<a name="l12352"></a>12352           }
<a name="l12353"></a>12353           bond(newfront, adjfront);
<a name="l12354"></a>12354           <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12355"></a>12355             tspivot(oldfront, checksh);
<a name="l12356"></a>12356             <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12357"></a>12357               tsbond(newfront, checksh);
<a name="l12358"></a>12358             }
<a name="l12359"></a>12359           }
<a name="l12360"></a>12360           <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l12361"></a>12361             <span class="comment">// Only queue the faces of the two new tets.</span>
<a name="l12362"></a>12362             <span class="keywordflow">if</span> (j &lt; 2) enqueueflipface(newfront, flipque);
<a name="l12363"></a>12363           }
<a name="l12364"></a>12364         }
<a name="l12365"></a>12365         <span class="comment">// Adjust the faces in the temporary new tets at ab for recursively</span>
<a name="l12366"></a>12366         <span class="comment">//   processing on the n-1 tets.(See the description at beginning)</span>
<a name="l12367"></a>12367         <span class="keywordflow">for</span> (j = 0; j &lt; n - 1; j++) {
<a name="l12368"></a>12368           fnextself(tmpabtetlist[j]);
<a name="l12369"></a>12369         }
<a name="l12370"></a>12370         <span class="keywordflow">if</span> (n &gt; 4) {
<a name="l12371"></a>12371           success = removeedgebytranNM(&amp;tmpkey, n-1, tmpabtetlist,
<a name="l12372"></a>12372             &amp;(newtetlist[2]), NULL, NULL, flipque);
<a name="l12373"></a>12373         } <span class="keywordflow">else</span> { <span class="comment">// assert(n == 4);</span>
<a name="l12374"></a>12374           success = removeedgebyflip32(&amp;tmpkey, tmpabtetlist,
<a name="l12375"></a>12375             &amp;(newtetlist[2]), flipque);
<a name="l12376"></a>12376         }
<a name="l12377"></a>12377         <span class="comment">// No matter it was success or not, delete the temporary tets.</span>
<a name="l12378"></a>12378         <span class="keywordflow">for</span> (j = 0; j &lt; n - 1; j++) {
<a name="l12379"></a>12379           tetrahedrondealloc(tmpabtetlist[j].tet);
<a name="l12380"></a>12380         }
<a name="l12381"></a>12381         <span class="keywordflow">if</span> (success) {
<a name="l12382"></a>12382           <span class="comment">// The new configuration is good.</span>
<a name="l12383"></a>12383           <span class="comment">// Do not delete the old tets.</span>
<a name="l12384"></a>12384           <span class="comment">// for (j = 0; j &lt; n; j++) {</span>
<a name="l12385"></a>12385           <span class="comment">//   tetrahedrondealloc(abtetlist[j].tet);</span>
<a name="l12386"></a>12386           <span class="comment">// }</span>
<a name="l12387"></a>12387           <span class="comment">// Save the minimal improved quality value.</span>
<a name="l12388"></a>12388           <span class="keywordflow">if</span> (key != (REAL *) NULL) {
<a name="l12389"></a>12389             *key = (tmpkey &lt; cosmaxd ? tmpkey : cosmaxd);
<a name="l12390"></a>12390           }
<a name="l12391"></a>12391           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12392"></a>12392         } <span class="keywordflow">else</span> {
<a name="l12393"></a>12393           <span class="comment">// The new configuration is bad, substitue back the old tets.</span>
<a name="l12394"></a>12394           <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l12395"></a>12395             oldfront = abtetlist[(i + j) % n];
<a name="l12396"></a>12396             esymself(oldfront);
<a name="l12397"></a>12397             enextfnextself(oldfront); <span class="comment">// [0]a.p_0.p_n-1, [j]a.p_j.p_j-1.</span>
<a name="l12398"></a>12398             sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy.</span>
<a name="l12399"></a>12399             bond(oldfront, adjfront);
<a name="l12400"></a>12400             <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12401"></a>12401               tspivot(oldfront, checksh);
<a name="l12402"></a>12402               <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12403"></a>12403                 tsbond(oldfront, checksh);
<a name="l12404"></a>12404               }
<a name="l12405"></a>12405             }
<a name="l12406"></a>12406           }
<a name="l12407"></a>12407           <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l12408"></a>12408             oldfront = abtetlist[(i + j) % n];
<a name="l12409"></a>12409             esymself(oldfront);
<a name="l12410"></a>12410             enext2fnextself(oldfront); <span class="comment">// [0]b.p_0.p_n-1, [j]b.p_j.p_j-1.</span>
<a name="l12411"></a>12411             sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy</span>
<a name="l12412"></a>12412             bond(oldfront, adjfront);
<a name="l12413"></a>12413             <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12414"></a>12414               tspivot(oldfront, checksh);
<a name="l12415"></a>12415               <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12416"></a>12416                 tsbond(oldfront, checksh);
<a name="l12417"></a>12417               }
<a name="l12418"></a>12418             }
<a name="l12419"></a>12419           }
<a name="l12420"></a>12420           <span class="comment">// Delete the new tets.</span>
<a name="l12421"></a>12421           tetrahedrondealloc(newtetlist[0].tet);
<a name="l12422"></a>12422           tetrahedrondealloc(newtetlist[1].tet);
<a name="l12423"></a>12423           <span class="comment">// If tmpkey has been modified, then the failure was not due to</span>
<a name="l12424"></a>12424           <span class="comment">//   unflipable configuration, but the non-improvement.</span>
<a name="l12425"></a>12425           <span class="keywordflow">if</span> (key &amp;&amp; (tmpkey &lt; *key)) {
<a name="l12426"></a>12426             *key = tmpkey;
<a name="l12427"></a>12427             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12428"></a>12428           }
<a name="l12429"></a>12429         } <span class="comment">// if (success)</span>
<a name="l12430"></a>12430       } <span class="comment">// if (doflip)</span>
<a name="l12431"></a>12431     } <span class="comment">// if (ori &gt; 0.0)</span>
<a name="l12432"></a>12432   } <span class="comment">// for (i = 0; i &lt; n; i++)</span>
<a name="l12433"></a>12433 
<a name="l12434"></a>12434   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12435"></a>12435 }
<a name="l12436"></a>12436 
<a name="l12438"></a>12438 <span class="comment">//                                                                           //</span>
<a name="l12439"></a>12439 <span class="comment">// removeedgebycombNM()    Remove an edge by combining two flipNMs.          //</span>
<a name="l12440"></a>12440 <span class="comment">//                                                                           //</span>
<a name="l12441"></a>12441 <span class="comment">// Given a set T of tets surrounding edge ab. The premise is that ab can not //</span>
<a name="l12442"></a>12442 <span class="comment">// be removed by a flipNM. This routine attempts to remove ab by two flipNMs,//</span>
<a name="l12443"></a>12443 <span class="comment">// i.e., first find and flip an edge af (or bf) by flipNM, then flip ab by   //</span>
<a name="l12444"></a>12444 <span class="comment">// flipNM. If it succeeds, two sets T(ab) and T(af) of tets are replaced by  //</span>
<a name="l12445"></a>12445 <span class="comment">// a new set T&#39; and both ab and af are not edges in T&#39; anymore.              //</span>
<a name="l12446"></a>12446 <span class="comment">//                                                                           //</span>
<a name="l12447"></a>12447 <span class="comment">// &#39;abtetlist&#39; contains n tets sharing ab. Imaging that ab is perpendicular  //</span>
<a name="l12448"></a>12448 <span class="comment">// to the screen, such that a lies in front of and b lies behind it. Let the //</span>
<a name="l12449"></a>12449 <span class="comment">// projections of the n apexes on the screen in clockwise order are: p_0,...,//</span>
<a name="l12450"></a>12450 <span class="comment">// p_n-1, respectively. So the list of tets are: [0]abp_0p_n-1, [1]abp_1p_0, //</span>
<a name="l12451"></a>12451 <span class="comment">// ..., [n-1]abp_n-1p_n-2, respectively.                                     //</span>
<a name="l12452"></a>12452 <span class="comment">//                                                                           //</span>
<a name="l12453"></a>12453 <span class="comment">// The principle of the approach is: for a face a.b.p_0, check if edge b.p_0 //</span>
<a name="l12454"></a>12454 <span class="comment">// is of type N32 (or N44). If it is, then try to do a flipNM on it. If the  //</span>
<a name="l12455"></a>12455 <span class="comment">// flip is successful, then try to do another flipNM on a.b.  If one of the  //</span>
<a name="l12456"></a>12456 <span class="comment">// two flipNMs fails, restore the old tets as they have never been flipped.  //</span>
<a name="l12457"></a>12457 <span class="comment">// Then try the next face a.b.p_1.  The process can be looped for all faces  //</span>
<a name="l12458"></a>12458 <span class="comment">// having ab. Stop if ab is removed or all faces have been visited. Note in  //</span>
<a name="l12459"></a>12459 <span class="comment">// the above description only b.p_0 is considered, a.p_0 is done by swapping //</span>
<a name="l12460"></a>12460 <span class="comment">// the position of a and b.                                                  //</span>
<a name="l12461"></a>12461 <span class="comment">//                                                                           //</span>
<a name="l12462"></a>12462 <span class="comment">// Similar operations have been described in [Joe,1995].  My approach checks //</span>
<a name="l12463"></a>12463 <span class="comment">// more cases for finding flips than Joe&#39;s.  For instance, the cases (1)-(7) //</span>
<a name="l12464"></a>12464 <span class="comment">// of Joe only consider abf for finding a flip (T23/T32).  My approach looks //</span>
<a name="l12465"></a>12465 <span class="comment">// all faces at ab for finding flips. Moreover, the flipNM can flip an edge  //</span>
<a name="l12466"></a>12466 <span class="comment">// whose star may have more than 3 tets while Joe&#39;s only works on 3-tet case.//</span>
<a name="l12467"></a>12467 <span class="comment">//                                                                           //</span>
<a name="l12468"></a>12468 <span class="comment">// If ab is removed, &#39;newtetlist&#39; contains the new tets. Two sets &#39;abtetlist&#39;//</span>
<a name="l12469"></a>12469 <span class="comment">// (n tets) and &#39;bftetlist&#39; (n1 tets) have been replaced.  The number of new //</span>
<a name="l12470"></a>12470 <span class="comment">// tets can be calculated by follows: the 1st flip transforms n1 tets into   //</span>
<a name="l12471"></a>12471 <span class="comment">// (n1 - 2) * 2 new tets, however,one of the new tets goes into the new link //</span>
<a name="l12472"></a>12472 <span class="comment">// of ab, i.e., the reduced tet number in Star(ab) is n - 1;  the 2nd flip   //</span>
<a name="l12473"></a>12473 <span class="comment">// transforms n - 1 tets into (n - 3) * 2 new tets. Hence the number of new  //</span>
<a name="l12474"></a>12474 <span class="comment">// tets are: m = ((n1 - 2) * 2 - 1) + (n - 3) * 2.  The old tets are NOT del-//</span>
<a name="l12475"></a>12475 <span class="comment">// eted. The caller has the right to delete them or reverse the operation.   //</span>
<a name="l12476"></a>12476 <span class="comment">//                                                                           //</span>
<a name="l12478"></a>12478 <span class="comment"></span>
<a name="l12479"></a>12479 <span class="keywordtype">bool</span> tetgenmesh::removeedgebycombNM(REAL *key, <span class="keywordtype">int</span> n, triface *abtetlist,
<a name="l12480"></a>12480   <span class="keywordtype">int</span> *n1, triface *bftetlist, triface *newtetlist, queue *flipque)
<a name="l12481"></a>12481 {
<a name="l12482"></a>12482   triface tmpabtetlist[11];
<a name="l12483"></a>12483   triface newfront, oldfront, adjfront;
<a name="l12484"></a>12484   face checksh;
<a name="l12485"></a>12485   point pa, pb, p[10];
<a name="l12486"></a>12486   REAL ori, tmpkey, tmpkey2;
<a name="l12487"></a>12487   REAL attrib, volume;
<a name="l12488"></a>12488   <span class="keywordtype">bool</span> doflip, success;
<a name="l12489"></a>12489   <span class="keywordtype">int</span> twice, count;
<a name="l12490"></a>12490   <span class="keywordtype">int</span> i, j, k, m;
<a name="l12491"></a>12491 
<a name="l12492"></a>12492   <span class="comment">// Maximal 10 tets in Star(ab).</span>
<a name="l12493"></a>12493   assert(n &lt;= 10);
<a name="l12494"></a>12494 
<a name="l12495"></a>12495   <span class="comment">// Do the following procedure twice, one for flipping edge b.p_0 and the</span>
<a name="l12496"></a>12496   <span class="comment">//   other for p_0.a which is symmetric to the first.</span>
<a name="l12497"></a>12497   twice = 0;
<a name="l12498"></a>12498   <span class="keywordflow">do</span> {
<a name="l12499"></a>12499     <span class="comment">// Two points a and b are fixed.</span>
<a name="l12500"></a>12500     pa = org(abtetlist[0]);
<a name="l12501"></a>12501     pb = dest(abtetlist[0]);
<a name="l12502"></a>12502     <span class="comment">// The points p_0, ..., p_n-1 are permuted in the following loop.</span>
<a name="l12503"></a>12503     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l12504"></a>12504       <span class="comment">// Get the n points for the current configuration.</span>
<a name="l12505"></a>12505       <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l12506"></a>12506         p[j] = apex(abtetlist[(i + j) % n]);
<a name="l12507"></a>12507       }
<a name="l12508"></a>12508       <span class="comment">// Check if b.p_0 is of type N32 or N44.</span>
<a name="l12509"></a>12509       ori = orient3d(pb, p[0], p[1], p[n - 1]);
<a name="l12510"></a>12510       <span class="keywordflow">if</span> ((ori &gt; 0) &amp;&amp; (key != (REAL *) NULL)) {
<a name="l12511"></a>12511         <span class="comment">// b.p_0 is not N32. However, it is possible that the tet b.p_0.p_1.</span>
<a name="l12512"></a>12512         <span class="comment">//   p_n-1 has worse quality value than the key. In such case, also</span>
<a name="l12513"></a>12513         <span class="comment">//   try to flip b.p_0.</span>
<a name="l12514"></a>12514         tetalldihedral(pb, p[0], p[n - 1], p[1], NULL, &amp;tmpkey, NULL);
<a name="l12515"></a>12515         <span class="keywordflow">if</span> (tmpkey &lt; *key) ori = 0.0;
<a name="l12516"></a>12516       }
<a name="l12517"></a>12517       <span class="keywordflow">if</span> (ori &lt;= 0.0) {
<a name="l12518"></a>12518         <span class="comment">// b.p_0 is either N32 or N44. Try the 1st flipNM.</span>
<a name="l12519"></a>12519         bftetlist[0] = abtetlist[i];
<a name="l12520"></a>12520         enextself(bftetlist[0]);<span class="comment">// go to edge b.p_0.</span>
<a name="l12521"></a>12521         adjustedgering(bftetlist[0], CW); <span class="comment">// edge p_0.b.</span>
<a name="l12522"></a>12522         assert(apex(bftetlist[0]) == pa);
<a name="l12523"></a>12523         <span class="comment">// Form Star(b.p_0).</span>
<a name="l12524"></a>12524         doflip = <span class="keyword">true</span>;
<a name="l12525"></a>12525         *n1 = 0;
<a name="l12526"></a>12526         <span class="keywordflow">do</span> {
<a name="l12527"></a>12527           <span class="comment">// Is the list full?</span>
<a name="l12528"></a>12528           <span class="keywordflow">if</span> (*n1 == 10) <span class="keywordflow">break</span>;
<a name="l12529"></a>12529           <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12530"></a>12530             <span class="comment">// Stop if a subface appears.</span>
<a name="l12531"></a>12531             tspivot(bftetlist[*n1], checksh);
<a name="l12532"></a>12532             <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12533"></a>12533               doflip = <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l12534"></a>12534             }
<a name="l12535"></a>12535           }
<a name="l12536"></a>12536           <span class="comment">// Get the next tet at p_0.b.</span>
<a name="l12537"></a>12537           fnext(bftetlist[*n1], bftetlist[(*n1) + 1]);
<a name="l12538"></a>12538           (*n1)++;
<a name="l12539"></a>12539         } <span class="keywordflow">while</span> (apex(bftetlist[*n1]) != pa);
<a name="l12540"></a>12540         <span class="comment">// 2 &lt;= n1 &lt;= 10.</span>
<a name="l12541"></a>12541         <span class="keywordflow">if</span> (doflip) {
<a name="l12542"></a>12542           success = <span class="keyword">false</span>;
<a name="l12543"></a>12543           tmpkey = -1.0;  <span class="comment">// = acos(pi).</span>
<a name="l12544"></a>12544           <span class="keywordflow">if</span> (key != (REAL *) NULL) tmpkey = *key;
<a name="l12545"></a>12545           m = 0;
<a name="l12546"></a>12546           <span class="keywordflow">if</span> (*n1 == 3) {
<a name="l12547"></a>12547             <span class="comment">// Three tets case. Try flip32.</span>
<a name="l12548"></a>12548             success = removeedgebyflip32(&amp;tmpkey,bftetlist,newtetlist,flipque);
<a name="l12549"></a>12549             m = 2;
<a name="l12550"></a>12550           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((*n1 &gt; 3) &amp;&amp; (*n1 &lt; 7)) {
<a name="l12551"></a>12551             <span class="comment">// Four or more tets case. Try flipNM.</span>
<a name="l12552"></a>12552             success = removeedgebytranNM(&amp;tmpkey, *n1, bftetlist, newtetlist,
<a name="l12553"></a>12553                                          p[1], p[n - 1], flipque);
<a name="l12554"></a>12554             <span class="comment">// If success, the number of new tets.</span>
<a name="l12555"></a>12555             m = ((*n1) - 2) * 2;
<a name="l12556"></a>12556           } <span class="keywordflow">else</span> {
<a name="l12557"></a>12557             <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l12558"></a>12558               printf(<span class="stringliteral">&quot;  !! Unhandled case: n1 = %d.\n&quot;</span>, *n1);
<a name="l12559"></a>12559             }
<a name="l12560"></a>12560           }
<a name="l12561"></a>12561           <span class="keywordflow">if</span> (success) {
<a name="l12562"></a>12562             <span class="comment">// b.p_0 is flipped. The link of ab is reduced (by 1), i.e., p_0</span>
<a name="l12563"></a>12563             <span class="comment">//   is not on the link of ab. Two old tets a.b.p_0.p_n-1 and</span>
<a name="l12564"></a>12564             <span class="comment">//   a.b.p_1.p_0 have been removed from the Star(ab) and one new</span>
<a name="l12565"></a>12565             <span class="comment">//   tet t = a.b.p_1.p_n-1 belongs to Star(ab).</span>
<a name="l12566"></a>12566             <span class="comment">// Find t in the &#39;newtetlist&#39; and remove it from the list.</span>
<a name="l12567"></a>12567             setpointmark(pa, -pointmark(pa) - 1);
<a name="l12568"></a>12568             setpointmark(pb, -pointmark(pb) - 1);
<a name="l12569"></a>12569             assert(m &gt; 0);
<a name="l12570"></a>12570             <span class="keywordflow">for</span> (j = 0; j &lt; m; j++) {
<a name="l12571"></a>12571               tmpabtetlist[0] = newtetlist[j];
<a name="l12572"></a>12572               <span class="comment">// Does it has ab?</span>
<a name="l12573"></a>12573               count = 0;
<a name="l12574"></a>12574               <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) {
<a name="l12575"></a>12575                 <span class="keywordflow">if</span> (pointmark((point)(tmpabtetlist[0].tet[4+k])) &lt; 0) count++;
<a name="l12576"></a>12576               }
<a name="l12577"></a>12577               <span class="keywordflow">if</span> (count == 2) {
<a name="l12578"></a>12578                 <span class="comment">// It is. Adjust t to be the edge ab.</span>
<a name="l12579"></a>12579                 <span class="keywordflow">for</span> (tmpabtetlist[0].loc = 0; tmpabtetlist[0].loc &lt; 4;
<a name="l12580"></a>12580                      tmpabtetlist[0].loc++) {
<a name="l12581"></a>12581                   <span class="keywordflow">if</span> ((oppo(tmpabtetlist[0]) != pa) &amp;&amp;
<a name="l12582"></a>12582                       (oppo(tmpabtetlist[0]) != pb)) <span class="keywordflow">break</span>;
<a name="l12583"></a>12583                 }
<a name="l12584"></a>12584                 <span class="comment">// The face of t must contain ab.</span>
<a name="l12585"></a>12585                 assert(tmpabtetlist[0].loc &lt; 4);
<a name="l12586"></a>12586                 findedge(&amp;(tmpabtetlist[0]), pa, pb);
<a name="l12587"></a>12587                 <span class="keywordflow">break</span>;
<a name="l12588"></a>12588               }
<a name="l12589"></a>12589             }
<a name="l12590"></a>12590             assert(j &lt; m); <span class="comment">// The tet must exist.</span>
<a name="l12591"></a>12591             <span class="comment">// Remove t from list. Fill t&#39;s position by the last tet.</span>
<a name="l12592"></a>12592             newtetlist[j] = newtetlist[m - 1];
<a name="l12593"></a>12593             setpointmark(pa, -(pointmark(pa) + 1));
<a name="l12594"></a>12594             setpointmark(pb, -(pointmark(pb) + 1));
<a name="l12595"></a>12595             <span class="comment">// Create the temporary Star(ab) for the next flipNM.</span>
<a name="l12596"></a>12596             adjustedgering(tmpabtetlist[0], CCW);
<a name="l12597"></a>12597             <span class="keywordflow">if</span> (org(tmpabtetlist[0]) != pa) {
<a name="l12598"></a>12598               fnextself(tmpabtetlist[0]);
<a name="l12599"></a>12599               esymself(tmpabtetlist[0]);
<a name="l12600"></a>12600             }
<a name="l12601"></a>12601 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l12602"></a>12602 <span class="preprocessor"></span>            <span class="comment">// Make sure current edge is a-&gt;b.</span>
<a name="l12603"></a>12603             assert(org(tmpabtetlist[0]) == pa);
<a name="l12604"></a>12604             assert(dest(tmpabtetlist[0]) == pb);
<a name="l12605"></a>12605             assert(apex(tmpabtetlist[0]) == p[n - 1]);
<a name="l12606"></a>12606             assert(oppo(tmpabtetlist[0]) == p[1]);
<a name="l12607"></a>12607 <span class="preprocessor">#endif // SELF_CHECK</span>
<a name="l12608"></a>12608 <span class="preprocessor"></span>            <span class="comment">// There are n - 2 left temporary tets.</span>
<a name="l12609"></a>12609             <span class="keywordflow">for</span> (j = 1; j &lt; n - 1; j++) {
<a name="l12610"></a>12610               maketetrahedron(&amp;(tmpabtetlist[j]));
<a name="l12611"></a>12611               setorg(tmpabtetlist[j], pa);
<a name="l12612"></a>12612               setdest(tmpabtetlist[j], pb);
<a name="l12613"></a>12613               setapex(tmpabtetlist[j], p[j]);
<a name="l12614"></a>12614               setoppo(tmpabtetlist[j], p[j + 1]);
<a name="l12615"></a>12615             }
<a name="l12616"></a>12616             <span class="comment">// Transfer the element attributes.</span>
<a name="l12617"></a>12617             <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberoftetrahedronattributes; j++) {
<a name="l12618"></a>12618               attrib = elemattribute(abtetlist[0].tet, j);
<a name="l12619"></a>12619               <span class="keywordflow">for</span> (k = 0; k &lt; n - 1; k++) {
<a name="l12620"></a>12620                 setelemattribute(tmpabtetlist[k].tet, j, attrib);
<a name="l12621"></a>12621               }
<a name="l12622"></a>12622             }
<a name="l12623"></a>12623             <span class="comment">// Transfer the volume constraints.</span>
<a name="l12624"></a>12624             <span class="keywordflow">if</span> (b-&gt;varvolume &amp;&amp; !b-&gt;refine) {
<a name="l12625"></a>12625               volume = volumebound(abtetlist[0].tet);
<a name="l12626"></a>12626               <span class="keywordflow">for</span> (k = 0; k &lt; n - 1; k++) {
<a name="l12627"></a>12627                 setvolumebound(tmpabtetlist[k].tet, volume);
<a name="l12628"></a>12628               }
<a name="l12629"></a>12629             }
<a name="l12630"></a>12630             <span class="comment">// Glue n - 1 internal faces of Star(ab).</span>
<a name="l12631"></a>12631             <span class="keywordflow">for</span> (j = 0; j &lt; n - 1; j++) {
<a name="l12632"></a>12632               fnext(tmpabtetlist[j], newfront);
<a name="l12633"></a>12633               bond(newfront, tmpabtetlist[(j + 1) % (n - 1)]); <span class="comment">// a.b.p_j+1</span>
<a name="l12634"></a>12634             }
<a name="l12635"></a>12635             <span class="comment">// Substitute the old tets with the new tets by connecting the</span>
<a name="l12636"></a>12636             <span class="comment">//   new tets to the adjacent tets in the mesh. There are (n-2)</span>
<a name="l12637"></a>12637             <span class="comment">//   * 2 (outer) faces of the new tets need to be operated.</span>
<a name="l12638"></a>12638             <span class="comment">// Note that the old tets still have the pointers to their</span>
<a name="l12639"></a>12639             <span class="comment">//   adjacent tets in the mesh.  These pointers can be re-used</span>
<a name="l12640"></a>12640             <span class="comment">//   to inverse the substitution.</span>
<a name="l12641"></a>12641             <span class="keywordflow">for</span> (j = 2; j &lt; n; j++) {
<a name="l12642"></a>12642               <span class="comment">// Get an old tet: [j]a.b.p_j.p_j-1, (j &gt; 1).</span>
<a name="l12643"></a>12643               oldfront = abtetlist[(i + j) % n];
<a name="l12644"></a>12644               esymself(oldfront);
<a name="l12645"></a>12645               enextfnextself(oldfront);
<a name="l12646"></a>12646               <span class="comment">// Get an adjacent tet at face: [j]a.p_j.p_j-1.</span>
<a name="l12647"></a>12647               sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy.</span>
<a name="l12648"></a>12648               <span class="comment">// Get the corresponding face from the new tets.</span>
<a name="l12649"></a>12649               <span class="comment">// j &gt;= 2.</span>
<a name="l12650"></a>12650               enext2fnext(tmpabtetlist[j - 1], newfront); <span class="comment">// a.p_j.p_j-1</span>
<a name="l12651"></a>12651               bond(newfront, adjfront);
<a name="l12652"></a>12652               <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12653"></a>12653                 tspivot(oldfront, checksh);
<a name="l12654"></a>12654                 <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12655"></a>12655                   tsbond(newfront, checksh);
<a name="l12656"></a>12656                 }
<a name="l12657"></a>12657               }
<a name="l12658"></a>12658             }
<a name="l12659"></a>12659             <span class="keywordflow">for</span> (j = 2; j &lt; n; j++) {
<a name="l12660"></a>12660               <span class="comment">// Get an old tet: [j]a.b.p_j.p_j-1, (j &gt; 2).</span>
<a name="l12661"></a>12661               oldfront = abtetlist[(i + j) % n];
<a name="l12662"></a>12662               esymself(oldfront);
<a name="l12663"></a>12663               enext2fnextself(oldfront);
<a name="l12664"></a>12664               <span class="comment">// Get an adjacent tet at face: [j]b.p_j.p_j-1.</span>
<a name="l12665"></a>12665               sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy.</span>
<a name="l12666"></a>12666               <span class="comment">// Get the corresponding face from the new tets.</span>
<a name="l12667"></a>12667               <span class="comment">// j &gt;= 2.</span>
<a name="l12668"></a>12668               enextfnext(tmpabtetlist[j - 1], newfront); <span class="comment">// b.p_j.p_j-1</span>
<a name="l12669"></a>12669               bond(newfront, adjfront);
<a name="l12670"></a>12670               <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12671"></a>12671                 tspivot(oldfront, checksh);
<a name="l12672"></a>12672                 <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12673"></a>12673                   tsbond(newfront, checksh);
<a name="l12674"></a>12674                 }
<a name="l12675"></a>12675               }
<a name="l12676"></a>12676             }
<a name="l12677"></a>12677             <span class="comment">// Adjust the faces in the temporary new tets at ab for</span>
<a name="l12678"></a>12678             <span class="comment">//   recursively processing on the n-1 tets.</span>
<a name="l12679"></a>12679             <span class="keywordflow">for</span> (j = 0; j &lt; n - 1; j++) {
<a name="l12680"></a>12680               fnextself(tmpabtetlist[j]);
<a name="l12681"></a>12681             }
<a name="l12682"></a>12682             tmpkey2 = -1;
<a name="l12683"></a>12683             <span class="keywordflow">if</span> (key) tmpkey2 = *key;
<a name="l12684"></a>12684             <span class="keywordflow">if</span> ((n - 1) == 3) {
<a name="l12685"></a>12685               success = removeedgebyflip32(&amp;tmpkey2, tmpabtetlist,
<a name="l12686"></a>12686                 &amp;(newtetlist[m - 1]), flipque);
<a name="l12687"></a>12687             } <span class="keywordflow">else</span> { <span class="comment">// assert((n - 1) &gt;= 4);</span>
<a name="l12688"></a>12688               success = removeedgebytranNM(&amp;tmpkey2, n - 1, tmpabtetlist,
<a name="l12689"></a>12689                 &amp;(newtetlist[m - 1]), NULL, NULL, flipque);
<a name="l12690"></a>12690             }
<a name="l12691"></a>12691             <span class="comment">// No matter it was success or not, delete the temporary tets.</span>
<a name="l12692"></a>12692             <span class="keywordflow">for</span> (j = 0; j &lt; n - 1; j++) {
<a name="l12693"></a>12693               tetrahedrondealloc(tmpabtetlist[j].tet);
<a name="l12694"></a>12694             }
<a name="l12695"></a>12695             <span class="keywordflow">if</span> (success) {
<a name="l12696"></a>12696               <span class="comment">// The new configuration is good.</span>
<a name="l12697"></a>12697               <span class="comment">// Do not delete the old tets.</span>
<a name="l12698"></a>12698               <span class="comment">// for (j = 0; j &lt; n; j++) {</span>
<a name="l12699"></a>12699               <span class="comment">//   tetrahedrondealloc(abtetlist[j].tet);</span>
<a name="l12700"></a>12700               <span class="comment">// }</span>
<a name="l12701"></a>12701               <span class="comment">// Return the bigger dihedral in the two sets of new tets.</span>
<a name="l12702"></a>12702               <span class="keywordflow">if</span> (key != (REAL *) NULL) {
<a name="l12703"></a>12703                 *key = tmpkey2 &lt; tmpkey ? tmpkey2 : tmpkey;
<a name="l12704"></a>12704               }
<a name="l12705"></a>12705               <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l12706"></a>12706             } <span class="keywordflow">else</span> {
<a name="l12707"></a>12707               <span class="comment">// The new configuration is bad, substitue back the old tets.</span>
<a name="l12708"></a>12708               <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l12709"></a>12709                 oldfront = abtetlist[(i + j) % n];
<a name="l12710"></a>12710                 esymself(oldfront);
<a name="l12711"></a>12711                 enextfnextself(oldfront); <span class="comment">// [0]a.p_0.p_n-1, [j]a.p_j.p_j-1.</span>
<a name="l12712"></a>12712                 sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy.</span>
<a name="l12713"></a>12713                 bond(oldfront, adjfront);
<a name="l12714"></a>12714                 <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12715"></a>12715                   tspivot(oldfront, checksh);
<a name="l12716"></a>12716                   <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12717"></a>12717                     tsbond(oldfront, checksh);
<a name="l12718"></a>12718                   }
<a name="l12719"></a>12719                 }
<a name="l12720"></a>12720               }
<a name="l12721"></a>12721               <span class="keywordflow">for</span> (j = 0; j &lt; n; j++) {
<a name="l12722"></a>12722                 oldfront = abtetlist[(i + j) % n];
<a name="l12723"></a>12723                 esymself(oldfront);
<a name="l12724"></a>12724                 enext2fnextself(oldfront); <span class="comment">// [0]b.p_0.p_n-1, [j]b.p_j.p_j-1.</span>
<a name="l12725"></a>12725                 sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy</span>
<a name="l12726"></a>12726                 bond(oldfront, adjfront);
<a name="l12727"></a>12727                 <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12728"></a>12728                   tspivot(oldfront, checksh);
<a name="l12729"></a>12729                   <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12730"></a>12730                     tsbond(oldfront, checksh);
<a name="l12731"></a>12731                   }
<a name="l12732"></a>12732                 }
<a name="l12733"></a>12733               }
<a name="l12734"></a>12734               <span class="comment">// Substitute back the old tets of the first flip.</span>
<a name="l12735"></a>12735               <span class="keywordflow">for</span> (j = 0; j &lt; *n1; j++) {
<a name="l12736"></a>12736                 oldfront = bftetlist[j];
<a name="l12737"></a>12737                 esymself(oldfront);
<a name="l12738"></a>12738                 enextfnextself(oldfront);
<a name="l12739"></a>12739                 sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy.</span>
<a name="l12740"></a>12740                 bond(oldfront, adjfront);
<a name="l12741"></a>12741                 <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12742"></a>12742                   tspivot(oldfront, checksh);
<a name="l12743"></a>12743                   <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12744"></a>12744                     tsbond(oldfront, checksh);
<a name="l12745"></a>12745                   }
<a name="l12746"></a>12746                 }
<a name="l12747"></a>12747               }
<a name="l12748"></a>12748               <span class="keywordflow">for</span> (j = 0; j &lt; *n1; j++) {
<a name="l12749"></a>12749                 oldfront = bftetlist[j];
<a name="l12750"></a>12750                 esymself(oldfront);
<a name="l12751"></a>12751                 enext2fnextself(oldfront); <span class="comment">// [0]b.p_0.p_n-1, [j]b.p_j.p_j-1.</span>
<a name="l12752"></a>12752                 sym(oldfront, adjfront); <span class="comment">// adjfront may be dummy</span>
<a name="l12753"></a>12753                 bond(oldfront, adjfront);
<a name="l12754"></a>12754                 <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12755"></a>12755                   tspivot(oldfront, checksh);
<a name="l12756"></a>12756                   <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l12757"></a>12757                     tsbond(oldfront, checksh);
<a name="l12758"></a>12758                   }
<a name="l12759"></a>12759                 }
<a name="l12760"></a>12760               }
<a name="l12761"></a>12761               <span class="comment">// Delete the new tets of the first flip. Note that one new</span>
<a name="l12762"></a>12762               <span class="comment">//   tet has already been removed from the list.</span>
<a name="l12763"></a>12763               <span class="keywordflow">for</span> (j = 0; j &lt; m - 1; j++) {
<a name="l12764"></a>12764                 tetrahedrondealloc(newtetlist[j].tet);
<a name="l12765"></a>12765               }
<a name="l12766"></a>12766             } <span class="comment">// if (success)</span>
<a name="l12767"></a>12767           } <span class="comment">// if (success)</span>
<a name="l12768"></a>12768         } <span class="comment">// if (doflip)</span>
<a name="l12769"></a>12769       } <span class="comment">// if (ori &lt;= 0.0)</span>
<a name="l12770"></a>12770     } <span class="comment">// for (i = 0; i &lt; n; i++)</span>
<a name="l12771"></a>12771     <span class="comment">// Inverse a and b and the tets configuration.</span>
<a name="l12772"></a>12772     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) newtetlist[i] = abtetlist[i];
<a name="l12773"></a>12773     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l12774"></a>12774       oldfront = newtetlist[n - i - 1];
<a name="l12775"></a>12775       esymself(oldfront);
<a name="l12776"></a>12776       fnextself(oldfront);
<a name="l12777"></a>12777       abtetlist[i] = oldfront;
<a name="l12778"></a>12778     }
<a name="l12779"></a>12779     twice++;
<a name="l12780"></a>12780   } <span class="keywordflow">while</span> (twice &lt; 2);
<a name="l12781"></a>12781 
<a name="l12782"></a>12782   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l12783"></a>12783 }
<a name="l12784"></a>12784 
<a name="l12786"></a>12786 <span class="comment">//                                                                           //</span>
<a name="l12787"></a>12787 <span class="comment">// splittetrahedron()    Insert a point into a tetrahedron, split it into    //</span>
<a name="l12788"></a>12788 <span class="comment">//                       four tetrahedra.                                    //</span>
<a name="l12789"></a>12789 <span class="comment">//                                                                           //</span>
<a name="l12790"></a>12790 <span class="comment">// The tetrahedron is given by &#39;splittet&#39;.  Let it is abcd.  The inserting   //</span>
<a name="l12791"></a>12791 <span class="comment">// point &#39;newpoint&#39; v should lie strictly inside abcd.                       //</span>
<a name="l12792"></a>12792 <span class="comment">//                                                                           //</span>
<a name="l12793"></a>12793 <span class="comment">// Splitting a tetrahedron is to shrink abcd to abcv,  and create three new  //</span>
<a name="l12794"></a>12794 <span class="comment">// tetrahedra badv, cbdv, and acdv.                                          //</span>
<a name="l12795"></a>12795 <span class="comment">//                                                                           //</span>
<a name="l12796"></a>12796 <span class="comment">// On completion, &#39;splittet&#39; returns abcv.  If &#39;flipqueue&#39; is not NULL, it   //</span>
<a name="l12797"></a>12797 <span class="comment">// contains all possibly non-locally Delaunay faces.                         //</span>
<a name="l12798"></a>12798 <span class="comment">//                                                                           //</span>
<a name="l12800"></a>12800 <span class="comment"></span>
<a name="l12801"></a>12801 <span class="keywordtype">void</span> tetgenmesh::splittetrahedron(point newpoint, triface* splittet,
<a name="l12802"></a>12802   queue* flipqueue)
<a name="l12803"></a>12803 {
<a name="l12804"></a>12804   triface oldabd, oldbcd, oldcad;                      <span class="comment">// Old configuration.</span>
<a name="l12805"></a>12805   triface abdcasing, bcdcasing, cadcasing;
<a name="l12806"></a>12806   face abdsh, bcdsh, cadsh;
<a name="l12807"></a>12807   triface abcv, badv, cbdv, acdv;                      <span class="comment">// New configuration.</span>
<a name="l12808"></a>12808   triface worktet;
<a name="l12809"></a>12809   face abseg, bcseg, caseg;
<a name="l12810"></a>12810   face adseg, bdseg, cdseg;
<a name="l12811"></a>12811   point pa, pb, pc, pd;
<a name="l12812"></a>12812   REAL attrib, volume;
<a name="l12813"></a>12813   <span class="keywordtype">int</span> i;
<a name="l12814"></a>12814 
<a name="l12815"></a>12815   abcv = *splittet;
<a name="l12816"></a>12816   abcv.ver = 0;
<a name="l12817"></a>12817   <span class="comment">// Set the changed vertices and new tetrahedron.</span>
<a name="l12818"></a>12818   pa = org(abcv);
<a name="l12819"></a>12819   pb = dest(abcv);
<a name="l12820"></a>12820   pc = apex(abcv);
<a name="l12821"></a>12821   pd = oppo(abcv);
<a name="l12822"></a>12822 
<a name="l12823"></a>12823   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l12824"></a>12824     printf(<span class="stringliteral">&quot;  Inserting point %d in tetrahedron (%d, %d, %d, %d).\n&quot;</span>,
<a name="l12825"></a>12825            pointmark(newpoint), pointmark(pa), pointmark(pb), pointmark(pc),
<a name="l12826"></a>12826            pointmark(pd));
<a name="l12827"></a>12827   }
<a name="l12828"></a>12828 
<a name="l12829"></a>12829   fnext(abcv, oldabd);
<a name="l12830"></a>12830   enextfnext(abcv, oldbcd);
<a name="l12831"></a>12831   enext2fnext(abcv, oldcad);
<a name="l12832"></a>12832   sym(oldabd, abdcasing);
<a name="l12833"></a>12833   sym(oldbcd, bcdcasing);
<a name="l12834"></a>12834   sym(oldcad, cadcasing);
<a name="l12835"></a>12835   maketetrahedron(&amp;badv);
<a name="l12836"></a>12836   maketetrahedron(&amp;cbdv);
<a name="l12837"></a>12837   maketetrahedron(&amp;acdv);
<a name="l12838"></a>12838 
<a name="l12839"></a>12839   <span class="comment">// Set &#39;badv&#39; vertices.</span>
<a name="l12840"></a>12840   setorg (badv, pb);
<a name="l12841"></a>12841   setdest(badv, pa);
<a name="l12842"></a>12842   setapex(badv, pd);
<a name="l12843"></a>12843   setoppo(badv, newpoint);
<a name="l12844"></a>12844   <span class="comment">// Set &#39;cbdv&#39; vertices.</span>
<a name="l12845"></a>12845   setorg (cbdv, pc);
<a name="l12846"></a>12846   setdest(cbdv, pb);
<a name="l12847"></a>12847   setapex(cbdv, pd);
<a name="l12848"></a>12848   setoppo(cbdv, newpoint);
<a name="l12849"></a>12849   <span class="comment">// Set &#39;acdv&#39; vertices.</span>
<a name="l12850"></a>12850   setorg (acdv, pa);
<a name="l12851"></a>12851   setdest(acdv, pc);
<a name="l12852"></a>12852   setapex(acdv, pd);
<a name="l12853"></a>12853   setoppo(acdv, newpoint);
<a name="l12854"></a>12854   <span class="comment">// Set &#39;abcv&#39; vertices</span>
<a name="l12855"></a>12855   setoppo(abcv, newpoint);
<a name="l12856"></a>12856 
<a name="l12857"></a>12857   <span class="comment">// Set the element attributes of the new tetrahedra.</span>
<a name="l12858"></a>12858   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l12859"></a>12859     attrib = elemattribute(abcv.tet, i);
<a name="l12860"></a>12860     setelemattribute(badv.tet, i, attrib);
<a name="l12861"></a>12861     setelemattribute(cbdv.tet, i, attrib);
<a name="l12862"></a>12862     setelemattribute(acdv.tet, i, attrib);
<a name="l12863"></a>12863   }
<a name="l12864"></a>12864   <span class="comment">// Set the volume constraint of the new tetrahedra.</span>
<a name="l12865"></a>12865   <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l12866"></a>12866     volume = volumebound(abcv.tet);
<a name="l12867"></a>12867     setvolumebound(badv.tet, volume);
<a name="l12868"></a>12868     setvolumebound(cbdv.tet, volume);
<a name="l12869"></a>12869     setvolumebound(acdv.tet, volume);
<a name="l12870"></a>12870   }
<a name="l12871"></a>12871 
<a name="l12872"></a>12872   <span class="comment">// Bond the new triangles to the surrounding tetrahedron.</span>
<a name="l12873"></a>12873   bond(badv, abdcasing);
<a name="l12874"></a>12874   bond(cbdv, bcdcasing);
<a name="l12875"></a>12875   bond(acdv, cadcasing);
<a name="l12876"></a>12876   <span class="comment">// There may exist subfaces need to be bonded to the new tetrahedra.</span>
<a name="l12877"></a>12877   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l12878"></a>12878     tspivot(oldabd, abdsh);
<a name="l12879"></a>12879     <span class="keywordflow">if</span> (abdsh.sh != dummysh) {
<a name="l12880"></a>12880       tsdissolve(oldabd);
<a name="l12881"></a>12881       tsbond(badv, abdsh);
<a name="l12882"></a>12882     }
<a name="l12883"></a>12883     tspivot(oldbcd, bcdsh);
<a name="l12884"></a>12884     <span class="keywordflow">if</span> (bcdsh.sh != dummysh) {
<a name="l12885"></a>12885       tsdissolve(oldbcd);
<a name="l12886"></a>12886       tsbond(cbdv, bcdsh);
<a name="l12887"></a>12887     }
<a name="l12888"></a>12888     tspivot(oldcad, cadsh);
<a name="l12889"></a>12889     <span class="keywordflow">if</span> (cadsh.sh != dummysh) {
<a name="l12890"></a>12890       tsdissolve(oldcad);
<a name="l12891"></a>12891       tsbond(acdv, cadsh);
<a name="l12892"></a>12892     }
<a name="l12893"></a>12893   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l12894"></a>12894     tsspivot1(abcv, abseg);
<a name="l12895"></a>12895     <span class="keywordflow">if</span> (abseg.sh != dummysh) {
<a name="l12896"></a>12896       tssbond1(badv, abseg);
<a name="l12897"></a>12897     }
<a name="l12898"></a>12898     enext(abcv, worktet);
<a name="l12899"></a>12899     tsspivot1(worktet, bcseg);
<a name="l12900"></a>12900     <span class="keywordflow">if</span> (bcseg.sh != dummysh) {
<a name="l12901"></a>12901       tssbond1(cbdv, bcseg);
<a name="l12902"></a>12902     }
<a name="l12903"></a>12903     enext2(abcv, worktet);
<a name="l12904"></a>12904     tsspivot1(worktet, caseg);
<a name="l12905"></a>12905     <span class="keywordflow">if</span> (caseg.sh != dummysh) {
<a name="l12906"></a>12906       tssbond1(acdv, caseg);
<a name="l12907"></a>12907     }
<a name="l12908"></a>12908     fnext(abcv, worktet);
<a name="l12909"></a>12909     enext2self(worktet);
<a name="l12910"></a>12910     tsspivot1(worktet, adseg);
<a name="l12911"></a>12911     <span class="keywordflow">if</span> (adseg.sh != dummysh) {
<a name="l12912"></a>12912       tssdissolve1(worktet);
<a name="l12913"></a>12913       enext(badv, worktet);
<a name="l12914"></a>12914       tssbond1(worktet, adseg);
<a name="l12915"></a>12915       enext2(acdv, worktet);
<a name="l12916"></a>12916       tssbond1(worktet, adseg);
<a name="l12917"></a>12917     }
<a name="l12918"></a>12918     enextfnext(abcv, worktet);
<a name="l12919"></a>12919     enext2self(worktet);
<a name="l12920"></a>12920     tsspivot1(worktet, bdseg);
<a name="l12921"></a>12921     <span class="keywordflow">if</span> (bdseg.sh != dummysh) {
<a name="l12922"></a>12922       tssdissolve1(worktet);
<a name="l12923"></a>12923       enext(cbdv, worktet);
<a name="l12924"></a>12924       tssbond1(worktet, bdseg);
<a name="l12925"></a>12925       enext2(badv, worktet);
<a name="l12926"></a>12926       tssbond1(worktet, bdseg);
<a name="l12927"></a>12927     }
<a name="l12928"></a>12928     enext2fnext(abcv, worktet);
<a name="l12929"></a>12929     enext2self(worktet);
<a name="l12930"></a>12930     tsspivot1(worktet, cdseg);
<a name="l12931"></a>12931     <span class="keywordflow">if</span> (cdseg.sh != dummysh) {
<a name="l12932"></a>12932       tssdissolve1(worktet);
<a name="l12933"></a>12933       enext(acdv, worktet);
<a name="l12934"></a>12934       tssbond1(worktet, cdseg);
<a name="l12935"></a>12935       enext2(cbdv, worktet);
<a name="l12936"></a>12936       tssbond1(worktet, cdseg);
<a name="l12937"></a>12937     }
<a name="l12938"></a>12938   }
<a name="l12939"></a>12939   badv.loc = 3;
<a name="l12940"></a>12940   cbdv.loc = 2;
<a name="l12941"></a>12941   bond(badv, cbdv);
<a name="l12942"></a>12942   cbdv.loc = 3;
<a name="l12943"></a>12943   acdv.loc = 2;
<a name="l12944"></a>12944   bond(cbdv, acdv);
<a name="l12945"></a>12945   acdv.loc = 3;
<a name="l12946"></a>12946   badv.loc = 2;
<a name="l12947"></a>12947   bond(acdv, badv);
<a name="l12948"></a>12948   badv.loc = 1;
<a name="l12949"></a>12949   bond(badv, oldabd);
<a name="l12950"></a>12950   cbdv.loc = 1;
<a name="l12951"></a>12951   bond(cbdv, oldbcd);
<a name="l12952"></a>12952   acdv.loc = 1;
<a name="l12953"></a>12953   bond(acdv, oldcad);
<a name="l12954"></a>12954 
<a name="l12955"></a>12955   badv.loc = 0;
<a name="l12956"></a>12956   cbdv.loc = 0;
<a name="l12957"></a>12957   acdv.loc = 0;
<a name="l12958"></a>12958   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l12959"></a>12959     printf(<span class="stringliteral">&quot;    Updating abcv &quot;</span>);
<a name="l12960"></a>12960     printtet(&amp;abcv);
<a name="l12961"></a>12961     printf(<span class="stringliteral">&quot;    Creating badv &quot;</span>);
<a name="l12962"></a>12962     printtet(&amp;badv);
<a name="l12963"></a>12963     printf(<span class="stringliteral">&quot;    Creating cbdv &quot;</span>);
<a name="l12964"></a>12964     printtet(&amp;cbdv);
<a name="l12965"></a>12965     printf(<span class="stringliteral">&quot;    Creating acdv &quot;</span>);
<a name="l12966"></a>12966     printtet(&amp;acdv);
<a name="l12967"></a>12967   }
<a name="l12968"></a>12968 
<a name="l12969"></a>12969   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l12970"></a>12970     enqueueflipface(abcv, flipqueue);
<a name="l12971"></a>12971     enqueueflipface(badv, flipqueue);
<a name="l12972"></a>12972     enqueueflipface(cbdv, flipqueue);
<a name="l12973"></a>12973     enqueueflipface(acdv, flipqueue);
<a name="l12974"></a>12974   }
<a name="l12975"></a>12975 
<a name="l12976"></a>12976   <span class="comment">// Save a handle for quick point location.</span>
<a name="l12977"></a>12977   recenttet = abcv;
<a name="l12978"></a>12978   <span class="comment">// Set the return handle be abcv.</span>
<a name="l12979"></a>12979   *splittet = abcv;
<a name="l12980"></a>12980 }
<a name="l12981"></a>12981 
<a name="l12983"></a>12983 <span class="comment">//                                                                           //</span>
<a name="l12984"></a>12984 <span class="comment">// unsplittetrahedron()    Reverse the operation of inserting a point into a //</span>
<a name="l12985"></a>12985 <span class="comment">//                         tetrahedron, so as to remove the newly inserted   //</span>
<a name="l12986"></a>12986 <span class="comment">//                         point from the mesh.                              //</span>
<a name="l12987"></a>12987 <span class="comment">//                                                                           //</span>
<a name="l12988"></a>12988 <span class="comment">// Assume the origional tetrahedron is abcd, it was split by v into four     //</span>
<a name="l12989"></a>12989 <span class="comment">// tetrahedra abcv, badv, cbdv, and acdv. &#39;splittet&#39; represents face abc of  //</span>
<a name="l12990"></a>12990 <span class="comment">// abcv (i.e., its opposite is v).                                           //</span>
<a name="l12991"></a>12991 <span class="comment">//                                                                           //</span>
<a name="l12992"></a>12992 <span class="comment">// Point v is removed by expanding abcv to abcd, deleting three tetrahedra   //</span>
<a name="l12993"></a>12993 <span class="comment">// badv, cbdv and acdv.  On return, point v is not deleted in this routine.  //</span>
<a name="l12994"></a>12994 <span class="comment">//                                                                           //</span>
<a name="l12996"></a>12996 <span class="comment"></span>
<a name="l12997"></a>12997 <span class="keywordtype">void</span> tetgenmesh::unsplittetrahedron(triface* splittet)
<a name="l12998"></a>12998 {
<a name="l12999"></a>12999   triface abcv, badv, cbdv, acdv;
<a name="l13000"></a>13000   triface oldabv, oldbcv, oldcav;
<a name="l13001"></a>13001   triface badcasing, cbdcasing, acdcasing;
<a name="l13002"></a>13002   face badsh, cbdsh, acdsh;
<a name="l13003"></a>13003 
<a name="l13004"></a>13004   abcv = *splittet;
<a name="l13005"></a>13005   adjustedgering(abcv, CCW);  <span class="comment">// for sure.</span>
<a name="l13006"></a>13006   fnext(abcv, oldabv);
<a name="l13007"></a>13007   fnext(oldabv, badv);
<a name="l13008"></a>13008   esymself(badv);
<a name="l13009"></a>13009   enextfnext(abcv, oldbcv);
<a name="l13010"></a>13010   fnext(oldbcv, cbdv);
<a name="l13011"></a>13011   esymself(cbdv);
<a name="l13012"></a>13012   enext2fnext(abcv, oldcav);
<a name="l13013"></a>13013   fnext(oldcav, acdv);
<a name="l13014"></a>13014   esymself(acdv);
<a name="l13015"></a>13015 
<a name="l13016"></a>13016   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l13017"></a>13017     printf(<span class="stringliteral">&quot;  Removing point %d in tetrahedron (%d, %d, %d, %d).\n&quot;</span>,
<a name="l13018"></a>13018            pointmark(oppo(abcv)), pointmark(org(abcv)), pointmark(dest(abcv)),
<a name="l13019"></a>13019            pointmark(apex(abcv)), pointmark(apex(badv)));
<a name="l13020"></a>13020   }
<a name="l13021"></a>13021 
<a name="l13022"></a>13022   sym(badv, badcasing);
<a name="l13023"></a>13023   tspivot(badv, badsh);
<a name="l13024"></a>13024   sym(cbdv, cbdcasing);
<a name="l13025"></a>13025   tspivot(cbdv, cbdsh);
<a name="l13026"></a>13026   sym(acdv, acdcasing);
<a name="l13027"></a>13027   tspivot(acdv, acdsh);
<a name="l13028"></a>13028 
<a name="l13029"></a>13029   <span class="comment">// Expanding abcv to abcd.</span>
<a name="l13030"></a>13030   setoppo(abcv, apex(badv));
<a name="l13031"></a>13031   bond(oldabv, badcasing);
<a name="l13032"></a>13032   <span class="keywordflow">if</span> (badsh.sh != dummysh) {
<a name="l13033"></a>13033     tsbond(oldabv, badsh);
<a name="l13034"></a>13034   }
<a name="l13035"></a>13035   bond(oldbcv, cbdcasing);
<a name="l13036"></a>13036   <span class="keywordflow">if</span> (cbdsh.sh != dummysh) {
<a name="l13037"></a>13037     tsbond(oldbcv, cbdsh);
<a name="l13038"></a>13038   }
<a name="l13039"></a>13039   bond(oldcav, acdcasing);
<a name="l13040"></a>13040   <span class="keywordflow">if</span> (acdsh.sh != dummysh) {
<a name="l13041"></a>13041     tsbond(oldcav, acdsh);
<a name="l13042"></a>13042   }
<a name="l13043"></a>13043 
<a name="l13044"></a>13044   <span class="comment">// Delete the three split-out tetrahedra.</span>
<a name="l13045"></a>13045   tetrahedrondealloc(badv.tet);
<a name="l13046"></a>13046   tetrahedrondealloc(cbdv.tet);
<a name="l13047"></a>13047   tetrahedrondealloc(acdv.tet);
<a name="l13048"></a>13048 }
<a name="l13049"></a>13049 
<a name="l13051"></a>13051 <span class="comment">//                                                                           //</span>
<a name="l13052"></a>13052 <span class="comment">// splittetface()    Insert a point on a face of a mesh.                     //</span>
<a name="l13053"></a>13053 <span class="comment">//                                                                           //</span>
<a name="l13054"></a>13054 <span class="comment">// &#39;splittet&#39; is the splitting face.  Let it is abcd, where abc is the face  //</span>
<a name="l13055"></a>13055 <span class="comment">// will be split. If abc is not a hull face, abce is the tetrahedron at the  //</span>
<a name="l13056"></a>13056 <span class="comment">// opposite of d.                                                            //</span>
<a name="l13057"></a>13057 <span class="comment">//                                                                           //</span>
<a name="l13058"></a>13058 <span class="comment">// To split face abc by a point v is to shrink the tetrahedra abcd to abvd,  //</span>
<a name="l13059"></a>13059 <span class="comment">// create two new tetrahedra bcvd, cavd.  If abc is not a hull face, shrink  //</span>
<a name="l13060"></a>13060 <span class="comment">// the tetrahedra bace to bave, create two new tetrahedra cbve, acve.        //</span>
<a name="l13061"></a>13061 <span class="comment">//                                                                           //</span>
<a name="l13062"></a>13062 <span class="comment">// If abc is a subface, it is split into three subfaces simultaneously by    //</span>
<a name="l13063"></a>13063 <span class="comment">// calling routine splitsubface(), hence, abv, bcv, cav.  The edge rings of  //</span>
<a name="l13064"></a>13064 <span class="comment">// the split subfaces have the same orientation as abc&#39;s.                    //</span>
<a name="l13065"></a>13065 <span class="comment">//                                                                           //</span>
<a name="l13066"></a>13066 <span class="comment">// On completion, &#39;splittet&#39; returns abvd.  If &#39;flipqueue&#39; is not NULL, it   //</span>
<a name="l13067"></a>13067 <span class="comment">// contains all possibly non-locally Delaunay faces.                         //</span>
<a name="l13068"></a>13068 <span class="comment">//                                                                           //</span>
<a name="l13070"></a>13070 <span class="comment"></span>
<a name="l13071"></a>13071 <span class="keywordtype">void</span> tetgenmesh::splittetface(point newpoint, triface* splittet,
<a name="l13072"></a>13072   queue* flipqueue)
<a name="l13073"></a>13073 {
<a name="l13074"></a>13074   triface abcd, bace;                                  <span class="comment">// Old configuration.</span>
<a name="l13075"></a>13075   triface oldbcd, oldcad, oldace, oldcbe;
<a name="l13076"></a>13076   triface bcdcasing, cadcasing, acecasing, cbecasing;
<a name="l13077"></a>13077   face abcsh, bcdsh, cadsh, acesh, cbesh;
<a name="l13078"></a>13078   triface abvd, bcvd, cavd, bave, cbve, acve;          <span class="comment">// New configuration.</span>
<a name="l13079"></a>13079   triface worktet;
<a name="l13080"></a>13080   face bcseg, caseg;
<a name="l13081"></a>13081   face adseg, bdseg, cdseg;
<a name="l13082"></a>13082   face aeseg, beseg, ceseg;
<a name="l13083"></a>13083   point pa, pb, pc, pd, pe;
<a name="l13084"></a>13084   REAL attrib, volume;
<a name="l13085"></a>13085   <span class="keywordtype">bool</span> mirrorflag;
<a name="l13086"></a>13086   <span class="keywordtype">int</span> i;
<a name="l13087"></a>13087 
<a name="l13088"></a>13088   abcd = *splittet;
<a name="l13089"></a>13089   <span class="comment">// abcd.ver = 0; // Adjust to be CCW edge ring.</span>
<a name="l13090"></a>13090   adjustedgering(abcd, CCW);
<a name="l13091"></a>13091   pa = org(abcd);
<a name="l13092"></a>13092   pb = dest(abcd);
<a name="l13093"></a>13093   pc = apex(abcd);
<a name="l13094"></a>13094   pd = oppo(abcd);
<a name="l13095"></a>13095   pe = (point) NULL; <span class="comment">// avoid a compile warning.</span>
<a name="l13096"></a>13096   <span class="comment">// Is there a second tetrahderon?</span>
<a name="l13097"></a>13097   mirrorflag = issymexist(&amp;abcd);
<a name="l13098"></a>13098   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13099"></a>13099     <span class="comment">// This is an interior face.</span>
<a name="l13100"></a>13100     sym(abcd, bace);
<a name="l13101"></a>13101     findedge(&amp;bace, dest(abcd), org(abcd));
<a name="l13102"></a>13102     pe = oppo(bace);
<a name="l13103"></a>13103   }
<a name="l13104"></a>13104   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l13105"></a>13105     <span class="comment">// Is there a subface need to be split together?</span>
<a name="l13106"></a>13106     tspivot(abcd, abcsh);
<a name="l13107"></a>13107     <span class="keywordflow">if</span> (abcsh.sh != dummysh) {
<a name="l13108"></a>13108       <span class="comment">// Exists! Keep the edge ab of both handles be the same.</span>
<a name="l13109"></a>13109       findedge(&amp;abcsh, org(abcd), dest(abcd));
<a name="l13110"></a>13110     }
<a name="l13111"></a>13111   }
<a name="l13112"></a>13112 
<a name="l13113"></a>13113   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l13114"></a>13114     printf(<span class="stringliteral">&quot;  Inserting point %d on face (%d, %d, %d).\n&quot;</span>, pointmark(newpoint),
<a name="l13115"></a>13115            pointmark(pa), pointmark(pb), pointmark(pc));
<a name="l13116"></a>13116   }
<a name="l13117"></a>13117 
<a name="l13118"></a>13118   <span class="comment">// Save the old configuration at faces bcd and cad.</span>
<a name="l13119"></a>13119   enextfnext(abcd, oldbcd);
<a name="l13120"></a>13120   enext2fnext(abcd, oldcad);
<a name="l13121"></a>13121   sym(oldbcd, bcdcasing);
<a name="l13122"></a>13122   sym(oldcad, cadcasing);
<a name="l13123"></a>13123   <span class="comment">// Create two new tetrahedra.</span>
<a name="l13124"></a>13124   maketetrahedron(&amp;bcvd);
<a name="l13125"></a>13125   maketetrahedron(&amp;cavd);
<a name="l13126"></a>13126   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13127"></a>13127     <span class="comment">// Save the old configuration at faces bce and cae.</span>
<a name="l13128"></a>13128     enextfnext(bace, oldace);
<a name="l13129"></a>13129     enext2fnext(bace, oldcbe);
<a name="l13130"></a>13130     sym(oldace, acecasing);
<a name="l13131"></a>13131     sym(oldcbe, cbecasing);
<a name="l13132"></a>13132     <span class="comment">// Create two new tetrahedra.</span>
<a name="l13133"></a>13133     maketetrahedron(&amp;acve);
<a name="l13134"></a>13134     maketetrahedron(&amp;cbve);
<a name="l13135"></a>13135   } <span class="keywordflow">else</span> {
<a name="l13136"></a>13136     <span class="comment">// Splitting a boundary face increases the number of boundary faces.</span>
<a name="l13137"></a>13137     hullsize += 2;
<a name="l13138"></a>13138   }
<a name="l13139"></a>13139 
<a name="l13140"></a>13140   <span class="comment">// Set vertices to the changed tetrahedron and new tetrahedra.</span>
<a name="l13141"></a>13141   abvd = abcd;  <span class="comment">// Update &#39;abcd&#39; to &#39;abvd&#39;.</span>
<a name="l13142"></a>13142   setapex(abvd, newpoint);
<a name="l13143"></a>13143   setorg (bcvd, pb);  <span class="comment">// Set &#39;bcvd&#39;.</span>
<a name="l13144"></a>13144   setdest(bcvd, pc);
<a name="l13145"></a>13145   setapex(bcvd, newpoint);
<a name="l13146"></a>13146   setoppo(bcvd, pd);
<a name="l13147"></a>13147   setorg (cavd, pc);  <span class="comment">// Set &#39;cavd&#39;.</span>
<a name="l13148"></a>13148   setdest(cavd, pa);
<a name="l13149"></a>13149   setapex(cavd, newpoint);
<a name="l13150"></a>13150   setoppo(cavd, pd);
<a name="l13151"></a>13151   <span class="comment">// Set the element attributes of the new tetrahedra.</span>
<a name="l13152"></a>13152   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l13153"></a>13153     attrib = elemattribute(abvd.tet, i);
<a name="l13154"></a>13154     setelemattribute(bcvd.tet, i, attrib);
<a name="l13155"></a>13155     setelemattribute(cavd.tet, i, attrib);
<a name="l13156"></a>13156   }
<a name="l13157"></a>13157   <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l13158"></a>13158     <span class="comment">// Set the area constraint of the new tetrahedra.</span>
<a name="l13159"></a>13159     volume = volumebound(abvd.tet);
<a name="l13160"></a>13160     setvolumebound(bcvd.tet, volume);
<a name="l13161"></a>13161     setvolumebound(cavd.tet, volume);
<a name="l13162"></a>13162   }
<a name="l13163"></a>13163   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13164"></a>13164     bave = bace;  <span class="comment">// Update &#39;bace&#39; to &#39;bave&#39;.</span>
<a name="l13165"></a>13165     setapex(bave, newpoint);
<a name="l13166"></a>13166     setorg (acve, pa);  <span class="comment">// Set &#39;acve&#39;.</span>
<a name="l13167"></a>13167     setdest(acve, pc);
<a name="l13168"></a>13168     setapex(acve, newpoint);
<a name="l13169"></a>13169     setoppo(acve, pe);
<a name="l13170"></a>13170     setorg (cbve, pc);  <span class="comment">// Set &#39;cbve&#39;.</span>
<a name="l13171"></a>13171     setdest(cbve, pb);
<a name="l13172"></a>13172     setapex(cbve, newpoint);
<a name="l13173"></a>13173     setoppo(cbve, pe);
<a name="l13174"></a>13174     <span class="comment">// Set the element attributes of the new tetrahedra.</span>
<a name="l13175"></a>13175     <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l13176"></a>13176       attrib = elemattribute(bave.tet, i);
<a name="l13177"></a>13177       setelemattribute(acve.tet, i, attrib);
<a name="l13178"></a>13178       setelemattribute(cbve.tet, i, attrib);
<a name="l13179"></a>13179     }
<a name="l13180"></a>13180     <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l13181"></a>13181       <span class="comment">// Set the area constraint of the new tetrahedra.</span>
<a name="l13182"></a>13182       volume = volumebound(bave.tet);
<a name="l13183"></a>13183       setvolumebound(acve.tet, volume);
<a name="l13184"></a>13184       setvolumebound(cbve.tet, volume);
<a name="l13185"></a>13185     }
<a name="l13186"></a>13186   }
<a name="l13187"></a>13187 
<a name="l13188"></a>13188   <span class="comment">// Bond the new tetrahedra to the surrounding tetrahedra.</span>
<a name="l13189"></a>13189   bcvd.loc = 1;
<a name="l13190"></a>13190   bond(bcvd, bcdcasing);
<a name="l13191"></a>13191   cavd.loc = 1;
<a name="l13192"></a>13192   bond(cavd, cadcasing);
<a name="l13193"></a>13193   bcvd.loc = 3;
<a name="l13194"></a>13194   bond(bcvd, oldbcd);
<a name="l13195"></a>13195   cavd.loc = 2;
<a name="l13196"></a>13196   bond(cavd, oldcad);
<a name="l13197"></a>13197   bcvd.loc = 2;
<a name="l13198"></a>13198   cavd.loc = 3;
<a name="l13199"></a>13199   bond(bcvd, cavd);
<a name="l13200"></a>13200   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13201"></a>13201     acve.loc = 1;
<a name="l13202"></a>13202     bond(acve, acecasing);
<a name="l13203"></a>13203     cbve.loc = 1;
<a name="l13204"></a>13204     bond(cbve, cbecasing);
<a name="l13205"></a>13205     acve.loc = 3;
<a name="l13206"></a>13206     bond(acve, oldace);
<a name="l13207"></a>13207     cbve.loc = 2;
<a name="l13208"></a>13208     bond(cbve, oldcbe);
<a name="l13209"></a>13209     acve.loc = 2;
<a name="l13210"></a>13210     cbve.loc = 3;
<a name="l13211"></a>13211     bond(acve, cbve);
<a name="l13212"></a>13212     <span class="comment">// Bond two new coplanar facets.</span>
<a name="l13213"></a>13213     bcvd.loc = 0;
<a name="l13214"></a>13214     cbve.loc = 0;
<a name="l13215"></a>13215     bond(bcvd, cbve);
<a name="l13216"></a>13216     cavd.loc = 0;
<a name="l13217"></a>13217     acve.loc = 0;
<a name="l13218"></a>13218     bond(cavd, acve);
<a name="l13219"></a>13219   }
<a name="l13220"></a>13220 
<a name="l13221"></a>13221   <span class="comment">// There may exist subface needed to be bonded to the new tetrahedra.</span>
<a name="l13222"></a>13222   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l13223"></a>13223     tspivot(oldbcd, bcdsh);
<a name="l13224"></a>13224     <span class="keywordflow">if</span> (bcdsh.sh != dummysh) {
<a name="l13225"></a>13225       tsdissolve(oldbcd);
<a name="l13226"></a>13226       bcvd.loc = 1;
<a name="l13227"></a>13227       tsbond(bcvd, bcdsh);
<a name="l13228"></a>13228     }
<a name="l13229"></a>13229     tspivot(oldcad, cadsh);
<a name="l13230"></a>13230     <span class="keywordflow">if</span> (cadsh.sh != dummysh) {
<a name="l13231"></a>13231       tsdissolve(oldcad);
<a name="l13232"></a>13232       cavd.loc = 1;
<a name="l13233"></a>13233       tsbond(cavd, cadsh);
<a name="l13234"></a>13234     }
<a name="l13235"></a>13235     <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13236"></a>13236       tspivot(oldace, acesh);
<a name="l13237"></a>13237       <span class="keywordflow">if</span> (acesh.sh != dummysh) {
<a name="l13238"></a>13238         tsdissolve(oldace);
<a name="l13239"></a>13239         acve.loc = 1;
<a name="l13240"></a>13240         tsbond(acve, acesh);
<a name="l13241"></a>13241       }
<a name="l13242"></a>13242       tspivot(oldcbe, cbesh);
<a name="l13243"></a>13243       <span class="keywordflow">if</span> (cbesh.sh != dummysh) {
<a name="l13244"></a>13244         tsdissolve(oldcbe);
<a name="l13245"></a>13245         cbve.loc = 1;
<a name="l13246"></a>13246         tsbond(cbve, cbesh);
<a name="l13247"></a>13247       }
<a name="l13248"></a>13248     }
<a name="l13249"></a>13249     <span class="comment">// Is there a subface needs to be split together?</span>
<a name="l13250"></a>13250     <span class="keywordflow">if</span> (abcsh.sh != dummysh) {
<a name="l13251"></a>13251       <span class="comment">// Split this subface &#39;abc&#39; into three i.e, abv, bcv, cav.</span>
<a name="l13252"></a>13252       splitsubface(newpoint, &amp;abcsh, (queue *) NULL);
<a name="l13253"></a>13253     }
<a name="l13254"></a>13254   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksubsegs) {
<a name="l13255"></a>13255     <span class="comment">// abvd.loc = abvd.ver = 0;</span>
<a name="l13256"></a>13256     bcvd.loc = bcvd.ver = 0;
<a name="l13257"></a>13257     cavd.loc = cavd.ver = 0;
<a name="l13258"></a>13258     <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13259"></a>13259       <span class="comment">// bave.loc = bave.ver = 0;</span>
<a name="l13260"></a>13260       cbve.loc = cbve.ver = 0;
<a name="l13261"></a>13261       acve.loc = acve.ver = 0;
<a name="l13262"></a>13262     }
<a name="l13263"></a>13263     enext(abvd, worktet);
<a name="l13264"></a>13264     tsspivot1(worktet, bcseg);
<a name="l13265"></a>13265     <span class="keywordflow">if</span> (bcseg.sh != dummysh) {
<a name="l13266"></a>13266       tssdissolve1(worktet);
<a name="l13267"></a>13267       tssbond1(bcvd, bcseg);
<a name="l13268"></a>13268       <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13269"></a>13269         enext2(bave, worktet);
<a name="l13270"></a>13270         tssdissolve1(worktet);
<a name="l13271"></a>13271         tssbond1(cbve, bcseg);
<a name="l13272"></a>13272       }
<a name="l13273"></a>13273     }
<a name="l13274"></a>13274     enext2(abvd, worktet);
<a name="l13275"></a>13275     tsspivot1(worktet, caseg);
<a name="l13276"></a>13276     <span class="keywordflow">if</span> (caseg.sh != dummysh) {
<a name="l13277"></a>13277       tssdissolve1(worktet);
<a name="l13278"></a>13278       tssbond1(cavd, caseg);
<a name="l13279"></a>13279       <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13280"></a>13280         enext(bave, worktet);
<a name="l13281"></a>13281         tssdissolve1(worktet);
<a name="l13282"></a>13282         tssbond1(acve, caseg);
<a name="l13283"></a>13283       }
<a name="l13284"></a>13284     }
<a name="l13285"></a>13285     fnext(abvd, worktet);
<a name="l13286"></a>13286     enext2self(worktet);
<a name="l13287"></a>13287     tsspivot1(worktet, adseg);
<a name="l13288"></a>13288     <span class="keywordflow">if</span> (adseg.sh != dummysh) {
<a name="l13289"></a>13289       fnext(cavd, worktet);
<a name="l13290"></a>13290       enextself(worktet);
<a name="l13291"></a>13291       tssbond1(worktet, adseg);
<a name="l13292"></a>13292     }
<a name="l13293"></a>13293     fnext(abvd, worktet);
<a name="l13294"></a>13294     enextself(worktet);
<a name="l13295"></a>13295     tsspivot1(worktet, bdseg);
<a name="l13296"></a>13296     <span class="keywordflow">if</span> (bdseg.sh != dummysh) {
<a name="l13297"></a>13297       fnext(bcvd, worktet);
<a name="l13298"></a>13298       enext2self(worktet);
<a name="l13299"></a>13299       tssbond1(worktet, bdseg);
<a name="l13300"></a>13300     }
<a name="l13301"></a>13301     enextfnext(abvd, worktet);
<a name="l13302"></a>13302     enextself(worktet);
<a name="l13303"></a>13303     tsspivot1(worktet, cdseg);
<a name="l13304"></a>13304     <span class="keywordflow">if</span> (cdseg.sh != dummysh) {
<a name="l13305"></a>13305       tssdissolve1(worktet);
<a name="l13306"></a>13306       fnext(bcvd, worktet);
<a name="l13307"></a>13307       enextself(worktet);
<a name="l13308"></a>13308       tssbond1(worktet, cdseg);
<a name="l13309"></a>13309       fnext(cavd, worktet);
<a name="l13310"></a>13310       enext2self(worktet);
<a name="l13311"></a>13311       tssbond1(worktet, cdseg);
<a name="l13312"></a>13312     }
<a name="l13313"></a>13313     <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13314"></a>13314       fnext(bave, worktet);
<a name="l13315"></a>13315       enextself(worktet);
<a name="l13316"></a>13316       tsspivot1(worktet, aeseg);
<a name="l13317"></a>13317       <span class="keywordflow">if</span> (aeseg.sh != dummysh) {
<a name="l13318"></a>13318         fnext(acve, worktet);
<a name="l13319"></a>13319         enext2self(worktet);
<a name="l13320"></a>13320         tssbond1(worktet, aeseg);
<a name="l13321"></a>13321       }
<a name="l13322"></a>13322       fnext(bave, worktet);
<a name="l13323"></a>13323       enext2self(worktet);
<a name="l13324"></a>13324       tsspivot1(worktet, beseg);
<a name="l13325"></a>13325       <span class="keywordflow">if</span> (beseg.sh != dummysh) {
<a name="l13326"></a>13326         fnext(cbve, worktet);
<a name="l13327"></a>13327         enextself(worktet);
<a name="l13328"></a>13328         tssbond1(worktet, beseg);
<a name="l13329"></a>13329       }
<a name="l13330"></a>13330       enextfnext(bave, worktet);
<a name="l13331"></a>13331       enextself(worktet);
<a name="l13332"></a>13332       tsspivot1(worktet, ceseg);
<a name="l13333"></a>13333       <span class="keywordflow">if</span> (ceseg.sh != dummysh) {
<a name="l13334"></a>13334         tssdissolve1(worktet);
<a name="l13335"></a>13335         fnext(cbve, worktet);
<a name="l13336"></a>13336         enext2self(worktet);
<a name="l13337"></a>13337         tssbond1(worktet, ceseg);
<a name="l13338"></a>13338         fnext(acve, worktet);
<a name="l13339"></a>13339         enextself(worktet);
<a name="l13340"></a>13340         tssbond1(worktet, ceseg);
<a name="l13341"></a>13341       }
<a name="l13342"></a>13342     }
<a name="l13343"></a>13343   }
<a name="l13344"></a>13344 
<a name="l13345"></a>13345   <span class="comment">// Save a handle for quick point location.</span>
<a name="l13346"></a>13346   recenttet = abvd;
<a name="l13347"></a>13347   <span class="comment">// Set the return handle be abvd.</span>
<a name="l13348"></a>13348   *splittet = abvd;
<a name="l13349"></a>13349 
<a name="l13350"></a>13350   bcvd.loc = 0;
<a name="l13351"></a>13351   cavd.loc = 0;
<a name="l13352"></a>13352   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13353"></a>13353     cbve.loc = 0;
<a name="l13354"></a>13354     acve.loc = 0;
<a name="l13355"></a>13355   }
<a name="l13356"></a>13356   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l13357"></a>13357     printf(<span class="stringliteral">&quot;    Updating abvd &quot;</span>);
<a name="l13358"></a>13358     printtet(&amp;abvd);
<a name="l13359"></a>13359     printf(<span class="stringliteral">&quot;    Creating bcvd &quot;</span>);
<a name="l13360"></a>13360     printtet(&amp;bcvd);
<a name="l13361"></a>13361     printf(<span class="stringliteral">&quot;    Creating cavd &quot;</span>);
<a name="l13362"></a>13362     printtet(&amp;cavd);
<a name="l13363"></a>13363     <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13364"></a>13364       printf(<span class="stringliteral">&quot;    Updating bave &quot;</span>);
<a name="l13365"></a>13365       printtet(&amp;bave);
<a name="l13366"></a>13366       printf(<span class="stringliteral">&quot;    Creating cbve &quot;</span>);
<a name="l13367"></a>13367       printtet(&amp;cbve);
<a name="l13368"></a>13368       printf(<span class="stringliteral">&quot;    Creating acve &quot;</span>);
<a name="l13369"></a>13369       printtet(&amp;acve);
<a name="l13370"></a>13370     }
<a name="l13371"></a>13371   }
<a name="l13372"></a>13372 
<a name="l13373"></a>13373   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l13374"></a>13374     fnextself(abvd);
<a name="l13375"></a>13375     enqueueflipface(abvd, flipqueue);
<a name="l13376"></a>13376     fnextself(bcvd);
<a name="l13377"></a>13377     enqueueflipface(bcvd, flipqueue);
<a name="l13378"></a>13378     fnextself(cavd);
<a name="l13379"></a>13379     enqueueflipface(cavd, flipqueue);
<a name="l13380"></a>13380     <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13381"></a>13381       fnextself(bave);
<a name="l13382"></a>13382       enqueueflipface(bave, flipqueue);
<a name="l13383"></a>13383       fnextself(cbve);
<a name="l13384"></a>13384       enqueueflipface(cbve, flipqueue);
<a name="l13385"></a>13385       fnextself(acve);
<a name="l13386"></a>13386       enqueueflipface(acve, flipqueue);
<a name="l13387"></a>13387     }
<a name="l13388"></a>13388   }
<a name="l13389"></a>13389 }
<a name="l13390"></a>13390 
<a name="l13392"></a>13392 <span class="comment">//                                                                           //</span>
<a name="l13393"></a>13393 <span class="comment">// unsplittetface()    Reverse the operation of inserting a point on a face, //</span>
<a name="l13394"></a>13394 <span class="comment">//                     so as to remove the newly inserted point.             //</span>
<a name="l13395"></a>13395 <span class="comment">//                                                                           //</span>
<a name="l13396"></a>13396 <span class="comment">// Assume the original face is abc, the tetrahedron containing abc is abcd.  //</span>
<a name="l13397"></a>13397 <span class="comment">// If abc is not a hull face, bace is the tetrahedron at the opposite of d.  //</span>
<a name="l13398"></a>13398 <span class="comment">// After face abc was split by a point v, tetrahedron abcd had been split    //</span>
<a name="l13399"></a>13399 <span class="comment">// into three tetrahedra, abvd, bcvd, cavd, and bace (if it exists) had been //</span>
<a name="l13400"></a>13400 <span class="comment">// split into bave, cbve, acve. &#39;splittet&#39; represents abvd (its apex is v).  //</span>
<a name="l13401"></a>13401 <span class="comment">//                                                                           //</span>
<a name="l13402"></a>13402 <span class="comment">// Point v is removed by expanding abvd to abcd, deleting two tetrahedra     //</span>
<a name="l13403"></a>13403 <span class="comment">// bcvd, cavd. Expanding bave(if it exists) to bace, deleting two tetrahedra //</span>
<a name="l13404"></a>13404 <span class="comment">// cbve, acve.  If abv is a subface, routine unsplitsubface() will be called //</span>
<a name="l13405"></a>13405 <span class="comment">// to reverse the operation of splitting a subface. On completion, point v   //</span>
<a name="l13406"></a>13406 <span class="comment">// is not deleted in this routine.                                           //</span>
<a name="l13407"></a>13407 <span class="comment">//                                                                           //</span>
<a name="l13409"></a>13409 <span class="comment"></span>
<a name="l13410"></a>13410 <span class="keywordtype">void</span> tetgenmesh::unsplittetface(triface* splittet)
<a name="l13411"></a>13411 {
<a name="l13412"></a>13412   triface abvd, bcvd, cavd, bave, cbve, acve;
<a name="l13413"></a>13413   triface oldbvd, oldvad, oldvbe, oldave;
<a name="l13414"></a>13414   triface bcdcasing, cadcasing, cbecasing, acecasing;
<a name="l13415"></a>13415   face bcdsh, cadsh, cbesh, acesh;
<a name="l13416"></a>13416   face abvsh;
<a name="l13417"></a>13417   <span class="keywordtype">bool</span> mirrorflag;
<a name="l13418"></a>13418 
<a name="l13419"></a>13419   abvd = *splittet;
<a name="l13420"></a>13420   adjustedgering(abvd, CCW); <span class="comment">// for sure.</span>
<a name="l13421"></a>13421   enextfnext(abvd, oldbvd);
<a name="l13422"></a>13422   fnext(oldbvd, bcvd);
<a name="l13423"></a>13423   esymself(bcvd);
<a name="l13424"></a>13424   enextself(bcvd);
<a name="l13425"></a>13425   enext2fnext(abvd, oldvad);
<a name="l13426"></a>13426   fnext(oldvad, cavd);
<a name="l13427"></a>13427   esymself(cavd);
<a name="l13428"></a>13428   enext2self(cavd);
<a name="l13429"></a>13429   <span class="comment">// Is there a second tetrahedron?</span>
<a name="l13430"></a>13430   sym(abvd, bave);
<a name="l13431"></a>13431   mirrorflag = bave.tet != dummytet;
<a name="l13432"></a>13432   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13433"></a>13433     findedge(&amp;bave, dest(abvd), org(abvd));
<a name="l13434"></a>13434     enextfnext(bave, oldave);
<a name="l13435"></a>13435     fnext(oldave, acve);
<a name="l13436"></a>13436     esymself(acve);
<a name="l13437"></a>13437     enextself(acve);
<a name="l13438"></a>13438     enext2fnext(bave, oldvbe);
<a name="l13439"></a>13439     fnext(oldvbe, cbve);
<a name="l13440"></a>13440     esymself(cbve);
<a name="l13441"></a>13441     enext2self(cbve);
<a name="l13442"></a>13442   } <span class="keywordflow">else</span> {
<a name="l13443"></a>13443     <span class="comment">// Unsplit a hull face decrease the number of boundary faces.</span>
<a name="l13444"></a>13444     hullsize -= 2;
<a name="l13445"></a>13445   }
<a name="l13446"></a>13446   <span class="comment">// Is there a subface at abv.</span>
<a name="l13447"></a>13447   tspivot(abvd, abvsh);
<a name="l13448"></a>13448   <span class="keywordflow">if</span> (abvsh.sh != dummysh) {
<a name="l13449"></a>13449     <span class="comment">// Exists! Keep the edge ab of both handles be the same.</span>
<a name="l13450"></a>13450     findedge(&amp;abvsh, org(abvd), dest(abvd));
<a name="l13451"></a>13451   }
<a name="l13452"></a>13452 
<a name="l13453"></a>13453   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l13454"></a>13454     printf(<span class="stringliteral">&quot;  Removing point %d on face (%d, %d, %d).\n&quot;</span>,
<a name="l13455"></a>13455            pointmark(apex(abvd)), pointmark(org(abvd)), pointmark(dest(abvd)),
<a name="l13456"></a>13456            pointmark(dest(bcvd)));
<a name="l13457"></a>13457   }
<a name="l13458"></a>13458 
<a name="l13459"></a>13459   fnextself(bcvd); <span class="comment">// bcvd has changed to bcdv.</span>
<a name="l13460"></a>13460   sym(bcvd, bcdcasing);
<a name="l13461"></a>13461   tspivot(bcvd, bcdsh);
<a name="l13462"></a>13462   fnextself(cavd); <span class="comment">// cavd has changed to cadv.</span>
<a name="l13463"></a>13463   sym(cavd, cadcasing);
<a name="l13464"></a>13464   tspivot(cavd, cadsh);
<a name="l13465"></a>13465   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13466"></a>13466     fnextself(acve); <span class="comment">// acve has changed to acev.</span>
<a name="l13467"></a>13467     sym(acve, acecasing);
<a name="l13468"></a>13468     tspivot(acve, acesh);
<a name="l13469"></a>13469     fnextself(cbve); <span class="comment">// cbve has changed to cbev.</span>
<a name="l13470"></a>13470     sym(cbve, cbecasing);
<a name="l13471"></a>13471     tspivot(cbve, cbesh);
<a name="l13472"></a>13472   }
<a name="l13473"></a>13473 
<a name="l13474"></a>13474   <span class="comment">// Expand abvd to abcd.</span>
<a name="l13475"></a>13475   setapex(abvd, dest(bcvd));
<a name="l13476"></a>13476   bond(oldbvd, bcdcasing);
<a name="l13477"></a>13477   <span class="keywordflow">if</span> (bcdsh.sh != dummysh) {
<a name="l13478"></a>13478     tsbond(oldbvd, bcdsh);
<a name="l13479"></a>13479   }
<a name="l13480"></a>13480   bond(oldvad, cadcasing);
<a name="l13481"></a>13481   <span class="keywordflow">if</span> (cadsh.sh != dummysh) {
<a name="l13482"></a>13482     tsbond(oldvad, cadsh);
<a name="l13483"></a>13483   }
<a name="l13484"></a>13484   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13485"></a>13485     <span class="comment">// Expanding bave to bace.</span>
<a name="l13486"></a>13486     setapex(bave, dest(acve));
<a name="l13487"></a>13487     bond(oldave, acecasing);
<a name="l13488"></a>13488     <span class="keywordflow">if</span> (acesh.sh != dummysh) {
<a name="l13489"></a>13489       tsbond(oldave, acesh);
<a name="l13490"></a>13490     }
<a name="l13491"></a>13491     bond(oldvbe, cbecasing);
<a name="l13492"></a>13492     <span class="keywordflow">if</span> (cbesh.sh != dummysh) {
<a name="l13493"></a>13493       tsbond(oldvbe, cbesh);
<a name="l13494"></a>13494     }
<a name="l13495"></a>13495   }
<a name="l13496"></a>13496 
<a name="l13497"></a>13497   <span class="comment">// Unsplit a subface if there exists.</span>
<a name="l13498"></a>13498   <span class="keywordflow">if</span> (abvsh.sh != dummysh) {
<a name="l13499"></a>13499     unsplitsubface(&amp;abvsh);
<a name="l13500"></a>13500   }
<a name="l13501"></a>13501 
<a name="l13502"></a>13502   <span class="comment">// Delete the split-out tetrahedra.</span>
<a name="l13503"></a>13503   tetrahedrondealloc(bcvd.tet);
<a name="l13504"></a>13504   tetrahedrondealloc(cavd.tet);
<a name="l13505"></a>13505   <span class="keywordflow">if</span> (mirrorflag) {
<a name="l13506"></a>13506     tetrahedrondealloc(acve.tet);
<a name="l13507"></a>13507     tetrahedrondealloc(cbve.tet);
<a name="l13508"></a>13508   }
<a name="l13509"></a>13509 }
<a name="l13510"></a>13510 
<a name="l13512"></a>13512 <span class="comment">//                                                                           //</span>
<a name="l13513"></a>13513 <span class="comment">// splitsubface()    Insert a point on a subface, split it into three.       //</span>
<a name="l13514"></a>13514 <span class="comment">//                                                                           //</span>
<a name="l13515"></a>13515 <span class="comment">// The subface is &#39;splitface&#39;.  Let it is abc. The inserting point &#39;newpoint&#39;//</span>
<a name="l13516"></a>13516 <span class="comment">// v should lie inside abc.  If the neighbor tetrahedra of abc exist, i.e.,  //</span>
<a name="l13517"></a>13517 <span class="comment">// abcd and bace, they should have been split by routine splittetface()      //</span>
<a name="l13518"></a>13518 <span class="comment">// before calling this routine, so the connection between the new tetrahedra //</span>
<a name="l13519"></a>13519 <span class="comment">// and new subfaces can be correctly set.                                    //</span>
<a name="l13520"></a>13520 <span class="comment">//                                                                           //</span>
<a name="l13521"></a>13521 <span class="comment">// To split subface abc by point v is to shrink abc to abv, create two new   //</span>
<a name="l13522"></a>13522 <span class="comment">// subfaces bcv and cav.  Set the connection between updated and new created //</span>
<a name="l13523"></a>13523 <span class="comment">// subfaces. If there is a subsegment at edge bc or ca, connection of new    //</span>
<a name="l13524"></a>13524 <span class="comment">// subface (bcv or cav) to its casing subfaces is a face link, &#39;casingin&#39; is //</span>
<a name="l13525"></a>13525 <span class="comment">// the predecessor and &#39;casingout&#39; is the successor. It is important to keep //</span>
<a name="l13526"></a>13526 <span class="comment">// the orientations of the edge rings of the updated and created subfaces be //</span>
<a name="l13527"></a>13527 <span class="comment">// the same as abc&#39;s. So they have the same orientation as other subfaces of //</span>
<a name="l13528"></a>13528 <span class="comment">// this facet with respect to the lift point of this facet.                  //</span>
<a name="l13529"></a>13529 <span class="comment">//                                                                           //</span>
<a name="l13530"></a>13530 <span class="comment">// On completion, &#39;splitface&#39; returns abv.  If &#39;flipqueue&#39; is not NULL, it   //</span>
<a name="l13531"></a>13531 <span class="comment">// returns all possibly non-Delaunay edges.                                  //</span>
<a name="l13532"></a>13532 <span class="comment">//                                                                           //</span>
<a name="l13534"></a>13534 <span class="comment"></span>
<a name="l13535"></a>13535 <span class="keywordtype">void</span> tetgenmesh::splitsubface(point newpoint, face* splitface,
<a name="l13536"></a>13536   queue* flipqueue)
<a name="l13537"></a>13537 {
<a name="l13538"></a>13538   triface abvd, bcvd, cavd, bave, cbve, acve;
<a name="l13539"></a>13539   face abc, oldbc, oldca, bc, ca, spinsh;
<a name="l13540"></a>13540   face bccasin, bccasout, cacasin, cacasout;
<a name="l13541"></a>13541   face abv, bcv, cav;
<a name="l13542"></a>13542   point pa, pb, pc;
<a name="l13543"></a>13543 
<a name="l13544"></a>13544   abc = *splitface;
<a name="l13545"></a>13545   <span class="comment">// The newly created subfaces will have the same edge ring as abc.</span>
<a name="l13546"></a>13546   adjustedgering(abc, CCW);
<a name="l13547"></a>13547   pa = sorg(abc);
<a name="l13548"></a>13548   pb = sdest(abc);
<a name="l13549"></a>13549   pc = sapex(abc);
<a name="l13550"></a>13550 
<a name="l13551"></a>13551   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l13552"></a>13552     printf(<span class="stringliteral">&quot;  Inserting point %d on subface (%d, %d, %d).\n&quot;</span>,
<a name="l13553"></a>13553            pointmark(newpoint), pointmark(pa), pointmark(pb), pointmark(pc));
<a name="l13554"></a>13554   }
<a name="l13555"></a>13555 
<a name="l13556"></a>13556   <span class="comment">// Save the old configuration at edge bc and ca.  Subsegments may appear</span>
<a name="l13557"></a>13557   <span class="comment">//   at both sides, save the face links and dissolve them.</span>
<a name="l13558"></a>13558   senext(abc, oldbc);
<a name="l13559"></a>13559   senext2(abc, oldca);
<a name="l13560"></a>13560   spivot(oldbc, bccasout);
<a name="l13561"></a>13561   sspivot(oldbc, bc);
<a name="l13562"></a>13562   <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l13563"></a>13563     <span class="keywordflow">if</span> (oldbc.sh != bccasout.sh) {
<a name="l13564"></a>13564       <span class="comment">// &#39;oldbc&#39; is not self-bonded.</span>
<a name="l13565"></a>13565       spinsh = bccasout;
<a name="l13566"></a>13566       <span class="keywordflow">do</span> {
<a name="l13567"></a>13567         bccasin = spinsh;
<a name="l13568"></a>13568         spivotself(spinsh);
<a name="l13569"></a>13569       } <span class="keywordflow">while</span> (spinsh.sh != oldbc.sh);
<a name="l13570"></a>13570     } <span class="keywordflow">else</span> {
<a name="l13571"></a>13571       bccasout.sh = dummysh;
<a name="l13572"></a>13572     }
<a name="l13573"></a>13573     ssdissolve(oldbc);
<a name="l13574"></a>13574   }
<a name="l13575"></a>13575   spivot(oldca, cacasout);
<a name="l13576"></a>13576   sspivot(oldca, ca);
<a name="l13577"></a>13577   <span class="keywordflow">if</span> (ca.sh != dummysh) {
<a name="l13578"></a>13578     <span class="keywordflow">if</span> (oldca.sh != cacasout.sh) {
<a name="l13579"></a>13579       <span class="comment">// &#39;oldca&#39; is not self-bonded.</span>
<a name="l13580"></a>13580       spinsh = cacasout;
<a name="l13581"></a>13581       <span class="keywordflow">do</span> {
<a name="l13582"></a>13582         cacasin = spinsh;
<a name="l13583"></a>13583         spivotself(spinsh);
<a name="l13584"></a>13584       } <span class="keywordflow">while</span> (spinsh.sh != oldca.sh);
<a name="l13585"></a>13585     } <span class="keywordflow">else</span> {
<a name="l13586"></a>13586       cacasout.sh = dummysh;
<a name="l13587"></a>13587     }
<a name="l13588"></a>13588     ssdissolve(oldca);
<a name="l13589"></a>13589   }
<a name="l13590"></a>13590   <span class="comment">// Create two new subfaces.</span>
<a name="l13591"></a>13591   makeshellface(subfaces, &amp;bcv);
<a name="l13592"></a>13592   makeshellface(subfaces, &amp;cav);
<a name="l13593"></a>13593 
<a name="l13594"></a>13594   <span class="comment">// Set the vertices of changed and new subfaces.</span>
<a name="l13595"></a>13595   abv = abc;  <span class="comment">// Update &#39;abc&#39; to &#39;abv&#39;.</span>
<a name="l13596"></a>13596   setsapex(abv, newpoint);
<a name="l13597"></a>13597   setsorg(bcv, pb);  <span class="comment">// Set &#39;bcv&#39;.</span>
<a name="l13598"></a>13598   setsdest(bcv, pc);
<a name="l13599"></a>13599   setsapex(bcv, newpoint);
<a name="l13600"></a>13600   setsorg(cav, pc);  <span class="comment">// Set &#39;cav&#39;.</span>
<a name="l13601"></a>13601   setsdest(cav, pa);
<a name="l13602"></a>13602   setsapex(cav, newpoint);
<a name="l13603"></a>13603   <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l13604"></a>13604     <span class="comment">// Copy yhr area bound into the new subfaces.</span>
<a name="l13605"></a>13605     setareabound(bcv, areabound(abv));
<a name="l13606"></a>13606     setareabound(cav, areabound(abv));
<a name="l13607"></a>13607   }
<a name="l13608"></a>13608   <span class="comment">// Copy the boundary mark into the new subfaces.</span>
<a name="l13609"></a>13609   setshellmark(bcv, shellmark(abv));
<a name="l13610"></a>13610   setshellmark(cav, shellmark(abv));
<a name="l13611"></a>13611   <span class="comment">// Copy the subface type into the new subfaces.</span>
<a name="l13612"></a>13612   setshelltype(bcv, shelltype(abv));
<a name="l13613"></a>13613   setshelltype(cav, shelltype(abv));
<a name="l13614"></a>13614   <span class="keywordflow">if</span> (checkpbcs) {
<a name="l13615"></a>13615     <span class="comment">// Copy the pbcgroup into the new subfaces.</span>
<a name="l13616"></a>13616     setshellpbcgroup(bcv, shellpbcgroup(abv));
<a name="l13617"></a>13617     setshellpbcgroup(cav, shellpbcgroup(abv));
<a name="l13618"></a>13618   }
<a name="l13619"></a>13619   <span class="comment">// Bond the new subfaces to the surrounding subfaces.</span>
<a name="l13620"></a>13620   <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l13621"></a>13621     <span class="keywordflow">if</span> (bccasout.sh != dummysh) {
<a name="l13622"></a>13622       sbond1(bccasin, bcv);
<a name="l13623"></a>13623       sbond1(bcv, bccasout);
<a name="l13624"></a>13624     } <span class="keywordflow">else</span> {
<a name="l13625"></a>13625       <span class="comment">// Bond &#39;bcv&#39; to itsself.</span>
<a name="l13626"></a>13626       sbond(bcv, bcv);
<a name="l13627"></a>13627     }
<a name="l13628"></a>13628     ssbond(bcv, bc);
<a name="l13629"></a>13629   } <span class="keywordflow">else</span> {
<a name="l13630"></a>13630     sbond(bcv, bccasout);
<a name="l13631"></a>13631   }
<a name="l13632"></a>13632   <span class="keywordflow">if</span> (ca.sh != dummysh) {
<a name="l13633"></a>13633     <span class="keywordflow">if</span> (cacasout.sh != dummysh) {
<a name="l13634"></a>13634       sbond1(cacasin, cav);
<a name="l13635"></a>13635       sbond1(cav, cacasout);
<a name="l13636"></a>13636     } <span class="keywordflow">else</span> {
<a name="l13637"></a>13637       <span class="comment">// Bond &#39;cav&#39; to itself.</span>
<a name="l13638"></a>13638       sbond(cav, cav);
<a name="l13639"></a>13639     }
<a name="l13640"></a>13640     ssbond(cav, ca);
<a name="l13641"></a>13641   } <span class="keywordflow">else</span> {
<a name="l13642"></a>13642     sbond(cav, cacasout);
<a name="l13643"></a>13643   }
<a name="l13644"></a>13644   senext2self(bcv);
<a name="l13645"></a>13645   sbond(bcv, oldbc);
<a name="l13646"></a>13646   senextself(cav);
<a name="l13647"></a>13647   sbond(cav, oldca);
<a name="l13648"></a>13648   senext2self(bcv);
<a name="l13649"></a>13649   senextself(cav);
<a name="l13650"></a>13650   sbond(bcv, cav);
<a name="l13651"></a>13651 
<a name="l13652"></a>13652   <span class="comment">// Bond the new subfaces to the new tetrahedra if they exist.</span>
<a name="l13653"></a>13653   stpivot(abv, abvd);
<a name="l13654"></a>13654   <span class="keywordflow">if</span> (abvd.tet != dummytet) {
<a name="l13655"></a>13655     <span class="comment">// Get two new tetrahedra and their syms.</span>
<a name="l13656"></a>13656     findedge(&amp;abvd, sorg(abv), sdest(abv));
<a name="l13657"></a>13657     enextfnext(abvd, bcvd);
<a name="l13658"></a>13658 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13659"></a>13659 <span class="preprocessor"></span>    assert(bcvd.tet != dummytet);
<a name="l13660"></a>13660 <span class="preprocessor">#endif</span>
<a name="l13661"></a>13661 <span class="preprocessor"></span>    fnextself(bcvd);
<a name="l13662"></a>13662     enext2fnext(abvd, cavd);
<a name="l13663"></a>13663 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13664"></a>13664 <span class="preprocessor"></span>    assert(cavd.tet != dummytet);
<a name="l13665"></a>13665 <span class="preprocessor">#endif</span>
<a name="l13666"></a>13666 <span class="preprocessor"></span>    fnextself(cavd);
<a name="l13667"></a>13667     <span class="comment">// Bond two new subfaces to the two new tetrahedra.</span>
<a name="l13668"></a>13668     tsbond(bcvd, bcv);
<a name="l13669"></a>13669     tsbond(cavd, cav);
<a name="l13670"></a>13670   }
<a name="l13671"></a>13671   <span class="comment">// Set the connection at the other sides if the tetrahedra exist.</span>
<a name="l13672"></a>13672   sesymself(abv);  <span class="comment">// bav</span>
<a name="l13673"></a>13673   stpivot(abv, bave);
<a name="l13674"></a>13674   <span class="keywordflow">if</span> (bave.tet != dummytet) {
<a name="l13675"></a>13675     sesymself(bcv);  <span class="comment">// cbv</span>
<a name="l13676"></a>13676     sesymself(cav);  <span class="comment">// acv</span>
<a name="l13677"></a>13677     <span class="comment">// Get two new tetrahedra and their syms.</span>
<a name="l13678"></a>13678     findedge(&amp;bave, sorg(abv), sdest(abv));
<a name="l13679"></a>13679     enextfnext(bave, acve);
<a name="l13680"></a>13680 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13681"></a>13681 <span class="preprocessor"></span>    assert(acve.tet != dummytet);
<a name="l13682"></a>13682 <span class="preprocessor">#endif</span>
<a name="l13683"></a>13683 <span class="preprocessor"></span>    fnextself(acve);
<a name="l13684"></a>13684     enext2fnext(bave, cbve);
<a name="l13685"></a>13685 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13686"></a>13686 <span class="preprocessor"></span>    assert(cbve.tet != dummytet);
<a name="l13687"></a>13687 <span class="preprocessor">#endif</span>
<a name="l13688"></a>13688 <span class="preprocessor"></span>    fnextself(cbve);
<a name="l13689"></a>13689     <span class="comment">// Bond two new subfaces to the two new tetrahedra.</span>
<a name="l13690"></a>13690     tsbond(acve, cav);
<a name="l13691"></a>13691     tsbond(cbve, bcv);
<a name="l13692"></a>13692   }
<a name="l13693"></a>13693 
<a name="l13694"></a>13694   bcv.shver = 0;
<a name="l13695"></a>13695   cav.shver = 0;
<a name="l13696"></a>13696   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l13697"></a>13697     printf(<span class="stringliteral">&quot;    Updating abv &quot;</span>);
<a name="l13698"></a>13698     printsh(&amp;abv);
<a name="l13699"></a>13699     printf(<span class="stringliteral">&quot;    Creating bcv &quot;</span>);
<a name="l13700"></a>13700     printsh(&amp;bcv);
<a name="l13701"></a>13701     printf(<span class="stringliteral">&quot;    Creating cav &quot;</span>);
<a name="l13702"></a>13702     printsh(&amp;cav);
<a name="l13703"></a>13703   }
<a name="l13704"></a>13704 
<a name="l13705"></a>13705   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l13706"></a>13706     enqueueflipedge(abv, flipqueue);
<a name="l13707"></a>13707     enqueueflipedge(bcv, flipqueue);
<a name="l13708"></a>13708     enqueueflipedge(cav, flipqueue);
<a name="l13709"></a>13709   }
<a name="l13710"></a>13710 
<a name="l13711"></a>13711   <span class="comment">// Set the return handle be abv.</span>
<a name="l13712"></a>13712   *splitface = abv;
<a name="l13713"></a>13713 }
<a name="l13714"></a>13714 
<a name="l13716"></a>13716 <span class="comment">//                                                                           //</span>
<a name="l13717"></a>13717 <span class="comment">// unsplitsubface()    Reverse the operation of inserting a point on a       //</span>
<a name="l13718"></a>13718 <span class="comment">//                     subface, so as to remove the newly inserted point.    //</span>
<a name="l13719"></a>13719 <span class="comment">//                                                                           //</span>
<a name="l13720"></a>13720 <span class="comment">// Assume the original subface is abc, it was split by a point v into three  //</span>
<a name="l13721"></a>13721 <span class="comment">// subfaces abv, bcv and cav.  &#39;splitsh&#39; represents abv.                     //</span>
<a name="l13722"></a>13722 <span class="comment">//                                                                           //</span>
<a name="l13723"></a>13723 <span class="comment">// To remove point v is to expand abv to abc, delete bcv and cav. If edge bc //</span>
<a name="l13724"></a>13724 <span class="comment">// or ca is a subsegment,  the connection at a subsegment is a subface link, //</span>
<a name="l13725"></a>13725 <span class="comment">// &#39;-casin&#39; and &#39;-casout&#39; are used to save the predecessor and successor of  //</span>
<a name="l13726"></a>13726 <span class="comment">// bcv or cav.  On completion, point v is not deleted in this routine.       //</span>
<a name="l13727"></a>13727 <span class="comment">//                                                                           //</span>
<a name="l13729"></a>13729 <span class="comment"></span>
<a name="l13730"></a>13730 <span class="keywordtype">void</span> tetgenmesh::unsplitsubface(face* splitsh)
<a name="l13731"></a>13731 {
<a name="l13732"></a>13732   face abv, bcv, cav;
<a name="l13733"></a>13733   face oldbv, oldva, bc, ca, spinsh;
<a name="l13734"></a>13734   face bccasin, bccasout, cacasin, cacasout;
<a name="l13735"></a>13735 
<a name="l13736"></a>13736   abv = *splitsh;
<a name="l13737"></a>13737   senext(abv, oldbv);
<a name="l13738"></a>13738   spivot(oldbv, bcv);
<a name="l13739"></a>13739   <span class="keywordflow">if</span> (sorg(bcv) != sdest(oldbv)) {
<a name="l13740"></a>13740     sesymself(bcv);
<a name="l13741"></a>13741   }
<a name="l13742"></a>13742   senextself(bcv);
<a name="l13743"></a>13743   senext2(abv, oldva);
<a name="l13744"></a>13744   spivot(oldva, cav);
<a name="l13745"></a>13745   <span class="keywordflow">if</span> (sorg(cav) != sdest(oldva)) {
<a name="l13746"></a>13746     sesymself(cav);
<a name="l13747"></a>13747   }
<a name="l13748"></a>13748   senext2self(cav);
<a name="l13749"></a>13749 
<a name="l13750"></a>13750   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l13751"></a>13751     printf(<span class="stringliteral">&quot;  Removing point %d on subface (%d, %d, %d).\n&quot;</span>,
<a name="l13752"></a>13752            pointmark(sapex(abv)), pointmark(sorg(abv)), pointmark(sdest(abv)),
<a name="l13753"></a>13753            pointmark(sdest(bcv)));
<a name="l13754"></a>13754   }
<a name="l13755"></a>13755 
<a name="l13756"></a>13756   spivot(bcv, bccasout);
<a name="l13757"></a>13757   sspivot(bcv, bc);
<a name="l13758"></a>13758   <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l13759"></a>13759     <span class="keywordflow">if</span> (bcv.sh != bccasout.sh) {
<a name="l13760"></a>13760       <span class="comment">// &#39;bcv&#39; is not self-bonded.</span>
<a name="l13761"></a>13761       spinsh = bccasout;
<a name="l13762"></a>13762       <span class="keywordflow">do</span> {
<a name="l13763"></a>13763         bccasin = spinsh;
<a name="l13764"></a>13764         spivotself(spinsh);
<a name="l13765"></a>13765       } <span class="keywordflow">while</span> (spinsh.sh != bcv.sh);
<a name="l13766"></a>13766     } <span class="keywordflow">else</span> {
<a name="l13767"></a>13767       bccasout.sh = dummysh;
<a name="l13768"></a>13768     }
<a name="l13769"></a>13769   }
<a name="l13770"></a>13770   spivot(cav, cacasout);
<a name="l13771"></a>13771   sspivot(cav, ca);
<a name="l13772"></a>13772   <span class="keywordflow">if</span> (ca.sh != dummysh) {
<a name="l13773"></a>13773     <span class="keywordflow">if</span> (cav.sh != cacasout.sh) {
<a name="l13774"></a>13774       <span class="comment">// &#39;cav&#39; is not self-bonded.</span>
<a name="l13775"></a>13775       spinsh = cacasout;
<a name="l13776"></a>13776       <span class="keywordflow">do</span> {
<a name="l13777"></a>13777        cacasin = spinsh;
<a name="l13778"></a>13778        spivotself(spinsh);
<a name="l13779"></a>13779       } <span class="keywordflow">while</span> (spinsh.sh != cav.sh);
<a name="l13780"></a>13780     } <span class="keywordflow">else</span> {
<a name="l13781"></a>13781       cacasout.sh = dummysh;
<a name="l13782"></a>13782     }
<a name="l13783"></a>13783   }
<a name="l13784"></a>13784 
<a name="l13785"></a>13785   <span class="comment">// Expand abv to abc.</span>
<a name="l13786"></a>13786   setsapex(abv, sdest(bcv));
<a name="l13787"></a>13787   <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l13788"></a>13788     <span class="keywordflow">if</span> (bccasout.sh != dummysh) {
<a name="l13789"></a>13789       sbond1(bccasin, oldbv);
<a name="l13790"></a>13790       sbond1(oldbv, bccasout);
<a name="l13791"></a>13791     } <span class="keywordflow">else</span> {
<a name="l13792"></a>13792       <span class="comment">// Bond &#39;oldbv&#39; to itself.</span>
<a name="l13793"></a>13793       sbond(oldbv, oldbv);
<a name="l13794"></a>13794     }
<a name="l13795"></a>13795     ssbond(oldbv, bc);
<a name="l13796"></a>13796   } <span class="keywordflow">else</span> {
<a name="l13797"></a>13797     sbond(oldbv, bccasout);
<a name="l13798"></a>13798   }
<a name="l13799"></a>13799   <span class="keywordflow">if</span> (ca.sh != dummysh) {
<a name="l13800"></a>13800     <span class="keywordflow">if</span> (cacasout.sh != dummysh) {
<a name="l13801"></a>13801       sbond1(cacasin, oldva);
<a name="l13802"></a>13802       sbond1(oldva, cacasout);
<a name="l13803"></a>13803     } <span class="keywordflow">else</span> {
<a name="l13804"></a>13804       <span class="comment">// Bond &#39;oldva&#39; to itself.</span>
<a name="l13805"></a>13805       sbond(oldva, oldva);
<a name="l13806"></a>13806     }
<a name="l13807"></a>13807     ssbond(oldva, ca);
<a name="l13808"></a>13808   } <span class="keywordflow">else</span> {
<a name="l13809"></a>13809     sbond(oldva, cacasout);
<a name="l13810"></a>13810   }
<a name="l13811"></a>13811 
<a name="l13812"></a>13812   <span class="comment">// Delete two split-out subfaces.</span>
<a name="l13813"></a>13813   shellfacedealloc(subfaces, bcv.sh);
<a name="l13814"></a>13814   shellfacedealloc(subfaces, cav.sh);
<a name="l13815"></a>13815 }
<a name="l13816"></a>13816 
<a name="l13818"></a>13818 <span class="comment">//                                                                           //</span>
<a name="l13819"></a>13819 <span class="comment">// splittetedge()    Insert a point on an edge of the mesh.                  //</span>
<a name="l13820"></a>13820 <span class="comment">//                                                                           //</span>
<a name="l13821"></a>13821 <span class="comment">// The edge is given by &#39;splittet&#39;. Assume its four corners are a, b, n1 and //</span>
<a name="l13822"></a>13822 <span class="comment">// n2, where ab is the edge will be split. Around ab may exist any number of //</span>
<a name="l13823"></a>13823 <span class="comment">// tetrahedra. For convenience, they&#39;re ordered in a sequence following the  //</span>
<a name="l13824"></a>13824 <span class="comment">// right-hand rule with your thumb points from a to b. Let the vertex set of //</span>
<a name="l13825"></a>13825 <span class="comment">// these tetrahedra be {a, b, n1, n2, ..., n(i)}. NOTE the tetrahedra around //</span>
<a name="l13826"></a>13826 <span class="comment">// ab may not connect to each other (can only happen when ab is a subsegment,//</span>
<a name="l13827"></a>13827 <span class="comment">// hence some faces abn(i) are subfaces).  If ab is a subsegment, abn1 must  //</span>
<a name="l13828"></a>13828 <span class="comment">// be a subface.                                                             //</span>
<a name="l13829"></a>13829 <span class="comment">//                                                                           //</span>
<a name="l13830"></a>13830 <span class="comment">// To split edge ab by a point v is to split all tetrahedra containing ab by //</span>
<a name="l13831"></a>13831 <span class="comment">// v.  More specifically, for each such tetrahedron, an1n2b, it is shrunk to //</span>
<a name="l13832"></a>13832 <span class="comment">// an1n2v, and a new tetrahedra bn2n1v is created. If ab is a subsegment, or //</span>
<a name="l13833"></a>13833 <span class="comment">// some faces of the splitting tetrahedra are subfaces, they must be split   //</span>
<a name="l13834"></a>13834 <span class="comment">// either by calling routine &#39;splitsubedge()&#39;.                               //</span>
<a name="l13835"></a>13835 <span class="comment">//                                                                           //</span>
<a name="l13836"></a>13836 <span class="comment">// On completion, &#39;splittet&#39; returns avn1n2.  If &#39;flipqueue&#39; is not NULL, it //</span>
<a name="l13837"></a>13837 <span class="comment">// returns all faces which may become non-Delaunay after this operation.     //</span>
<a name="l13838"></a>13838 <span class="comment">//                                                                           //</span>
<a name="l13840"></a>13840 <span class="comment"></span>
<a name="l13841"></a>13841 <span class="keywordtype">void</span> tetgenmesh::splittetedge(point newpoint, triface* splittet,
<a name="l13842"></a>13842   queue* flipqueue)
<a name="l13843"></a>13843 {
<a name="l13844"></a>13844   triface *bots, *newtops;
<a name="l13845"></a>13845   triface oldtop, topcasing;
<a name="l13846"></a>13846   triface spintet, tmpbond0, tmpbond1;
<a name="l13847"></a>13847   face abseg, splitsh, topsh, spinsh;
<a name="l13848"></a>13848   triface worktet;
<a name="l13849"></a>13849   face n1n2seg, n2vseg, n1vseg;
<a name="l13850"></a>13850   point pa, pb, n1, n2;
<a name="l13851"></a>13851   REAL attrib, volume;
<a name="l13852"></a>13852   <span class="keywordtype">int</span> wrapcount, hitbdry;
<a name="l13853"></a>13853   <span class="keywordtype">int</span> i, j;
<a name="l13854"></a>13854 
<a name="l13855"></a>13855   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l13856"></a>13856     <span class="comment">// Is there a subsegment need to be split together?</span>
<a name="l13857"></a>13857     tsspivot(splittet, &amp;abseg);
<a name="l13858"></a>13858     <span class="keywordflow">if</span> (abseg.sh != dummysh) {
<a name="l13859"></a>13859       abseg.shver = 0;
<a name="l13860"></a>13860       <span class="comment">// Orient the edge direction of &#39;splittet&#39; be abseg.</span>
<a name="l13861"></a>13861       <span class="keywordflow">if</span> (org(*splittet) != sorg(abseg)) {
<a name="l13862"></a>13862         esymself(*splittet);
<a name="l13863"></a>13863       }
<a name="l13864"></a>13864     }
<a name="l13865"></a>13865   }
<a name="l13866"></a>13866   spintet = *splittet;
<a name="l13867"></a>13867   pa = org(spintet);
<a name="l13868"></a>13868   pb = dest(spintet);
<a name="l13869"></a>13869 
<a name="l13870"></a>13870   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l13871"></a>13871     printf(<span class="stringliteral">&quot;  Inserting point %d on edge (%d, %d).\n&quot;</span>,
<a name="l13872"></a>13872            pointmark(newpoint), pointmark(pa), pointmark(pb));
<a name="l13873"></a>13873   }
<a name="l13874"></a>13874 
<a name="l13875"></a>13875   <span class="comment">// Collect the tetrahedra containing the splitting edge (ab).</span>
<a name="l13876"></a>13876   n1 = apex(spintet);
<a name="l13877"></a>13877   hitbdry = 0;
<a name="l13878"></a>13878   wrapcount = 1;
<a name="l13879"></a>13879   <span class="keywordflow">if</span> (checksubfaces &amp;&amp; abseg.sh != dummysh) {
<a name="l13880"></a>13880     <span class="comment">// It may happen that some tetrahedra containing ab (a subsegment) are</span>
<a name="l13881"></a>13881     <span class="comment">//   completely disconnected with others. If it happens, use the face</span>
<a name="l13882"></a>13882     <span class="comment">//   link of ab to cross the boundary.</span>
<a name="l13883"></a>13883     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l13884"></a>13884       <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l13885"></a>13885         <span class="comment">// Meet a boundary, walk through it.</span>
<a name="l13886"></a>13886         hitbdry ++;
<a name="l13887"></a>13887         tspivot(spintet, spinsh);
<a name="l13888"></a>13888 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13889"></a>13889 <span class="preprocessor"></span>        assert(spinsh.sh != dummysh);
<a name="l13890"></a>13890 <span class="preprocessor">#endif</span>
<a name="l13891"></a>13891 <span class="preprocessor"></span>        findedge(&amp;spinsh, pa, pb);
<a name="l13892"></a>13892         sfnextself(spinsh);
<a name="l13893"></a>13893         stpivot(spinsh, spintet);
<a name="l13894"></a>13894 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13895"></a>13895 <span class="preprocessor"></span>        assert(spintet.tet != dummytet);
<a name="l13896"></a>13896 <span class="preprocessor">#endif</span>
<a name="l13897"></a>13897 <span class="preprocessor"></span>        findedge(&amp;spintet, pa, pb);
<a name="l13898"></a>13898         <span class="comment">// Remember this position (hull face) in &#39;splittet&#39;.</span>
<a name="l13899"></a>13899         *splittet = spintet;
<a name="l13900"></a>13900         <span class="comment">// Split two hull faces increase the hull size;</span>
<a name="l13901"></a>13901         hullsize += 2;
<a name="l13902"></a>13902       }
<a name="l13903"></a>13903       <span class="keywordflow">if</span> (apex(spintet) == n1) <span class="keywordflow">break</span>;
<a name="l13904"></a>13904       wrapcount ++;
<a name="l13905"></a>13905     }
<a name="l13906"></a>13906     <span class="keywordflow">if</span> (hitbdry &gt; 0) {
<a name="l13907"></a>13907       wrapcount -= hitbdry;
<a name="l13908"></a>13908     }
<a name="l13909"></a>13909   } <span class="keywordflow">else</span> {
<a name="l13910"></a>13910     <span class="comment">// All the tetrahedra containing ab are connected together. If there</span>
<a name="l13911"></a>13911     <span class="comment">//   are subfaces, &#39;splitsh&#39; keeps one of them.</span>
<a name="l13912"></a>13912     splitsh.sh = dummysh;
<a name="l13913"></a>13913     <span class="keywordflow">while</span> (hitbdry &lt; 2) {
<a name="l13914"></a>13914       <span class="keywordflow">if</span> (checksubfaces &amp;&amp; splitsh.sh == dummysh) {
<a name="l13915"></a>13915         tspivot(spintet, splitsh);
<a name="l13916"></a>13916       }
<a name="l13917"></a>13917       <span class="keywordflow">if</span> (fnextself(spintet)) {
<a name="l13918"></a>13918         <span class="keywordflow">if</span> (apex(spintet) == n1) <span class="keywordflow">break</span>;
<a name="l13919"></a>13919         wrapcount++;
<a name="l13920"></a>13920       } <span class="keywordflow">else</span> {
<a name="l13921"></a>13921         hitbdry ++;
<a name="l13922"></a>13922         <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l13923"></a>13923           esym(*splittet, spintet);
<a name="l13924"></a>13924         }
<a name="l13925"></a>13925       }
<a name="l13926"></a>13926     }
<a name="l13927"></a>13927     <span class="keywordflow">if</span> (hitbdry &gt; 0) {
<a name="l13928"></a>13928       <span class="comment">// ab is on the hull.</span>
<a name="l13929"></a>13929       wrapcount -= 1;
<a name="l13930"></a>13930       <span class="comment">// &#39;spintet&#39; now is a hull face, inverse its edge direction.</span>
<a name="l13931"></a>13931       esym(spintet, *splittet);
<a name="l13932"></a>13932       <span class="comment">// Split two hull faces increases the number of hull faces.</span>
<a name="l13933"></a>13933       hullsize += 2;
<a name="l13934"></a>13934     }
<a name="l13935"></a>13935   }
<a name="l13936"></a>13936 
<a name="l13937"></a>13937   <span class="comment">// Make arrays of updating (bot, oldtop) and new (newtop) tetrahedra.</span>
<a name="l13938"></a>13938   bots = <span class="keyword">new</span> triface[wrapcount];
<a name="l13939"></a>13939   newtops = <span class="keyword">new</span> triface[wrapcount];
<a name="l13940"></a>13940   <span class="comment">// Spin around ab, gather tetrahedra and set up new tetrahedra.</span>
<a name="l13941"></a>13941   spintet = *splittet;
<a name="l13942"></a>13942   <span class="keywordflow">for</span> (i = 0; i &lt; wrapcount; i++) {
<a name="l13943"></a>13943     <span class="comment">// Get &#39;bots[i] = an1n2b&#39;.</span>
<a name="l13944"></a>13944     enext2fnext(spintet, bots[i]);
<a name="l13945"></a>13945     esymself(bots[i]);
<a name="l13946"></a>13946     <span class="comment">// Create &#39;newtops[i]&#39;.</span>
<a name="l13947"></a>13947     maketetrahedron(&amp;(newtops[i]));
<a name="l13948"></a>13948     <span class="comment">// Go to the next.</span>
<a name="l13949"></a>13949     fnextself(spintet);
<a name="l13950"></a>13950     <span class="keywordflow">if</span> (checksubfaces &amp;&amp; abseg.sh != dummysh) {
<a name="l13951"></a>13951       <span class="keywordflow">if</span> (!issymexist(&amp;spintet)) {
<a name="l13952"></a>13952         <span class="comment">// We meet a hull face, walk through it.</span>
<a name="l13953"></a>13953         tspivot(spintet, spinsh);
<a name="l13954"></a>13954 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13955"></a>13955 <span class="preprocessor"></span>        assert(spinsh.sh != dummysh);
<a name="l13956"></a>13956 <span class="preprocessor">#endif</span>
<a name="l13957"></a>13957 <span class="preprocessor"></span>        findedge(&amp;spinsh, pa, pb);
<a name="l13958"></a>13958         sfnextself(spinsh);
<a name="l13959"></a>13959         stpivot(spinsh, spintet);
<a name="l13960"></a>13960 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13961"></a>13961 <span class="preprocessor"></span>        assert(spintet.tet != dummytet);
<a name="l13962"></a>13962 <span class="preprocessor">#endif</span>
<a name="l13963"></a>13963 <span class="preprocessor"></span>        findedge(&amp;spintet, pa, pb);
<a name="l13964"></a>13964       }
<a name="l13965"></a>13965     }
<a name="l13966"></a>13966   }
<a name="l13967"></a>13967 
<a name="l13968"></a>13968   <span class="comment">// Set the vertices of updated and new tetrahedra.</span>
<a name="l13969"></a>13969   <span class="keywordflow">for</span> (i = 0; i &lt; wrapcount; i++) {
<a name="l13970"></a>13970     <span class="comment">// Update &#39;bots[i] = an1n2v&#39;.</span>
<a name="l13971"></a>13971     setoppo(bots[i], newpoint);
<a name="l13972"></a>13972     <span class="comment">// Set &#39;newtops[i] = bn2n1v&#39;.</span>
<a name="l13973"></a>13973     n1 = dest(bots[i]);
<a name="l13974"></a>13974     n2 = apex(bots[i]);
<a name="l13975"></a>13975     <span class="comment">// Set &#39;newtops[i]&#39;.</span>
<a name="l13976"></a>13976     setorg(newtops[i], pb);
<a name="l13977"></a>13977     setdest(newtops[i], n2);
<a name="l13978"></a>13978     setapex(newtops[i], n1);
<a name="l13979"></a>13979     setoppo(newtops[i], newpoint);
<a name="l13980"></a>13980     <span class="comment">// Set the element attributes of a new tetrahedron.</span>
<a name="l13981"></a>13981     <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberoftetrahedronattributes; j++) {
<a name="l13982"></a>13982       attrib = elemattribute(bots[i].tet, j);
<a name="l13983"></a>13983       setelemattribute(newtops[i].tet, j, attrib);
<a name="l13984"></a>13984     }
<a name="l13985"></a>13985     <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l13986"></a>13986       <span class="comment">// Set the area constraint of a new tetrahedron.</span>
<a name="l13987"></a>13987       volume = volumebound(bots[i].tet);
<a name="l13988"></a>13988       setvolumebound(newtops[i].tet, volume);
<a name="l13989"></a>13989     }
<a name="l13990"></a>13990 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l13991"></a>13991 <span class="preprocessor"></span>    <span class="comment">// Make sure no inversed tetrahedron has been created.</span>
<a name="l13992"></a>13992     <span class="comment">// volume = orient3d(pa, n1, n2, newpoint);</span>
<a name="l13993"></a>13993     <span class="comment">// if (volume &gt;= 0.0) {</span>
<a name="l13994"></a>13994     <span class="comment">//   printf(&quot;Internal error in splittetedge(): volume = %.12g.\n&quot;, volume);</span>
<a name="l13995"></a>13995     <span class="comment">// }</span>
<a name="l13996"></a>13996     <span class="comment">// volume = orient3d(pb, n2, n1, newpoint);</span>
<a name="l13997"></a>13997     <span class="comment">// if (volume &gt;= 0.0) {</span>
<a name="l13998"></a>13998     <span class="comment">//   printf(&quot;Internal error in splittetedge(): volume = %.12g.\n&quot;, volume);</span>
<a name="l13999"></a>13999     <span class="comment">// }</span>
<a name="l14000"></a>14000 <span class="preprocessor">#endif</span>
<a name="l14001"></a>14001 <span class="preprocessor"></span>  }
<a name="l14002"></a>14002 
<a name="l14003"></a>14003   <span class="comment">// Bond newtops to topcasings and bots.</span>
<a name="l14004"></a>14004   <span class="keywordflow">for</span> (i = 0; i &lt; wrapcount; i++) {
<a name="l14005"></a>14005     <span class="comment">// Get &#39;oldtop = n1n2va&#39; from &#39;bots[i]&#39;.</span>
<a name="l14006"></a>14006     enextfnext(bots[i], oldtop);
<a name="l14007"></a>14007     sym(oldtop, topcasing);
<a name="l14008"></a>14008     bond(newtops[i], topcasing);
<a name="l14009"></a>14009     <span class="keywordflow">if</span> (checksubfaces) {
<a name="l14010"></a>14010       tspivot(oldtop, topsh);
<a name="l14011"></a>14011       <span class="keywordflow">if</span> (topsh.sh != dummysh) {
<a name="l14012"></a>14012         tsdissolve(oldtop);
<a name="l14013"></a>14013         tsbond(newtops[i], topsh);
<a name="l14014"></a>14014       }
<a name="l14015"></a>14015     }
<a name="l14016"></a>14016     enextfnext(newtops[i], tmpbond0);
<a name="l14017"></a>14017     bond(oldtop, tmpbond0);
<a name="l14018"></a>14018   }
<a name="l14019"></a>14019   <span class="comment">// Bond between newtops.</span>
<a name="l14020"></a>14020   fnext(newtops[0], tmpbond0);
<a name="l14021"></a>14021   enext2fnext(bots[0], spintet);
<a name="l14022"></a>14022   <span class="keywordflow">for</span> (i = 1; i &lt; wrapcount; i ++) {
<a name="l14023"></a>14023     <span class="keywordflow">if</span> (issymexist(&amp;spintet)) {
<a name="l14024"></a>14024       enext2fnext(newtops[i], tmpbond1);
<a name="l14025"></a>14025       bond(tmpbond0, tmpbond1);
<a name="l14026"></a>14026     }
<a name="l14027"></a>14027     fnext(newtops[i], tmpbond0);
<a name="l14028"></a>14028     enext2fnext(bots[i], spintet);
<a name="l14029"></a>14029   }
<a name="l14030"></a>14030   <span class="comment">// Bond the last to the first if no boundary.</span>
<a name="l14031"></a>14031   <span class="keywordflow">if</span> (issymexist(&amp;spintet)) {
<a name="l14032"></a>14032     enext2fnext(newtops[0], tmpbond1);
<a name="l14033"></a>14033     bond(tmpbond0, tmpbond1);
<a name="l14034"></a>14034   }
<a name="l14035"></a>14035   <span class="keywordflow">if</span> (checksubsegs) {
<a name="l14036"></a>14036     <span class="keywordflow">for</span> (i = 0; i &lt; wrapcount; i++) {
<a name="l14037"></a>14037       enextfnext(bots[i], worktet); <span class="comment">// edge n1-&gt;n2.</span>
<a name="l14038"></a>14038       tsspivot1(worktet, n1n2seg);
<a name="l14039"></a>14039       <span class="keywordflow">if</span> (n1n2seg.sh != dummysh) {
<a name="l14040"></a>14040         enext(newtops[i], tmpbond0);
<a name="l14041"></a>14041         tssbond1(tmpbond0, n1n2seg);
<a name="l14042"></a>14042       }
<a name="l14043"></a>14043       enextself(worktet); <span class="comment">// edge n2-&gt;v ==&gt; n2-&gt;b</span>
<a name="l14044"></a>14044       tsspivot1(worktet, n2vseg);
<a name="l14045"></a>14045       <span class="keywordflow">if</span> (n2vseg.sh != dummysh) {
<a name="l14046"></a>14046         tssdissolve1(worktet);
<a name="l14047"></a>14047         tssbond1(newtops[i], n2vseg);
<a name="l14048"></a>14048       }
<a name="l14049"></a>14049       enextself(worktet); <span class="comment">// edge v-&gt;n1 ==&gt; b-&gt;n1</span>
<a name="l14050"></a>14050       tsspivot1(worktet, n1vseg);
<a name="l14051"></a>14051       <span class="keywordflow">if</span> (n1vseg.sh != dummysh) {
<a name="l14052"></a>14052         tssdissolve1(worktet);
<a name="l14053"></a>14053         enext2(newtops[i], tmpbond0);
<a name="l14054"></a>14054         tssbond1(tmpbond0, n1vseg);
<a name="l14055"></a>14055       }
<a name="l14056"></a>14056     }
<a name="l14057"></a>14057   }
<a name="l14058"></a>14058 
<a name="l14059"></a>14059   <span class="comment">// Is there exist subfaces and subsegment need to be split?</span>
<a name="l14060"></a>14060   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l14061"></a>14061     <span class="keywordflow">if</span> (abseg.sh != dummysh) {
<a name="l14062"></a>14062       <span class="comment">// A subsegment needs be split.</span>
<a name="l14063"></a>14063       spivot(abseg, splitsh);
<a name="l14064"></a>14064 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14065"></a>14065 <span class="preprocessor"></span>      assert(splitsh.sh != dummysh);
<a name="l14066"></a>14066 <span class="preprocessor">#endif</span>
<a name="l14067"></a>14067 <span class="preprocessor"></span>    }
<a name="l14068"></a>14068     <span class="keywordflow">if</span> (splitsh.sh != dummysh) {
<a name="l14069"></a>14069       <span class="comment">// Split subfaces (and subsegment).</span>
<a name="l14070"></a>14070       findedge(&amp;splitsh, pa, pb);
<a name="l14071"></a>14071       splitsubedge(newpoint, &amp;splitsh, (queue *) NULL);
<a name="l14072"></a>14072     }
<a name="l14073"></a>14073   }
<a name="l14074"></a>14074 
<a name="l14075"></a>14075   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l14076"></a>14076     <span class="keywordflow">for</span> (i = 0; i &lt; wrapcount; i++) {
<a name="l14077"></a>14077       printf(<span class="stringliteral">&quot;    Updating bots[%i] &quot;</span>, i);
<a name="l14078"></a>14078       printtet(&amp;(bots[i]));
<a name="l14079"></a>14079       printf(<span class="stringliteral">&quot;    Creating newtops[%i] &quot;</span>, i);
<a name="l14080"></a>14080       printtet(&amp;(newtops[i]));
<a name="l14081"></a>14081     }
<a name="l14082"></a>14082   }
<a name="l14083"></a>14083 
<a name="l14084"></a>14084   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l14085"></a>14085     <span class="keywordflow">for</span> (i = 0; i &lt; wrapcount; i++) {
<a name="l14086"></a>14086       enqueueflipface(bots[i], flipqueue);
<a name="l14087"></a>14087       enqueueflipface(newtops[i], flipqueue);
<a name="l14088"></a>14088     }
<a name="l14089"></a>14089   }
<a name="l14090"></a>14090 
<a name="l14091"></a>14091   <span class="comment">// Set the return handle be avn1n2.  It is got by transforming from</span>
<a name="l14092"></a>14092   <span class="comment">//   &#39;bots[0]&#39; (which is an1n2v).</span>
<a name="l14093"></a>14093   fnext(bots[0], spintet); <span class="comment">// spintet is an1vn2.</span>
<a name="l14094"></a>14094   esymself(spintet); <span class="comment">// spintet is n1avn2.</span>
<a name="l14095"></a>14095   enextself(spintet); <span class="comment">// spintet is avn1n2.</span>
<a name="l14096"></a>14096   *splittet = spintet;
<a name="l14097"></a>14097 
<a name="l14098"></a>14098   <span class="keyword">delete</span> [] bots;
<a name="l14099"></a>14099   <span class="keyword">delete</span> [] newtops;
<a name="l14100"></a>14100 }
<a name="l14101"></a>14101 
<a name="l14103"></a>14103 <span class="comment">//                                                                           //</span>
<a name="l14104"></a>14104 <span class="comment">// unsplittetedge()    Reverse the operation of splitting an edge, so as to  //</span>
<a name="l14105"></a>14105 <span class="comment">//                     remove the newly inserted point.                      //</span>
<a name="l14106"></a>14106 <span class="comment">//                                                                           //</span>
<a name="l14107"></a>14107 <span class="comment">// Assume the original edge is ab, the tetrahedron containing ab is abn1n2.  //</span>
<a name="l14108"></a>14108 <span class="comment">// After ab was split by a point v, every tetrahedron containing ab (e.g.,   //</span>
<a name="l14109"></a>14109 <span class="comment">// abn1n2) has been split into two (e.g., an1n2v and bn2n1v). &#39;splittet&#39;     //</span>
<a name="l14110"></a>14110 <span class="comment">// represents avn1n2 (i.e., its destination is v).                           //</span>
<a name="l14111"></a>14111 <span class="comment">//                                                                           //</span>
<a name="l14112"></a>14112 <span class="comment">// To remove point v is to expand each split tetrahedron containing ab (e.g.,//</span>
<a name="l14113"></a>14113 <span class="comment">// (avn1n2 to abn1n2), then delete the redundant one(e.g., vbn1n2). If there //</span>
<a name="l14114"></a>14114 <span class="comment">// exists any subface around ab, routine unsplitsubedge() will be called to  //</span>
<a name="l14115"></a>14115 <span class="comment">// reverse the operation of splitting a edge (or a subsegment) of subfaces.  //</span>
<a name="l14116"></a>14116 <span class="comment">// On completion, point v is not deleted in this routine.                    //</span>
<a name="l14117"></a>14117 <span class="comment">//                                                                           //</span>
<a name="l14119"></a>14119 <span class="comment"></span>
<a name="l14120"></a>14120 <span class="keywordtype">void</span> tetgenmesh::unsplittetedge(triface* splittet)
<a name="l14121"></a>14121 {
<a name="l14122"></a>14122   triface *bots, *newtops;
<a name="l14123"></a>14123   triface oldtop, topcasing;
<a name="l14124"></a>14124   triface spintet;
<a name="l14125"></a>14125   face avseg, splitsh, topsh, spinsh;
<a name="l14126"></a>14126   point pa, pv, n1;
<a name="l14127"></a>14127   <span class="keywordtype">int</span> wrapcount, hitbdry;
<a name="l14128"></a>14128   <span class="keywordtype">int</span> i;
<a name="l14129"></a>14129 
<a name="l14130"></a>14130   spintet = *splittet;
<a name="l14131"></a>14131   pa = org(spintet);
<a name="l14132"></a>14132   pv = dest(spintet);
<a name="l14133"></a>14133   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l14134"></a>14134     <span class="comment">// Is there a subsegment need to be unsplit together?</span>
<a name="l14135"></a>14135     tsspivot(splittet, &amp;avseg);
<a name="l14136"></a>14136     <span class="keywordflow">if</span> (avseg.sh != dummysh) {
<a name="l14137"></a>14137       <span class="comment">// The subsegment&#39;s direction should conform to &#39;splittet&#39;.</span>
<a name="l14138"></a>14138       <span class="keywordflow">if</span> (sorg(avseg) != pa) {
<a name="l14139"></a>14139         sesymself(avseg);
<a name="l14140"></a>14140       }
<a name="l14141"></a>14141     }
<a name="l14142"></a>14142   }
<a name="l14143"></a>14143 
<a name="l14144"></a>14144   n1 = apex(spintet);
<a name="l14145"></a>14145   hitbdry = 0;
<a name="l14146"></a>14146   wrapcount = 1;
<a name="l14147"></a>14147   <span class="keywordflow">if</span> (checksubfaces &amp;&amp; avseg.sh != dummysh) {
<a name="l14148"></a>14148     <span class="comment">// It may happen that some tetrahedra containing ab (a subsegment) are</span>
<a name="l14149"></a>14149     <span class="comment">//   completely disconnected with others. If it happens, use the face</span>
<a name="l14150"></a>14150     <span class="comment">//   link of ab to cross the boundary.</span>
<a name="l14151"></a>14151     <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l14152"></a>14152       <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l14153"></a>14153         <span class="comment">// Meet a boundary, walk through it.</span>
<a name="l14154"></a>14154         hitbdry ++;
<a name="l14155"></a>14155         tspivot(spintet, spinsh);
<a name="l14156"></a>14156 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14157"></a>14157 <span class="preprocessor"></span>        assert(spinsh.sh != dummysh);
<a name="l14158"></a>14158 <span class="preprocessor">#endif</span>
<a name="l14159"></a>14159 <span class="preprocessor"></span>        findedge(&amp;spinsh, pa, pv);
<a name="l14160"></a>14160         sfnextself(spinsh);
<a name="l14161"></a>14161         stpivot(spinsh, spintet);
<a name="l14162"></a>14162 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14163"></a>14163 <span class="preprocessor"></span>        assert(spintet.tet != dummytet);
<a name="l14164"></a>14164 <span class="preprocessor">#endif</span>
<a name="l14165"></a>14165 <span class="preprocessor"></span>        findedge(&amp;spintet, pa, pv);
<a name="l14166"></a>14166         <span class="comment">// Remember this position (hull face) in &#39;splittet&#39;.</span>
<a name="l14167"></a>14167         *splittet = spintet;
<a name="l14168"></a>14168         <span class="comment">// Split two hull faces increase the hull size;</span>
<a name="l14169"></a>14169         hullsize += 2;
<a name="l14170"></a>14170       }
<a name="l14171"></a>14171       <span class="keywordflow">if</span> (apex(spintet) == n1) <span class="keywordflow">break</span>;
<a name="l14172"></a>14172       wrapcount ++;
<a name="l14173"></a>14173     }
<a name="l14174"></a>14174     <span class="keywordflow">if</span> (hitbdry &gt; 0) {
<a name="l14175"></a>14175       wrapcount -= hitbdry;
<a name="l14176"></a>14176     }
<a name="l14177"></a>14177   } <span class="keywordflow">else</span> {
<a name="l14178"></a>14178     <span class="comment">// All the tetrahedra containing ab are connected together. If there</span>
<a name="l14179"></a>14179     <span class="comment">//   are subfaces, &#39;splitsh&#39; keeps one of them.</span>
<a name="l14180"></a>14180     splitsh.sh = dummysh;
<a name="l14181"></a>14181     <span class="keywordflow">while</span> (hitbdry &lt; 2) {
<a name="l14182"></a>14182       <span class="keywordflow">if</span> (checksubfaces &amp;&amp; splitsh.sh == dummysh) {
<a name="l14183"></a>14183         tspivot(spintet, splitsh);
<a name="l14184"></a>14184       }
<a name="l14185"></a>14185       <span class="keywordflow">if</span> (fnextself(spintet)) {
<a name="l14186"></a>14186         <span class="keywordflow">if</span> (apex(spintet) == n1) <span class="keywordflow">break</span>;
<a name="l14187"></a>14187         wrapcount++;
<a name="l14188"></a>14188       } <span class="keywordflow">else</span> {
<a name="l14189"></a>14189         hitbdry ++;
<a name="l14190"></a>14190         <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l14191"></a>14191           esym(*splittet, spintet);
<a name="l14192"></a>14192         }
<a name="l14193"></a>14193       }
<a name="l14194"></a>14194     }
<a name="l14195"></a>14195     <span class="keywordflow">if</span> (hitbdry &gt; 0) {
<a name="l14196"></a>14196       <span class="comment">// ab is on the hull.</span>
<a name="l14197"></a>14197       wrapcount -= 1;
<a name="l14198"></a>14198       <span class="comment">// &#39;spintet&#39; now is a hull face, inverse its edge direction.</span>
<a name="l14199"></a>14199       esym(spintet, *splittet);
<a name="l14200"></a>14200       <span class="comment">// Split two hull faces increases the number of hull faces.</span>
<a name="l14201"></a>14201       hullsize += 2;
<a name="l14202"></a>14202     }
<a name="l14203"></a>14203   }
<a name="l14204"></a>14204 
<a name="l14205"></a>14205   <span class="comment">// Make arrays of updating (bot, oldtop) and new (newtop) tetrahedra.</span>
<a name="l14206"></a>14206   bots = <span class="keyword">new</span> triface[wrapcount];
<a name="l14207"></a>14207   newtops = <span class="keyword">new</span> triface[wrapcount];
<a name="l14208"></a>14208   <span class="comment">// Spin around av, gather tetrahedra and set up new tetrahedra.</span>
<a name="l14209"></a>14209   spintet = *splittet;
<a name="l14210"></a>14210   <span class="keywordflow">for</span> (i = 0; i &lt; wrapcount; i++) {
<a name="l14211"></a>14211     <span class="comment">// Get &#39;bots[i] = an1n2v&#39;.</span>
<a name="l14212"></a>14212     enext2fnext(spintet, bots[i]);
<a name="l14213"></a>14213     esymself(bots[i]);
<a name="l14214"></a>14214     <span class="comment">// Get &#39;oldtop = n1n2va&#39;.</span>
<a name="l14215"></a>14215     enextfnext(bots[i], oldtop);
<a name="l14216"></a>14216     <span class="comment">// Get &#39;newtops[i] = &#39;bn1n2v&#39;</span>
<a name="l14217"></a>14217     fnext(oldtop, newtops[i]); <span class="comment">// newtop = n1n2bv</span>
<a name="l14218"></a>14218     esymself(newtops[i]); <span class="comment">// newtop = n2n1bv</span>
<a name="l14219"></a>14219     enext2self(newtops[i]); <span class="comment">// newtop = bn2n1v</span>
<a name="l14220"></a>14220     <span class="comment">// Go to the next.</span>
<a name="l14221"></a>14221     fnextself(spintet);
<a name="l14222"></a>14222     <span class="keywordflow">if</span> (checksubfaces &amp;&amp; avseg.sh != dummysh) {
<a name="l14223"></a>14223       <span class="keywordflow">if</span> (!issymexist(&amp;spintet)) {
<a name="l14224"></a>14224         <span class="comment">// We meet a hull face, walk through it.</span>
<a name="l14225"></a>14225         tspivot(spintet, spinsh);
<a name="l14226"></a>14226 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14227"></a>14227 <span class="preprocessor"></span>        assert(spinsh.sh != dummysh);
<a name="l14228"></a>14228 <span class="preprocessor">#endif</span>
<a name="l14229"></a>14229 <span class="preprocessor"></span>        findedge(&amp;spinsh, pa, pv);
<a name="l14230"></a>14230         sfnextself(spinsh);
<a name="l14231"></a>14231         stpivot(spinsh, spintet);
<a name="l14232"></a>14232 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14233"></a>14233 <span class="preprocessor"></span>        assert(spintet.tet != dummytet);
<a name="l14234"></a>14234 <span class="preprocessor">#endif</span>
<a name="l14235"></a>14235 <span class="preprocessor"></span>        findedge(&amp;spintet, pa, pv);
<a name="l14236"></a>14236       }
<a name="l14237"></a>14237     }
<a name="l14238"></a>14238   }
<a name="l14239"></a>14239 
<a name="l14240"></a>14240   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l14241"></a>14241     printf(<span class="stringliteral">&quot;  Removing point %d from edge (%d, %d).\n&quot;</span>,
<a name="l14242"></a>14242            pointmark(oppo(bots[0])), pointmark(org(bots[0])),
<a name="l14243"></a>14243            pointmark(org(newtops[0])));
<a name="l14244"></a>14244   }
<a name="l14245"></a>14245 
<a name="l14246"></a>14246   <span class="keywordflow">for</span> (i = 0; i &lt; wrapcount; i++) {
<a name="l14247"></a>14247     <span class="comment">// Expand an1n2v to an1n2b.</span>
<a name="l14248"></a>14248     setoppo(bots[i], org(newtops[i]));
<a name="l14249"></a>14249     <span class="comment">// Get &#39;oldtop = n1n2va&#39; from &#39;bot[i]&#39;.</span>
<a name="l14250"></a>14250     enextfnext(bots[i], oldtop);
<a name="l14251"></a>14251     <span class="comment">// Get &#39;topcasing&#39; from &#39;newtop[i]&#39;</span>
<a name="l14252"></a>14252     sym(newtops[i], topcasing);
<a name="l14253"></a>14253     <span class="comment">// Bond them.</span>
<a name="l14254"></a>14254     bond(oldtop, topcasing);
<a name="l14255"></a>14255     <span class="keywordflow">if</span> (checksubfaces) {
<a name="l14256"></a>14256       tspivot(newtops[i], topsh);
<a name="l14257"></a>14257       <span class="keywordflow">if</span> (topsh.sh != dummysh) {
<a name="l14258"></a>14258         tsbond(oldtop, topsh);
<a name="l14259"></a>14259       }
<a name="l14260"></a>14260     }
<a name="l14261"></a>14261     <span class="comment">// Delete the tetrahedron above an1n2v.</span>
<a name="l14262"></a>14262     tetrahedrondealloc(newtops[i].tet);
<a name="l14263"></a>14263   }
<a name="l14264"></a>14264 
<a name="l14265"></a>14265   <span class="comment">// If there exists any subface, unsplit them.</span>
<a name="l14266"></a>14266   <span class="keywordflow">if</span> (checksubfaces) {
<a name="l14267"></a>14267     <span class="keywordflow">if</span> (avseg.sh != dummysh) {
<a name="l14268"></a>14268       spivot(avseg, splitsh);
<a name="l14269"></a>14269 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14270"></a>14270 <span class="preprocessor"></span>      assert(splitsh.sh != dummysh);
<a name="l14271"></a>14271 <span class="preprocessor">#endif</span>
<a name="l14272"></a>14272 <span class="preprocessor"></span>    }
<a name="l14273"></a>14273     <span class="keywordflow">if</span> (splitsh.sh != dummysh) {
<a name="l14274"></a>14274       findedge(&amp;splitsh, pa, pv);
<a name="l14275"></a>14275       unsplitsubedge(&amp;splitsh);
<a name="l14276"></a>14276     }
<a name="l14277"></a>14277   }
<a name="l14278"></a>14278 
<a name="l14279"></a>14279   <span class="keyword">delete</span> [] bots;
<a name="l14280"></a>14280   <span class="keyword">delete</span> [] newtops;
<a name="l14281"></a>14281 }
<a name="l14282"></a>14282 
<a name="l14284"></a>14284 <span class="comment">//                                                                           //</span>
<a name="l14285"></a>14285 <span class="comment">// splitsubedge()    Insert a point on an edge of the surface mesh.          //</span>
<a name="l14286"></a>14286 <span class="comment">//                                                                           //</span>
<a name="l14287"></a>14287 <span class="comment">// The splitting edge is given by &#39;splitsh&#39;. Assume its three corners are a, //</span>
<a name="l14288"></a>14288 <span class="comment">// b, c, where ab is the edge will be split. ab may be a subsegment.         //</span>
<a name="l14289"></a>14289 <span class="comment">//                                                                           //</span>
<a name="l14290"></a>14290 <span class="comment">// To split edge ab is to split all subfaces conatining ab. If ab is not a   //</span>
<a name="l14291"></a>14291 <span class="comment">// subsegment, there are only two subfaces need be split, otherwise, there   //</span>
<a name="l14292"></a>14292 <span class="comment">// may have any number of subfaces need be split. Each splitting subface abc //</span>
<a name="l14293"></a>14293 <span class="comment">// is shrunk to avc, a new subface vbc is created.  It is important to keep  //</span>
<a name="l14294"></a>14294 <span class="comment">// the orientations of edge rings of avc and vbc be the same as abc&#39;s. If ab //</span>
<a name="l14295"></a>14295 <span class="comment">// is a subsegment, it is shrunk to av and a new subsegment vb is created.   //</span>
<a name="l14296"></a>14296 <span class="comment">//                                                                           //</span>
<a name="l14297"></a>14297 <span class="comment">// If there are tetrahedra adjoining to the splitting subfaces, they should  //</span>
<a name="l14298"></a>14298 <span class="comment">// be split before calling this routine, so the connection between the new   //</span>
<a name="l14299"></a>14299 <span class="comment">// tetrahedra and the new subfaces can be correctly set.                     //</span>
<a name="l14300"></a>14300 <span class="comment">//                                                                           //</span>
<a name="l14301"></a>14301 <span class="comment">// On completion, &#39;splitsh&#39; returns avc.  If &#39;flipqueue&#39; is not NULL, it     //</span>
<a name="l14302"></a>14302 <span class="comment">// returns all edges which may be non-Delaunay.                              //</span>
<a name="l14303"></a>14303 <span class="comment">//                                                                           //</span>
<a name="l14305"></a>14305 <span class="comment"></span>
<a name="l14306"></a>14306 <span class="keywordtype">void</span> tetgenmesh::splitsubedge(point newpoint, face* splitsh, queue* flipqueue)
<a name="l14307"></a>14307 {
<a name="l14308"></a>14308   triface abcd, bace, vbcd, bvce;
<a name="l14309"></a>14309   face startabc, spinabc, spinsh;
<a name="l14310"></a>14310   face oldbc, bccasin, bccasout;
<a name="l14311"></a>14311   face ab, bc;
<a name="l14312"></a>14312   face avc, vbc, vbc1;
<a name="l14313"></a>14313   face av, vb;
<a name="l14314"></a>14314   point pa, pb;
<a name="l14315"></a>14315 
<a name="l14316"></a>14316   startabc = *splitsh;
<a name="l14317"></a>14317   <span class="comment">// Is there a subsegment?</span>
<a name="l14318"></a>14318   sspivot(startabc, ab);
<a name="l14319"></a>14319   <span class="keywordflow">if</span> (ab.sh != dummysh) {
<a name="l14320"></a>14320     ab.shver = 0;
<a name="l14321"></a>14321     <span class="keywordflow">if</span> (sorg(startabc) != sorg(ab)) {
<a name="l14322"></a>14322       sesymself(startabc);
<a name="l14323"></a>14323     }
<a name="l14324"></a>14324   }
<a name="l14325"></a>14325   pa = sorg(startabc);
<a name="l14326"></a>14326   pb = sdest(startabc);
<a name="l14327"></a>14327 
<a name="l14328"></a>14328   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l14329"></a>14329     printf(<span class="stringliteral">&quot;  Inserting point %d on subedge (%d, %d) %s.\n&quot;</span>,
<a name="l14330"></a>14330            pointmark(newpoint), pointmark(pa), pointmark(pb),
<a name="l14331"></a>14331            (ab.sh != dummysh ? <span class="stringliteral">&quot;(seg)&quot;</span> : <span class="stringliteral">&quot; &quot;</span>));
<a name="l14332"></a>14332   }
<a name="l14333"></a>14333 
<a name="l14334"></a>14334   <span class="comment">// Spin arround ab, split every subface containing ab.</span>
<a name="l14335"></a>14335   spinabc = startabc;
<a name="l14336"></a>14336   <span class="keywordflow">do</span> {
<a name="l14337"></a>14337     <span class="comment">// Adjust spinabc be edge ab.</span>
<a name="l14338"></a>14338     <span class="keywordflow">if</span> (sorg(spinabc) != pa) {
<a name="l14339"></a>14339       sesymself(spinabc);
<a name="l14340"></a>14340     }
<a name="l14341"></a>14341     <span class="comment">// Save old configuration at edge bc, if bc has a subsegment, save the</span>
<a name="l14342"></a>14342     <span class="comment">//   face link of it and dissolve it from bc.</span>
<a name="l14343"></a>14343     senext(spinabc, oldbc);
<a name="l14344"></a>14344     spivot(oldbc, bccasout);
<a name="l14345"></a>14345     sspivot(oldbc, bc);
<a name="l14346"></a>14346     <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l14347"></a>14347       <span class="keywordflow">if</span> (spinabc.sh != bccasout.sh) {
<a name="l14348"></a>14348         <span class="comment">// &#39;spinabc&#39; is not self-bonded.</span>
<a name="l14349"></a>14349         spinsh = bccasout;
<a name="l14350"></a>14350         <span class="keywordflow">do</span> {
<a name="l14351"></a>14351           bccasin = spinsh;
<a name="l14352"></a>14352           spivotself(spinsh);
<a name="l14353"></a>14353         } <span class="keywordflow">while</span> (spinsh.sh != oldbc.sh);
<a name="l14354"></a>14354       } <span class="keywordflow">else</span> {
<a name="l14355"></a>14355         bccasout.sh = dummysh;
<a name="l14356"></a>14356       }
<a name="l14357"></a>14357       ssdissolve(oldbc);
<a name="l14358"></a>14358     }
<a name="l14359"></a>14359     <span class="comment">// Create a new subface.</span>
<a name="l14360"></a>14360     makeshellface(subfaces, &amp;vbc);
<a name="l14361"></a>14361     <span class="comment">// Split abc.</span>
<a name="l14362"></a>14362     avc = spinabc;  <span class="comment">// Update &#39;abc&#39; to &#39;avc&#39;.</span>
<a name="l14363"></a>14363     setsdest(avc, newpoint);
<a name="l14364"></a>14364     <span class="comment">// Make &#39;vbc&#39; be in the same edge ring as &#39;avc&#39;.</span>
<a name="l14365"></a>14365     vbc.shver = avc.shver;
<a name="l14366"></a>14366     setsorg(vbc, newpoint); <span class="comment">// Set &#39;vbc&#39;.</span>
<a name="l14367"></a>14367     setsdest(vbc, pb);
<a name="l14368"></a>14368     setsapex(vbc, sapex(avc));
<a name="l14369"></a>14369     <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l14370"></a>14370       <span class="comment">// Copy the area bound into the new subface.</span>
<a name="l14371"></a>14371       setareabound(vbc, areabound(avc));
<a name="l14372"></a>14372     }
<a name="l14373"></a>14373     <span class="comment">// Copy the shell marker and shell type into the new subface.</span>
<a name="l14374"></a>14374     setshellmark(vbc, shellmark(avc));
<a name="l14375"></a>14375     setshelltype(vbc, shelltype(avc));
<a name="l14376"></a>14376     <span class="keywordflow">if</span> (checkpbcs) {
<a name="l14377"></a>14377       <span class="comment">// Copy the pbcgroup into the new subface.</span>
<a name="l14378"></a>14378       setshellpbcgroup(vbc, shellpbcgroup(avc));
<a name="l14379"></a>14379     }
<a name="l14380"></a>14380     <span class="comment">// Set the connection between updated and new subfaces.</span>
<a name="l14381"></a>14381     senext2self(vbc);
<a name="l14382"></a>14382     sbond(vbc, oldbc);
<a name="l14383"></a>14383     <span class="comment">// Set the connection between new subface and casings.</span>
<a name="l14384"></a>14384     senext2self(vbc);
<a name="l14385"></a>14385     <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l14386"></a>14386       <span class="keywordflow">if</span> (bccasout.sh != dummysh) {
<a name="l14387"></a>14387         <span class="comment">// Insert &#39;vbc&#39; into face link.</span>
<a name="l14388"></a>14388         sbond1(bccasin, vbc);
<a name="l14389"></a>14389         sbond1(vbc, bccasout);
<a name="l14390"></a>14390       } <span class="keywordflow">else</span> {
<a name="l14391"></a>14391         <span class="comment">// Bond &#39;vbc&#39; to itself.</span>
<a name="l14392"></a>14392         sbond(vbc, vbc);
<a name="l14393"></a>14393       }
<a name="l14394"></a>14394       ssbond(vbc, bc);
<a name="l14395"></a>14395     } <span class="keywordflow">else</span> {
<a name="l14396"></a>14396       sbond(vbc, bccasout);
<a name="l14397"></a>14397     }
<a name="l14398"></a>14398     <span class="comment">// Go to next subface at edge ab.</span>
<a name="l14399"></a>14399     spivotself(spinabc);
<a name="l14400"></a>14400     <span class="keywordflow">if</span> (spinabc.sh == dummysh) {
<a name="l14401"></a>14401       <span class="keywordflow">break</span>; <span class="comment">// &#39;ab&#39; is a hull edge.</span>
<a name="l14402"></a>14402     }
<a name="l14403"></a>14403   } <span class="keywordflow">while</span> (spinabc.sh != startabc.sh);
<a name="l14404"></a>14404 
<a name="l14405"></a>14405   <span class="comment">// Get the new subface vbc above the updated subface avc (= startabc).</span>
<a name="l14406"></a>14406   senext(startabc, oldbc);
<a name="l14407"></a>14407   spivot(oldbc, vbc);
<a name="l14408"></a>14408   <span class="keywordflow">if</span> (sorg(vbc) == newpoint) {
<a name="l14409"></a>14409     sesymself(vbc);
<a name="l14410"></a>14410   }
<a name="l14411"></a>14411 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14412"></a>14412 <span class="preprocessor"></span>  assert(sorg(vbc) == sdest(oldbc) &amp;&amp; sdest(vbc) == sorg(oldbc));
<a name="l14413"></a>14413 <span class="preprocessor">#endif</span>
<a name="l14414"></a>14414 <span class="preprocessor"></span>  senextself(vbc);
<a name="l14415"></a>14415   <span class="comment">// Set the face link for the new created subfaces around edge vb.</span>
<a name="l14416"></a>14416   spinabc = startabc;
<a name="l14417"></a>14417   <span class="keywordflow">do</span> {
<a name="l14418"></a>14418     <span class="comment">// Go to the next subface at edge av.</span>
<a name="l14419"></a>14419     spivotself(spinabc);
<a name="l14420"></a>14420     <span class="keywordflow">if</span> (spinabc.sh == dummysh) {
<a name="l14421"></a>14421       <span class="keywordflow">break</span>; <span class="comment">// &#39;ab&#39; is a hull edge.</span>
<a name="l14422"></a>14422     }
<a name="l14423"></a>14423     <span class="keywordflow">if</span> (sorg(spinabc) != pa) {
<a name="l14424"></a>14424       sesymself(spinabc);
<a name="l14425"></a>14425     }
<a name="l14426"></a>14426     <span class="comment">// Get the new subface vbc1 above the updated subface avc (= spinabc).</span>
<a name="l14427"></a>14427     senext(spinabc, oldbc);
<a name="l14428"></a>14428     spivot(oldbc, vbc1);
<a name="l14429"></a>14429     <span class="keywordflow">if</span> (sorg(vbc1) == newpoint) {
<a name="l14430"></a>14430       sesymself(vbc1);
<a name="l14431"></a>14431     }
<a name="l14432"></a>14432 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14433"></a>14433 <span class="preprocessor"></span>    assert(sorg(vbc1) == sdest(oldbc) &amp;&amp; sdest(vbc1) == sorg(oldbc));
<a name="l14434"></a>14434 <span class="preprocessor">#endif</span>
<a name="l14435"></a>14435 <span class="preprocessor"></span>    senextself(vbc1);
<a name="l14436"></a>14436     <span class="comment">// Set the connection: vbc-&gt;vbc1.</span>
<a name="l14437"></a>14437     sbond1(vbc, vbc1);
<a name="l14438"></a>14438     <span class="comment">// For the next connection.</span>
<a name="l14439"></a>14439     vbc = vbc1;
<a name="l14440"></a>14440   } <span class="keywordflow">while</span> (spinabc.sh != startabc.sh);
<a name="l14441"></a>14441 
<a name="l14442"></a>14442   <span class="comment">// Split ab if it is a subsegment.</span>
<a name="l14443"></a>14443   <span class="keywordflow">if</span> (ab.sh != dummysh) {
<a name="l14444"></a>14444     <span class="comment">// Update subsegment ab to av.</span>
<a name="l14445"></a>14445     av = ab;
<a name="l14446"></a>14446     setsdest(av, newpoint);
<a name="l14447"></a>14447     <span class="comment">// Create a new subsegment vb.</span>
<a name="l14448"></a>14448     makeshellface(subsegs, &amp;vb);
<a name="l14449"></a>14449     setsorg(vb, newpoint);
<a name="l14450"></a>14450     setsdest(vb, pb);
<a name="l14451"></a>14451     <span class="comment">// vb gets the same mark and segment type as av.</span>
<a name="l14452"></a>14452     setshellmark(vb, shellmark(av));
<a name="l14453"></a>14453     setshelltype(vb, shelltype(av));
<a name="l14454"></a>14454     <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l14455"></a>14455       <span class="comment">// Copy the area bound into the new subsegment.</span>
<a name="l14456"></a>14456       setareabound(vb, areabound(av));
<a name="l14457"></a>14457     }
<a name="l14458"></a>14458     <span class="comment">// Save the old connection at ab (re-use the handles oldbc, bccasout).</span>
<a name="l14459"></a>14459     senext(av, oldbc);
<a name="l14460"></a>14460     spivot(oldbc, bccasout);
<a name="l14461"></a>14461     <span class="comment">// Bond av and vb (bonded at their &quot;fake&quot; edges).</span>
<a name="l14462"></a>14462     senext2(vb, bccasin);
<a name="l14463"></a>14463     sbond(bccasin, oldbc);
<a name="l14464"></a>14464     <span class="keywordflow">if</span> (bccasout.sh != dummysh) {
<a name="l14465"></a>14465       <span class="comment">// There is a subsegment connecting with ab at b. It will connect</span>
<a name="l14466"></a>14466       <span class="comment">//   to vb at b after splitting.</span>
<a name="l14467"></a>14467       bccasout.shver = 0;
<a name="l14468"></a>14468       <span class="keywordflow">if</span> (sorg(bccasout) != pb) sesymself(bccasout);
<a name="l14469"></a>14469 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14470"></a>14470 <span class="preprocessor"></span>      assert(sorg(bccasout) == pb);
<a name="l14471"></a>14471 <span class="preprocessor">#endif</span>
<a name="l14472"></a>14472 <span class="preprocessor"></span>      senext2self(bccasout);
<a name="l14473"></a>14473       senext(vb, bccasin);
<a name="l14474"></a>14474       sbond(bccasin, bccasout);
<a name="l14475"></a>14475     }
<a name="l14476"></a>14476     <span class="comment">// Bond all new subfaces (vbc) to vb.</span>
<a name="l14477"></a>14477     spinabc = startabc;
<a name="l14478"></a>14478     <span class="keywordflow">do</span> {
<a name="l14479"></a>14479       <span class="comment">// Adjust spinabc be edge av.</span>
<a name="l14480"></a>14480       <span class="keywordflow">if</span> (sorg(spinabc) != pa) {
<a name="l14481"></a>14481         sesymself(spinabc);
<a name="l14482"></a>14482       }
<a name="l14483"></a>14483       <span class="comment">// Get new subface vbc above the updated subface avc (= spinabc).</span>
<a name="l14484"></a>14484       senext(spinabc, oldbc);
<a name="l14485"></a>14485       spivot(oldbc, vbc);
<a name="l14486"></a>14486       <span class="keywordflow">if</span> (sorg(vbc) == newpoint) {
<a name="l14487"></a>14487         sesymself(vbc);
<a name="l14488"></a>14488       }
<a name="l14489"></a>14489       senextself(vbc);
<a name="l14490"></a>14490       <span class="comment">// Bond the new subface and the new subsegment.</span>
<a name="l14491"></a>14491       ssbond(vbc, vb);
<a name="l14492"></a>14492       <span class="comment">// Go to the next.</span>
<a name="l14493"></a>14493       spivotself(spinabc);
<a name="l14494"></a>14494 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14495"></a>14495 <span class="preprocessor"></span>      assert(spinabc.sh != dummysh);
<a name="l14496"></a>14496 <span class="preprocessor">#endif</span>
<a name="l14497"></a>14497 <span class="preprocessor"></span>    } <span class="keywordflow">while</span> (spinabc.sh != startabc.sh);
<a name="l14498"></a>14498   }
<a name="l14499"></a>14499 
<a name="l14500"></a>14500   <span class="comment">// Bond the new subfaces to new tetrahedra if they exist.  New tetrahedra</span>
<a name="l14501"></a>14501   <span class="comment">//   should have been created before calling this routine.</span>
<a name="l14502"></a>14502   spinabc = startabc;
<a name="l14503"></a>14503   <span class="keywordflow">do</span> {
<a name="l14504"></a>14504     <span class="comment">// Adjust spinabc be edge av.</span>
<a name="l14505"></a>14505     <span class="keywordflow">if</span> (sorg(spinabc) != pa) {
<a name="l14506"></a>14506       sesymself(spinabc);
<a name="l14507"></a>14507     }
<a name="l14508"></a>14508     <span class="comment">// Get new subface vbc above the updated subface avc (= spinabc).</span>
<a name="l14509"></a>14509     senext(spinabc, oldbc);
<a name="l14510"></a>14510     spivot(oldbc, vbc);
<a name="l14511"></a>14511     <span class="keywordflow">if</span> (sorg(vbc) == newpoint) {
<a name="l14512"></a>14512       sesymself(vbc);
<a name="l14513"></a>14513     }
<a name="l14514"></a>14514     senextself(vbc);
<a name="l14515"></a>14515     <span class="comment">// Get the adjacent tetrahedra at &#39;spinabc&#39;.</span>
<a name="l14516"></a>14516     stpivot(spinabc, abcd);
<a name="l14517"></a>14517     <span class="keywordflow">if</span> (abcd.tet != dummytet) {
<a name="l14518"></a>14518       findedge(&amp;abcd, sorg(spinabc), sdest(spinabc));
<a name="l14519"></a>14519       enextfnext(abcd, vbcd);
<a name="l14520"></a>14520       fnextself(vbcd);
<a name="l14521"></a>14521 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14522"></a>14522 <span class="preprocessor"></span>      assert(vbcd.tet != dummytet);
<a name="l14523"></a>14523 <span class="preprocessor">#endif</span>
<a name="l14524"></a>14524 <span class="preprocessor"></span>      tsbond(vbcd, vbc);
<a name="l14525"></a>14525       sym(vbcd, bvce);
<a name="l14526"></a>14526       sesymself(vbc);
<a name="l14527"></a>14527       tsbond(bvce, vbc);
<a name="l14528"></a>14528     } <span class="keywordflow">else</span> {
<a name="l14529"></a>14529       <span class="comment">// One side is empty, check the other side.</span>
<a name="l14530"></a>14530       sesymself(spinabc);
<a name="l14531"></a>14531       stpivot(spinabc, bace);
<a name="l14532"></a>14532       <span class="keywordflow">if</span> (bace.tet != dummytet) {
<a name="l14533"></a>14533         findedge(&amp;bace, sorg(spinabc), sdest(spinabc));
<a name="l14534"></a>14534         enext2fnext(bace, bvce);
<a name="l14535"></a>14535         fnextself(bvce);
<a name="l14536"></a>14536 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14537"></a>14537 <span class="preprocessor"></span>        assert(bvce.tet != dummytet);
<a name="l14538"></a>14538 <span class="preprocessor">#endif</span>
<a name="l14539"></a>14539 <span class="preprocessor"></span>        sesymself(vbc);
<a name="l14540"></a>14540         tsbond(bvce, vbc);
<a name="l14541"></a>14541       }
<a name="l14542"></a>14542     }
<a name="l14543"></a>14543     <span class="comment">// Go to the next.</span>
<a name="l14544"></a>14544     spivotself(spinabc);
<a name="l14545"></a>14545     <span class="keywordflow">if</span> (spinabc.sh == dummysh) {
<a name="l14546"></a>14546       <span class="keywordflow">break</span>; <span class="comment">// &#39;ab&#39; is a hull edge.</span>
<a name="l14547"></a>14547     }
<a name="l14548"></a>14548   } <span class="keywordflow">while</span> (spinabc.sh != startabc.sh);
<a name="l14549"></a>14549 
<a name="l14550"></a>14550   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l14551"></a>14551     spinabc = startabc;
<a name="l14552"></a>14552     <span class="keywordflow">do</span> {
<a name="l14553"></a>14553       <span class="comment">// Adjust spinabc be edge av.</span>
<a name="l14554"></a>14554       <span class="keywordflow">if</span> (sorg(spinabc) != pa) {
<a name="l14555"></a>14555         sesymself(spinabc);
<a name="l14556"></a>14556       }
<a name="l14557"></a>14557       printf(<span class="stringliteral">&quot;    Updating abc:\n&quot;</span>);
<a name="l14558"></a>14558       printsh(&amp;spinabc);
<a name="l14559"></a>14559       <span class="comment">// Get new subface vbc above the updated subface avc (= spinabc).</span>
<a name="l14560"></a>14560       senext(spinabc, oldbc);
<a name="l14561"></a>14561       spivot(oldbc, vbc);
<a name="l14562"></a>14562       <span class="keywordflow">if</span> (sorg(vbc) == newpoint) {
<a name="l14563"></a>14563         sesymself(vbc);
<a name="l14564"></a>14564       }
<a name="l14565"></a>14565       senextself(vbc);
<a name="l14566"></a>14566       printf(<span class="stringliteral">&quot;    Creating vbc:\n&quot;</span>);
<a name="l14567"></a>14567       printsh(&amp;vbc);
<a name="l14568"></a>14568       <span class="comment">// Go to the next.</span>
<a name="l14569"></a>14569       spivotself(spinabc);
<a name="l14570"></a>14570       <span class="keywordflow">if</span> (spinabc.sh == dummysh) {
<a name="l14571"></a>14571         <span class="keywordflow">break</span>; <span class="comment">// &#39;ab&#39; is a hull edge.</span>
<a name="l14572"></a>14572       }
<a name="l14573"></a>14573     } <span class="keywordflow">while</span> (spinabc.sh != startabc.sh);
<a name="l14574"></a>14574   }
<a name="l14575"></a>14575 
<a name="l14576"></a>14576   <span class="keywordflow">if</span> (flipqueue != (queue *) NULL) {
<a name="l14577"></a>14577     spinabc = startabc;
<a name="l14578"></a>14578     <span class="keywordflow">do</span> {
<a name="l14579"></a>14579       <span class="comment">// Adjust spinabc be edge av.</span>
<a name="l14580"></a>14580       <span class="keywordflow">if</span> (sorg(spinabc) != pa) {
<a name="l14581"></a>14581         sesymself(spinabc);
<a name="l14582"></a>14582       }
<a name="l14583"></a>14583       senext2(spinabc, oldbc); <span class="comment">// Re-use oldbc.</span>
<a name="l14584"></a>14584       enqueueflipedge(oldbc, flipqueue);
<a name="l14585"></a>14585       <span class="comment">// Get new subface vbc above the updated subface avc (= spinabc).</span>
<a name="l14586"></a>14586       senext(spinabc, oldbc);
<a name="l14587"></a>14587       spivot(oldbc, vbc);
<a name="l14588"></a>14588       <span class="keywordflow">if</span> (sorg(vbc) == newpoint) {
<a name="l14589"></a>14589         sesymself(vbc);
<a name="l14590"></a>14590       }
<a name="l14591"></a>14591       senextself(vbc);
<a name="l14592"></a>14592       senext(vbc, oldbc); <span class="comment">// Re-use oldbc.</span>
<a name="l14593"></a>14593       enqueueflipedge(oldbc, flipqueue);
<a name="l14594"></a>14594       <span class="comment">// Go to the next.</span>
<a name="l14595"></a>14595       spivotself(spinabc);
<a name="l14596"></a>14596       <span class="keywordflow">if</span> (spinabc.sh == dummysh) {
<a name="l14597"></a>14597         <span class="keywordflow">break</span>; <span class="comment">// &#39;ab&#39; is a hull edge.</span>
<a name="l14598"></a>14598       }
<a name="l14599"></a>14599     } <span class="keywordflow">while</span> (spinabc.sh != startabc.sh);
<a name="l14600"></a>14600   }
<a name="l14601"></a>14601 }
<a name="l14602"></a>14602 
<a name="l14604"></a>14604 <span class="comment">//                                                                           //</span>
<a name="l14605"></a>14605 <span class="comment">// unsplitsubedge()    Reverse the operation of splitting an edge of subface,//</span>
<a name="l14606"></a>14606 <span class="comment">//                     so as to remove a point from the edge.                //</span>
<a name="l14607"></a>14607 <span class="comment">//                                                                           //</span>
<a name="l14608"></a>14608 <span class="comment">// Assume the original edge is ab, the subface containing it is abc. It was  //</span>
<a name="l14609"></a>14609 <span class="comment">// split by a point v into avc, and vbc.  &#39;splitsh&#39; represents avc, further- //</span>
<a name="l14610"></a>14610 <span class="comment">// more, if av is a subsegment, av should be the zero version of the split   //</span>
<a name="l14611"></a>14611 <span class="comment">// subsegment (i.e., av.shver = 0), so we are sure that the destination (v)  //</span>
<a name="l14612"></a>14612 <span class="comment">// of both avc and av is the deleting point.                                 //</span>
<a name="l14613"></a>14613 <span class="comment">//                                                                           //</span>
<a name="l14614"></a>14614 <span class="comment">// To remove point v is to expand avc to abc, delete vbc, do the same for    //</span>
<a name="l14615"></a>14615 <span class="comment">// other subfaces containing av and vb. If av and vb are subsegments, expand //</span>
<a name="l14616"></a>14616 <span class="comment">// av to ab, delete vb.  On completion, point v is not deleted.              //</span>
<a name="l14617"></a>14617 <span class="comment">//                                                                           //</span>
<a name="l14619"></a>14619 <span class="comment"></span>
<a name="l14620"></a>14620 <span class="keywordtype">void</span> tetgenmesh::unsplitsubedge(face* splitsh)
<a name="l14621"></a>14621 {
<a name="l14622"></a>14622   face startavc, spinavc, spinbcv;
<a name="l14623"></a>14623   face oldvc, bccasin, bccasout, spinsh;
<a name="l14624"></a>14624   face av, vb, bc;
<a name="l14625"></a>14625   point pa, pv, pb;
<a name="l14626"></a>14626 
<a name="l14627"></a>14627   startavc = *splitsh;
<a name="l14628"></a>14628   sspivot(startavc, av);
<a name="l14629"></a>14629   <span class="keywordflow">if</span> (av.sh != dummysh) {
<a name="l14630"></a>14630     <span class="comment">// Orient the direction of subsegment to conform the subface.</span>
<a name="l14631"></a>14631     <span class="keywordflow">if</span> (sorg(av) != sorg(startavc)) {
<a name="l14632"></a>14632       sesymself(av);
<a name="l14633"></a>14633     }
<a name="l14634"></a>14634 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14635"></a>14635 <span class="preprocessor"></span>    assert(av.shver == 0);
<a name="l14636"></a>14636 <span class="preprocessor">#endif</span>
<a name="l14637"></a>14637 <span class="preprocessor"></span>  }
<a name="l14638"></a>14638   senext(startavc, oldvc);
<a name="l14639"></a>14639   spivot(oldvc, vb);  <span class="comment">// vb is subface vbc</span>
<a name="l14640"></a>14640   <span class="keywordflow">if</span> (sorg(vb) != sdest(oldvc)) {
<a name="l14641"></a>14641     sesymself(vb);
<a name="l14642"></a>14642   }
<a name="l14643"></a>14643   senextself(vb);
<a name="l14644"></a>14644   pa = sorg(startavc);
<a name="l14645"></a>14645   pv = sdest(startavc);
<a name="l14646"></a>14646   pb = sdest(vb);
<a name="l14647"></a>14647 
<a name="l14648"></a>14648   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l14649"></a>14649     printf(<span class="stringliteral">&quot;  Removing point %d from subedge (%d, %d).\n&quot;</span>,
<a name="l14650"></a>14650            pointmark(pv), pointmark(pa), pointmark(pb));
<a name="l14651"></a>14651   }
<a name="l14652"></a>14652 
<a name="l14653"></a>14653   <span class="comment">// Spin arround av, unsplit every subface containing av.</span>
<a name="l14654"></a>14654   spinavc = startavc;
<a name="l14655"></a>14655   <span class="keywordflow">do</span> {
<a name="l14656"></a>14656     <span class="comment">// Adjust spinavc be edge av.</span>
<a name="l14657"></a>14657     <span class="keywordflow">if</span> (sorg(spinavc) != pa) {
<a name="l14658"></a>14658       sesymself(spinavc);
<a name="l14659"></a>14659     }
<a name="l14660"></a>14660     <span class="comment">// Save old configuration at edge bc, if bc has a subsegment, save the</span>
<a name="l14661"></a>14661     <span class="comment">//   face link of it.</span>
<a name="l14662"></a>14662     senext(spinavc, oldvc);
<a name="l14663"></a>14663     spivot(oldvc, spinbcv);
<a name="l14664"></a>14664     <span class="keywordflow">if</span> (sorg(spinbcv) != sdest(oldvc)) {
<a name="l14665"></a>14665       sesymself(spinbcv);
<a name="l14666"></a>14666     }
<a name="l14667"></a>14667     senext2self(spinbcv);
<a name="l14668"></a>14668     spivot(spinbcv, bccasout);
<a name="l14669"></a>14669     sspivot(spinbcv, bc);
<a name="l14670"></a>14670     <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l14671"></a>14671       <span class="keywordflow">if</span> (spinbcv.sh != bccasout.sh) {
<a name="l14672"></a>14672         <span class="comment">// &#39;spinbcv&#39; is not self-bonded.</span>
<a name="l14673"></a>14673         spinsh = bccasout;
<a name="l14674"></a>14674         <span class="keywordflow">do</span> {
<a name="l14675"></a>14675           bccasin = spinsh;
<a name="l14676"></a>14676           spivotself(spinsh);
<a name="l14677"></a>14677         } <span class="keywordflow">while</span> (spinsh.sh != spinbcv.sh);
<a name="l14678"></a>14678       } <span class="keywordflow">else</span> {
<a name="l14679"></a>14679         bccasout.sh = dummysh;
<a name="l14680"></a>14680       }
<a name="l14681"></a>14681     }
<a name="l14682"></a>14682     <span class="comment">// Expand avc to abc.</span>
<a name="l14683"></a>14683     setsdest(spinavc, pb);
<a name="l14684"></a>14684     <span class="keywordflow">if</span> (bc.sh != dummysh) {
<a name="l14685"></a>14685       <span class="keywordflow">if</span> (bccasout.sh != dummysh) {
<a name="l14686"></a>14686         sbond1(bccasin, oldvc);
<a name="l14687"></a>14687         sbond1(oldvc, bccasout);
<a name="l14688"></a>14688       } <span class="keywordflow">else</span> {
<a name="l14689"></a>14689         <span class="comment">// Bond &#39;oldbc&#39; to itself.</span>
<a name="l14690"></a>14690         sbond(oldvc, oldvc);
<a name="l14691"></a>14691       }
<a name="l14692"></a>14692       ssbond(oldvc, bc);
<a name="l14693"></a>14693     } <span class="keywordflow">else</span> {
<a name="l14694"></a>14694       sbond(oldvc, bccasout);
<a name="l14695"></a>14695     }
<a name="l14696"></a>14696     <span class="comment">// Delete bcv.</span>
<a name="l14697"></a>14697     shellfacedealloc(subfaces, spinbcv.sh);
<a name="l14698"></a>14698     <span class="comment">// Go to next subface at edge av.</span>
<a name="l14699"></a>14699     spivotself(spinavc);
<a name="l14700"></a>14700     <span class="keywordflow">if</span> (spinavc.sh == dummysh) {
<a name="l14701"></a>14701       <span class="keywordflow">break</span>; <span class="comment">// &#39;av&#39; is a hull edge.</span>
<a name="l14702"></a>14702     }
<a name="l14703"></a>14703   } <span class="keywordflow">while</span> (spinavc.sh != startavc.sh);
<a name="l14704"></a>14704 
<a name="l14705"></a>14705   <span class="comment">// Is there a subsegment need to be unsplit?</span>
<a name="l14706"></a>14706   <span class="keywordflow">if</span> (av.sh != dummysh) {
<a name="l14707"></a>14707     senext(av, oldvc);  <span class="comment">// Re-use oldvc.</span>
<a name="l14708"></a>14708     spivot(oldvc, vb);
<a name="l14709"></a>14709     vb.shver = 0;
<a name="l14710"></a>14710 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14711"></a>14711 <span class="preprocessor"></span>    assert(sdest(av) == sorg(vb));
<a name="l14712"></a>14712 <span class="preprocessor">#endif</span>
<a name="l14713"></a>14713 <span class="preprocessor"></span>    senext(vb, spinbcv); <span class="comment">// Re-use spinbcv.</span>
<a name="l14714"></a>14714     spivot(spinbcv, bccasout);
<a name="l14715"></a>14715     <span class="comment">// Expand av to ab.</span>
<a name="l14716"></a>14716     setsdest(av, pb);
<a name="l14717"></a>14717     sbond(oldvc, bccasout);
<a name="l14718"></a>14718     <span class="comment">// Delete vb.</span>
<a name="l14719"></a>14719     shellfacedealloc(subsegs, vb.sh);
<a name="l14720"></a>14720   }
<a name="l14721"></a>14721 }
<a name="l14722"></a>14722 
<a name="l14724"></a>14724 <span class="comment">//                                                                           //</span>
<a name="l14725"></a>14725 <span class="comment">// insertsite()    Insert a point into the mesh.                             //</span>
<a name="l14726"></a>14726 <span class="comment">//                                                                           //</span>
<a name="l14727"></a>14727 <span class="comment">// The &#39;newpoint&#39; is located.  If &#39;searchtet-&gt;tet&#39; is not NULL, the search   //</span>
<a name="l14728"></a>14728 <span class="comment">// for the containing tetrahedron begins from &#39;searchtet&#39;, otherwise, a full //</span>
<a name="l14729"></a>14729 <span class="comment">// point location procedure is called.  If &#39;newpoint&#39; is found inside a      //</span>
<a name="l14730"></a>14730 <span class="comment">// tetrahedron, the tetrahedron is split into four (by splittetrahedron());  //</span>
<a name="l14731"></a>14731 <span class="comment">// if &#39;newpoint&#39; lies on a face, the face is split into three, thereby       //</span>
<a name="l14732"></a>14732 <span class="comment">// splitting the two adjacent tetrahedra into six (by splittetface()); if    //</span>
<a name="l14733"></a>14733 <span class="comment">// &#39;newpoint&#39; lies on an edge, the edge is split into two, thereby, every    //</span>
<a name="l14734"></a>14734 <span class="comment">// tetrahedron containing this edge is split into two. If &#39;newpoint&#39; lies on //</span>
<a name="l14735"></a>14735 <span class="comment">// an existing vertex, no action is taken, and the value DUPLICATEPOINT  is  //</span>
<a name="l14736"></a>14736 <span class="comment">// returned and &#39;searchtet&#39; is set to a handle whose origin is the vertex.   //</span>
<a name="l14737"></a>14737 <span class="comment">//                                                                           //</span>
<a name="l14738"></a>14738 <span class="comment">// If &#39;flipqueue&#39; is not NULL, after &#39;newpoint&#39; is inserted, it returns all  //</span>
<a name="l14739"></a>14739 <span class="comment">// faces which may become non-Delaunay due to the newly inserted point. Flip //</span>
<a name="l14740"></a>14740 <span class="comment">// operations can be performed as necessary on them to maintain the Delaunay //</span>
<a name="l14741"></a>14741 <span class="comment">// property.                                                                 //</span>
<a name="l14742"></a>14742 <span class="comment">//                                                                           //</span>
<a name="l14744"></a>14744 <span class="comment"></span>
<a name="l14745"></a>14745 <span class="keyword">enum</span> tetgenmesh::insertsiteresult tetgenmesh::insertsite(point newpoint,
<a name="l14746"></a>14746   triface* searchtet, <span class="keywordtype">bool</span> approx, queue* flipqueue)
<a name="l14747"></a>14747 {
<a name="l14748"></a>14748   <span class="keyword">enum</span> locateresult intersect, exactloc;
<a name="l14749"></a>14749   point checkpt;
<a name="l14750"></a>14750   REAL epspp, checklen;
<a name="l14751"></a>14751   <span class="keywordtype">int</span> count;
<a name="l14752"></a>14752 
<a name="l14753"></a>14753   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l14754"></a>14754     printf(<span class="stringliteral">&quot;  Insert point to mesh: (%.12g, %.12g, %.12g) %d.\n&quot;</span>,
<a name="l14755"></a>14755            newpoint[0], newpoint[1], newpoint[2], pointmark(newpoint));
<a name="l14756"></a>14756   }
<a name="l14757"></a>14757 
<a name="l14758"></a>14758   <span class="keywordflow">if</span> (searchtet-&gt;tet == (tetrahedron *) NULL) {
<a name="l14759"></a>14759     <span class="comment">// Search for a tetrahedron containing &#39;newpoint&#39;.</span>
<a name="l14760"></a>14760     searchtet-&gt;tet = dummytet;
<a name="l14761"></a>14761     exactloc = locate(newpoint, searchtet);
<a name="l14762"></a>14762   } <span class="keywordflow">else</span> {
<a name="l14763"></a>14763     <span class="comment">// Start searching from the tetrahedron provided by the caller.</span>
<a name="l14764"></a>14764     exactloc = preciselocate(newpoint, searchtet, tetrahedrons-&gt;items);
<a name="l14765"></a>14765   }
<a name="l14766"></a>14766   intersect = exactloc;
<a name="l14767"></a>14767   <span class="keywordflow">if</span> (approx &amp;&amp; (exactloc != ONVERTEX)) {
<a name="l14768"></a>14768     <span class="comment">// Adjust the exact location to an approx. location wrt. epsilon.</span>
<a name="l14769"></a>14769     epspp = b-&gt;epsilon;
<a name="l14770"></a>14770     count = 0;
<a name="l14771"></a>14771     <span class="keywordflow">while</span> (count &lt; 16) {
<a name="l14772"></a>14772       intersect = adjustlocate(newpoint, searchtet, exactloc, epspp);
<a name="l14773"></a>14773       <span class="keywordflow">if</span> (intersect == ONVERTEX) {
<a name="l14774"></a>14774         checkpt = org(*searchtet);
<a name="l14775"></a>14775         checklen = distance(checkpt, newpoint);
<a name="l14776"></a>14776         <span class="keywordflow">if</span> (checklen / longest &gt; b-&gt;epsilon) {
<a name="l14777"></a>14777           epspp *= 1e-2;
<a name="l14778"></a>14778           count++;
<a name="l14779"></a>14779           <span class="keywordflow">continue</span>;
<a name="l14780"></a>14780         }
<a name="l14781"></a>14781       }
<a name="l14782"></a>14782       <span class="keywordflow">break</span>;
<a name="l14783"></a>14783     }
<a name="l14784"></a>14784   }
<a name="l14785"></a>14785   <span class="comment">// Keep current search state for next searching.</span>
<a name="l14786"></a>14786   recenttet = *searchtet;
<a name="l14787"></a>14787 
<a name="l14788"></a>14788   <span class="comment">// Insert the point using the right routine</span>
<a name="l14789"></a>14789   <span class="keywordflow">switch</span> (intersect) {
<a name="l14790"></a>14790   <span class="keywordflow">case</span> ONVERTEX:
<a name="l14791"></a>14791     <span class="comment">// There&#39;s already a vertex there. Return in &#39;searchtet&#39; a tetrahedron</span>
<a name="l14792"></a>14792     <span class="comment">//   whose origin is the existing vertex.</span>
<a name="l14793"></a>14793     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l14794"></a>14794       printf(<span class="stringliteral">&quot;  Not insert for duplicating point.\n&quot;</span>);
<a name="l14795"></a>14795     }
<a name="l14796"></a>14796     <span class="keywordflow">return</span> DUPLICATEPOINT;
<a name="l14797"></a>14797 
<a name="l14798"></a>14798   <span class="keywordflow">case</span> OUTSIDE:
<a name="l14799"></a>14799     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l14800"></a>14800       printf(<span class="stringliteral">&quot;  Not insert for locating outside the mesh.\n&quot;</span>);
<a name="l14801"></a>14801     }
<a name="l14802"></a>14802     <span class="keywordflow">return</span> OUTSIDEPOINT;
<a name="l14803"></a>14803 
<a name="l14804"></a>14804   <span class="keywordflow">case</span> ONEDGE:
<a name="l14805"></a>14805     <span class="comment">// &#39;newpoint&#39; falls on an edge.</span>
<a name="l14806"></a>14806     splittetedge(newpoint, searchtet, flipqueue);
<a name="l14807"></a>14807     <span class="keywordflow">return</span> SUCCESSONEDGE;
<a name="l14808"></a>14808 
<a name="l14809"></a>14809   <span class="keywordflow">case</span> ONFACE:
<a name="l14810"></a>14810     <span class="comment">// &#39;newpoint&#39; falls on a face.</span>
<a name="l14811"></a>14811     splittetface(newpoint, searchtet, flipqueue);
<a name="l14812"></a>14812     <span class="keywordflow">return</span> SUCCESSONFACE;
<a name="l14813"></a>14813 
<a name="l14814"></a>14814   <span class="keywordflow">case</span> INTETRAHEDRON:
<a name="l14815"></a>14815     <span class="comment">// &#39;newpoint&#39; falls inside a tetrahedron.</span>
<a name="l14816"></a>14816     splittetrahedron(newpoint, searchtet, flipqueue);
<a name="l14817"></a>14817     <span class="keywordflow">return</span> SUCCESSINTET;
<a name="l14818"></a>14818 
<a name="l14819"></a>14819   <span class="keywordflow">default</span>:
<a name="l14820"></a>14820     <span class="comment">// Impossible case.</span>
<a name="l14821"></a>14821     <span class="keywordflow">return</span> OUTSIDEPOINT;
<a name="l14822"></a>14822   }
<a name="l14823"></a>14823 }
<a name="l14824"></a>14824 
<a name="l14826"></a>14826 <span class="comment">//                                                                           //</span>
<a name="l14827"></a>14827 <span class="comment">// undosite()    Undo the most recently point insertion.                     //</span>
<a name="l14828"></a>14828 <span class="comment">//                                                                           //</span>
<a name="l14829"></a>14829 <span class="comment">// &#39;insresult&#39; indicates in where the newpoint has been inserted, i.e., in a //</span>
<a name="l14830"></a>14830 <span class="comment">// tetrahedron, on a face, or on an edge.  A correspoding routine will be    //</span>
<a name="l14831"></a>14831 <span class="comment">// called to undo the point insertion.  &#39;splittet&#39; is a handle represent one //</span>
<a name="l14832"></a>14832 <span class="comment">// of the resulting tetrahedra, but it may be changed after transformation,  //</span>
<a name="l14833"></a>14833 <span class="comment">// even may be dead.  Four points &#39;torg&#39;, ... &#39;toppo&#39; are the corners which  //</span>
<a name="l14834"></a>14834 <span class="comment">// &#39;splittet&#39; should have. On finish, &#39;newpoint&#39; is not removed.             //</span>
<a name="l14835"></a>14835 <span class="comment">//                                                                           //</span>
<a name="l14837"></a>14837 <span class="comment"></span>
<a name="l14838"></a>14838 <span class="keywordtype">void</span> tetgenmesh::undosite(<span class="keyword">enum</span> insertsiteresult insresult, triface* splittet,
<a name="l14839"></a>14839   point torg, point tdest, point tapex, point toppo)
<a name="l14840"></a>14840 {
<a name="l14841"></a>14841   <span class="comment">// Set the four corners of &#39;splittet&#39; exactly be &#39;torg&#39;, ... &#39;toppo&#39;.</span>
<a name="l14842"></a>14842   findface(splittet, torg, tdest, tapex);
<a name="l14843"></a>14843   <span class="keywordflow">if</span> (oppo(*splittet) != toppo) {
<a name="l14844"></a>14844     symself(*splittet);
<a name="l14845"></a>14845 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l14846"></a>14846 <span class="preprocessor"></span>    assert(oppo(*splittet) == toppo);
<a name="l14847"></a>14847 <span class="preprocessor">#endif</span>
<a name="l14848"></a>14848 <span class="preprocessor"></span>    <span class="comment">// The sym() operation may inverse the edge, correct it if so.</span>
<a name="l14849"></a>14849     findedge(splittet, torg, tdest);
<a name="l14850"></a>14850   }
<a name="l14851"></a>14851 
<a name="l14852"></a>14852   <span class="comment">// Unsplit the tetrahedron according to &#39;insresult&#39;.</span>
<a name="l14853"></a>14853   <span class="keywordflow">switch</span> (insresult) {
<a name="l14854"></a>14854   <span class="keywordflow">case</span> SUCCESSINTET:
<a name="l14855"></a>14855     <span class="comment">// &#39;splittet&#39; should be the face with &#39;newpoint&#39; as its opposite.</span>
<a name="l14856"></a>14856     unsplittetrahedron(splittet);
<a name="l14857"></a>14857     <span class="keywordflow">break</span>;
<a name="l14858"></a>14858   <span class="keywordflow">case</span> SUCCESSONFACE:
<a name="l14859"></a>14859     <span class="comment">// &#39;splittet&#39; should be the one of three splitted face with &#39;newpoint&#39;</span>
<a name="l14860"></a>14860     <span class="comment">//   as its apex.</span>
<a name="l14861"></a>14861     unsplittetface(splittet);
<a name="l14862"></a>14862     <span class="keywordflow">break</span>;
<a name="l14863"></a>14863   <span class="keywordflow">case</span> SUCCESSONEDGE:
<a name="l14864"></a>14864     <span class="comment">// &#39;splittet&#39; should be the tet with destination is &#39;newpoint&#39;.</span>
<a name="l14865"></a>14865     unsplittetedge(splittet);
<a name="l14866"></a>14866     <span class="keywordflow">break</span>;
<a name="l14867"></a>14867   <span class="keywordflow">default</span>: <span class="comment">// To omit compile warnings.</span>
<a name="l14868"></a>14868     <span class="keywordflow">break</span>;
<a name="l14869"></a>14869   }
<a name="l14870"></a>14870 }
<a name="l14871"></a>14871 
<a name="l14873"></a>14873 <span class="comment">//                                                                           //</span>
<a name="l14874"></a>14874 <span class="comment">// closeopenface()    Close &quot;open&quot; faces recursively.                        //</span>
<a name="l14875"></a>14875 <span class="comment">//                                                                           //</span>
<a name="l14876"></a>14876 <span class="comment">// This is the support routine of inserthullsite(). A point p which lies out-//</span>
<a name="l14877"></a>14877 <span class="comment">// side of CH(T). p is inserted to T by forming a tet t from p and a visible //</span>
<a name="l14878"></a>14878 <span class="comment">// CH face f. The three sides of f which have p as a vertex is called &quot;open&quot; //</span>
<a name="l14879"></a>14879 <span class="comment">// face. Each open face will be closed by either creating a tet on top of it //</span>
<a name="l14880"></a>14880 <span class="comment">// or become a new CH face.                                                  //</span>
<a name="l14881"></a>14881 <span class="comment">//                                                                           //</span>
<a name="l14883"></a>14883 <span class="comment"></span>
<a name="l14884"></a>14884 <span class="keywordtype">void</span> tetgenmesh::closeopenface(triface* openface, queue* flipque)
<a name="l14885"></a>14885 {
<a name="l14886"></a>14886   triface newtet, oldhull;
<a name="l14887"></a>14887   triface newopenface, closeface;
<a name="l14888"></a>14888   point inspoint, pa, pb, pc;
<a name="l14889"></a>14889   REAL attrib, volume;
<a name="l14890"></a>14890   <span class="keywordtype">int</span> i;
<a name="l14891"></a>14891 
<a name="l14892"></a>14892   <span class="comment">// Get the new point p.</span>
<a name="l14893"></a>14893   inspoint = apex(*openface);
<a name="l14894"></a>14894   <span class="comment">// Find the old CH face f_o (f and f_o share the same edge).</span>
<a name="l14895"></a>14895   esym(*openface, oldhull);
<a name="l14896"></a>14896   <span class="keywordflow">while</span> (fnextself(oldhull)) ;
<a name="l14897"></a>14897   <span class="keywordflow">if</span> (apex(oldhull) != inspoint) {
<a name="l14898"></a>14898     <span class="comment">// Is f_o visible by p?</span>
<a name="l14899"></a>14899     pa = org(oldhull);
<a name="l14900"></a>14900     pb = dest(oldhull);
<a name="l14901"></a>14901     pc = apex(oldhull);
<a name="l14902"></a>14902     <span class="keywordflow">if</span> (orient3d(pa, pb, pc, inspoint) &lt; 0.0) {
<a name="l14903"></a>14903       <span class="comment">// Yes. Create a new tet t above f_o.</span>
<a name="l14904"></a>14904       maketetrahedron(&amp;newtet);
<a name="l14905"></a>14905       setorg(newtet, pa);
<a name="l14906"></a>14906       setdest(newtet, pb);
<a name="l14907"></a>14907       setapex(newtet, pc);
<a name="l14908"></a>14908       setoppo(newtet, inspoint);
<a name="l14909"></a>14909       <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l14910"></a>14910         attrib = elemattribute(oldhull.tet, i);
<a name="l14911"></a>14911         setelemattribute(newtet.tet, i, attrib);
<a name="l14912"></a>14912       }
<a name="l14913"></a>14913       <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l14914"></a>14914         volume = volumebound(oldhull.tet);
<a name="l14915"></a>14915         setvolumebound(newtet.tet, volume);
<a name="l14916"></a>14916       }
<a name="l14917"></a>14917       <span class="comment">// Connect t to T.</span>
<a name="l14918"></a>14918       bond(newtet, oldhull);
<a name="l14919"></a>14919       <span class="comment">// Close f.</span>
<a name="l14920"></a>14920       fnext(newtet, newopenface);
<a name="l14921"></a>14921       bond(newopenface, *openface);
<a name="l14922"></a>14922       <span class="comment">// f_o becomes an interior face.</span>
<a name="l14923"></a>14923       enqueueflipface(oldhull, flipque);
<a name="l14924"></a>14924       <span class="comment">// Hull face number decreases.</span>
<a name="l14925"></a>14925       hullsize--;
<a name="l14926"></a>14926       <span class="comment">// Two faces of t become open face.</span>
<a name="l14927"></a>14927       enextself(newtet);
<a name="l14928"></a>14928       <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l14929"></a>14929         fnext(newtet, newopenface);
<a name="l14930"></a>14930         sym(newopenface, closeface);
<a name="l14931"></a>14931         <span class="keywordflow">if</span> (closeface.tet == dummytet) {
<a name="l14932"></a>14932           closeopenface(&amp;newopenface, flipque);
<a name="l14933"></a>14933         }
<a name="l14934"></a>14934         enextself(newtet);
<a name="l14935"></a>14935       }
<a name="l14936"></a>14936     } <span class="keywordflow">else</span> {
<a name="l14937"></a>14937       <span class="comment">// Inivisible. f becomes a new CH face.</span>
<a name="l14938"></a>14938       hullsize++;
<a name="l14939"></a>14939       <span class="comment">// Let &#39;dummytet&#39; holds f for the next point location.</span>
<a name="l14940"></a>14940       dummytet[0] = encode(*openface);
<a name="l14941"></a>14941     }
<a name="l14942"></a>14942   } <span class="keywordflow">else</span> {
<a name="l14943"></a>14943     <span class="comment">// f_o is co-incident with f --&gt; f is closed by f_o.</span>
<a name="l14944"></a>14944     bond(*openface, oldhull);
<a name="l14945"></a>14945     <span class="comment">// f is an interior face.</span>
<a name="l14946"></a>14946     enqueueflipface(*openface, flipque);
<a name="l14947"></a>14947   }
<a name="l14948"></a>14948 }
<a name="l14949"></a>14949 
<a name="l14951"></a>14951 <span class="comment">//                                                                           //</span>
<a name="l14952"></a>14952 <span class="comment">// inserthullsite()    Insert a point which lies outside the convex hull.    //</span>
<a name="l14953"></a>14953 <span class="comment">//                                                                           //</span>
<a name="l14954"></a>14954 <span class="comment">// The &#39;inspoint&#39; p lies outside the tetrahedralization T.  The &#39;horiz&#39; f is //</span>
<a name="l14955"></a>14955 <span class="comment">// on the convex hull of T, CH(T), which is visible by p (Imagine f is para- //</span>
<a name="l14956"></a>14956 <span class="comment">// llel to the horizon). To insert p into T we have to enlarge the CH(T) and //</span>
<a name="l14957"></a>14957 <span class="comment">// update T so that p is on the new CH(T).                                   //</span>
<a name="l14958"></a>14958 <span class="comment">//                                                                           //</span>
<a name="l14959"></a>14959 <span class="comment">// To enlarge the CH(T).  We need to find the set F of faces which are on CH //</span>
<a name="l14960"></a>14960 <span class="comment">// (T) and visible by p (F can be formed by a depth-first search from f).  p //</span>
<a name="l14961"></a>14961 <span class="comment">// is then inserted into T by mounting new tets formed by p and these faces. //</span>
<a name="l14962"></a>14962 <span class="comment">// Faces of F become interior faces and may non-locally Delaunay.  They are  //</span>
<a name="l14963"></a>14963 <span class="comment">// queued in &#39;flipqueue&#39; for flip tests.                                     //</span>
<a name="l14964"></a>14964 <span class="comment">//                                                                           //</span>
<a name="l14966"></a>14966 <span class="comment"></span>
<a name="l14967"></a>14967 <span class="keywordtype">void</span> tetgenmesh::inserthullsite(point inspoint, triface* horiz, queue* flipque)
<a name="l14968"></a>14968 {
<a name="l14969"></a>14969   triface firstnewtet;
<a name="l14970"></a>14970   triface openface, closeface;
<a name="l14971"></a>14971   REAL attrib, volume;
<a name="l14972"></a>14972   <span class="keywordtype">int</span> i;
<a name="l14973"></a>14973 
<a name="l14974"></a>14974   <span class="comment">// Let f face to p.</span>
<a name="l14975"></a>14975   adjustedgering(*horiz, CW);
<a name="l14976"></a>14976   <span class="comment">// Create the first tet t (from f and p).</span>
<a name="l14977"></a>14977   maketetrahedron(&amp;firstnewtet);
<a name="l14978"></a>14978   setorg (firstnewtet, org(*horiz));
<a name="l14979"></a>14979   setdest(firstnewtet, dest(*horiz));
<a name="l14980"></a>14980   setapex(firstnewtet, apex(*horiz));
<a name="l14981"></a>14981   setoppo(firstnewtet, inspoint);
<a name="l14982"></a>14982   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedronattributes; i++) {
<a name="l14983"></a>14983     attrib = elemattribute(horiz-&gt;tet, i);
<a name="l14984"></a>14984     setelemattribute(firstnewtet.tet, i, attrib);
<a name="l14985"></a>14985   }
<a name="l14986"></a>14986   <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l14987"></a>14987     volume = volumebound(horiz-&gt;tet);
<a name="l14988"></a>14988     setvolumebound(firstnewtet.tet, volume);
<a name="l14989"></a>14989   }
<a name="l14990"></a>14990   <span class="comment">// Connect t to T.</span>
<a name="l14991"></a>14991   bond(firstnewtet, *horiz);
<a name="l14992"></a>14992   <span class="comment">// f is not on CH(T) anymore.</span>
<a name="l14993"></a>14993   enqueueflipface(*horiz, flipque);
<a name="l14994"></a>14994   <span class="comment">// Hull face number decreases.</span>
<a name="l14995"></a>14995   hullsize--;
<a name="l14996"></a>14996 
<a name="l14997"></a>14997   <span class="comment">// Call the faces of t which have p as a vertex &quot;open&quot; face.</span>
<a name="l14998"></a>14998   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l14999"></a>14999     <span class="comment">// Get an open face f_i of t.</span>
<a name="l15000"></a>15000     fnext(firstnewtet, openface);
<a name="l15001"></a>15001     <span class="comment">// Close f_i if it is still open.</span>
<a name="l15002"></a>15002     sym(openface, closeface);
<a name="l15003"></a>15003     <span class="keywordflow">if</span> (closeface.tet == dummytet) {
<a name="l15004"></a>15004       closeopenface(&amp;openface, flipque);
<a name="l15005"></a>15005     }
<a name="l15006"></a>15006     <span class="comment">// Go to the next open face of t.</span>
<a name="l15007"></a>15007     enextself(firstnewtet);
<a name="l15008"></a>15008   }
<a name="l15009"></a>15009 }
<a name="l15010"></a>15010 
<a name="l15012"></a>15012 <span class="comment">//                                                                           //</span>
<a name="l15013"></a>15013 <span class="comment">// Terminology: BC(p) and CBC(p), B(p) and C(p).                             //</span>
<a name="l15014"></a>15014 <span class="comment">//                                                                           //</span>
<a name="l15015"></a>15015 <span class="comment">// Given an arbitrary point p,  the Bowyer-Watson cavity BC(p) is formed by  //</span>
<a name="l15016"></a>15016 <span class="comment">// tets whose circumspheres containing p.  The outer faces of BC(p) form a   //</span>
<a name="l15017"></a>15017 <span class="comment">// polyhedron B(p).                                                          //</span>
<a name="l15018"></a>15018 <span class="comment">//                                                                           //</span>
<a name="l15019"></a>15019 <span class="comment">// If p is on a facet F, the constrained Bowyer-Watson cavity CBC(p) on F is //</span>
<a name="l15020"></a>15020 <span class="comment">// formed by subfaces of F whose circumspheres containing p. The outer edges //</span>
<a name="l15021"></a>15021 <span class="comment">// of CBC(p) form a polygon C(p).  B(p) is separated into two parts by C(p), //</span>
<a name="l15022"></a>15022 <span class="comment">// denoted as B_1(p) and B_2(p), one of them may be empty (F is on the hull).//</span>
<a name="l15023"></a>15023 <span class="comment">//                                                                           //</span>
<a name="l15024"></a>15024 <span class="comment">// If p is on a segment S which is shared by n facets.  There exist n C(p)s, //</span>
<a name="l15025"></a>15025 <span class="comment">// each one is a non-closed polygon (without S). B(p) is split into n parts, //</span>
<a name="l15026"></a>15026 <span class="comment">// each of them is denoted as B_i(p), some B_i(p) may be empty.              //</span>
<a name="l15027"></a>15027 <span class="comment">//                                                                           //</span>
<a name="l15029"></a>15029 <span class="comment"></span>
<a name="l15031"></a>15031 <span class="comment">//                                                                           //</span>
<a name="l15032"></a>15032 <span class="comment">// formbowatcavitysub()    Form CBC(p) and C(p) on a facet F.                //</span>
<a name="l15033"></a>15033 <span class="comment">//                                                                           //</span>
<a name="l15034"></a>15034 <span class="comment">// Parameters: bp = p, bpseg = S, sublist = CBC(p), subceillist = C(p).      //</span>
<a name="l15035"></a>15035 <span class="comment">//                                                                           //</span>
<a name="l15036"></a>15036 <span class="comment">// CBC(p) contains at least one subface on input; S may be NULL which means  //</span>
<a name="l15037"></a>15037 <span class="comment">// that p is inside a facet. On output, all subfaces of CBC(p) are infected, //</span>
<a name="l15038"></a>15038 <span class="comment">// and the edge rings are oriented to the same halfspace.                    //</span>
<a name="l15039"></a>15039 <span class="comment">//                                                                           //</span>
<a name="l15041"></a>15041 <span class="comment"></span>
<a name="l15042"></a>15042 <span class="keywordtype">void</span> tetgenmesh::formbowatcavitysub(point bp, face* bpseg, list* sublist,
<a name="l15043"></a>15043   list* subceillist)
<a name="l15044"></a>15044 {
<a name="l15045"></a>15045   triface adjtet;
<a name="l15046"></a>15046   face startsh, neighsh;
<a name="l15047"></a>15047   face checkseg;
<a name="l15048"></a>15048   point pa, pb, pc, pd;
<a name="l15049"></a>15049   REAL sign;
<a name="l15050"></a>15050   <span class="keywordtype">int</span> i, j;
<a name="l15051"></a>15051 
<a name="l15052"></a>15052   <span class="comment">// Form CBC(p) and C(p) by a broadth-first searching.</span>
<a name="l15053"></a>15053   <span class="keywordflow">for</span> (i = 0; i &lt; sublist-&gt;len(); i++) {
<a name="l15054"></a>15054     startsh = * (face *)(* sublist)[i]; <span class="comment">// startsh = f.</span>
<a name="l15055"></a>15055     <span class="comment">// Look for three neighbors of f.</span>
<a name="l15056"></a>15056     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l15057"></a>15057       sspivot(startsh, checkseg);
<a name="l15058"></a>15058       <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l15059"></a>15059         <span class="comment">// Get its neighbor n.</span>
<a name="l15060"></a>15060         spivot(startsh, neighsh);
<a name="l15061"></a>15061         <span class="comment">// Is n already in CBC(p)?</span>
<a name="l15062"></a>15062         <span class="keywordflow">if</span> (!sinfected(neighsh)) {
<a name="l15063"></a>15063           stpivot(neighsh, adjtet);
<a name="l15064"></a>15064           <span class="keywordflow">if</span> (adjtet.tet == dummytet) {
<a name="l15065"></a>15065             sesymself(neighsh);
<a name="l15066"></a>15066             stpivot(neighsh, adjtet);
<a name="l15067"></a>15067           }
<a name="l15068"></a>15068           <span class="comment">// For positive orientation that insphere() test requires.</span>
<a name="l15069"></a>15069           adjustedgering(adjtet, CW);
<a name="l15070"></a>15070           pa = org(adjtet);
<a name="l15071"></a>15071           pb = dest(adjtet);
<a name="l15072"></a>15072           pc = apex(adjtet);
<a name="l15073"></a>15073           pd = oppo(adjtet);
<a name="l15074"></a>15074           sign = insphere(pa, pb, pc, pd, bp);
<a name="l15075"></a>15075           <span class="keywordflow">if</span> (sign &gt;= 0.0) {
<a name="l15076"></a>15076             <span class="comment">// Orient edge ring of n according to that of f.</span>
<a name="l15077"></a>15077             <span class="keywordflow">if</span> (sorg(neighsh) != sdest(startsh)) sesymself(neighsh);
<a name="l15078"></a>15078             <span class="comment">// Collect it into CBC(p).</span>
<a name="l15079"></a>15079             sinfect(neighsh);
<a name="l15080"></a>15080             sublist-&gt;append(&amp;neighsh);
<a name="l15081"></a>15081           } <span class="keywordflow">else</span> {
<a name="l15082"></a>15082             subceillist-&gt;append(&amp;startsh); <span class="comment">// Found an edge of C(p).</span>
<a name="l15083"></a>15083           }
<a name="l15084"></a>15084         }
<a name="l15085"></a>15085       } <span class="keywordflow">else</span> {
<a name="l15086"></a>15086         <span class="comment">// Do not cross a segment.</span>
<a name="l15087"></a>15087         <span class="keywordflow">if</span> (bpseg != (face *) NULL) {
<a name="l15088"></a>15088           <span class="keywordflow">if</span> (checkseg.sh != bpseg-&gt;sh) {
<a name="l15089"></a>15089             subceillist-&gt;append(&amp;startsh); <span class="comment">// Found an edge of C(p).</span>
<a name="l15090"></a>15090           }
<a name="l15091"></a>15091         } <span class="keywordflow">else</span> {
<a name="l15092"></a>15092           subceillist-&gt;append(&amp;startsh); <span class="comment">// Found an edge of C(p).</span>
<a name="l15093"></a>15093         }
<a name="l15094"></a>15094       }
<a name="l15095"></a>15095       senextself(startsh);
<a name="l15096"></a>15096     }
<a name="l15097"></a>15097   }
<a name="l15098"></a>15098 
<a name="l15099"></a>15099   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l15100"></a>15100     printf(<span class="stringliteral">&quot;    Collect CBC(%d): %d subfaces, %d edges.\n&quot;</span>, pointmark(bp),
<a name="l15101"></a>15101            sublist-&gt;len(), subceillist-&gt;len());
<a name="l15102"></a>15102   }
<a name="l15103"></a>15103 }
<a name="l15104"></a>15104 
<a name="l15106"></a>15106 <span class="comment">//                                                                           //</span>
<a name="l15107"></a>15107 <span class="comment">// formbowatcavityquad()    Form BC_i(p) and B_i(p) in a quadrant.           //</span>
<a name="l15108"></a>15108 <span class="comment">//                                                                           //</span>
<a name="l15109"></a>15109 <span class="comment">// Parameters: bp = p, tetlist = BC_i(p), ceillist = B_i(p).                 //</span>
<a name="l15110"></a>15110 <span class="comment">//                                                                           //</span>
<a name="l15111"></a>15111 <span class="comment">// BC_i(p) contains at least one tet on input. On finish, all tets collected //</span>
<a name="l15112"></a>15112 <span class="comment">// in BC_i(p) are infected. B_i(p) may not closed when p is on segment or in //</span>
<a name="l15113"></a>15113 <span class="comment">// facet. C(p) must be formed before this routine.  Check the infect flag of //</span>
<a name="l15114"></a>15114 <span class="comment">// a subface to identify the unclosed side of B_i(p).  These sides will be   //</span>
<a name="l15115"></a>15115 <span class="comment">// closed by new subfaces of C(p)s.                                          //</span>
<a name="l15116"></a>15116 <span class="comment">//                                                                           //</span>
<a name="l15118"></a>15118 <span class="comment"></span>
<a name="l15119"></a>15119 <span class="keywordtype">void</span> tetgenmesh::formbowatcavityquad(point bp, list* tetlist, list* ceillist)
<a name="l15120"></a>15120 {
<a name="l15121"></a>15121   triface starttet, neightet;
<a name="l15122"></a>15122   face checksh;
<a name="l15123"></a>15123   point pa, pb, pc, pd;
<a name="l15124"></a>15124   REAL sign;
<a name="l15125"></a>15125   <span class="keywordtype">int</span> i;
<a name="l15126"></a>15126 
<a name="l15127"></a>15127   <span class="comment">// Form BC_i(p) and B_i(p) by a broadth-first searching.</span>
<a name="l15128"></a>15128   <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l15129"></a>15129     starttet = * (triface *)(* tetlist)[i];
<a name="l15130"></a>15130     <span class="keywordflow">for</span> (starttet.loc = 0; starttet.loc &lt; 4; starttet.loc++) {
<a name="l15131"></a>15131       <span class="comment">// Try to collect the neighbor of the face (f).</span>
<a name="l15132"></a>15132       tspivot(starttet, checksh);
<a name="l15133"></a>15133       <span class="keywordflow">if</span> (checksh.sh == dummysh) {
<a name="l15134"></a>15134         <span class="comment">// Get its neighbor n.</span>
<a name="l15135"></a>15135         sym(starttet, neightet);
<a name="l15136"></a>15136         <span class="comment">// Is n already in BC_i(p)?</span>
<a name="l15137"></a>15137         <span class="keywordflow">if</span> (!infected(neightet)) {
<a name="l15138"></a>15138           <span class="comment">// For positive orientation that insphere() test requires.</span>
<a name="l15139"></a>15139           adjustedgering(neightet, CW);
<a name="l15140"></a>15140           pa = org(neightet);
<a name="l15141"></a>15141           pb = dest(neightet);
<a name="l15142"></a>15142           pc = apex(neightet);
<a name="l15143"></a>15143           pd = oppo(neightet);
<a name="l15144"></a>15144           sign = insphere(pa, pb, pc, pd, bp);
<a name="l15145"></a>15145           <span class="keywordflow">if</span> (sign &gt;= 0.0) {
<a name="l15146"></a>15146             <span class="comment">// Collect it into BC_i(p).</span>
<a name="l15147"></a>15147             infect(neightet);
<a name="l15148"></a>15148             tetlist-&gt;append(&amp;neightet);
<a name="l15149"></a>15149           } <span class="keywordflow">else</span> {
<a name="l15150"></a>15150             ceillist-&gt;append(&amp;starttet); <span class="comment">// Found a face of B_i(p).</span>
<a name="l15151"></a>15151           }
<a name="l15152"></a>15152         }
<a name="l15153"></a>15153       } <span class="keywordflow">else</span> {
<a name="l15154"></a>15154         <span class="comment">// Do not cross a boundary face.</span>
<a name="l15155"></a>15155         <span class="keywordflow">if</span> (!sinfected(checksh)) {
<a name="l15156"></a>15156           ceillist-&gt;append(&amp;starttet); <span class="comment">// Found a face of B_i(p).</span>
<a name="l15157"></a>15157         }
<a name="l15158"></a>15158       }
<a name="l15159"></a>15159     }
<a name="l15160"></a>15160   }
<a name="l15161"></a>15161 
<a name="l15162"></a>15162   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l15163"></a>15163     printf(<span class="stringliteral">&quot;    Collect BC_i(%d): %d tets, %d faces.\n&quot;</span>, pointmark(bp),
<a name="l15164"></a>15164            tetlist-&gt;len(), ceillist-&gt;len());
<a name="l15165"></a>15165   }
<a name="l15166"></a>15166 }
<a name="l15167"></a>15167 
<a name="l15169"></a>15169 <span class="comment">//                                                                           //</span>
<a name="l15170"></a>15170 <span class="comment">// formbowatcavitysegquad()    Form BC_i(p) and B_i(p) in a segment quadrant.//</span>
<a name="l15171"></a>15171 <span class="comment">//                                                                           //</span>
<a name="l15172"></a>15172 <span class="comment">// Parameters: bp = p, tetlist = BC_i(p), ceillist = B_i(p).                 //</span>
<a name="l15173"></a>15173 <span class="comment">//                                                                           //</span>
<a name="l15174"></a>15174 <span class="comment">// BC_i(p) contains at least one tet on input. On finish, all tets collected //</span>
<a name="l15175"></a>15175 <span class="comment">// in BC_i(p) are infected. B_i(p) is not closed. C(p) must be formed before //</span>
<a name="l15176"></a>15176 <span class="comment">// this routine. Check the infect flag of a subface to identify the unclosed //</span>
<a name="l15177"></a>15177 <span class="comment">// sides of B_i(p).  These sides will be closed by new subfaces of C(p)s.    //</span>
<a name="l15178"></a>15178 <span class="comment">//                                                                           //</span>
<a name="l15179"></a>15179 <span class="comment">// During the repair of encroaching subsegments, there may exist locally non-//</span>
<a name="l15180"></a>15180 <span class="comment">// Delaunay faces. These faces are collected in BC_i(p) either.  B_i(p) has  //</span>
<a name="l15181"></a>15181 <span class="comment">// to be formed later than BC_i(p).                                          //</span>
<a name="l15182"></a>15182 <span class="comment">//                                                                           //</span>
<a name="l15184"></a>15184 <span class="comment"></span>
<a name="l15185"></a>15185 <span class="keywordtype">void</span> tetgenmesh::formbowatcavitysegquad(point bp, list* tetlist,list* ceillist)
<a name="l15186"></a>15186 {
<a name="l15187"></a>15187   triface starttet, neightet, cavtet;
<a name="l15188"></a>15188   face checksh;
<a name="l15189"></a>15189   point pa, pb, pc, pd, pe;
<a name="l15190"></a>15190   REAL sign;
<a name="l15191"></a>15191   <span class="keywordtype">int</span> i;
<a name="l15192"></a>15192 
<a name="l15193"></a>15193   <span class="comment">// Form BC_i(p) by a broadth-first searching.</span>
<a name="l15194"></a>15194   <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l15195"></a>15195     starttet = * (triface *)(* tetlist)[i];
<a name="l15196"></a>15196     <span class="keywordflow">for</span> (starttet.loc = 0; starttet.loc &lt; 4; starttet.loc++) {
<a name="l15197"></a>15197       <span class="comment">// Try to collect the neighbor of the face f.</span>
<a name="l15198"></a>15198       tspivot(starttet, checksh);
<a name="l15199"></a>15199       <span class="keywordflow">if</span> (checksh.sh == dummysh) {
<a name="l15200"></a>15200         <span class="comment">// Get its neighbor n.</span>
<a name="l15201"></a>15201         sym(starttet, neightet);
<a name="l15202"></a>15202         <span class="comment">// Is n already in BC_i(p)?</span>
<a name="l15203"></a>15203         <span class="keywordflow">if</span> (!infected(neightet)) {
<a name="l15204"></a>15204           <span class="comment">// For positive orientation that insphere() test requires.</span>
<a name="l15205"></a>15205           adjustedgering(neightet, CW);
<a name="l15206"></a>15206           pa = org(neightet);
<a name="l15207"></a>15207           pb = dest(neightet);
<a name="l15208"></a>15208           pc = apex(neightet);
<a name="l15209"></a>15209           pd = oppo(neightet);
<a name="l15210"></a>15210           sign = insphere(pa, pb, pc, pd, bp);
<a name="l15211"></a>15211           <span class="keywordflow">if</span> (sign &gt;= 0.0) {
<a name="l15212"></a>15212             <span class="comment">// Collect it into BC_i(p).</span>
<a name="l15213"></a>15213             infect(neightet);
<a name="l15214"></a>15214             tetlist-&gt;append(&amp;neightet);
<a name="l15215"></a>15215           } <span class="keywordflow">else</span> {
<a name="l15216"></a>15216             <span class="comment">// Check if the face is locally non-Delaunay.</span>
<a name="l15217"></a>15217             pe = oppo(starttet);
<a name="l15218"></a>15218             sign = insphere(pa, pb, pc, pd, pe);
<a name="l15219"></a>15219             <span class="keywordflow">if</span> (sign &gt;= 0.0) {
<a name="l15220"></a>15220               <span class="comment">// Collect it into BC_i(p).</span>
<a name="l15221"></a>15221               infect(neightet);
<a name="l15222"></a>15222               tetlist-&gt;append(&amp;neightet);
<a name="l15223"></a>15223             }
<a name="l15224"></a>15224           }
<a name="l15225"></a>15225         }
<a name="l15226"></a>15226       }
<a name="l15227"></a>15227     }
<a name="l15228"></a>15228   }
<a name="l15229"></a>15229 
<a name="l15230"></a>15230   <span class="comment">// Generate B_i(p).</span>
<a name="l15231"></a>15231   <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l15232"></a>15232     cavtet = * (triface *)(* tetlist)[i];
<a name="l15233"></a>15233     <span class="keywordflow">for</span> (cavtet.loc = 0; cavtet.loc &lt; 4; cavtet.loc++) {
<a name="l15234"></a>15234       tspivot(cavtet, checksh);
<a name="l15235"></a>15235       <span class="keywordflow">if</span> (checksh.sh == dummysh) {
<a name="l15236"></a>15236         sym(cavtet, neightet);
<a name="l15237"></a>15237         <span class="keywordflow">if</span> (!infected(neightet)) {
<a name="l15238"></a>15238           ceillist-&gt;append(&amp;cavtet); <span class="comment">// Found a face of B(p).</span>
<a name="l15239"></a>15239         }
<a name="l15240"></a>15240       } <span class="keywordflow">else</span> {
<a name="l15241"></a>15241         <span class="comment">// Do not cross a boundary face.</span>
<a name="l15242"></a>15242         <span class="keywordflow">if</span> (!sinfected(checksh)) {
<a name="l15243"></a>15243           ceillist-&gt;append(&amp;cavtet); <span class="comment">// Found a face of B(p).</span>
<a name="l15244"></a>15244         }
<a name="l15245"></a>15245       }
<a name="l15246"></a>15246     }
<a name="l15247"></a>15247   }
<a name="l15248"></a>15248 
<a name="l15249"></a>15249   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l15250"></a>15250     printf(<span class="stringliteral">&quot;    Collect BC_i(%d): %d tets, %d faces.\n&quot;</span>, pointmark(bp),
<a name="l15251"></a>15251            tetlist-&gt;len(), ceillist-&gt;len());
<a name="l15252"></a>15252   }
<a name="l15253"></a>15253 }
<a name="l15254"></a>15254 
<a name="l15256"></a>15256 <span class="comment">//                                                                           //</span>
<a name="l15257"></a>15257 <span class="comment">// formbowatcavity()    Form BC(p), B(p), CBC(p)s, and C(p)s.                //</span>
<a name="l15258"></a>15258 <span class="comment">//                                                                           //</span>
<a name="l15259"></a>15259 <span class="comment">// If &#39;bpseg&#39;(S) != NULL, p is on segment S, else, p is on facet containing  //</span>
<a name="l15260"></a>15260 <span class="comment">// &#39;bpsh&#39; (F).  &#39;n&#39; returns the number of quadrants in BC(p). &#39;nmax&#39; is the  //</span>
<a name="l15261"></a>15261 <span class="comment">// maximum pre-allocated array length for the lists.                         //</span>
<a name="l15262"></a>15262 <span class="comment">//                                                                           //</span>
<a name="l15264"></a>15264 <span class="comment"></span>
<a name="l15265"></a>15265 <span class="keywordtype">void</span> tetgenmesh::formbowatcavity(point bp, face* bpseg, face* bpsh, <span class="keywordtype">int</span>* n,
<a name="l15266"></a>15266   <span class="keywordtype">int</span>* nmax, list** sublists, list** subceillists, list** tetlists,
<a name="l15267"></a>15267   list** ceillists)
<a name="l15268"></a>15268 {
<a name="l15269"></a>15269   list *sublist;
<a name="l15270"></a>15270   triface adjtet;
<a name="l15271"></a>15271   face startsh, spinsh;
<a name="l15272"></a>15272   point pa, pb;
<a name="l15273"></a>15273   <span class="keywordtype">int</span> i, j;
<a name="l15274"></a>15274 
<a name="l15275"></a>15275   *n = 0;
<a name="l15276"></a>15276   <span class="keywordflow">if</span> (bpseg != (face *) NULL) {
<a name="l15277"></a>15277     <span class="comment">// p is on segment S.</span>
<a name="l15278"></a>15278     bpseg-&gt;shver = 0;
<a name="l15279"></a>15279     pa = sorg(*bpseg);
<a name="l15280"></a>15280     pb = sdest(*bpseg);
<a name="l15281"></a>15281     <span class="comment">// Count the number of facets sharing at S.</span>
<a name="l15282"></a>15282     spivot(*bpseg, startsh);
<a name="l15283"></a>15283     spinsh = startsh;
<a name="l15284"></a>15284     <span class="keywordflow">do</span> {
<a name="l15285"></a>15285       (*n)++; <span class="comment">// spinshlist-&gt;append(&amp;spinsh);</span>
<a name="l15286"></a>15286       spivotself(spinsh);
<a name="l15287"></a>15287     } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l15288"></a>15288     <span class="comment">// *n is the number of quadrants around S.</span>
<a name="l15289"></a>15289     <span class="keywordflow">if</span> (*n &gt; *nmax) {
<a name="l15290"></a>15290       <span class="comment">// Reallocate arrays. Should not happen very often.</span>
<a name="l15291"></a>15291       <span class="keyword">delete</span> [] tetlists;
<a name="l15292"></a>15292       <span class="keyword">delete</span> [] ceillists;
<a name="l15293"></a>15293       <span class="keyword">delete</span> [] sublists;
<a name="l15294"></a>15294       <span class="keyword">delete</span> [] subceillists;
<a name="l15295"></a>15295       tetlists = <span class="keyword">new</span> list*[*n];
<a name="l15296"></a>15296       ceillists = <span class="keyword">new</span> list*[*n];
<a name="l15297"></a>15297       sublists = <span class="keyword">new</span> list*[*n];
<a name="l15298"></a>15298       subceillists = <span class="keyword">new</span> list*[*n];
<a name="l15299"></a>15299       *nmax = *n;
<a name="l15300"></a>15300     }
<a name="l15301"></a>15301     <span class="comment">// Form CBC(p)s and C(p)s.</span>
<a name="l15302"></a>15302     spinsh = startsh;
<a name="l15303"></a>15303     <span class="keywordflow">for</span> (i = 0; i &lt; *n; i++) {
<a name="l15304"></a>15304       sublists[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l15305"></a>15305       subceillists[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l15306"></a>15306       <span class="comment">// Set a subface f to start search.</span>
<a name="l15307"></a>15307       startsh = spinsh;
<a name="l15308"></a>15308       <span class="comment">// Let f face to the quadrant of interest (used in forming BC(p)).</span>
<a name="l15309"></a>15309       findedge(&amp;startsh, pa, pb);
<a name="l15310"></a>15310       sinfect(startsh);
<a name="l15311"></a>15311       sublists[i]-&gt;append(&amp;startsh);
<a name="l15312"></a>15312       formbowatcavitysub(bp, bpseg, sublists[i], subceillists[i]);
<a name="l15313"></a>15313       <span class="comment">// Go to the next facet.</span>
<a name="l15314"></a>15314       spivotself(spinsh);
<a name="l15315"></a>15315     }
<a name="l15316"></a>15316   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sublists != (list **) NULL) {
<a name="l15317"></a>15317     <span class="comment">// p is on a facet.</span>
<a name="l15318"></a>15318     *n = 2;
<a name="l15319"></a>15319     <span class="comment">// Form CBC(p) and C(p).</span>
<a name="l15320"></a>15320     sublists[0] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l15321"></a>15321     subceillists[0] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l15322"></a>15322     sinfect(*bpsh);
<a name="l15323"></a>15323     sublists[0]-&gt;append(bpsh);
<a name="l15324"></a>15324     formbowatcavitysub(bp, NULL, sublists[0], subceillists[0]);
<a name="l15325"></a>15325   } <span class="keywordflow">else</span> {
<a name="l15326"></a>15326     <span class="comment">// p is inside a tet.</span>
<a name="l15327"></a>15327     *n = 1;
<a name="l15328"></a>15328   }
<a name="l15329"></a>15329 
<a name="l15330"></a>15330   <span class="comment">// Form BC_i(p) and B_i(p).</span>
<a name="l15331"></a>15331   <span class="keywordflow">for</span> (i = 0; i &lt; *n; i++) {
<a name="l15332"></a>15332     tetlists[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l15333"></a>15333     ceillists[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l15334"></a>15334     <span class="keywordflow">if</span> (sublists != (list **) NULL) {
<a name="l15335"></a>15335       <span class="comment">// There are C(p)s.</span>
<a name="l15336"></a>15336       sublist = ((bpseg == (face *) NULL) ? sublists[0] : sublists[i]);
<a name="l15337"></a>15337       <span class="comment">// Add all adjacent tets of C_i(p) into BC_i(p).</span>
<a name="l15338"></a>15338       <span class="keywordflow">for</span> (j = 0; j &lt; sublist-&gt;len(); j++) {
<a name="l15339"></a>15339         startsh = * (face *)(* sublist)[j];
<a name="l15340"></a>15340         <span class="comment">// Adjust the side facing to the right quadrant for C(p).</span>
<a name="l15341"></a>15341         <span class="keywordflow">if</span> ((bpseg == (face *) NULL) &amp;&amp; (i == 1)) sesymself(startsh);
<a name="l15342"></a>15342         stpivot(startsh, adjtet);
<a name="l15343"></a>15343         <span class="keywordflow">if</span> (adjtet.tet != dummytet) {
<a name="l15344"></a>15344           <span class="keywordflow">if</span> (!infected(adjtet)) {
<a name="l15345"></a>15345             infect(adjtet);
<a name="l15346"></a>15346             tetlists[i]-&gt;append(&amp;adjtet);
<a name="l15347"></a>15347           }
<a name="l15348"></a>15348         }
<a name="l15349"></a>15349       }
<a name="l15350"></a>15350       <span class="keywordflow">if</span> (bpseg != (face *) NULL) {
<a name="l15351"></a>15351         <span class="comment">// The quadrant is bounded by another facet.</span>
<a name="l15352"></a>15352         sublist = ((i &lt; *n - 1) ? sublists[i + 1] : sublists[0]);
<a name="l15353"></a>15353         <span class="keywordflow">for</span> (j = 0; j &lt; sublist-&gt;len(); j++) {
<a name="l15354"></a>15354           startsh = * (face *)(* sublist)[j];
<a name="l15355"></a>15355           <span class="comment">// Adjust the side facing to the right quadrant for C(p).</span>
<a name="l15356"></a>15356           sesymself(startsh);
<a name="l15357"></a>15357           stpivot(startsh, adjtet);
<a name="l15358"></a>15358           <span class="keywordflow">if</span> (adjtet.tet != dummytet) {
<a name="l15359"></a>15359             <span class="keywordflow">if</span> (!infected(adjtet)) {
<a name="l15360"></a>15360               infect(adjtet);
<a name="l15361"></a>15361               tetlists[i]-&gt;append(&amp;adjtet);
<a name="l15362"></a>15362             }
<a name="l15363"></a>15363           }
<a name="l15364"></a>15364         }
<a name="l15365"></a>15365       }
<a name="l15366"></a>15366     }
<a name="l15367"></a>15367     <span class="comment">// It is possible that BC_i(p) is empty.</span>
<a name="l15368"></a>15368     <span class="keywordflow">if</span> (tetlists[i]-&gt;len() == 0) <span class="keywordflow">continue</span>;
<a name="l15369"></a>15369     <span class="comment">// Collect the rest of tets of BC_i(p) and form B_i(p).</span>
<a name="l15370"></a>15370     <span class="comment">// if (b-&gt;conformdel) {</span>
<a name="l15371"></a>15371       <span class="comment">// formbowatcavitysegquad(bp, tetlists[i], ceillists[i]);</span>
<a name="l15372"></a>15372     <span class="comment">// } else {</span>
<a name="l15373"></a>15373       formbowatcavityquad(bp, tetlists[i], ceillists[i]);
<a name="l15374"></a>15374     <span class="comment">// }</span>
<a name="l15375"></a>15375   }
<a name="l15376"></a>15376 }
<a name="l15377"></a>15377 
<a name="l15379"></a>15379 <span class="comment">//                                                                           //</span>
<a name="l15380"></a>15380 <span class="comment">// releasebowatcavity()    Undo and free the memory allocated in routine     //</span>
<a name="l15381"></a>15381 <span class="comment">//                         formbowatcavity().                                //</span>
<a name="l15382"></a>15382 <span class="comment">//                                                                           //</span>
<a name="l15384"></a>15384 <span class="comment"></span>
<a name="l15385"></a>15385 <span class="keywordtype">void</span> tetgenmesh::releasebowatcavity(face* bpseg, <span class="keywordtype">int</span> n, list** sublists,
<a name="l15386"></a>15386   list** subceillist, list** tetlists, list** ceillists)
<a name="l15387"></a>15387 {
<a name="l15388"></a>15388   triface oldtet;
<a name="l15389"></a>15389   face oldsh;
<a name="l15390"></a>15390   <span class="keywordtype">int</span> i, j;
<a name="l15391"></a>15391 
<a name="l15392"></a>15392   <span class="keywordflow">if</span> (sublists != (list **) NULL) {
<a name="l15393"></a>15393     <span class="comment">// Release CBC(p)s.</span>
<a name="l15394"></a>15394     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l15395"></a>15395       <span class="comment">// Uninfect subfaces of CBC(p).</span>
<a name="l15396"></a>15396       <span class="keywordflow">for</span> (j = 0; j &lt; sublists[i]-&gt;len(); j++) {
<a name="l15397"></a>15397         oldsh = * (face *)(* (sublists[i]))[j];
<a name="l15398"></a>15398 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l15399"></a>15399 <span class="preprocessor"></span>        assert(sinfected(oldsh));
<a name="l15400"></a>15400 <span class="preprocessor">#endif</span>
<a name="l15401"></a>15401 <span class="preprocessor"></span>        suninfect(oldsh);
<a name="l15402"></a>15402       }
<a name="l15403"></a>15403       <span class="keyword">delete</span> sublists[i];
<a name="l15404"></a>15404       <span class="keyword">delete</span> subceillist[i];
<a name="l15405"></a>15405       sublists[i] = (list *) NULL;
<a name="l15406"></a>15406       subceillist[i] = (list *) NULL;
<a name="l15407"></a>15407       <span class="keywordflow">if</span> (bpseg == (face *) NULL) <span class="keywordflow">break</span>;
<a name="l15408"></a>15408     }
<a name="l15409"></a>15409   }
<a name="l15410"></a>15410   <span class="comment">// Release BC(p).</span>
<a name="l15411"></a>15411   <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l15412"></a>15412     <span class="comment">// Uninfect tets of BC_i(p).</span>
<a name="l15413"></a>15413     <span class="keywordflow">for</span> (j = 0; j &lt; tetlists[i]-&gt;len(); j++) {
<a name="l15414"></a>15414       oldtet = * (triface *)(* (tetlists[i]))[j];
<a name="l15415"></a>15415 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l15416"></a>15416 <span class="preprocessor"></span>      assert(infected(oldtet));
<a name="l15417"></a>15417 <span class="preprocessor">#endif</span>
<a name="l15418"></a>15418 <span class="preprocessor"></span>      uninfect(oldtet);
<a name="l15419"></a>15419     }
<a name="l15420"></a>15420     <span class="keyword">delete</span> tetlists[i];
<a name="l15421"></a>15421     <span class="keyword">delete</span> ceillists[i];
<a name="l15422"></a>15422     tetlists[i] = (list *) NULL;
<a name="l15423"></a>15423     ceillists[i] = (list *) NULL;
<a name="l15424"></a>15424   }
<a name="l15425"></a>15425 }
<a name="l15426"></a>15426 
<a name="l15428"></a>15428 <span class="comment">//                                                                           //</span>
<a name="l15429"></a>15429 <span class="comment">// validatebowatcavityquad()    Valid B_i(p).                                //</span>
<a name="l15430"></a>15430 <span class="comment">//                                                                           //</span>
<a name="l15431"></a>15431 <span class="comment">// B_i(p) is valid if all faces of B_i(p) are visible by p, else B_i(p) is   //</span>
<a name="l15432"></a>15432 <span class="comment">// invalid.  Each tet of BC_i(p) which has such a face is marked (uninfect). //</span>
<a name="l15433"></a>15433 <span class="comment">// They will be removed in updatebowatcavityquad().                          //</span>
<a name="l15434"></a>15434 <span class="comment">//                                                                           //</span>
<a name="l15435"></a>15435 <span class="comment">// Return TRUE if B(p) is valid, else, return FALSE.                         //</span>
<a name="l15436"></a>15436 <span class="comment">//                                                                           //</span>
<a name="l15438"></a>15438 <span class="comment"></span>
<a name="l15439"></a>15439 <span class="keywordtype">bool</span> tetgenmesh::validatebowatcavityquad(point bp,list* ceillist,REAL maxcosd)
<a name="l15440"></a>15440 {
<a name="l15441"></a>15441   triface ceiltet;
<a name="l15442"></a>15442   point pa, pb, pc;
<a name="l15443"></a>15443   REAL ori, cosd;
<a name="l15444"></a>15444   <span class="keywordtype">int</span> remcount, i;
<a name="l15445"></a>15445 
<a name="l15446"></a>15446   <span class="comment">// Check the validate of B(p), cut tets having invisible faces.</span>
<a name="l15447"></a>15447   remcount = 0;
<a name="l15448"></a>15448   <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l15449"></a>15449     ceiltet = * (triface *)(* ceillist)[i];
<a name="l15450"></a>15450     <span class="keywordflow">if</span> (infected(ceiltet)) {
<a name="l15451"></a>15451       adjustedgering(ceiltet, CCW);
<a name="l15452"></a>15452       pa = org(ceiltet);
<a name="l15453"></a>15453       pb = dest(ceiltet);
<a name="l15454"></a>15454       pc = apex(ceiltet);
<a name="l15455"></a>15455       ori = orient3d(pa, pb, pc, bp);
<a name="l15456"></a>15456       <span class="keywordflow">if</span> (ori &gt;= 0.0) {
<a name="l15457"></a>15457         <span class="comment">// Found an invisible face.</span>
<a name="l15458"></a>15458         uninfect(ceiltet);
<a name="l15459"></a>15459         remcount++;
<a name="l15460"></a>15460         <span class="keywordflow">continue</span>;
<a name="l15461"></a>15461       }
<a name="l15462"></a>15462       <span class="comment">// If a non-trival &#39;maxcosd&#39; is given.</span>
<a name="l15463"></a>15463       <span class="keywordflow">if</span> (maxcosd &gt; -1.0) {
<a name="l15464"></a>15464         <span class="comment">// Get the maximal dihedral angle of tet abcp.</span>
<a name="l15465"></a>15465         tetalldihedral(pa, pb, pc, bp, NULL, &amp;cosd, NULL);
<a name="l15466"></a>15466         <span class="comment">// Do not form the tet if the maximal dihedral angle is not reduced.</span>
<a name="l15467"></a>15467         <span class="keywordflow">if</span> (cosd &lt; maxcosd) {
<a name="l15468"></a>15468           uninfect(ceiltet);
<a name="l15469"></a>15469           remcount++;
<a name="l15470"></a>15470         }
<a name="l15471"></a>15471       }
<a name="l15472"></a>15472     }
<a name="l15473"></a>15473   }
<a name="l15474"></a>15474   <span class="keywordflow">return</span> remcount == 0;
<a name="l15475"></a>15475 }
<a name="l15476"></a>15476 
<a name="l15478"></a>15478 <span class="comment">//                                                                           //</span>
<a name="l15479"></a>15479 <span class="comment">// updatebowatcavityquad()    Update BC_i(p) and reform B_i(p).              //</span>
<a name="l15480"></a>15480 <span class="comment">//                                                                           //</span>
<a name="l15481"></a>15481 <span class="comment">// B_i(p) is invalid and some tets in BC_i(p) have been marked to be removed //</span>
<a name="l15482"></a>15482 <span class="comment">// in validatebowatcavityquad().  This routine actually remove the cut tets  //</span>
<a name="l15483"></a>15483 <span class="comment">// of BC_i(p) and re-form the B_i(p).                                        //</span>
<a name="l15484"></a>15484 <span class="comment">//                                                                           //</span>
<a name="l15486"></a>15486 <span class="comment"></span>
<a name="l15487"></a>15487 <span class="keywordtype">void</span> tetgenmesh::updatebowatcavityquad(list* tetlist, list* ceillist)
<a name="l15488"></a>15488 {
<a name="l15489"></a>15489   triface cavtet, neightet;
<a name="l15490"></a>15490   face checksh;
<a name="l15491"></a>15491   <span class="keywordtype">int</span> remcount, i;
<a name="l15492"></a>15492 
<a name="l15493"></a>15493   remcount = 0;
<a name="l15494"></a>15494   <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l15495"></a>15495     cavtet = * (triface *)(* tetlist)[i];
<a name="l15496"></a>15496     <span class="keywordflow">if</span> (!infected(cavtet)) {
<a name="l15497"></a>15497       tetlist-&gt;del(i, 1);
<a name="l15498"></a>15498       remcount++;
<a name="l15499"></a>15499       i--;
<a name="l15500"></a>15500     }
<a name="l15501"></a>15501   }
<a name="l15502"></a>15502 
<a name="l15503"></a>15503   <span class="comment">// Are there tets have been cut in BC_i(p)?</span>
<a name="l15504"></a>15504   <span class="keywordflow">if</span> (remcount &gt; 0) {
<a name="l15505"></a>15505     <span class="comment">// Re-form B_i(p).</span>
<a name="l15506"></a>15506     ceillist-&gt;clear();
<a name="l15507"></a>15507     <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l15508"></a>15508       cavtet = * (triface *)(* tetlist)[i];
<a name="l15509"></a>15509       <span class="keywordflow">for</span> (cavtet.loc = 0; cavtet.loc &lt; 4; cavtet.loc++) {
<a name="l15510"></a>15510         tspivot(cavtet, checksh);
<a name="l15511"></a>15511         <span class="keywordflow">if</span> (checksh.sh == dummysh) {
<a name="l15512"></a>15512           sym(cavtet, neightet);
<a name="l15513"></a>15513           <span class="keywordflow">if</span> (!infected(neightet)) {
<a name="l15514"></a>15514             ceillist-&gt;append(&amp;cavtet); <span class="comment">// Found a face of B_i(p).</span>
<a name="l15515"></a>15515           }
<a name="l15516"></a>15516         } <span class="keywordflow">else</span> {
<a name="l15517"></a>15517           <span class="comment">// Do not cross a boundary face.</span>
<a name="l15518"></a>15518           <span class="keywordflow">if</span> (!sinfected(checksh)) {
<a name="l15519"></a>15519             ceillist-&gt;append(&amp;cavtet); <span class="comment">// Found a face of B_i(p).</span>
<a name="l15520"></a>15520           }
<a name="l15521"></a>15521         }
<a name="l15522"></a>15522       }
<a name="l15523"></a>15523     }
<a name="l15524"></a>15524     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l15525"></a>15525       printf(<span class="stringliteral">&quot;    Update BC_i(p): %d tets, %d faces.\n&quot;</span>, tetlist-&gt;len(),
<a name="l15526"></a>15526              ceillist-&gt;len());
<a name="l15527"></a>15527     }
<a name="l15528"></a>15528   }
<a name="l15529"></a>15529 }
<a name="l15530"></a>15530 
<a name="l15532"></a>15532 <span class="comment">//                                                                           //</span>
<a name="l15533"></a>15533 <span class="comment">// updatebowatcavitysub()    Check and update CBC(p) and C(p).               //</span>
<a name="l15534"></a>15534 <span class="comment">//                                                                           //</span>
<a name="l15535"></a>15535 <span class="comment">// A CBC(p) is valid if all its subfaces are inside or on the hull of BC(p). //</span>
<a name="l15536"></a>15536 <span class="comment">// A subface s of CBC(p) is invalid if it is in one of the two cases:        //</span>
<a name="l15537"></a>15537 <span class="comment">//   (1) s is completely outside BC(p);                                      //</span>
<a name="l15538"></a>15538 <span class="comment">//   (2) s has two adjacent tets but only one of them is in BC(p);           //</span>
<a name="l15539"></a>15539 <span class="comment">// s is removed from CBC(p) if it is invalid. If there is an adjacent tet of //</span>
<a name="l15540"></a>15540 <span class="comment">// s which is in BC(p), it gets removed from BC(p) too. If CBC(p) is updated,//</span>
<a name="l15541"></a>15541 <span class="comment">// C(p) is re-formed.                                                        //</span>
<a name="l15542"></a>15542 <span class="comment">//                                                                           //</span>
<a name="l15543"></a>15543 <span class="comment">// A C(p) is valid if all its edges are on the hull of BC(p).  An edge e of  //</span>
<a name="l15544"></a>15544 <span class="comment">// C(p) may be inside BC(p) if e is a segment and belongs to only one facet. //</span>
<a name="l15545"></a>15545 <span class="comment">// To correct C(p), a tet of BC(p) which shields e gets removed.             //</span>
<a name="l15546"></a>15546 <span class="comment">//                                                                           //</span>
<a name="l15547"></a>15547 <span class="comment">// If BC(p) is formed with locally non-Delaunay check (b-&gt;conformdel &gt; 0).   //</span>
<a name="l15548"></a>15548 <span class="comment">// A boundary-consistent check is needed for non-segment edges of C(p). Let  //</span>
<a name="l15549"></a>15549 <span class="comment">// e be such an edge, the subface f contains e and outside C(p) may belong   //</span>
<a name="l15550"></a>15550 <span class="comment">// to B(p) due to the non-coplanarity of the facet definition.  The tet of   //</span>
<a name="l15551"></a>15551 <span class="comment">// BC(p) containing f gets removed to avoid creating a degenerate new tet.   //</span>
<a name="l15552"></a>15552 <span class="comment">//                                                                           //</span>
<a name="l15553"></a>15553 <span class="comment">// &#39;cutcount&#39; accumulates the total number of cuttets(not only by this call).//</span>
<a name="l15554"></a>15554 <span class="comment">//                                                                           //</span>
<a name="l15556"></a>15556 <span class="comment"></span>
<a name="l15557"></a>15557 <span class="keywordtype">void</span> tetgenmesh::updatebowatcavitysub(list* sublist, list* subceillist,
<a name="l15558"></a>15558   <span class="keywordtype">int</span>* cutcount)
<a name="l15559"></a>15559 {
<a name="l15560"></a>15560   triface adjtet, rotface;
<a name="l15561"></a>15561   face checksh, neighsh;
<a name="l15562"></a>15562   face checkseg;
<a name="l15563"></a>15563   point pa, pb, pc;
<a name="l15564"></a>15564   REAL ori1, ori2;
<a name="l15565"></a>15565   <span class="keywordtype">int</span> remcount;
<a name="l15566"></a>15566   <span class="keywordtype">int</span> i, j;
<a name="l15567"></a>15567 
<a name="l15568"></a>15568   remcount = 0;
<a name="l15569"></a>15569   <span class="comment">// Check the validity of CBC(p).</span>
<a name="l15570"></a>15570   <span class="keywordflow">for</span> (i = 0; i &lt; sublist-&gt;len(); i++) {
<a name="l15571"></a>15571     checksh = * (face *)(* sublist)[i];
<a name="l15572"></a>15572     <span class="comment">// Check two adjacent tets of s.</span>
<a name="l15573"></a>15573     <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l15574"></a>15574       stpivot(checksh, adjtet);
<a name="l15575"></a>15575       <span class="keywordflow">if</span> (adjtet.tet != dummytet) {
<a name="l15576"></a>15576         <span class="keywordflow">if</span> (!infected(adjtet)) {
<a name="l15577"></a>15577           <span class="comment">// Could be either case (1) or (2).</span>
<a name="l15578"></a>15578           suninfect(checksh); <span class="comment">// s survives.</span>
<a name="l15579"></a>15579           <span class="comment">// If the sym. adjtet exists, it should remove from BC(p) too.</span>
<a name="l15580"></a>15580           sesymself(checksh);
<a name="l15581"></a>15581           stpivot(checksh, adjtet);
<a name="l15582"></a>15582           <span class="keywordflow">if</span> (adjtet.tet != dummytet) {
<a name="l15583"></a>15583             <span class="keywordflow">if</span> (infected(adjtet)) {
<a name="l15584"></a>15584               <span class="comment">// Found an adj. tet in BC(p), remove it.</span>
<a name="l15585"></a>15585               uninfect(adjtet);
<a name="l15586"></a>15586               (*cutcount)++;
<a name="l15587"></a>15587             }
<a name="l15588"></a>15588           }
<a name="l15589"></a>15589           <span class="comment">// Remove s from C(p).</span>
<a name="l15590"></a>15590           sublist-&gt;del(i, 1);
<a name="l15591"></a>15591           i--;
<a name="l15592"></a>15592           remcount++;
<a name="l15593"></a>15593           <span class="keywordflow">break</span>;
<a name="l15594"></a>15594         }
<a name="l15595"></a>15595       }
<a name="l15596"></a>15596       sesymself(checksh);
<a name="l15597"></a>15597     }
<a name="l15598"></a>15598   }
<a name="l15599"></a>15599   <span class="keywordflow">if</span> (remcount &gt; 0) {
<a name="l15600"></a>15600     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l15601"></a>15601       printf(<span class="stringliteral">&quot;    Removed %d subfaces from CBC(p).\n&quot;</span>, remcount);
<a name="l15602"></a>15602     }
<a name="l15603"></a>15603     <span class="comment">// Re-generate C(p).</span>
<a name="l15604"></a>15604     subceillist-&gt;clear();
<a name="l15605"></a>15605     <span class="keywordflow">for</span> (i = 0; i &lt; sublist-&gt;len(); i++) {
<a name="l15606"></a>15606       checksh = * (face *)(* sublist)[i];
<a name="l15607"></a>15607       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l15608"></a>15608         spivot(checksh, neighsh);
<a name="l15609"></a>15609         <span class="keywordflow">if</span> (!sinfected(neighsh)) {
<a name="l15610"></a>15610           subceillist-&gt;append(&amp;checksh);
<a name="l15611"></a>15611         }
<a name="l15612"></a>15612         senextself(checksh);
<a name="l15613"></a>15613       }
<a name="l15614"></a>15614     }
<a name="l15615"></a>15615     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l15616"></a>15616       printf(<span class="stringliteral">&quot;    Update CBC(p): %d subs, %d edges.\n&quot;</span>, sublist-&gt;len(),
<a name="l15617"></a>15617              subceillist-&gt;len());
<a name="l15618"></a>15618     }
<a name="l15619"></a>15619   }
<a name="l15620"></a>15620 
<a name="l15621"></a>15621   <span class="comment">// Check the validity of C(p).</span>
<a name="l15622"></a>15622   <span class="keywordflow">for</span> (i = 0; i &lt; subceillist-&gt;len(); i++) {
<a name="l15623"></a>15623     checksh = * (face *)(* subceillist)[i];
<a name="l15624"></a>15624     sspivot(checksh, checkseg);
<a name="l15625"></a>15625     <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l15626"></a>15626       <span class="comment">// A segment. Check if it is inside BC(p).</span>
<a name="l15627"></a>15627       stpivot(checksh, adjtet);
<a name="l15628"></a>15628       <span class="keywordflow">if</span> (adjtet.tet == dummytet) {
<a name="l15629"></a>15629         sesym(checksh, neighsh);
<a name="l15630"></a>15630         stpivot(neighsh, adjtet);
<a name="l15631"></a>15631       }
<a name="l15632"></a>15632       findedge(&amp;adjtet, sorg(checkseg), sdest(checkseg));
<a name="l15633"></a>15633       adjustedgering(adjtet, CCW);
<a name="l15634"></a>15634       fnext(adjtet, rotface); <span class="comment">// It&#39;s the same tet.</span>
<a name="l15635"></a>15635       <span class="comment">// Rotate rotface (f), stop on either of the following cases:</span>
<a name="l15636"></a>15636       <span class="comment">//   (a) meet a subface, or</span>
<a name="l15637"></a>15637       <span class="comment">//   (b) enter an uninfected tet, or</span>
<a name="l15638"></a>15638       <span class="comment">//   (c) rewind back to adjtet.</span>
<a name="l15639"></a>15639       <span class="keywordflow">do</span> {
<a name="l15640"></a>15640         <span class="keywordflow">if</span> (!infected(rotface)) <span class="keywordflow">break</span>; <span class="comment">// case (b)</span>
<a name="l15641"></a>15641         tspivot(rotface, neighsh);
<a name="l15642"></a>15642         <span class="keywordflow">if</span> (neighsh.sh != dummysh) <span class="keywordflow">break</span>; <span class="comment">// case (a)</span>
<a name="l15643"></a>15643         <span class="comment">// Go to the next tet of the facing ring.</span>
<a name="l15644"></a>15644         fnextself(rotface);
<a name="l15645"></a>15645       } <span class="keywordflow">while</span> (apex(rotface) != apex(adjtet));
<a name="l15646"></a>15646       <span class="comment">// Is it case (c)?</span>
<a name="l15647"></a>15647       <span class="keywordflow">if</span> (apex(rotface) == apex(adjtet)) {
<a name="l15648"></a>15648         <span class="comment">// The segment is enclosed by BC(p), invalid cavity.</span>
<a name="l15649"></a>15649         pa = org(adjtet);
<a name="l15650"></a>15650         pb = dest(adjtet);
<a name="l15651"></a>15651         pc = apex(adjtet);
<a name="l15652"></a>15652         <span class="comment">// Find the shield tet and cut it. Notice that the shield tet may</span>
<a name="l15653"></a>15653         <span class="comment">//   not be unique when there are four coplanar points, ie.,</span>
<a name="l15654"></a>15654         <span class="comment">//   ori1 * ori2 == 0.0. In such case, choose either of them.</span>
<a name="l15655"></a>15655         fnext(adjtet, rotface);
<a name="l15656"></a>15656         <span class="keywordflow">do</span> {
<a name="l15657"></a>15657           fnextself(rotface);
<a name="l15658"></a>15658           assert(infected(rotface));
<a name="l15659"></a>15659           ori1 = orient3d(pa, pb, pc, apex(rotface));
<a name="l15660"></a>15660           ori2 = orient3d(pa, pb, pc, oppo(rotface));
<a name="l15661"></a>15661         } <span class="keywordflow">while</span> (ori1 * ori2 &gt; 0.0);
<a name="l15662"></a>15662         <span class="comment">// Cut this tet from BC(p).</span>
<a name="l15663"></a>15663         uninfect(rotface);
<a name="l15664"></a>15664         (*cutcount)++;
<a name="l15665"></a>15665       }
<a name="l15666"></a>15666     } <span class="keywordflow">else</span> {
<a name="l15667"></a>15667       <span class="comment">/*// An edge. Check if boundary-consistency should be enforced.</span>
<a name="l15668"></a>15668 <span class="comment">      if (b-&gt;conformdel &gt; 0) {</span>
<a name="l15669"></a>15669 <span class="comment">        // Get the adj-sub n at e, it must be outside C(p).</span>
<a name="l15670"></a>15670 <span class="comment">        spivot(checksh, neighsh);</span>
<a name="l15671"></a>15671 <span class="comment">        assert(!sinfected(neighsh));</span>
<a name="l15672"></a>15672 <span class="comment">        // Check if n is on B(p).</span>
<a name="l15673"></a>15673 <span class="comment">        for (j = 0; j &lt; 2; j++) {</span>
<a name="l15674"></a>15674 <span class="comment">          stpivot(neighsh, adjtet);</span>
<a name="l15675"></a>15675 <span class="comment">          if (adjtet.tet != dummytet) {</span>
<a name="l15676"></a>15676 <span class="comment">            if (infected(adjtet)) {</span>
<a name="l15677"></a>15677 <span class="comment">              uninfect(adjtet);</span>
<a name="l15678"></a>15678 <span class="comment">              (*cutcount)++;</span>
<a name="l15679"></a>15679 <span class="comment">            }</span>
<a name="l15680"></a>15680 <span class="comment">          }</span>
<a name="l15681"></a>15681 <span class="comment">          sesymself(neighsh);</span>
<a name="l15682"></a>15682 <span class="comment">        }</span>
<a name="l15683"></a>15683 <span class="comment">      } */</span>
<a name="l15684"></a>15684     }
<a name="l15685"></a>15685   }
<a name="l15686"></a>15686 }
<a name="l15687"></a>15687 
<a name="l15689"></a>15689 <span class="comment">//                                                                           //</span>
<a name="l15690"></a>15690 <span class="comment">// trimbowatcavity()    Validate B(p), CBC(p)s and C(p)s, update BC(p).      //</span>
<a name="l15691"></a>15691 <span class="comment">//                                                                           //</span>
<a name="l15692"></a>15692 <span class="comment">// A B(p) is valid if all its faces are visible by p. If a face f of B(p) is //</span>
<a name="l15693"></a>15693 <span class="comment">// found invisible by p, the tet of BC(p) containing f gets removed and B(p) //</span>
<a name="l15694"></a>15694 <span class="comment">// is refromed. The new B(p) may still contain invisible faces by p. Iterat- //</span>
<a name="l15695"></a>15695 <span class="comment">// ively do the above procedure until B(p) is satisfied.                     //</span>
<a name="l15696"></a>15696 <span class="comment">//                                                                           //</span>
<a name="l15697"></a>15697 <span class="comment">// A CBC(p) is valid if each subface of CBC(p) is either on the hull of BC(p)//</span>
<a name="l15698"></a>15698 <span class="comment">// or completely inside BC(p). If a subface s of CBC(p) is not valid, it is  //</span>
<a name="l15699"></a>15699 <span class="comment">// removed from CBC(p) and C(p) is reformed. If there exists a tet t of BC(p)//</span>
<a name="l15700"></a>15700 <span class="comment">// containg s, t is removed from BC(p). The process for validating BC(p) and //</span>
<a name="l15701"></a>15701 <span class="comment">// B(p) is re-excuted.                                                       //</span>
<a name="l15702"></a>15702 <span class="comment">//                                                                           //</span>
<a name="l15703"></a>15703 <span class="comment">// A C(p) is valid if each edge of C(p) is on the hull of BC(p). If an edge  //</span>
<a name="l15704"></a>15704 <span class="comment">// e of C(p) is invalid (e should be a subsegment which only belong to one   //</span>
<a name="l15705"></a>15705 <span class="comment">// facet), a tet of BC(p) which contains e and has two other faces shielding //</span>
<a name="l15706"></a>15706 <span class="comment">// e is removed. The process for validating BC(p) and B(p) is re-excuted.    //</span>
<a name="l15707"></a>15707 <span class="comment">//                                                                           //</span>
<a name="l15708"></a>15708 <span class="comment">// If either BC(p) or CBC(p) becomes empty. No valid BC(p) is found, return  //</span>
<a name="l15709"></a>15709 <span class="comment">// FALSE. else, return TRUE.                                                 //</span>
<a name="l15710"></a>15710 <span class="comment">//                                                                           //</span>
<a name="l15712"></a>15712 <span class="comment"></span>
<a name="l15713"></a>15713 <span class="keywordtype">bool</span> tetgenmesh::trimbowatcavity(point bp, face* bpseg, <span class="keywordtype">int</span> n, list** sublists,
<a name="l15714"></a>15714   list** subceillists, list** tetlists, list** ceillists, REAL maxcosd)
<a name="l15715"></a>15715 {
<a name="l15716"></a>15716   <span class="keywordtype">bool</span> valflag;
<a name="l15717"></a>15717   <span class="keywordtype">int</span> oldnum, cutnum, cutcount;
<a name="l15718"></a>15718   <span class="keywordtype">int</span> i;
<a name="l15719"></a>15719 
<a name="l15720"></a>15720   cutnum = 0; <span class="comment">// Count the total number of cut-off tets of BC(p).</span>
<a name="l15721"></a>15721   valflag = <span class="keyword">true</span>;
<a name="l15722"></a>15722 
<a name="l15723"></a>15723   <span class="keywordflow">do</span> {
<a name="l15724"></a>15724     <span class="comment">// Validate BC(p), B(p).</span>
<a name="l15725"></a>15725     <span class="keywordflow">for</span> (i = 0; i &lt; n &amp;&amp; valflag; i++) {
<a name="l15726"></a>15726       oldnum = tetlists[i]-&gt;len();
<a name="l15727"></a>15727       <span class="comment">// Iteratively validate BC_i(p) and B_i(p).</span>
<a name="l15728"></a>15728       <span class="keywordflow">while</span> (!validatebowatcavityquad(bp, ceillists[i], maxcosd)) {
<a name="l15729"></a>15729         <span class="comment">// Update BC_i(p) and B_i(p).</span>
<a name="l15730"></a>15730         updatebowatcavityquad(tetlists[i], ceillists[i]);
<a name="l15731"></a>15731         valflag = tetlists[i]-&gt;len() &gt; 0;
<a name="l15732"></a>15732       }
<a name="l15733"></a>15733       cutnum += (oldnum - tetlists[i]-&gt;len());
<a name="l15734"></a>15734     }
<a name="l15735"></a>15735     <span class="keywordflow">if</span> (valflag &amp;&amp; (sublists != (list **) NULL)) {
<a name="l15736"></a>15736       <span class="comment">// Validate CBC(p), C(p).</span>
<a name="l15737"></a>15737       cutcount = 0;
<a name="l15738"></a>15738       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l15739"></a>15739         updatebowatcavitysub(sublists[i], subceillists[i], &amp;cutcount);
<a name="l15740"></a>15740         <span class="comment">// Only do once if p is on a facet.</span>
<a name="l15741"></a>15741         <span class="keywordflow">if</span> (bpseg == (face *) NULL) <span class="keywordflow">break</span>;
<a name="l15742"></a>15742       }
<a name="l15743"></a>15743       <span class="comment">// Are there cut tets?</span>
<a name="l15744"></a>15744       <span class="keywordflow">if</span> (cutcount &gt; 0) {
<a name="l15745"></a>15745         <span class="comment">// Squeeze all cut tets in BC(p), keep valflag once it gets FLASE.</span>
<a name="l15746"></a>15746         <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l15747"></a>15747           <span class="keywordflow">if</span> (tetlists[i]-&gt;len() &gt; 0) {
<a name="l15748"></a>15748             updatebowatcavityquad(tetlists[i], ceillists[i]);
<a name="l15749"></a>15749             <span class="keywordflow">if</span> (valflag) {
<a name="l15750"></a>15750               valflag = tetlists[i]-&gt;len() &gt; 0;
<a name="l15751"></a>15751             }
<a name="l15752"></a>15752           }
<a name="l15753"></a>15753         }
<a name="l15754"></a>15754         cutnum += cutcount;
<a name="l15755"></a>15755         <span class="comment">// Go back to valid the updated BC(p).</span>
<a name="l15756"></a>15756         <span class="keywordflow">continue</span>;
<a name="l15757"></a>15757       }
<a name="l15758"></a>15758     }
<a name="l15759"></a>15759     <span class="keywordflow">break</span>; <span class="comment">// Leave the while-loop.</span>
<a name="l15760"></a>15760   } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l15761"></a>15761 
<a name="l15762"></a>15762   <span class="comment">// Check if any CBC(p) becomes non-empty.</span>
<a name="l15763"></a>15763   <span class="keywordflow">if</span> (valflag &amp;&amp; (sublists != (list **) NULL)) {
<a name="l15764"></a>15764     <span class="keywordflow">for</span> (i = 0; i &lt; n &amp;&amp; valflag; i++) {
<a name="l15765"></a>15765       valflag = (sublists[i]-&gt;len() &gt; 0);
<a name="l15766"></a>15766       <span class="keywordflow">if</span> (bpseg == (face *) NULL) <span class="keywordflow">break</span>;
<a name="l15767"></a>15767     }
<a name="l15768"></a>15768   }
<a name="l15769"></a>15769 
<a name="l15770"></a>15770   <span class="keywordflow">if</span> (valflag &amp;&amp; (cutnum &gt; 0)) {
<a name="l15771"></a>15771     <span class="comment">// Accumulate counters.</span>
<a name="l15772"></a>15772     <span class="keywordflow">if</span> (bpseg != (face *) NULL) {
<a name="l15773"></a>15773       updsegcount++;
<a name="l15774"></a>15774     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sublists != (list **) NULL) {
<a name="l15775"></a>15775       updsubcount++;
<a name="l15776"></a>15776     } <span class="keywordflow">else</span> {
<a name="l15777"></a>15777       updvolcount++;
<a name="l15778"></a>15778     }
<a name="l15779"></a>15779   }
<a name="l15780"></a>15780 
<a name="l15781"></a>15781   <span class="keywordflow">if</span> (!valflag) {
<a name="l15782"></a>15782     <span class="comment">// Accumulate counters.</span>
<a name="l15783"></a>15783     <span class="keywordflow">if</span> (bpseg != (face *) NULL) {
<a name="l15784"></a>15784       failsegcount++;
<a name="l15785"></a>15785     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sublists != (list **) NULL) {
<a name="l15786"></a>15786       failsubcount++;
<a name="l15787"></a>15787     } <span class="keywordflow">else</span> {
<a name="l15788"></a>15788       failvolcount++;
<a name="l15789"></a>15789     }
<a name="l15790"></a>15790   }
<a name="l15791"></a>15791 
<a name="l15792"></a>15792   <span class="keywordflow">return</span> valflag;
<a name="l15793"></a>15793 }
<a name="l15794"></a>15794 
<a name="l15796"></a>15796 <span class="comment">//                                                                           //</span>
<a name="l15797"></a>15797 <span class="comment">// bowatinsertsite()    Insert a point using the Bowyer-Watson method.       //</span>
<a name="l15798"></a>15798 <span class="comment">//                                                                           //</span>
<a name="l15799"></a>15799 <span class="comment">// Parameters: &#39;bp&#39; = p, &#39;splitseg&#39; = S, &#39;n&#39; = the number of quadrants,      //</span>
<a name="l15800"></a>15800 <span class="comment">// &#39;sublists&#39;, an array of CBC_i(p)s, &#39;subceillists&#39;, an array of C_i(p)s,   //</span>
<a name="l15801"></a>15801 <span class="comment">// &#39;tetlists&#39;, an array of BC_i(p)s, &#39;ceillists&#39;, an array of B_i(p)s.       //</span>
<a name="l15802"></a>15802 <span class="comment">//                                                                           //</span>
<a name="l15803"></a>15803 <span class="comment">// If p is inside the mesh domain, then S = NULL, n = 1, CBC(p) and C(p) are //</span>
<a name="l15804"></a>15804 <span class="comment">//   NULLs. &#39;tetlists[0]&#39; = BC(p), &#39;ceillists[0]&#39; = B(p).                    //</span>
<a name="l15805"></a>15805 <span class="comment">// If p is on a facet F, then S = NULL, n = 2, and &#39;subceillists[0]&#39; = C(p), //</span>
<a name="l15806"></a>15806 <span class="comment">//  &#39;subceillists[1]&#39; is not needed (set it to NULL). B_1(p) and B_2(p) are  //</span>
<a name="l15807"></a>15807 <span class="comment">//  in &#39;ceillists[0]&#39; and &#39;ceillists[1]&#39;.                                    //</span>
<a name="l15808"></a>15808 <span class="comment">// If p is on a segment S, then F(S) is a list of subfaces around S, and n = //</span>
<a name="l15809"></a>15809 <span class="comment">//   len(F(S)), there are n C_i(p)s and B_i(p)s supplied in &#39;subceillists[i]&#39;//</span>
<a name="l15810"></a>15810 <span class="comment">//   and &#39;ceillists[i]&#39;.                                                     //</span>
<a name="l15811"></a>15811 <span class="comment">//                                                                           //</span>
<a name="l15812"></a>15812 <span class="comment">// If &#39;verlist&#39; != NULL, it returns a list of vertices which connect to p.   //</span>
<a name="l15813"></a>15813 <span class="comment">//   This vertices are used for interpolating size of p.                     //</span>
<a name="l15814"></a>15814 <span class="comment">//                                                                           //</span>
<a name="l15815"></a>15815 <span class="comment">// If &#39;flipque&#39; != NULL, it returns a list of internal faces of new tets in  //</span>
<a name="l15816"></a>15816 <span class="comment">//   BC(p), faces on C(p)s are excluded. These faces may be locally non-     //</span>
<a name="l15817"></a>15817 <span class="comment">//   Delaunay and will be flipped if they are flippable. Such non-Delaunay   //</span>
<a name="l15818"></a>15818 <span class="comment">//   faces may exist when p is inserted to split an encroaching segment.     //</span>
<a name="l15819"></a>15819 <span class="comment">//                                                                           //</span>
<a name="l15820"></a>15820 <span class="comment">// &#39;chkencseg&#39;, &#39;chkencsub&#39;, and &#39;chkbadtet&#39; are flags that indicate whether //</span>
<a name="l15821"></a>15821 <span class="comment">// or not there should be checks for the creation of encroached subsegments, //</span>
<a name="l15822"></a>15822 <span class="comment">// subfaces, or bad quality tets. If &#39;chkencseg&#39; = TRUE, the encroached sub- //</span>
<a name="l15823"></a>15823 <span class="comment">// segments are added to the list of subsegments to be split.                //</span>
<a name="l15824"></a>15824 <span class="comment">//                                                                           //</span>
<a name="l15825"></a>15825 <span class="comment">// On return, &#39;ceillists&#39; returns Star(p).                                   //</span>
<a name="l15826"></a>15826 <span class="comment">//                                                                           //</span>
<a name="l15828"></a>15828 <span class="comment"></span>
<a name="l15829"></a>15829 <span class="keywordtype">void</span> tetgenmesh::bowatinsertsite(point bp,face* splitseg,<span class="keywordtype">int</span> n,list** sublists,
<a name="l15830"></a>15830   list** subceillists, list** tetlists, list** ceillists, list* verlist,
<a name="l15831"></a>15831   queue* flipque, <span class="keywordtype">bool</span> chkencseg, <span class="keywordtype">bool</span> chkencsub, <span class="keywordtype">bool</span> chkbadtet)
<a name="l15832"></a>15832 {
<a name="l15833"></a>15833   list *ceillist, *subceillist;
<a name="l15834"></a>15834   triface oldtet, newtet, newface, rotface, neightet;
<a name="l15835"></a>15835   face oldsh, newsh, newedge, checksh;
<a name="l15836"></a>15836   face spinsh, casingin, casingout;
<a name="l15837"></a>15837   face *apsegshs, *pbsegshs;
<a name="l15838"></a>15838   face apseg, pbseg, checkseg;
<a name="l15839"></a>15839   point pa, pb, pc;
<a name="l15840"></a>15840   REAL attrib, volume;
<a name="l15841"></a>15841   <span class="keywordtype">int</span> idx, i, j, k;
<a name="l15842"></a>15842 
<a name="l15843"></a>15843   apsegshs = NULL;
<a name="l15844"></a>15844   pbsegshs = NULL;
<a name="l15845"></a>15845 
<a name="l15846"></a>15846   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l15847"></a>15847     printf(<span class="stringliteral">&quot;    Insert point %d (%.12g, %.12g, %.12g)&quot;</span>, pointmark(bp), bp[0],
<a name="l15848"></a>15848            bp[1], bp[2]);
<a name="l15849"></a>15849   }
<a name="l15850"></a>15850   <span class="keywordflow">if</span> (splitseg != (face *) NULL) {
<a name="l15851"></a>15851     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l15852"></a>15852       printf(<span class="stringliteral">&quot; on segment.\n&quot;</span>);
<a name="l15853"></a>15853     }
<a name="l15854"></a>15854     bowatsegcount++;
<a name="l15855"></a>15855   } <span class="keywordflow">else</span> {
<a name="l15856"></a>15856     <span class="keywordflow">if</span> (subceillists != (list **) NULL) {
<a name="l15857"></a>15857       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l15858"></a>15858         printf(<span class="stringliteral">&quot; on facet.\n&quot;</span>);
<a name="l15859"></a>15859       }
<a name="l15860"></a>15860       bowatsubcount++;
<a name="l15861"></a>15861     } <span class="keywordflow">else</span> {
<a name="l15862"></a>15862       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l15863"></a>15863         printf(<span class="stringliteral">&quot; in volume.\n&quot;</span>);
<a name="l15864"></a>15864       }
<a name="l15865"></a>15865       bowatvolcount++;
<a name="l15866"></a>15866     }
<a name="l15867"></a>15867   }
<a name="l15868"></a>15868 
<a name="l15869"></a>15869   <span class="comment">// Create new tets to fill B(p).</span>
<a name="l15870"></a>15870   <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l15871"></a>15871     <span class="comment">// Create new tets from each B_i(p).</span>
<a name="l15872"></a>15872     ceillist = ceillists[k];
<a name="l15873"></a>15873     <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l15874"></a>15874       oldtet = * (triface *)(* ceillist)[i];
<a name="l15875"></a>15875       adjustedgering(oldtet, CCW);
<a name="l15876"></a>15876       pa = org(oldtet);
<a name="l15877"></a>15877       pb = dest(oldtet);
<a name="l15878"></a>15878       pc = apex(oldtet);
<a name="l15879"></a>15879       maketetrahedron(&amp;newtet);
<a name="l15880"></a>15880       setorg(newtet, pa);
<a name="l15881"></a>15881       setdest(newtet, pb);
<a name="l15882"></a>15882       setapex(newtet, pc);
<a name="l15883"></a>15883       setoppo(newtet, bp);
<a name="l15884"></a>15884       <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberoftetrahedronattributes; j++) {
<a name="l15885"></a>15885         attrib = elemattribute(oldtet.tet, j);
<a name="l15886"></a>15886         setelemattribute(newtet.tet, j, attrib);
<a name="l15887"></a>15887       }
<a name="l15888"></a>15888       <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l15889"></a>15889         volume = volumebound(oldtet.tet);
<a name="l15890"></a>15890         <span class="keywordflow">if</span> (volume &gt; 0.0) {
<a name="l15891"></a>15891           <span class="keywordflow">if</span> (!b-&gt;fixedvolume &amp;&amp; b-&gt;refine) {
<a name="l15892"></a>15892             <span class="comment">// &#39;-r -a&#39; switches and a .vol file case. Enlarge the maximum</span>
<a name="l15893"></a>15893             <span class="comment">//   volume constraint for the new tets. Hence the new points</span>
<a name="l15894"></a>15894             <span class="comment">//   only spread near the original constrained tet.</span>
<a name="l15895"></a>15895             volume *= 1.2;
<a name="l15896"></a>15896           }
<a name="l15897"></a>15897         }
<a name="l15898"></a>15898         setvolumebound(newtet.tet, volume);
<a name="l15899"></a>15899       }
<a name="l15900"></a>15900       sym(oldtet, neightet);
<a name="l15901"></a>15901       tspivot(oldtet, checksh);
<a name="l15902"></a>15902       <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l15903"></a>15903         bond(newtet, neightet);
<a name="l15904"></a>15904       }
<a name="l15905"></a>15905       <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l15906"></a>15906         tsbond(newtet, checksh);
<a name="l15907"></a>15907       }
<a name="l15908"></a>15908       <span class="keywordflow">if</span> (verlist != (list *) NULL) {
<a name="l15909"></a>15909         <span class="comment">// Collect vertices connecting to p.</span>
<a name="l15910"></a>15910         idx = pointmark(pa);
<a name="l15911"></a>15911         <span class="keywordflow">if</span> (idx &gt;= 0) {
<a name="l15912"></a>15912           setpointmark(pa, -idx - 1);
<a name="l15913"></a>15913           verlist-&gt;append(&amp;pa);
<a name="l15914"></a>15914         }
<a name="l15915"></a>15915         idx = pointmark(pb);
<a name="l15916"></a>15916         <span class="keywordflow">if</span> (idx &gt;= 0) {
<a name="l15917"></a>15917           setpointmark(pb, -idx - 1);
<a name="l15918"></a>15918           verlist-&gt;append(&amp;pb);
<a name="l15919"></a>15919         }
<a name="l15920"></a>15920         idx = pointmark(pc);
<a name="l15921"></a>15921         <span class="keywordflow">if</span> (idx &gt;= 0) {
<a name="l15922"></a>15922           setpointmark(pc, -idx - 1);
<a name="l15923"></a>15923           verlist-&gt;append(&amp;pc);
<a name="l15924"></a>15924         }
<a name="l15925"></a>15925       }
<a name="l15926"></a>15926       <span class="comment">// Replace the tet by the newtet for checking the quality.</span>
<a name="l15927"></a>15927       * (triface *)(* ceillist)[i] = newtet;
<a name="l15928"></a>15928     }
<a name="l15929"></a>15929   }
<a name="l15930"></a>15930   <span class="keywordflow">if</span> (verlist != (list *) NULL) {
<a name="l15931"></a>15931     <span class="comment">// Uninfect collected vertices.</span>
<a name="l15932"></a>15932     <span class="keywordflow">for</span> (i = 0; i &lt; verlist-&gt;len(); i++) {
<a name="l15933"></a>15933       pa = * (point *)(* verlist)[i];
<a name="l15934"></a>15934       idx = pointmark(pa);
<a name="l15935"></a>15935       setpointmark(pa, -(idx + 1));
<a name="l15936"></a>15936     }
<a name="l15937"></a>15937   }
<a name="l15938"></a>15938 
<a name="l15939"></a>15939   <span class="comment">// Connect new tets of B(p). Not all faces of new tets can be connected,</span>
<a name="l15940"></a>15940   <span class="comment">//   e.g., if there are empty B_i(p)s.</span>
<a name="l15941"></a>15941   <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l15942"></a>15942     ceillist = ceillists[k];
<a name="l15943"></a>15943     <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l15944"></a>15944       newtet = * (triface *)(* ceillist)[i];
<a name="l15945"></a>15945       newtet.ver = 0;
<a name="l15946"></a>15946       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l15947"></a>15947         fnext(newtet, newface);
<a name="l15948"></a>15948         sym(newface, neightet);
<a name="l15949"></a>15949         <span class="keywordflow">if</span> (neightet.tet == dummytet) {
<a name="l15950"></a>15950           <span class="comment">// Find the neighbor face by rotating the faces at edge ab.</span>
<a name="l15951"></a>15951           esym(newtet, rotface);
<a name="l15952"></a>15952           pa = org(rotface);
<a name="l15953"></a>15953           pb = dest(rotface);
<a name="l15954"></a>15954           <span class="keywordflow">while</span> (fnextself(rotface));
<a name="l15955"></a>15955           <span class="comment">// Do we meet a boundary face?</span>
<a name="l15956"></a>15956           tspivot(rotface, checksh);
<a name="l15957"></a>15957           <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l15958"></a>15958             <span class="comment">// Walk through the boundary and continue to rotate faces.</span>
<a name="l15959"></a>15959             <span class="keywordflow">do</span> {
<a name="l15960"></a>15960               findedge(&amp;checksh, pa, pb);
<a name="l15961"></a>15961               sfnextself(checksh);
<a name="l15962"></a>15962               assert((sorg(checksh) == pa) &amp;&amp; (sdest(checksh) == pb));
<a name="l15963"></a>15963               stpivot(checksh, rotface);
<a name="l15964"></a>15964               <span class="keywordflow">if</span> (infected(rotface)) {
<a name="l15965"></a>15965                 <span class="comment">// Meet an old tet of B_i(p). This side is on the hull and</span>
<a name="l15966"></a>15966                 <span class="comment">//   will be connected to a new subface created in C(p).</span>
<a name="l15967"></a>15967                 <span class="keywordflow">break</span>;
<a name="l15968"></a>15968               }
<a name="l15969"></a>15969               findedge(&amp;rotface, pa, pb);
<a name="l15970"></a>15970               <span class="keywordflow">while</span> (fnextself(rotface));
<a name="l15971"></a>15971               tspivot(rotface, checksh);
<a name="l15972"></a>15972             } <span class="keywordflow">while</span> (checksh.sh != dummysh);
<a name="l15973"></a>15973           }
<a name="l15974"></a>15974           <span class="comment">// The rotface has edge ab, but it may not have newpt.</span>
<a name="l15975"></a>15975           <span class="keywordflow">if</span> (apex(rotface) == apex(newface)) {
<a name="l15976"></a>15976             <span class="comment">// Bond the two tets together.</span>
<a name="l15977"></a>15977             bond(newface, rotface);
<a name="l15978"></a>15978             <span class="comment">// Queue (uniquely) this face if &#39;flipque&#39; is given.</span>
<a name="l15979"></a>15979             <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l15980"></a>15980               enqueueflipface(newface, flipque);
<a name="l15981"></a>15981             }
<a name="l15982"></a>15982           }
<a name="l15983"></a>15983         }
<a name="l15984"></a>15984         enextself(newtet);
<a name="l15985"></a>15985       }
<a name="l15986"></a>15986     }
<a name="l15987"></a>15987   }
<a name="l15988"></a>15988 
<a name="l15989"></a>15989   <span class="keywordflow">if</span> (subceillists != (list **) NULL) {
<a name="l15990"></a>15990     <span class="comment">// There are C(p)s.</span>
<a name="l15991"></a>15991     <span class="keywordflow">if</span> (splitseg != (face *) NULL) {
<a name="l15992"></a>15992       <span class="comment">// S (ab) is split by p.</span>
<a name="l15993"></a>15993       splitseg-&gt;shver = 0;
<a name="l15994"></a>15994       pa = sorg(*splitseg);
<a name="l15995"></a>15995       pb = sdest(*splitseg);
<a name="l15996"></a>15996       <span class="comment">// Allcate two arrays for saving the subface rings of the two new</span>
<a name="l15997"></a>15997       <span class="comment">//   segments a-&gt;p and p-&gt;b.</span>
<a name="l15998"></a>15998       apsegshs = <span class="keyword">new</span> face[n];
<a name="l15999"></a>15999       pbsegshs = <span class="keyword">new</span> face[n];
<a name="l16000"></a>16000     }
<a name="l16001"></a>16001 
<a name="l16002"></a>16002     <span class="comment">// For each C_k(p), do the following:</span>
<a name="l16003"></a>16003     <span class="comment">//   (1) Create new subfaces to fill C_k(p), insert them into B(p);</span>
<a name="l16004"></a>16004     <span class="comment">//   (2) Connect new subfaces to each other;</span>
<a name="l16005"></a>16005     <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l16006"></a>16006       subceillist = subceillists[k];
<a name="l16007"></a>16007 
<a name="l16008"></a>16008       <span class="comment">// Check if &#39;hullsize&#39; should be updated.</span>
<a name="l16009"></a>16009       oldsh = * (face *)(* subceillist)[0];
<a name="l16010"></a>16010       stpivot(oldsh, neightet);
<a name="l16011"></a>16011       <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l16012"></a>16012         sesymself(oldsh);
<a name="l16013"></a>16013         stpivot(oldsh, neightet);
<a name="l16014"></a>16014       }
<a name="l16015"></a>16015       <span class="keywordflow">if</span> (neightet.tet == dummytet) {
<a name="l16016"></a>16016         <span class="comment">// The hull size changes.</span>
<a name="l16017"></a>16017         hullsize += (subceillist-&gt;len() - sublists[k]-&gt;len());
<a name="l16018"></a>16018       }
<a name="l16019"></a>16019 
<a name="l16020"></a>16020       <span class="comment">// (1) Create new subfaces to fill C_k(p), insert them into B(p).</span>
<a name="l16021"></a>16021       <span class="keywordflow">for</span> (i = 0; i &lt; subceillist-&gt;len(); i++) {
<a name="l16022"></a>16022         oldsh = * (face *)(* subceillist)[i];
<a name="l16023"></a>16023         makeshellface(subfaces, &amp;newsh);
<a name="l16024"></a>16024         setsorg(newsh, sorg(oldsh));
<a name="l16025"></a>16025         setsdest(newsh, sdest(oldsh));
<a name="l16026"></a>16026         setsapex(newsh, bp);
<a name="l16027"></a>16027         <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l16028"></a>16028           setareabound(newsh, areabound(oldsh));
<a name="l16029"></a>16029         }
<a name="l16030"></a>16030         setshellmark(newsh, shellmark(oldsh));
<a name="l16031"></a>16031         setshelltype(newsh, shelltype(oldsh));
<a name="l16032"></a>16032         <span class="keywordflow">if</span> (checkpbcs) {
<a name="l16033"></a>16033           setshellpbcgroup(newsh, shellpbcgroup(oldsh));
<a name="l16034"></a>16034         }
<a name="l16035"></a>16035         <span class="comment">// Replace oldsh by newsh at the edge.</span>
<a name="l16036"></a>16036         spivot(oldsh, casingout);
<a name="l16037"></a>16037         sspivot(oldsh, checkseg);
<a name="l16038"></a>16038         <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l16039"></a>16039           <span class="comment">// A segment. Insert s into the face ring, ie, s_in -&gt; s -&gt; s_out.</span>
<a name="l16040"></a>16040           <span class="keywordflow">if</span> (oldsh.sh != casingout.sh) {
<a name="l16041"></a>16041             <span class="comment">// s is not bonded to itself.</span>
<a name="l16042"></a>16042             spinsh = casingout;
<a name="l16043"></a>16043             <span class="keywordflow">do</span> {
<a name="l16044"></a>16044               casingin = spinsh;
<a name="l16045"></a>16045               spivotself(spinsh);
<a name="l16046"></a>16046             } <span class="keywordflow">while</span> (sapex(spinsh) != sapex(oldsh));
<a name="l16047"></a>16047             assert(casingin.sh != oldsh.sh);
<a name="l16048"></a>16048             <span class="comment">// Bond s_in -&gt; s -&gt; s_out (and dissolve s_in -&gt; s_old -&gt; s_out).</span>
<a name="l16049"></a>16049             sbond1(casingin, newsh);
<a name="l16050"></a>16050             sbond1(newsh, casingout);
<a name="l16051"></a>16051           } <span class="keywordflow">else</span> {
<a name="l16052"></a>16052             <span class="comment">// Bond newsh -&gt; newsh.</span>
<a name="l16053"></a>16053             sbond(newsh, newsh);
<a name="l16054"></a>16054           }
<a name="l16055"></a>16055           <span class="comment">// Bond the segment.</span>
<a name="l16056"></a>16056           ssbond(newsh, checkseg);
<a name="l16057"></a>16057         } <span class="keywordflow">else</span> {
<a name="l16058"></a>16058           <span class="comment">// Bond s &lt;-&gt; s_out (and dissolve s_out -&gt; s_old).</span>
<a name="l16059"></a>16059           sbond(newsh, casingout);
<a name="l16060"></a>16060         }
<a name="l16061"></a>16061 
<a name="l16062"></a>16062         <span class="comment">// Insert newsh into B(p). Use the coonections of oldsh.</span>
<a name="l16063"></a>16063         stpivot(oldsh, neightet);
<a name="l16064"></a>16064         <span class="keywordflow">if</span> (neightet.tet == dummytet) {
<a name="l16065"></a>16065           sesymself(oldsh);
<a name="l16066"></a>16066           sesymself(newsh); <span class="comment">// Keep the same orientation as oldsh.</span>
<a name="l16067"></a>16067           stpivot(oldsh, neightet);
<a name="l16068"></a>16068         }
<a name="l16069"></a>16069         assert(infected(neightet));
<a name="l16070"></a>16070         <span class="comment">// Set on the rotating edge.</span>
<a name="l16071"></a>16071         findedge(&amp;neightet, sorg(oldsh), sdest(oldsh));
<a name="l16072"></a>16072         <span class="comment">// Choose the rotating direction (to the inside of B(p)).</span>
<a name="l16073"></a>16073         adjustedgering(neightet, CCW);
<a name="l16074"></a>16074         rotface = neightet;
<a name="l16075"></a>16075         <span class="comment">// Rotate face. Stop at a non-infected tet t (not in B(p)) or a</span>
<a name="l16076"></a>16076         <span class="comment">//   hull face f (on B(p)). Get the neighbor n of t or f.  n is</span>
<a name="l16077"></a>16077         <span class="comment">//   a new tet that has just been created to fill B(p).</span>
<a name="l16078"></a>16078         <span class="keywordflow">do</span> {
<a name="l16079"></a>16079           fnextself(rotface);
<a name="l16080"></a>16080           sym(rotface, neightet);
<a name="l16081"></a>16081           <span class="keywordflow">if</span> (neightet.tet == dummytet) {
<a name="l16082"></a>16082             tspivot(rotface, checksh);
<a name="l16083"></a>16083             assert(checksh.sh != dummysh);
<a name="l16084"></a>16084             stpivot(checksh, newtet);
<a name="l16085"></a>16085             <span class="keywordflow">break</span>;
<a name="l16086"></a>16086           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!infected(neightet)) {
<a name="l16087"></a>16087             sym(neightet, newtet);
<a name="l16088"></a>16088             <span class="keywordflow">break</span>;
<a name="l16089"></a>16089           }
<a name="l16090"></a>16090         } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l16091"></a>16091         assert(newtet.tet != rotface.tet);
<a name="l16092"></a>16092         <span class="comment">// Set the rotating edge of n.</span>
<a name="l16093"></a>16093         findedge(&amp;newtet, sorg(oldsh), sdest(oldsh));
<a name="l16094"></a>16094         <span class="comment">// Choose the rotating direction (to the inside of B(p)).</span>
<a name="l16095"></a>16095         adjustedgering(newtet, CCW);
<a name="l16096"></a>16096         fnext(newtet, newface);
<a name="l16097"></a>16097         assert(apex(newface) == bp);
<a name="l16098"></a>16098         <span class="comment">// newsh has already been oriented toward n.</span>
<a name="l16099"></a>16099         tsbond(newface, newsh);
<a name="l16100"></a>16100         sym(newface, neightet); <span class="comment">// &#39;neightet&#39; maybe outside.</span>
<a name="l16101"></a>16101         sesymself(newsh);
<a name="l16102"></a>16102         tsbond(neightet, newsh); <span class="comment">// Bond them anyway.</span>
<a name="l16103"></a>16103 
<a name="l16104"></a>16104         <span class="comment">// Replace oldsh by newsh in list.</span>
<a name="l16105"></a>16105         * (face *)(* subceillist)[i] = newsh;
<a name="l16106"></a>16106       }
<a name="l16107"></a>16107 
<a name="l16108"></a>16108       <span class="comment">// (2) Connect new subfaces to each other.</span>
<a name="l16109"></a>16109       <span class="keywordflow">for</span> (i = 0; i &lt; subceillist-&gt;len(); i++) {
<a name="l16110"></a>16110         <span class="comment">// Get a face cdp.</span>
<a name="l16111"></a>16111         newsh = * (face *)(* subceillist)[i];
<a name="l16112"></a>16112         <span class="comment">// Get a new tet containing cdp.</span>
<a name="l16113"></a>16113         stpivot(newsh, newtet);
<a name="l16114"></a>16114         <span class="keywordflow">if</span> (newtet.tet == dummytet) {
<a name="l16115"></a>16115           sesymself(newsh);
<a name="l16116"></a>16116           stpivot(newsh, newtet);
<a name="l16117"></a>16117         }
<a name="l16118"></a>16118         <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l16119"></a>16119           <span class="keywordflow">if</span> (j == 0) {
<a name="l16120"></a>16120             senext(newsh, newedge); <span class="comment">// edge dp.</span>
<a name="l16121"></a>16121           } <span class="keywordflow">else</span> {
<a name="l16122"></a>16122             senext2(newsh, newedge); <span class="comment">// edge pc.</span>
<a name="l16123"></a>16123             sesymself(newedge); <span class="comment">// edge cp.</span>
<a name="l16124"></a>16124           }
<a name="l16125"></a>16125           <span class="keywordflow">if</span> (splitseg != (face *) NULL) {
<a name="l16126"></a>16126             <span class="comment">// Don not operate on newedge if it is ap or pb.</span>
<a name="l16127"></a>16127             <span class="keywordflow">if</span> (sorg(newedge) == pa) {
<a name="l16128"></a>16128               apsegshs[k] = newedge;
<a name="l16129"></a>16129               <span class="keywordflow">continue</span>;
<a name="l16130"></a>16130             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sorg(newedge) == pb) {
<a name="l16131"></a>16131               pbsegshs[k] = newedge;
<a name="l16132"></a>16132               <span class="keywordflow">continue</span>;
<a name="l16133"></a>16133             }
<a name="l16134"></a>16134           }
<a name="l16135"></a>16135           <span class="comment">// There should no segment inside the cavity. Check it.</span>
<a name="l16136"></a>16136           sspivot(newedge, checkseg);
<a name="l16137"></a>16137           assert(checkseg.sh == dummysh);
<a name="l16138"></a>16138           spivot(newedge, casingout);
<a name="l16139"></a>16139           <span class="keywordflow">if</span> (casingout.sh == dummysh) {
<a name="l16140"></a>16140             rotface = newtet;
<a name="l16141"></a>16141             findedge(&amp;rotface, sorg(newedge), sdest(newedge));
<a name="l16142"></a>16142             <span class="comment">// Rotate newtet until meeting a new subface which contains</span>
<a name="l16143"></a>16143             <span class="comment">//   newedge. It must exist since newedge is not a seg.</span>
<a name="l16144"></a>16144             adjustedgering(rotface, CCW);
<a name="l16145"></a>16145             <span class="keywordflow">do</span> {
<a name="l16146"></a>16146               fnextself(rotface);
<a name="l16147"></a>16147               tspivot(rotface, checksh);
<a name="l16148"></a>16148               <span class="keywordflow">if</span> (checksh.sh != dummysh) <span class="keywordflow">break</span>;
<a name="l16149"></a>16149             } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l16150"></a>16150             findedge(&amp;checksh, sorg(newedge), sdest(newedge));
<a name="l16151"></a>16151             sbond(newedge, checksh);
<a name="l16152"></a>16152           }
<a name="l16153"></a>16153         }
<a name="l16154"></a>16154       }
<a name="l16155"></a>16155       <span class="comment">// Only do once if p is on a facet.</span>
<a name="l16156"></a>16156       <span class="keywordflow">if</span> (splitseg == (face *) NULL) <span class="keywordflow">break</span>;
<a name="l16157"></a>16157     } <span class="comment">// for (k = 0; k &lt; n; k++)</span>
<a name="l16158"></a>16158 
<a name="l16159"></a>16159     <span class="keywordflow">if</span> (splitseg != (face *) NULL) {
<a name="l16160"></a>16160       <span class="comment">// Update a-&gt;b to be a-&gt;p.</span>
<a name="l16161"></a>16161       apseg = *splitseg;
<a name="l16162"></a>16162       setsdest(apseg, bp);
<a name="l16163"></a>16163       <span class="comment">// Create a new subsegment p-&gt;b.</span>
<a name="l16164"></a>16164       makeshellface(subsegs, &amp;pbseg);
<a name="l16165"></a>16165       setsorg(pbseg, bp);
<a name="l16166"></a>16166       setsdest(pbseg, pb);
<a name="l16167"></a>16167       <span class="comment">// p-&gt;b gets the same mark and segment type as a-&gt;p.</span>
<a name="l16168"></a>16168       setshellmark(pbseg, shellmark(apseg));
<a name="l16169"></a>16169       setshelltype(pbseg, shelltype(apseg));
<a name="l16170"></a>16170       <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l16171"></a>16171         <span class="comment">// Copy the area bound into the new subsegment.</span>
<a name="l16172"></a>16172         setareabound(pbseg, areabound(apseg));
<a name="l16173"></a>16173       }
<a name="l16174"></a>16174       senext(apseg, checkseg);
<a name="l16175"></a>16175       <span class="comment">// Get the old connection at b of a-&gt;b.</span>
<a name="l16176"></a>16176       spivot(checkseg, casingout);
<a name="l16177"></a>16177       <span class="comment">// Bond a-&gt;p and p-&gt;b together.</span>
<a name="l16178"></a>16178       senext2(pbseg, casingin);
<a name="l16179"></a>16179       sbond(casingin, checkseg);
<a name="l16180"></a>16180       <span class="keywordflow">if</span> (casingout.sh != dummysh) {
<a name="l16181"></a>16181         <span class="comment">// There is a subsegment connect at b of p-&gt;b.</span>
<a name="l16182"></a>16182         casingout.shver = 0;
<a name="l16183"></a>16183 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l16184"></a>16184 <span class="preprocessor"></span>        assert(sorg(casingout) == pb);
<a name="l16185"></a>16185 <span class="preprocessor">#endif</span>
<a name="l16186"></a>16186 <span class="preprocessor"></span>        senext2self(casingout);
<a name="l16187"></a>16187         senext(pbseg, casingin);
<a name="l16188"></a>16188         sbond(casingin, casingout);
<a name="l16189"></a>16189       }
<a name="l16190"></a>16190 
<a name="l16191"></a>16191       <span class="comment">// Bond all new subfaces to a-&gt;p and p-&gt;b.</span>
<a name="l16192"></a>16192       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l16193"></a>16193         spinsh = apsegshs[i];
<a name="l16194"></a>16194         findedge(&amp;spinsh, pa, bp);
<a name="l16195"></a>16195         ssbond(spinsh, apseg);
<a name="l16196"></a>16196         spinsh = pbsegshs[i];
<a name="l16197"></a>16197         findedge(&amp;spinsh, bp, pb);
<a name="l16198"></a>16198         ssbond(spinsh, pbseg);
<a name="l16199"></a>16199       }
<a name="l16200"></a>16200       <span class="comment">// Bond all subfaces share at a-&gt;p together.</span>
<a name="l16201"></a>16201       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l16202"></a>16202         spinsh = apsegshs[i];
<a name="l16203"></a>16203         <span class="keywordflow">if</span> (i &lt; (n - 1)) {
<a name="l16204"></a>16204           casingout = apsegshs[i + 1];
<a name="l16205"></a>16205         } <span class="keywordflow">else</span> {
<a name="l16206"></a>16206           casingout = apsegshs[0];
<a name="l16207"></a>16207         }
<a name="l16208"></a>16208         sbond1(spinsh, casingout);
<a name="l16209"></a>16209       }
<a name="l16210"></a>16210       <span class="comment">// Bond all subfaces share at p-&gt;b together.</span>
<a name="l16211"></a>16211       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l16212"></a>16212         spinsh = pbsegshs[i];
<a name="l16213"></a>16213         <span class="keywordflow">if</span> (i &lt; (n - 1)) {
<a name="l16214"></a>16214           casingout = pbsegshs[i + 1];
<a name="l16215"></a>16215         } <span class="keywordflow">else</span> {
<a name="l16216"></a>16216           casingout = pbsegshs[0];
<a name="l16217"></a>16217         }
<a name="l16218"></a>16218         sbond1(spinsh, casingout);
<a name="l16219"></a>16219       }
<a name="l16220"></a>16220       <span class="keyword">delete</span> [] apsegshs;
<a name="l16221"></a>16221       <span class="keyword">delete</span> [] pbsegshs;
<a name="l16222"></a>16222 
<a name="l16223"></a>16223       <span class="comment">// Check for newly encroached subsegments if the flag is set.</span>
<a name="l16224"></a>16224       <span class="keywordflow">if</span> (chkencseg) {
<a name="l16225"></a>16225         <span class="comment">// Check if a-&gt;p and p-&gt;b are encroached by other vertices.</span>
<a name="l16226"></a>16226         checkseg4encroach(&amp;apseg, NULL, NULL, <span class="keyword">true</span>);
<a name="l16227"></a>16227         checkseg4encroach(&amp;pbseg, NULL, NULL, <span class="keyword">true</span>);
<a name="l16228"></a>16228         <span class="comment">// Check if the adjacent segments are encroached by p.</span>
<a name="l16229"></a>16229         tallencsegs(bp, n, ceillists);
<a name="l16230"></a>16230       }
<a name="l16231"></a>16231     } <span class="comment">// if (splitseg != (face *) NULL)</span>
<a name="l16232"></a>16232 
<a name="l16233"></a>16233     <span class="comment">// Delete subfaces of old CBC_i(p)s.</span>
<a name="l16234"></a>16234     <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l16235"></a>16235       <span class="keywordflow">for</span> (i = 0; i &lt; sublists[k]-&gt;len(); i++) {
<a name="l16236"></a>16236         oldsh = * (face *)(* (sublists[k]))[i];
<a name="l16237"></a>16237         shellfacedealloc(subfaces, oldsh.sh);
<a name="l16238"></a>16238       }
<a name="l16239"></a>16239       <span class="comment">// Clear the list so that the subs will not get unmarked later in</span>
<a name="l16240"></a>16240       <span class="comment">//   routine releasebowatcavity() which only frees the memory.</span>
<a name="l16241"></a>16241       sublists[k]-&gt;clear();
<a name="l16242"></a>16242       <span class="comment">// Only do once if p is on a facet.</span>
<a name="l16243"></a>16243       <span class="keywordflow">if</span> (splitseg == (face *) NULL) <span class="keywordflow">break</span>;
<a name="l16244"></a>16244     }
<a name="l16245"></a>16245 
<a name="l16246"></a>16246     <span class="comment">// Check for newly encroached subfaces if the flag is set.</span>
<a name="l16247"></a>16247     <span class="keywordflow">if</span> (chkencsub) {
<a name="l16248"></a>16248       <span class="comment">// Check if new subfaces of C_i(p) are encroached by other vertices.</span>
<a name="l16249"></a>16249       <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l16250"></a>16250         subceillist = subceillists[k];
<a name="l16251"></a>16251         <span class="keywordflow">for</span> (i = 0; i &lt; subceillist-&gt;len(); i++) {
<a name="l16252"></a>16252           newsh = * (face *)(* subceillist)[i];
<a name="l16253"></a>16253           checksub4encroach(&amp;newsh, NULL, <span class="keyword">true</span>);
<a name="l16254"></a>16254         }
<a name="l16255"></a>16255         <span class="comment">// Only do once if p is on a facet.</span>
<a name="l16256"></a>16256         <span class="keywordflow">if</span> (splitseg == (face *) NULL) <span class="keywordflow">break</span>;
<a name="l16257"></a>16257       }
<a name="l16258"></a>16258       <span class="comment">// Check if the adjacent subfaces are encroached by p.</span>
<a name="l16259"></a>16259       tallencsubs(bp, n, ceillists);
<a name="l16260"></a>16260     }
<a name="l16261"></a>16261   } <span class="comment">// if (subceillists != (list **) NULL)</span>
<a name="l16262"></a>16262 
<a name="l16263"></a>16263   <span class="comment">// Delete tets of old BC_i(p)s.</span>
<a name="l16264"></a>16264   <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l16265"></a>16265     <span class="keywordflow">for</span> (i = 0; i &lt; tetlists[k]-&gt;len(); i++) {
<a name="l16266"></a>16266       oldtet = * (triface *)(* (tetlists[k]))[i];
<a name="l16267"></a>16267       tetrahedrondealloc(oldtet.tet);
<a name="l16268"></a>16268     }
<a name="l16269"></a>16269     <span class="comment">// Clear the list so that the tets will not get unmarked later in</span>
<a name="l16270"></a>16270     <span class="comment">//   routine releasebowatcavity() which only frees the memory.</span>
<a name="l16271"></a>16271     tetlists[k]-&gt;clear();
<a name="l16272"></a>16272   }
<a name="l16273"></a>16273 
<a name="l16274"></a>16274   <span class="comment">// check for bad quality tets if the flags is set.</span>
<a name="l16275"></a>16275   <span class="keywordflow">if</span> (chkbadtet) {
<a name="l16276"></a>16276     <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l16277"></a>16277       ceillist = ceillists[k];
<a name="l16278"></a>16278       <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l16279"></a>16279         newtet = * (triface *)(* ceillist)[i];
<a name="l16280"></a>16280         checktet4badqual(&amp;newtet, <span class="keyword">true</span>);
<a name="l16281"></a>16281       }
<a name="l16282"></a>16282     }
<a name="l16283"></a>16283   }
<a name="l16284"></a>16284 
<a name="l16285"></a>16285   <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l16286"></a>16286     <span class="comment">// Newly created internal faces of BC(p) (excluding faces on C(p)s) are</span>
<a name="l16287"></a>16287     <span class="comment">//   in &#39;flipque&#39;.  Some of these faces may be locally non-Delaunay due,</span>
<a name="l16288"></a>16288     <span class="comment">//   to the existence of non-constrained tets. check and fix them.</span>
<a name="l16289"></a>16289     repairflipcount += flip(flipque, NULL);
<a name="l16290"></a>16290   }
<a name="l16291"></a>16291 }
<a name="l16292"></a>16292 
<a name="l16293"></a>16293 <span class="comment">//</span>
<a name="l16294"></a>16294 <span class="comment">// End of mesh transformation routines</span>
<a name="l16295"></a>16295 <span class="comment">//</span>
<a name="l16296"></a>16296 
<a name="l16297"></a>16297 <span class="comment">//</span>
<a name="l16298"></a>16298 <span class="comment">// Begin Delaunay tetrahedralization routines</span>
<a name="l16299"></a>16299 <span class="comment">//</span>
<a name="l16300"></a>16300 
<a name="l16302"></a>16302 <span class="comment">//                                                                           //</span>
<a name="l16303"></a>16303 <span class="comment">// formstarpolyhedron()    Get the star ployhedron of a point &#39;pt&#39;.          //</span>
<a name="l16304"></a>16304 <span class="comment">//                                                                           //</span>
<a name="l16305"></a>16305 <span class="comment">// The polyhedron P is formed by faces of tets having &#39;pt&#39; as a vertex.  If  //</span>
<a name="l16306"></a>16306 <span class="comment">// &#39;complete&#39; is TRUE, P is the complete star of &#39;pt&#39;. Otherwise, P is boun- //</span>
<a name="l16307"></a>16307 <span class="comment">// ded by subfaces, i.e. P is only part of the star of &#39;pt&#39;.                 //</span>
<a name="l16308"></a>16308 <span class="comment">//                                                                           //</span>
<a name="l16309"></a>16309 <span class="comment">// &#39;tetlist&#39; T returns the tets, it has one of such tets on input. Moreover, //</span>
<a name="l16310"></a>16310 <span class="comment">// if t is in T, then oppo(t) = p.  Topologically, T is the star of p;  and  //</span>
<a name="l16311"></a>16311 <span class="comment">// the faces of T is the link of p. &#39;verlist&#39; V returns the vertices of T.   //</span>
<a name="l16312"></a>16312 <span class="comment">//                                                                           //</span>
<a name="l16314"></a>16314 <span class="comment"></span>
<a name="l16315"></a>16315 <span class="keywordtype">void</span> tetgenmesh::formstarpolyhedron(point pt, list* tetlist, list* verlist,
<a name="l16316"></a>16316   <span class="keywordtype">bool</span> complete)
<a name="l16317"></a>16317 {
<a name="l16318"></a>16318   triface starttet, neightet;
<a name="l16319"></a>16319   face checksh;
<a name="l16320"></a>16320   point ver[3];
<a name="l16321"></a>16321   <span class="keywordtype">int</span> idx, i, j;
<a name="l16322"></a>16322 
<a name="l16323"></a>16323   <span class="comment">// Get a tet t containing p.</span>
<a name="l16324"></a>16324   starttet = * (triface *)(* tetlist)[0];
<a name="l16325"></a>16325   <span class="comment">// Let oppo(t) = p.</span>
<a name="l16326"></a>16326   <span class="keywordflow">for</span> (starttet.loc = 0; starttet.loc &lt; 4; starttet.loc++) {
<a name="l16327"></a>16327     <span class="keywordflow">if</span> (oppo(starttet) == pt) <span class="keywordflow">break</span>;
<a name="l16328"></a>16328   }
<a name="l16329"></a>16329   assert(starttet.loc &lt; 4);
<a name="l16330"></a>16330   <span class="comment">// Add t into T.</span>
<a name="l16331"></a>16331   * (triface *)(* tetlist)[0] = starttet;
<a name="l16332"></a>16332   infect(starttet);
<a name="l16333"></a>16333   <span class="keywordflow">if</span> (verlist != (list *) NULL) {
<a name="l16334"></a>16334     <span class="comment">// Add three verts of t into V.</span>
<a name="l16335"></a>16335     ver[0] = org(starttet);
<a name="l16336"></a>16336     ver[1] = dest(starttet);
<a name="l16337"></a>16337     ver[2] = apex(starttet);
<a name="l16338"></a>16338     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l16339"></a>16339       <span class="comment">// Mark the vert by inversing the index of the vert.</span>
<a name="l16340"></a>16340       idx = pointmark(ver[i]);
<a name="l16341"></a>16341       setpointmark(ver[i], -idx - 1); <span class="comment">// -1 to distinguish the zero.</span>
<a name="l16342"></a>16342       verlist-&gt;append(&amp;(ver[i]));
<a name="l16343"></a>16343     }
<a name="l16344"></a>16344   }
<a name="l16345"></a>16345 
<a name="l16346"></a>16346   <span class="comment">// Find other tets by a broadth-first search.</span>
<a name="l16347"></a>16347   <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l16348"></a>16348     starttet = * (triface *)(* tetlist)[i];
<a name="l16349"></a>16349     starttet.ver = 0;
<a name="l16350"></a>16350     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l16351"></a>16351       fnext(starttet, neightet);
<a name="l16352"></a>16352       tspivot(neightet, checksh);
<a name="l16353"></a>16353       <span class="comment">// Should we cross a subface.</span>
<a name="l16354"></a>16354       <span class="keywordflow">if</span> ((checksh.sh == dummysh) || complete) {
<a name="l16355"></a>16355         <span class="comment">// Get the neighbor n.</span>
<a name="l16356"></a>16356         symself(neightet);
<a name="l16357"></a>16357         <span class="keywordflow">if</span> ((neightet.tet != dummytet) &amp;&amp; !infected(neightet)) {
<a name="l16358"></a>16358           <span class="comment">// Let oppo(n) = p.</span>
<a name="l16359"></a>16359           <span class="keywordflow">for</span> (neightet.loc = 0; neightet.loc &lt; 4; neightet.loc++) {
<a name="l16360"></a>16360             <span class="keywordflow">if</span> (oppo(neightet) == pt) <span class="keywordflow">break</span>;
<a name="l16361"></a>16361           }
<a name="l16362"></a>16362           assert(neightet.loc &lt; 4);
<a name="l16363"></a>16363           <span class="comment">// Add n into T.</span>
<a name="l16364"></a>16364           infect(neightet);
<a name="l16365"></a>16365           tetlist-&gt;append(&amp;neightet);
<a name="l16366"></a>16366           <span class="keywordflow">if</span> (verlist != (list *) NULL) {
<a name="l16367"></a>16367             <span class="comment">// Add the apex vertex in n into V.</span>
<a name="l16368"></a>16368             ver[0] = org(starttet);
<a name="l16369"></a>16369             ver[1] = dest(starttet);
<a name="l16370"></a>16370             findedge(&amp;neightet, ver[0], ver[1]);
<a name="l16371"></a>16371             ver[2] = apex(neightet);
<a name="l16372"></a>16372             idx = pointmark(ver[2]);
<a name="l16373"></a>16373             <span class="keywordflow">if</span> (idx &gt;= 0) {
<a name="l16374"></a>16374               setpointmark(ver[2], -idx - 1);
<a name="l16375"></a>16375               verlist-&gt;append(&amp;(ver[2]));
<a name="l16376"></a>16376             }
<a name="l16377"></a>16377           }
<a name="l16378"></a>16378         }
<a name="l16379"></a>16379       }
<a name="l16380"></a>16380       enextself(starttet);
<a name="l16381"></a>16381     }
<a name="l16382"></a>16382   }
<a name="l16383"></a>16383 
<a name="l16384"></a>16384   <span class="comment">// Uninfect tets.</span>
<a name="l16385"></a>16385   <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l16386"></a>16386     starttet = * (triface *)(* tetlist)[i];
<a name="l16387"></a>16387     uninfect(starttet);
<a name="l16388"></a>16388   }
<a name="l16389"></a>16389   <span class="keywordflow">if</span> (verlist != (list *) NULL) {
<a name="l16390"></a>16390     <span class="comment">// Uninfect vertices.</span>
<a name="l16391"></a>16391     <span class="keywordflow">for</span> (i = 0; i &lt; verlist-&gt;len(); i++) {
<a name="l16392"></a>16392       ver[0] = * (point *)(* verlist)[i];
<a name="l16393"></a>16393       idx = pointmark(ver[0]);
<a name="l16394"></a>16394       setpointmark(ver[0], -(idx + 1));
<a name="l16395"></a>16395     }
<a name="l16396"></a>16396   }
<a name="l16397"></a>16397 }
<a name="l16398"></a>16398 
<a name="l16400"></a>16400 <span class="comment">//                                                                           //</span>
<a name="l16401"></a>16401 <span class="comment">// unifypoint()    Unify two distinct points if they&#39;re very close.          //</span>
<a name="l16402"></a>16402 <span class="comment">//                                                                           //</span>
<a name="l16403"></a>16403 <span class="comment">// This function is used for dealing with inputs from CAD tools.  Two points //</span>
<a name="l16404"></a>16404 <span class="comment">// p and q are unified if: dist(p, q) / longest &lt; eps.  Where dist() is the  //</span>
<a name="l16405"></a>16405 <span class="comment">// Euclidean distance between p and q, longest is the maximum edge size of   //</span>
<a name="l16406"></a>16406 <span class="comment">// the input point set, eps is the tolerrence specified by user, default is  //</span>
<a name="l16407"></a>16407 <span class="comment">// 1e-6, it can be adjusted by &#39;-T&#39; switch.                                  //</span>
<a name="l16408"></a>16408 <span class="comment">//                                                                           //</span>
<a name="l16410"></a>16410 <span class="comment"></span>
<a name="l16411"></a>16411 <span class="keywordtype">bool</span> tetgenmesh::unifypoint(point testpt, triface *starttet, <span class="keyword">enum</span> locateresult
<a name="l16412"></a>16412   loc, REAL eps)
<a name="l16413"></a>16413 {
<a name="l16414"></a>16414   triface symtet, spintet;
<a name="l16415"></a>16415   point checkpt, tapex;
<a name="l16416"></a>16416   REAL tol;
<a name="l16417"></a>16417   <span class="keywordtype">bool</span> merged;
<a name="l16418"></a>16418   <span class="keywordtype">int</span> hitbdry;
<a name="l16419"></a>16419   <span class="keywordtype">int</span> i;
<a name="l16420"></a>16420 
<a name="l16421"></a>16421   merged = <span class="keyword">false</span>;
<a name="l16422"></a>16422   tol = longest * eps;
<a name="l16423"></a>16423   <span class="keywordflow">if</span> ((loc == OUTSIDE) || (loc == INTETRAHEDRON) || (loc == ONFACE)) {
<a name="l16424"></a>16424     <span class="comment">// Check p is close to the four corners of the tet.</span>
<a name="l16425"></a>16425     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l16426"></a>16426       checkpt = (point) starttet-&gt;tet[4 + i];
<a name="l16427"></a>16427       if (distance(testpt, checkpt) &lt; tol) {
<a name="l16428"></a>16428         merged = <span class="keyword">true</span>; <span class="comment">// Found a merge point p&#39;.</span>
<a name="l16429"></a>16429         <span class="keywordflow">break</span>;
<a name="l16430"></a>16430       }
<a name="l16431"></a>16431     }
<a name="l16432"></a>16432     <span class="keywordflow">if</span> (!merged &amp;&amp; (loc == ONFACE)) {
<a name="l16433"></a>16433       <span class="comment">// Check the opposite point of the neighbor tet if it exists.</span>
<a name="l16434"></a>16434       sym(*starttet, symtet);
<a name="l16435"></a>16435       <span class="keywordflow">if</span> (symtet.tet != dummytet) {
<a name="l16436"></a>16436         checkpt = oppo(symtet);
<a name="l16437"></a>16437         <span class="keywordflow">if</span> (distance(testpt, checkpt) &lt; tol) {
<a name="l16438"></a>16438           merged = <span class="keyword">true</span>; <span class="comment">// Found a merge point p&#39;.</span>
<a name="l16439"></a>16439         }
<a name="l16440"></a>16440       }
<a name="l16441"></a>16441     }
<a name="l16442"></a>16442   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc == ONEDGE) {
<a name="l16443"></a>16443     <span class="comment">// Check two endpoints of the edge.</span>
<a name="l16444"></a>16444     checkpt = org(*starttet);
<a name="l16445"></a>16445     <span class="keywordflow">if</span> (distance(testpt, checkpt) &lt; tol) {
<a name="l16446"></a>16446       merged = <span class="keyword">true</span>; <span class="comment">// Found a merge point p&#39;.</span>
<a name="l16447"></a>16447     }
<a name="l16448"></a>16448     <span class="keywordflow">if</span> (!merged) {
<a name="l16449"></a>16449       checkpt = dest(*starttet);
<a name="l16450"></a>16450       <span class="keywordflow">if</span> (distance(testpt, checkpt) &lt; tol) {
<a name="l16451"></a>16451         merged = <span class="keyword">true</span>; <span class="comment">// Found a merge point p&#39;.</span>
<a name="l16452"></a>16452       }
<a name="l16453"></a>16453     }
<a name="l16454"></a>16454     <span class="keywordflow">if</span> (!merged) {
<a name="l16455"></a>16455       <span class="comment">// Check apexes of the faces having the edge.</span>
<a name="l16456"></a>16456       spintet = *starttet;
<a name="l16457"></a>16457       tapex = apex(*starttet);
<a name="l16458"></a>16458       hitbdry = 0;
<a name="l16459"></a>16459       <span class="keywordflow">do</span> {
<a name="l16460"></a>16460         checkpt = apex(spintet);
<a name="l16461"></a>16461         <span class="keywordflow">if</span> (distance(testpt, checkpt) &lt; tol) {
<a name="l16462"></a>16462           merged = <span class="keyword">true</span>; <span class="comment">// Found a merge point p&#39;.</span>
<a name="l16463"></a>16463           <span class="keywordflow">break</span>;
<a name="l16464"></a>16464         }
<a name="l16465"></a>16465         <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l16466"></a>16466           hitbdry++;
<a name="l16467"></a>16467           <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l16468"></a>16468             esym(*starttet, spintet);
<a name="l16469"></a>16469             <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l16470"></a>16470               hitbdry++;
<a name="l16471"></a>16471             }
<a name="l16472"></a>16472           }
<a name="l16473"></a>16473         }
<a name="l16474"></a>16474       } <span class="keywordflow">while</span> ((apex(spintet) != tapex) &amp;&amp; (hitbdry &lt; 2));
<a name="l16475"></a>16475     }
<a name="l16476"></a>16476   }
<a name="l16477"></a>16477   <span class="keywordflow">if</span> (merged) {
<a name="l16478"></a>16478     <span class="keywordflow">if</span> (b-&gt;object != tetgenbehavior::STL) {
<a name="l16479"></a>16479       <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l16480"></a>16480         printf(<span class="stringliteral">&quot;Warning:  Point %d is unified to point %d.\n&quot;</span>,
<a name="l16481"></a>16481                pointmark(testpt), pointmark(checkpt));
<a name="l16482"></a>16482       }
<a name="l16483"></a>16483       <span class="comment">// Count the number of duplicated points.</span>
<a name="l16484"></a>16484       dupverts++;
<a name="l16485"></a>16485     }
<a name="l16486"></a>16486     <span class="comment">// Remember it is a duplicated point.</span>
<a name="l16487"></a>16487     setpointtype(testpt, DUPLICATEDVERTEX);
<a name="l16488"></a>16488     <span class="comment">// Set a pointer to the point it duplicates.</span>
<a name="l16489"></a>16489     setpoint2ppt(testpt, checkpt);
<a name="l16490"></a>16490   }
<a name="l16491"></a>16491   <span class="keywordflow">return</span> merged;
<a name="l16492"></a>16492 }
<a name="l16493"></a>16493 
<a name="l16495"></a>16495 <span class="comment">//                                                                           //</span>
<a name="l16496"></a>16496 <span class="comment">// incrflipdelaunay()   Construct a delaunay tetrahedrization from a set of  //</span>
<a name="l16497"></a>16497 <span class="comment">//                      3D points by the incremental flip algorithm.         //</span>
<a name="l16498"></a>16498 <span class="comment">//                                                                           //</span>
<a name="l16499"></a>16499 <span class="comment">// The incremental flip algorithm (by Edelsbrunner and Shah) can be describ- //</span>
<a name="l16500"></a>16500 <span class="comment">// ed as follows:                                                            //</span>
<a name="l16501"></a>16501 <span class="comment">//                                                                           //</span>
<a name="l16502"></a>16502 <span class="comment">//   S be a set of points in 3D, Let 4 &lt;= i &lt;= n and assume that the         //</span>
<a name="l16503"></a>16503 <span class="comment">//   Delaunay tetrahedralization of the first i-1 points in S is already     //</span>
<a name="l16504"></a>16504 <span class="comment">//   constructed; call it D(i-1). Add the i-th point p_i (belong to S) to    //</span>
<a name="l16505"></a>16505 <span class="comment">//   D(i-1), and restore Delaunayhood by flipping; this result in D(i).      //</span>
<a name="l16506"></a>16506 <span class="comment">//   Repeat this procedure until i = n.                                      //</span>
<a name="l16507"></a>16507 <span class="comment">//                                                                           //</span>
<a name="l16508"></a>16508 <span class="comment">// This strategy always leads to the Delaunay triangulation of a point set.  //</span>
<a name="l16509"></a>16509 <span class="comment">// The return value is the number of convex hull faces of D.                 //</span>
<a name="l16510"></a>16510 <span class="comment">//                                                                           //</span>
<a name="l16512"></a>16512 <span class="comment"></span>
<a name="l16513"></a>16513 <span class="keywordtype">void</span> tetgenmesh::incrflipdelaunay(triface* oldtet, point* insertarray,
<a name="l16514"></a>16514   <span class="keywordtype">long</span> arraysize, <span class="keywordtype">bool</span> jump, <span class="keywordtype">bool</span> merge, REAL eps, queue* flipque)
<a name="l16515"></a>16515 {
<a name="l16516"></a>16516   triface newtet, searchtet;
<a name="l16517"></a>16517   point swappt, lastpt;
<a name="l16518"></a>16518   <span class="keyword">enum</span> locateresult loc;
<a name="l16519"></a>16519   REAL det, n[3];
<a name="l16520"></a>16520   REAL attrib, volume;
<a name="l16521"></a>16521   <span class="keywordtype">int</span> i, j;
<a name="l16522"></a>16522 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l16523"></a>16523 <span class="preprocessor"></span>  clock_t loc_start, loc_end;
<a name="l16524"></a>16524 <span class="preprocessor">#endif</span>
<a name="l16525"></a>16525 <span class="preprocessor"></span>
<a name="l16526"></a>16526   det = 0.0;
<a name="l16527"></a>16527   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l16528"></a>16528     printf(<span class="stringliteral">&quot;  Creating initial tetrahedralization.\n&quot;</span>);
<a name="l16529"></a>16529   }
<a name="l16530"></a>16530 
<a name="l16531"></a>16531   <span class="comment">// The initial tetrahedralization T only has one tet formed by 4 affinely</span>
<a name="l16532"></a>16532   <span class="comment">//   linear independent vertices of the point set V = &#39;insertarray&#39;. The</span>
<a name="l16533"></a>16533   <span class="comment">//   first point a = insertarray[0].</span>
<a name="l16534"></a>16534 
<a name="l16535"></a>16535   <span class="comment">// Get the second point b, that is not identical or very close to a.</span>
<a name="l16536"></a>16536   <span class="keywordflow">for</span> (i = 1; i &lt; arraysize; i++) {
<a name="l16537"></a>16537     det = distance(insertarray[0], insertarray[i]);
<a name="l16538"></a>16538     <span class="keywordflow">if</span> (det &gt; (longest * eps)) <span class="keywordflow">break</span>;
<a name="l16539"></a>16539   }
<a name="l16540"></a>16540   <span class="keywordflow">if</span> (i == arraysize) {
<a name="l16541"></a>16541     printf(<span class="stringliteral">&quot;\nAll points seem to be identical.\n&quot;</span>);
<a name="l16542"></a>16542     <span class="keywordflow">return</span>;
<a name="l16543"></a>16543   } <span class="keywordflow">else</span> {
<a name="l16544"></a>16544     <span class="comment">// Swap to move b from index i to index 1.</span>
<a name="l16545"></a>16545     swappt = insertarray[i];
<a name="l16546"></a>16546     insertarray[i] = insertarray[1];
<a name="l16547"></a>16547     insertarray[1] = swappt;
<a name="l16548"></a>16548   }
<a name="l16549"></a>16549   <span class="comment">// Get the third point c, that is not collinear with a and b.</span>
<a name="l16550"></a>16550   <span class="keywordflow">for</span> (i++; i &lt; arraysize; i++) {
<a name="l16551"></a>16551     <span class="keywordflow">if</span> (!iscollinear(insertarray[0], insertarray[1], insertarray[i], eps))
<a name="l16552"></a>16552       <span class="keywordflow">break</span>;
<a name="l16553"></a>16553   }
<a name="l16554"></a>16554   <span class="keywordflow">if</span> (i == arraysize) {
<a name="l16555"></a>16555     printf(<span class="stringliteral">&quot;\nAll points seem to be collinear.\n&quot;</span>);
<a name="l16556"></a>16556     <span class="keywordflow">return</span>;
<a name="l16557"></a>16557   } <span class="keywordflow">else</span> {
<a name="l16558"></a>16558     <span class="comment">// Swap to move c from index i to index 2.</span>
<a name="l16559"></a>16559     swappt = insertarray[i];
<a name="l16560"></a>16560     insertarray[i] = insertarray[2];
<a name="l16561"></a>16561     insertarray[2] = swappt;
<a name="l16562"></a>16562   }
<a name="l16563"></a>16563   <span class="comment">// Get the fourth point d, that is not coplanar with a, b, and c.</span>
<a name="l16564"></a>16564   <span class="keywordflow">for</span> (i++; i &lt; arraysize; i++) {
<a name="l16565"></a>16565     det = orient3d(insertarray[0], insertarray[1], insertarray[2],
<a name="l16566"></a>16566                    insertarray[i]);
<a name="l16567"></a>16567     <span class="keywordflow">if</span> (det == 0.0) <span class="keywordflow">continue</span>;
<a name="l16568"></a>16568     <span class="keywordflow">if</span> (!iscoplanar(insertarray[0], insertarray[1], insertarray[2],
<a name="l16569"></a>16569                     insertarray[i], det, eps)) <span class="keywordflow">break</span>;
<a name="l16570"></a>16570   }
<a name="l16571"></a>16571   <span class="keywordflow">if</span> (i == arraysize) {
<a name="l16572"></a>16572     <span class="comment">// It&#39;s a 2D problem.</span>
<a name="l16573"></a>16573     in-&gt;mesh_dim = 2;
<a name="l16574"></a>16574     <span class="comment">// All points are coplanar.</span>
<a name="l16575"></a>16575     <span class="keywordflow">if</span> (b-&gt;plc) {
<a name="l16576"></a>16576       <span class="comment">// Create an abovepoint. Maybe a surface triangulation can be formed.</span>
<a name="l16577"></a>16577       facenormal(insertarray[0], insertarray[1], insertarray[2], n, &amp;det);
<a name="l16578"></a>16578       <span class="keywordflow">if</span> (det != 0.0) <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) n[j] /= det;
<a name="l16579"></a>16579       <span class="comment">// Take the average edge length of the bounding box.</span>
<a name="l16580"></a>16580       det = (0.5*(xmax - xmin) + 0.5*(ymax - ymin) + 0.5*(zmax - zmin)) / 3.0;
<a name="l16581"></a>16581       <span class="comment">// Temporarily create a point. It will be removed by jettison();</span>
<a name="l16582"></a>16582       makepoint(&amp;lastpt);
<a name="l16583"></a>16583       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) lastpt[j] = insertarray[0][j] + det * n[j];
<a name="l16584"></a>16584       abovepoint = lastpt;
<a name="l16585"></a>16585       det = orient3d(insertarray[0], insertarray[1], insertarray[2], lastpt);
<a name="l16586"></a>16586       <span class="comment">// The index of the next inserting point is 3.</span>
<a name="l16587"></a>16587       i = 3;
<a name="l16588"></a>16588     } <span class="keywordflow">else</span> {
<a name="l16589"></a>16589       printf(<span class="stringliteral">&quot;\nAll points seem to be coplanar.\n&quot;</span>);
<a name="l16590"></a>16590       <span class="keywordflow">return</span>;
<a name="l16591"></a>16591     }
<a name="l16592"></a>16592   } <span class="keywordflow">else</span> {
<a name="l16593"></a>16593     <span class="comment">// Swap to move d from index i to index 3.</span>
<a name="l16594"></a>16594     swappt = insertarray[i];
<a name="l16595"></a>16595     insertarray[i] = insertarray[3];
<a name="l16596"></a>16596     insertarray[3] = swappt;
<a name="l16597"></a>16597     lastpt = insertarray[3];
<a name="l16598"></a>16598     <span class="comment">// The index of the next inserting point is 4.</span>
<a name="l16599"></a>16599     i = 4;
<a name="l16600"></a>16600   }
<a name="l16601"></a>16601 
<a name="l16602"></a>16602   <span class="comment">// Create the initial tet.</span>
<a name="l16603"></a>16603   maketetrahedron(&amp;newtet);
<a name="l16604"></a>16604   <span class="keywordflow">if</span> (det &gt; 0.0) {
<a name="l16605"></a>16605     <span class="comment">// For keeping the positive orientation.</span>
<a name="l16606"></a>16606     swappt = insertarray[0];
<a name="l16607"></a>16607     insertarray[0] = insertarray[1];
<a name="l16608"></a>16608     insertarray[1] = swappt;
<a name="l16609"></a>16609   }
<a name="l16610"></a>16610   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l16611"></a>16611     printf(<span class="stringliteral">&quot;  Create the first tet (%d, %d, %d, %d).\n&quot;</span>,
<a name="l16612"></a>16612            pointmark(insertarray[0]), pointmark(insertarray[1]),
<a name="l16613"></a>16613            pointmark(insertarray[2]), pointmark(lastpt));
<a name="l16614"></a>16614   }
<a name="l16615"></a>16615   setorg(newtet, insertarray[0]);
<a name="l16616"></a>16616   setdest(newtet, insertarray[1]);
<a name="l16617"></a>16617   setapex(newtet, insertarray[2]);
<a name="l16618"></a>16618   setoppo(newtet, lastpt);
<a name="l16619"></a>16619   <span class="keywordflow">if</span> (oldtet != (triface *) NULL) {
<a name="l16620"></a>16620     <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberoftetrahedronattributes; j++) {
<a name="l16621"></a>16621       attrib = elemattribute(oldtet-&gt;tet, j);
<a name="l16622"></a>16622       setelemattribute(newtet.tet, j, attrib);
<a name="l16623"></a>16623     }
<a name="l16624"></a>16624     <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l16625"></a>16625       volume = volumebound(oldtet-&gt;tet);
<a name="l16626"></a>16626       setvolumebound(newtet.tet, volume);
<a name="l16627"></a>16627     }
<a name="l16628"></a>16628   }
<a name="l16629"></a>16629   <span class="comment">// Set vertex type be FREEVOLVERTEX if it has no type yet.</span>
<a name="l16630"></a>16630   <span class="keywordflow">if</span> (pointtype(insertarray[0]) == UNUSEDVERTEX) {
<a name="l16631"></a>16631     setpointtype(insertarray[0], FREEVOLVERTEX);
<a name="l16632"></a>16632   }
<a name="l16633"></a>16633   <span class="keywordflow">if</span> (pointtype(insertarray[1]) == UNUSEDVERTEX) {
<a name="l16634"></a>16634     setpointtype(insertarray[1], FREEVOLVERTEX);
<a name="l16635"></a>16635   }
<a name="l16636"></a>16636   <span class="keywordflow">if</span> (pointtype(insertarray[2]) == UNUSEDVERTEX) {
<a name="l16637"></a>16637     setpointtype(insertarray[2], FREEVOLVERTEX);
<a name="l16638"></a>16638   }
<a name="l16639"></a>16639   <span class="keywordflow">if</span> (pointtype(lastpt) == UNUSEDVERTEX) {
<a name="l16640"></a>16640     setpointtype(lastpt, FREEVOLVERTEX);
<a name="l16641"></a>16641   }
<a name="l16642"></a>16642   <span class="comment">// Bond to &#39;dummytet&#39; for point location.</span>
<a name="l16643"></a>16643   dummytet[0] = encode(newtet);
<a name="l16644"></a>16644   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 3) {
<a name="l16645"></a>16645     printf(<span class="stringliteral">&quot;    Creating tetra &quot;</span>);
<a name="l16646"></a>16646     printtet(&amp;newtet);
<a name="l16647"></a>16647   }
<a name="l16648"></a>16648   <span class="comment">// At init, all faces of this tet are hull faces.</span>
<a name="l16649"></a>16649   hullsize = 4;
<a name="l16650"></a>16650 
<a name="l16651"></a>16651   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l16652"></a>16652     printf(<span class="stringliteral">&quot;  Incrementally inserting points.\n&quot;</span>);
<a name="l16653"></a>16653   }
<a name="l16654"></a>16654 
<a name="l16655"></a>16655   flip23s = flip32s = flip22s = flip44s = 0;
<a name="l16656"></a>16656   searchtet.tet = (tetrahedron *) NULL;
<a name="l16657"></a>16657 
<a name="l16658"></a>16658   <span class="comment">// Insert the rest of points, one by one.</span>
<a name="l16659"></a>16659   <span class="keywordflow">for</span> (; i &lt; arraysize; i++) {
<a name="l16660"></a>16660     <span class="comment">// Locate p_i in T.</span>
<a name="l16661"></a>16661 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l16662"></a>16662 <span class="preprocessor"></span>    loc_start = clock();
<a name="l16663"></a>16663 <span class="preprocessor">#endif</span>
<a name="l16664"></a>16664 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (jump) {
<a name="l16665"></a>16665       loc = locate(insertarray[i], &amp;searchtet);
<a name="l16666"></a>16666     } <span class="keywordflow">else</span> {
<a name="l16667"></a>16667       loc = preciselocate(insertarray[i], &amp;searchtet, tetrahedrons-&gt;items);
<a name="l16668"></a>16668     }
<a name="l16669"></a>16669 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l16670"></a>16670 <span class="preprocessor"></span>    loc_end = clock();
<a name="l16671"></a>16671     tloctime += ((REAL) (loc_end - loc_start)) / CLOCKS_PER_SEC;
<a name="l16672"></a>16672 <span class="preprocessor">#endif</span>
<a name="l16673"></a>16673 <span class="preprocessor"></span>    <span class="comment">// Keep current search state for next searching.</span>
<a name="l16674"></a>16674     recenttet = searchtet;
<a name="l16675"></a>16675     <span class="keywordflow">if</span> (loc == ONVERTEX) {
<a name="l16676"></a>16676       <span class="keywordflow">if</span> (b-&gt;object != tetgenbehavior::STL) {
<a name="l16677"></a>16677         <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l16678"></a>16678           printf(<span class="stringliteral">&quot;Warning:  Point %d is identical with point %d.\n&quot;</span>,
<a name="l16679"></a>16679                  pointmark(insertarray[i]), pointmark(org(searchtet)));
<a name="l16680"></a>16680         }
<a name="l16681"></a>16681       }
<a name="l16682"></a>16682       <span class="comment">// Count the number of duplicated points.</span>
<a name="l16683"></a>16683       dupverts++;
<a name="l16684"></a>16684       <span class="comment">// Remember it is a duplicated point.</span>
<a name="l16685"></a>16685       setpointtype(insertarray[i], DUPLICATEDVERTEX);
<a name="l16686"></a>16686       <span class="keywordflow">if</span> (b-&gt;plc || b-&gt;refine) {
<a name="l16687"></a>16687         <span class="comment">// Set a pointer to the point it duplicates.</span>
<a name="l16688"></a>16688         setpoint2ppt(insertarray[i], org(searchtet));
<a name="l16689"></a>16689       }
<a name="l16690"></a>16690       <span class="keywordflow">continue</span>; <span class="comment">// p_i is not inserted.</span>
<a name="l16691"></a>16691     }
<a name="l16692"></a>16692     <span class="keywordflow">if</span> (merge) {
<a name="l16693"></a>16693       <span class="comment">// Unify p_i if it is too close to a point of T.</span>
<a name="l16694"></a>16694       <span class="keywordflow">if</span> (unifypoint(insertarray[i], &amp;searchtet, loc, eps)) {
<a name="l16695"></a>16695         <span class="keywordflow">continue</span>; <span class="comment">// p_i is not inserted.</span>
<a name="l16696"></a>16696       }
<a name="l16697"></a>16697     }
<a name="l16698"></a>16698     <span class="comment">// Insert p_i in T.</span>
<a name="l16699"></a>16699     <span class="keywordflow">if</span> (loc != OUTSIDE) {
<a name="l16700"></a>16700       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l16701"></a>16701         printf(<span class="stringliteral">&quot;  Insert point %d in tetrahedralization.\n&quot;</span>,
<a name="l16702"></a>16702                pointmark(insertarray[i]));
<a name="l16703"></a>16703       }
<a name="l16704"></a>16704       <span class="keywordflow">if</span> (loc == INTETRAHEDRON) {
<a name="l16705"></a>16705         splittetrahedron(insertarray[i], &amp;searchtet, flipque);
<a name="l16706"></a>16706       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc == ONFACE) {
<a name="l16707"></a>16707         splittetface(insertarray[i], &amp;searchtet, flipque);
<a name="l16708"></a>16708       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc == ONEDGE) {
<a name="l16709"></a>16709         splittetedge(insertarray[i], &amp;searchtet, flipque);
<a name="l16710"></a>16710       }
<a name="l16711"></a>16711     } <span class="keywordflow">else</span> {
<a name="l16712"></a>16712       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l16713"></a>16713         printf(<span class="stringliteral">&quot;  Insert point %d on convex hull.\n&quot;</span>,
<a name="l16714"></a>16714                pointmark(insertarray[i]));
<a name="l16715"></a>16715       }
<a name="l16716"></a>16716       inserthullsite(insertarray[i], &amp;searchtet, flipque);
<a name="l16717"></a>16717     }
<a name="l16718"></a>16718     <span class="keywordflow">if</span> (pointtype(insertarray[i]) == UNUSEDVERTEX) {
<a name="l16719"></a>16719       <span class="comment">// p_i becomes a (volume) vertex of T.</span>
<a name="l16720"></a>16720       setpointtype(insertarray[i], FREEVOLVERTEX);
<a name="l16721"></a>16721     }
<a name="l16722"></a>16722 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l16723"></a>16723 <span class="preprocessor"></span>    loc_start = clock();
<a name="l16724"></a>16724 <span class="preprocessor">#endif</span>
<a name="l16725"></a>16725 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (!b-&gt;noflip) {
<a name="l16726"></a>16726       <span class="comment">// Recover Delaunayness of T by flipping.</span>
<a name="l16727"></a>16727       flip(flipque, NULL);
<a name="l16728"></a>16728     } <span class="keywordflow">else</span> {
<a name="l16729"></a>16729       lawson(NULL, flipque);
<a name="l16730"></a>16730       <span class="comment">// T remains regular.</span>
<a name="l16731"></a>16731       <span class="comment">// flipque-&gt;clear();</span>
<a name="l16732"></a>16732     }
<a name="l16733"></a>16733 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l16734"></a>16734 <span class="preprocessor"></span>    loc_end = clock();
<a name="l16735"></a>16735     tfliptime += ((REAL) (loc_end - loc_start)) / CLOCKS_PER_SEC;
<a name="l16736"></a>16736 <span class="preprocessor">#endif</span>
<a name="l16737"></a>16737 <span class="preprocessor"></span>  }
<a name="l16738"></a>16738 
<a name="l16739"></a>16739   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l16740"></a>16740     printf(<span class="stringliteral">&quot;  %ld Flips (T23 %ld, T32 %ld, T22 %ld, T44 %ld)\n&quot;</span>,
<a name="l16741"></a>16741       flip23s+flip32s+flip22s+flip44s, flip23s, flip32s, flip22s, flip44s);
<a name="l16742"></a>16742   }
<a name="l16743"></a>16743 }
<a name="l16744"></a>16744 
<a name="l16746"></a>16746 <span class="comment">//                                                                           //</span>
<a name="l16747"></a>16747 <span class="comment">// delaunizevertices()    Form a Delaunay tetrahedralization.                //</span>
<a name="l16748"></a>16748 <span class="comment">//                                                                           //</span>
<a name="l16749"></a>16749 <span class="comment">// Given a point set V (saved in &#39;points&#39;).  The Delaunay tetrahedralization //</span>
<a name="l16750"></a>16750 <span class="comment">// D of V is created by incrementally inserting vertices. Returns the number //</span>
<a name="l16751"></a>16751 <span class="comment">// of triangular faces bounding the convex hull of D.                        //</span>
<a name="l16752"></a>16752 <span class="comment">//                                                                           //</span>
<a name="l16754"></a>16754 <span class="comment"></span>
<a name="l16755"></a>16755 <span class="keywordtype">long</span> tetgenmesh::delaunizevertices()
<a name="l16756"></a>16756 {
<a name="l16757"></a>16757   queue *flipque;
<a name="l16758"></a>16758   point *insertarray;
<a name="l16759"></a>16759   <span class="keywordtype">long</span> arraysize;
<a name="l16760"></a>16760   <span class="keywordtype">int</span> i, j;
<a name="l16761"></a>16761 
<a name="l16762"></a>16762   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l16763"></a>16763     <span class="keywordflow">if</span> (!b-&gt;noflip) {
<a name="l16764"></a>16764       printf(<span class="stringliteral">&quot;Constructing Delaunay tetrahedralization.\n&quot;</span>);
<a name="l16765"></a>16765     } <span class="keywordflow">else</span> {
<a name="l16766"></a>16766       printf(<span class="stringliteral">&quot;Constructing regular tetrahedralization.\n&quot;</span>);
<a name="l16767"></a>16767     }
<a name="l16768"></a>16768   }
<a name="l16769"></a>16769 
<a name="l16770"></a>16770   flipque = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l16771"></a>16771   <span class="comment">// Prepare the array of points for inserting.</span>
<a name="l16772"></a>16772   arraysize = points-&gt;items;
<a name="l16773"></a>16773   insertarray = <span class="keyword">new</span> point[arraysize];
<a name="l16774"></a>16774   points-&gt;traversalinit();
<a name="l16775"></a>16775 
<a name="l16776"></a>16776   <span class="comment">// Randomize the point order.</span>
<a name="l16777"></a>16777   <span class="comment">// randomseed = b-&gt;srandseed;</span>
<a name="l16778"></a>16778   <span class="keywordflow">for</span> (i = 0; i &lt; arraysize; i++) {
<a name="l16779"></a>16779     j = (int) randomnation(i + 1); <span class="comment">// 0 &lt;= j &lt;= i;</span>
<a name="l16780"></a>16780     insertarray[i] = insertarray[j];
<a name="l16781"></a>16781     insertarray[j] = pointtraverse();
<a name="l16782"></a>16782   }
<a name="l16783"></a>16783 
<a name="l16784"></a>16784   <span class="comment">// Use lawson flip.</span>
<a name="l16785"></a>16785   b-&gt;noflip = 1;
<a name="l16786"></a>16786 
<a name="l16787"></a>16787   <span class="comment">// Form the DT by incremental flip Delaunay algorithm.</span>
<a name="l16788"></a>16788   incrflipdelaunay(NULL, insertarray, arraysize, <span class="keyword">true</span>, b-&gt;plc, b-&gt;epsilon,
<a name="l16789"></a>16789                    flipque);
<a name="l16790"></a>16790 
<a name="l16791"></a>16791   b-&gt;noflip = 0;
<a name="l16792"></a>16792 
<a name="l16793"></a>16793   <span class="keyword">delete</span> [] insertarray;
<a name="l16794"></a>16794   <span class="keyword">delete</span> flipque;
<a name="l16795"></a>16795   <span class="keywordflow">return</span> hullsize;
<a name="l16796"></a>16796 }
<a name="l16797"></a>16797 
<a name="l16798"></a>16798 <span class="comment">//</span>
<a name="l16799"></a>16799 <span class="comment">// End Delaunay tetrahedralization routines</span>
<a name="l16800"></a>16800 <span class="comment">//</span>
<a name="l16801"></a>16801 
<a name="l16802"></a>16802 <span class="comment">//</span>
<a name="l16803"></a>16803 <span class="comment">// Begin of surface triangulation routines</span>
<a name="l16804"></a>16804 <span class="comment">//</span>
<a name="l16805"></a>16805 
<a name="l16807"></a>16807 <span class="comment">//                                                                           //</span>
<a name="l16808"></a>16808 <span class="comment">// formstarpolygon()    Form the star polygon of a point in facet.           //</span>
<a name="l16809"></a>16809 <span class="comment">//                                                                           //</span>
<a name="l16810"></a>16810 <span class="comment">// The polygon P is formed by all coplanar subfaces having &#39;pt&#39; as a vertex. //</span>
<a name="l16811"></a>16811 <span class="comment">// P is bounded by segments, e.g, if no segments, P is the full star of pt.  //</span>
<a name="l16812"></a>16812 <span class="comment">//                                                                           //</span>
<a name="l16813"></a>16813 <span class="comment">// &#39;trilist&#39; T returns the subfaces, it has one of such subfaces on input.   //</span>
<a name="l16814"></a>16814 <span class="comment">// In addition, if f is in T, then sapex(f) = p. &#39;vertlist&#39; V are verts of P.//</span>
<a name="l16815"></a>16815 <span class="comment">// Topologically, T is the star of p; V and the edges of T are the link of p.//</span>
<a name="l16816"></a>16816 <span class="comment">//                                                                           //</span>
<a name="l16818"></a>16818 <span class="comment"></span>
<a name="l16819"></a>16819 <span class="keywordtype">void</span> tetgenmesh::formstarpolygon(point pt, list* trilist, list* vertlist)
<a name="l16820"></a>16820 {
<a name="l16821"></a>16821   face steinsh, lnextsh, rnextsh;
<a name="l16822"></a>16822   face checkseg;
<a name="l16823"></a>16823   point pa, pb, pc, pd;
<a name="l16824"></a>16824   <span class="keywordtype">int</span> i;
<a name="l16825"></a>16825 
<a name="l16826"></a>16826   <span class="comment">// Get a subface f containing p.</span>
<a name="l16827"></a>16827   steinsh = * (face *)(* trilist)[0];
<a name="l16828"></a>16828   steinsh.shver = 0; <span class="comment">// CCW</span>
<a name="l16829"></a>16829   <span class="comment">// Let sapex(f) be p.</span>
<a name="l16830"></a>16830   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l16831"></a>16831     <span class="keywordflow">if</span> (sapex(steinsh) == pt) <span class="keywordflow">break</span>;
<a name="l16832"></a>16832     senextself(steinsh);
<a name="l16833"></a>16833   }
<a name="l16834"></a>16834   assert(i &lt; 3);
<a name="l16835"></a>16835   <span class="comment">// Add the edge f into list.</span>
<a name="l16836"></a>16836   * (face *)(* trilist)[0] = steinsh;
<a name="l16837"></a>16837   pa = sorg(steinsh);
<a name="l16838"></a>16838   pb = sdest(steinsh);
<a name="l16839"></a>16839   <span class="keywordflow">if</span> (vertlist != (list *) NULL) {
<a name="l16840"></a>16840     <span class="comment">// Add two verts a, b into V,</span>
<a name="l16841"></a>16841     vertlist-&gt;append(&amp;pa);
<a name="l16842"></a>16842     vertlist-&gt;append(&amp;pb);
<a name="l16843"></a>16843   }
<a name="l16844"></a>16844 
<a name="l16845"></a>16845   <span class="comment">// Rotate edge pa to the left (CW) until meet pb or a segment.</span>
<a name="l16846"></a>16846   lnextsh = steinsh;
<a name="l16847"></a>16847   pc = pa;
<a name="l16848"></a>16848   <span class="keywordflow">do</span> {
<a name="l16849"></a>16849     senext2self(lnextsh);
<a name="l16850"></a>16850     assert(sorg(lnextsh) == pt);
<a name="l16851"></a>16851     sspivot(lnextsh, checkseg);
<a name="l16852"></a>16852     <span class="keywordflow">if</span> (checkseg.sh != dummysh) <span class="keywordflow">break</span>; <span class="comment">// Do not cross a segment.</span>
<a name="l16853"></a>16853     <span class="comment">// Get neighbor subface n (must exist).</span>
<a name="l16854"></a>16854     spivotself(lnextsh);
<a name="l16855"></a>16855     <span class="keywordflow">if</span> (lnextsh.sh == dummysh) <span class="keywordflow">break</span>; <span class="comment">// It&#39;s a hull edge.</span>
<a name="l16856"></a>16856     <span class="comment">// Go to the edge ca opposite to p.</span>
<a name="l16857"></a>16857     <span class="keywordflow">if</span> (sdest(lnextsh) != pt) sesymself(lnextsh);
<a name="l16858"></a>16858     assert(sdest(lnextsh) == pt);
<a name="l16859"></a>16859     senext2self(lnextsh);
<a name="l16860"></a>16860     <span class="comment">// Add n (at edge ca) to T.</span>
<a name="l16861"></a>16861     trilist-&gt;append(&amp;lnextsh);
<a name="l16862"></a>16862     <span class="comment">// Add edge ca to E.</span>
<a name="l16863"></a>16863     pc = sorg(lnextsh);
<a name="l16864"></a>16864     <span class="keywordflow">if</span> (pc == pb) <span class="keywordflow">break</span>; <span class="comment">// Rotate back.</span>
<a name="l16865"></a>16865     <span class="keywordflow">if</span> (vertlist != (list *) NULL) {
<a name="l16866"></a>16866       <span class="comment">// Add vert c into V.</span>
<a name="l16867"></a>16867       vertlist-&gt;append(&amp;pc);
<a name="l16868"></a>16868     }
<a name="l16869"></a>16869   } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l16870"></a>16870 
<a name="l16871"></a>16871   <span class="keywordflow">if</span> (pc != pb) {
<a name="l16872"></a>16872     <span class="comment">// Rotate edge bp to the right (CCW) until meet a segment.</span>
<a name="l16873"></a>16873     rnextsh = steinsh;
<a name="l16874"></a>16874     <span class="keywordflow">do</span> {
<a name="l16875"></a>16875       senextself(rnextsh);
<a name="l16876"></a>16876       assert(sdest(rnextsh) == pt);
<a name="l16877"></a>16877       sspivot(rnextsh, checkseg);
<a name="l16878"></a>16878       <span class="keywordflow">if</span> (checkseg.sh != dummysh) <span class="keywordflow">break</span>; <span class="comment">// Do not cross a segment.</span>
<a name="l16879"></a>16879       <span class="comment">// Get neighbor subface n (must exist).</span>
<a name="l16880"></a>16880       spivotself(rnextsh);
<a name="l16881"></a>16881       <span class="keywordflow">if</span> (rnextsh.sh == dummysh) <span class="keywordflow">break</span>; <span class="comment">// It&#39;s a hull edge.</span>
<a name="l16882"></a>16882       <span class="comment">// Go to the edge bd opposite to p.</span>
<a name="l16883"></a>16883       <span class="keywordflow">if</span> (sorg(rnextsh) != pt) sesymself(rnextsh);
<a name="l16884"></a>16884       assert(sorg(rnextsh) == pt);
<a name="l16885"></a>16885       senextself(rnextsh);
<a name="l16886"></a>16886       <span class="comment">// Add n (at edge bd) to T.</span>
<a name="l16887"></a>16887       trilist-&gt;append(&amp;rnextsh);
<a name="l16888"></a>16888       <span class="comment">// Add edge bd to E.</span>
<a name="l16889"></a>16889       pd = sdest(rnextsh);
<a name="l16890"></a>16890       <span class="keywordflow">if</span> (pd == pa) <span class="keywordflow">break</span>; <span class="comment">// Rotate back.</span>
<a name="l16891"></a>16891       <span class="keywordflow">if</span> (vertlist != (list *) NULL) {
<a name="l16892"></a>16892         <span class="comment">// Add vert d into V.</span>
<a name="l16893"></a>16893         vertlist-&gt;append(&amp;pd);
<a name="l16894"></a>16894       }
<a name="l16895"></a>16895     } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l16896"></a>16896   }
<a name="l16897"></a>16897 }
<a name="l16898"></a>16898 
<a name="l16900"></a>16900 <span class="comment">//                                                                           //</span>
<a name="l16901"></a>16901 <span class="comment">// About the &#39;abovepoint&#39;                                                    //</span>
<a name="l16902"></a>16902 <span class="comment">//                                                                           //</span>
<a name="l16903"></a>16903 <span class="comment">// The &#39;abovepoint&#39; of a facet is a point which is exactly non-coplanar with //</span>
<a name="l16904"></a>16904 <span class="comment">// the plane containing that facet.  With such an point, the 3D predicates:  //</span>
<a name="l16905"></a>16905 <span class="comment">// orient3d(), and insphere() can be used to substitute the corresponding 2D //</span>
<a name="l16906"></a>16906 <span class="comment">// siblings, e.g. orient2d(), and incircle().  Its location is not critical, //</span>
<a name="l16907"></a>16907 <span class="comment">// but floating-point accuracy is improved if it is nicely placed over the   //</span>
<a name="l16908"></a>16908 <span class="comment">// facet, not too close or too far away.                                     //</span>
<a name="l16909"></a>16909 <span class="comment">//                                                                           //</span>
<a name="l16910"></a>16910 <span class="comment">// We take the convention that the abovepoint of a facet always lies above   //</span>
<a name="l16911"></a>16911 <span class="comment">// the facet. By this convention, given three points a, b, and c in a facet, //</span>
<a name="l16912"></a>16912 <span class="comment">// we say c has the counterclockwise order with ab is corresponding to say   //</span>
<a name="l16913"></a>16913 <span class="comment">// that c is below the plane abp, where p is the lift point.                 //</span>
<a name="l16914"></a>16914 <span class="comment">//                                                                           //</span>
<a name="l16916"></a>16916 <span class="comment"></span>
<a name="l16918"></a>16918 <span class="comment">//                                                                           //</span>
<a name="l16919"></a>16919 <span class="comment">// getfacetabovepoint()    Get a point above a plane pass through a facet.   //</span>
<a name="l16920"></a>16920 <span class="comment">//                                                                           //</span>
<a name="l16921"></a>16921 <span class="comment">// The calculcated point is saved in &#39;facetabovepointarray&#39;. The &#39;abovepoint&#39;//</span>
<a name="l16922"></a>16922 <span class="comment">// is set on return.                                                         //</span>
<a name="l16923"></a>16923 <span class="comment">//                                                                           //</span>
<a name="l16925"></a>16925 <span class="comment"></span>
<a name="l16926"></a>16926 <span class="keywordtype">void</span> tetgenmesh::getfacetabovepoint(face* facetsh)
<a name="l16927"></a>16927 {
<a name="l16928"></a>16928   list *verlist, *trilist, *tetlist;
<a name="l16929"></a>16929   triface adjtet;
<a name="l16930"></a>16930   face symsh;
<a name="l16931"></a>16931   point p1, p2, p3, pa;
<a name="l16932"></a>16932   <span class="keyword">enum</span> locateresult loc;
<a name="l16933"></a>16933   REAL smallcos, cosa;
<a name="l16934"></a>16934   REAL largevol, volume;
<a name="l16935"></a>16935   REAL v1[3], v2[3], len;
<a name="l16936"></a>16936   <span class="keywordtype">int</span> smallidx, largeidx;
<a name="l16937"></a>16937   <span class="keywordtype">int</span> shmark;
<a name="l16938"></a>16938   <span class="keywordtype">int</span> i, j;
<a name="l16939"></a>16939 
<a name="l16940"></a>16940   abovecount++;
<a name="l16941"></a>16941   <span class="comment">// Initialize working lists.</span>
<a name="l16942"></a>16942   verlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL);
<a name="l16943"></a>16943   trilist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL);
<a name="l16944"></a>16944   tetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l16945"></a>16945 
<a name="l16946"></a>16946   <span class="comment">// Get three pivotal points p1, p2, and p3 in the facet as a base triangle</span>
<a name="l16947"></a>16947   <span class="comment">//   which is non-trivil and has good base angle (close to 90 degree).</span>
<a name="l16948"></a>16948 
<a name="l16949"></a>16949   <span class="comment">// p1 is chosen as the one which has the smallest index in pa, pb, pc.</span>
<a name="l16950"></a>16950   p1 = sorg(*facetsh);
<a name="l16951"></a>16951   pa = sdest(*facetsh);
<a name="l16952"></a>16952   <span class="keywordflow">if</span> (pointmark(pa) &lt; pointmark(p1)) p1 = pa;
<a name="l16953"></a>16953   pa = sapex(*facetsh);
<a name="l16954"></a>16954   <span class="keywordflow">if</span> (pointmark(pa) &lt; pointmark(p1)) p1 = pa;
<a name="l16955"></a>16955   <span class="comment">// Form the star polygon of p1.</span>
<a name="l16956"></a>16956   trilist-&gt;append(facetsh);
<a name="l16957"></a>16957   formstarpolygon(p1, trilist, verlist);
<a name="l16958"></a>16958 
<a name="l16959"></a>16959   <span class="comment">// Get the second pivotal point p2.</span>
<a name="l16960"></a>16960   p2 = * (point *)(* verlist)[0];
<a name="l16961"></a>16961   <span class="comment">// Get vector v1 = p1-&gt;p2.</span>
<a name="l16962"></a>16962   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) v1[i] = p2[i] - p1[i];
<a name="l16963"></a>16963   len = sqrt(dot(v1, v1));
<a name="l16964"></a>16964   assert(len &gt; 0.0);  <span class="comment">// p2 != p1.</span>
<a name="l16965"></a>16965   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) v1[i] /= len;
<a name="l16966"></a>16966 
<a name="l16967"></a>16967   <span class="comment">// Get the third pivotal point p3. p3 is chosen as the one in &#39;verlist&#39;</span>
<a name="l16968"></a>16968   <span class="comment">//   which forms an angle with v1 closer to 90 degree than others do.</span>
<a name="l16969"></a>16969   smallcos = 1.0; <span class="comment">// The cosine value of 0 degree.</span>
<a name="l16970"></a>16970   smallidx = 1;   <span class="comment">// Default value.</span>
<a name="l16971"></a>16971   <span class="keywordflow">for</span> (i = 1; i &lt; verlist-&gt;len(); i++) {
<a name="l16972"></a>16972     p3 = * (point *)(* verlist)[i];
<a name="l16973"></a>16973     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) v2[j] = p3[j] - p1[j];
<a name="l16974"></a>16974     len = sqrt(dot(v2, v2));
<a name="l16975"></a>16975     <span class="keywordflow">if</span> (len &gt; 0.0) { <span class="comment">// v2 is not too small.</span>
<a name="l16976"></a>16976       cosa = fabs(dot(v1, v2)) / len;
<a name="l16977"></a>16977       <span class="keywordflow">if</span> (cosa &lt; smallcos) {
<a name="l16978"></a>16978         smallidx = i;
<a name="l16979"></a>16979         smallcos = cosa;
<a name="l16980"></a>16980       }
<a name="l16981"></a>16981     }
<a name="l16982"></a>16982   }
<a name="l16983"></a>16983   assert(smallcos &lt; 1.0); <span class="comment">// p1-&gt;p3 != p1-&gt;p2.</span>
<a name="l16984"></a>16984   p3 = * (point *)(* verlist)[smallidx];
<a name="l16985"></a>16985   verlist-&gt;clear();
<a name="l16986"></a>16986 
<a name="l16987"></a>16987   <span class="keywordflow">if</span> (tetrahedrons-&gt;items &gt; 0l) {
<a name="l16988"></a>16988     <span class="comment">// Get a tet having p1 as a vertex.</span>
<a name="l16989"></a>16989     stpivot(*facetsh, adjtet);
<a name="l16990"></a>16990     <span class="keywordflow">if</span> (adjtet.tet == dummytet) {
<a name="l16991"></a>16991       sesym(*facetsh, symsh);
<a name="l16992"></a>16992       stpivot(symsh, adjtet);
<a name="l16993"></a>16993     }
<a name="l16994"></a>16994     <span class="keywordflow">if</span> (adjtet.tet == dummytet) {
<a name="l16995"></a>16995       decode(point2tet(p1), adjtet);
<a name="l16996"></a>16996       <span class="keywordflow">if</span> (isdead(&amp;adjtet)) {
<a name="l16997"></a>16997         adjtet.tet = dummytet;
<a name="l16998"></a>16998       } <span class="keywordflow">else</span> {
<a name="l16999"></a>16999         <span class="keywordflow">if</span> (!findorg(&amp;adjtet, p1)) {
<a name="l17000"></a>17000           adjtet.tet = dummytet;
<a name="l17001"></a>17001         }
<a name="l17002"></a>17002       }
<a name="l17003"></a>17003     }
<a name="l17004"></a>17004     <span class="keywordflow">if</span> (adjtet.tet == dummytet) {
<a name="l17005"></a>17005       loc = locate(p1, &amp;adjtet);
<a name="l17006"></a>17006       <span class="keywordflow">if</span> (loc == ONVERTEX) {
<a name="l17007"></a>17007         setpoint2tet(p1, encode(adjtet));
<a name="l17008"></a>17008       } <span class="keywordflow">else</span> {
<a name="l17009"></a>17009         adjtet.tet = dummytet;
<a name="l17010"></a>17010       }
<a name="l17011"></a>17011     }
<a name="l17012"></a>17012     <span class="keywordflow">if</span> (adjtet.tet != dummytet) {
<a name="l17013"></a>17013       <span class="comment">// Get the star polyhedron of p1.</span>
<a name="l17014"></a>17014       tetlist-&gt;append(&amp;adjtet);
<a name="l17015"></a>17015       formstarpolyhedron(p1, tetlist, verlist, <span class="keyword">false</span>);
<a name="l17016"></a>17016     }
<a name="l17017"></a>17017   }
<a name="l17018"></a>17018 
<a name="l17019"></a>17019   <span class="comment">// Get the abovepoint in &#39;verlist&#39;. It is the one form the largest valid</span>
<a name="l17020"></a>17020   <span class="comment">//   volumw with the base triangle over other points in &#39;verlist.</span>
<a name="l17021"></a>17021   largevol = 0.0;
<a name="l17022"></a>17022   largeidx = 0;
<a name="l17023"></a>17023   <span class="keywordflow">for</span> (i = 0; i &lt; verlist-&gt;len(); i++) {
<a name="l17024"></a>17024     pa = * (point *)(* verlist)[i];
<a name="l17025"></a>17025     volume = orient3d(p1, p2, p3, pa);
<a name="l17026"></a>17026     <span class="keywordflow">if</span> (!iscoplanar(p1, p2, p3, pa, volume, b-&gt;epsilon * 1e+2)) {
<a name="l17027"></a>17027       <span class="keywordflow">if</span> (fabs(volume) &gt; largevol) {
<a name="l17028"></a>17028         largevol = fabs(volume);
<a name="l17029"></a>17029         largeidx = i;
<a name="l17030"></a>17030       }
<a name="l17031"></a>17031     }
<a name="l17032"></a>17032   }
<a name="l17033"></a>17033 
<a name="l17034"></a>17034   <span class="comment">// Do we have the abovepoint?</span>
<a name="l17035"></a>17035   <span class="keywordflow">if</span> (largevol &gt; 0.0) {
<a name="l17036"></a>17036     abovepoint = * (point *)(* verlist)[largeidx];
<a name="l17037"></a>17037     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l17038"></a>17038       printf(<span class="stringliteral">&quot;    Chosen abovepoint %d for facet %d.\n&quot;</span>, pointmark(abovepoint),
<a name="l17039"></a>17039              shellmark(*facetsh));
<a name="l17040"></a>17040     }
<a name="l17041"></a>17041   } <span class="keywordflow">else</span> {
<a name="l17042"></a>17042     <span class="comment">// Calculate an abovepoint for this facet.</span>
<a name="l17043"></a>17043     facenormal(p1, p2, p3, v1, &amp;len);
<a name="l17044"></a>17044     <span class="keywordflow">if</span> (len != 0.0) <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) v1[i] /= len;
<a name="l17045"></a>17045     <span class="comment">// Take the average edge length of the bounding box.</span>
<a name="l17046"></a>17046     len = (0.5*(xmax - xmin) + 0.5*(ymax - ymin) + 0.5*(zmax - zmin)) / 3.0;
<a name="l17047"></a>17047     <span class="comment">// Temporarily create a point. It will be removed by jettison();</span>
<a name="l17048"></a>17048     makepoint(&amp;abovepoint);
<a name="l17049"></a>17049     setpointtype(abovepoint, UNUSEDVERTEX);
<a name="l17050"></a>17050     unuverts++;
<a name="l17051"></a>17051     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) abovepoint[i] = p1[i] + len * v1[i];
<a name="l17052"></a>17052     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l17053"></a>17053       printf(<span class="stringliteral">&quot;    Calculated abovepoint %d for facet %d.\n&quot;</span>,
<a name="l17054"></a>17054              pointmark(abovepoint), shellmark(*facetsh));
<a name="l17055"></a>17055     }
<a name="l17056"></a>17056   }
<a name="l17057"></a>17057   <span class="comment">// Save the abovepoint in &#39;facetabovepointarray&#39;.</span>
<a name="l17058"></a>17058   shmark = shellmark(*facetsh);
<a name="l17059"></a>17059   facetabovepointarray[shmark] = abovepoint;
<a name="l17060"></a>17060 
<a name="l17061"></a>17061   <span class="keyword">delete</span> trilist;
<a name="l17062"></a>17062   <span class="keyword">delete</span> tetlist;
<a name="l17063"></a>17063   <span class="keyword">delete</span> verlist;
<a name="l17064"></a>17064 }
<a name="l17065"></a>17065 
<a name="l17067"></a>17067 <span class="comment">//                                                                           //</span>
<a name="l17068"></a>17068 <span class="comment">// collectcavsubs()    Collect non-locally Delaunay subfaces wrt a point.    //</span>
<a name="l17069"></a>17069 <span class="comment">//                                                                           //</span>
<a name="l17070"></a>17070 <span class="comment">// &#39;cavsublist&#39; returns the list of subfaces. On input, it conatins at least //</span>
<a name="l17071"></a>17071 <span class="comment">// one subface.                                                              //</span>
<a name="l17072"></a>17072 <span class="comment">//                                                                           //</span>
<a name="l17074"></a>17074 <span class="comment"></span>
<a name="l17075"></a>17075 <span class="keywordtype">void</span> tetgenmesh::collectcavsubs(point newpoint, list* cavsublist)
<a name="l17076"></a>17076 {
<a name="l17077"></a>17077   face startsub, neighsub;
<a name="l17078"></a>17078   face checkseg;
<a name="l17079"></a>17079   point pa, pb, pc;
<a name="l17080"></a>17080   REAL sign, ori;
<a name="l17081"></a>17081   <span class="keywordtype">int</span> i, j;
<a name="l17082"></a>17082 
<a name="l17083"></a>17083   <span class="comment">// First infect subfaces in &#39;cavsublist&#39;.</span>
<a name="l17084"></a>17084   <span class="keywordflow">for</span> (i = 0; i &lt; cavsublist-&gt;len(); i++) {
<a name="l17085"></a>17085     startsub = * (face *)(* cavsublist)[i];
<a name="l17086"></a>17086     sinfect(startsub);
<a name="l17087"></a>17087   }
<a name="l17088"></a>17088   <span class="comment">// Find the other subfaces by a broadth-first searching.</span>
<a name="l17089"></a>17089   <span class="keywordflow">for</span> (i = 0; i &lt; cavsublist-&gt;len(); i++) {
<a name="l17090"></a>17090     startsub = * (face *)(* cavsublist)[i];
<a name="l17091"></a>17091     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l17092"></a>17092       sspivot(startsub, checkseg);
<a name="l17093"></a>17093       <span class="comment">// Is there a segment?</span>
<a name="l17094"></a>17094       <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l17095"></a>17095         <span class="comment">// No segment. Get the neighbor.</span>
<a name="l17096"></a>17096         spivot(startsub, neighsub);
<a name="l17097"></a>17097         <span class="keywordflow">if</span> (!sinfected(neighsub)) {
<a name="l17098"></a>17098           pa = sorg(neighsub);
<a name="l17099"></a>17099           pb = sdest(neighsub);
<a name="l17100"></a>17100           pc = sapex(neighsub);
<a name="l17101"></a>17101           sign = insphere(pa, pb, pc, abovepoint, newpoint);
<a name="l17102"></a>17102           ori = orient3d(pa, pb, pc, abovepoint);
<a name="l17103"></a>17103           <span class="keywordflow">if</span> (sign != 0.0) {
<a name="l17104"></a>17104             <span class="comment">// Correct the sign.</span>
<a name="l17105"></a>17105             sign = ori &gt; 0.0 ? sign : -sign;
<a name="l17106"></a>17106           }
<a name="l17107"></a>17107           <span class="keywordflow">if</span> (sign &gt; 0.0) {
<a name="l17108"></a>17108             <span class="comment">// neighsub is encroached by newpoint.</span>
<a name="l17109"></a>17109             sinfect(neighsub);
<a name="l17110"></a>17110             cavsublist-&gt;append(&amp;neighsub);
<a name="l17111"></a>17111           }
<a name="l17112"></a>17112         }
<a name="l17113"></a>17113       }
<a name="l17114"></a>17114       senextself(startsub);
<a name="l17115"></a>17115     }
<a name="l17116"></a>17116   }
<a name="l17117"></a>17117   <span class="comment">// Having found all subfaces, uninfect them before return.</span>
<a name="l17118"></a>17118   <span class="keywordflow">for</span> (i = 0; i &lt; cavsublist-&gt;len(); i++) {
<a name="l17119"></a>17119     startsub = * (face *)(* cavsublist)[i];
<a name="l17120"></a>17120     suninfect(startsub);
<a name="l17121"></a>17121   }
<a name="l17122"></a>17122 }
<a name="l17123"></a>17123 
<a name="l17125"></a>17125 <span class="comment">//                                                                           //</span>
<a name="l17126"></a>17126 <span class="comment">// collectvisiblesubs()    Collect convex hull edges which are visible from  //</span>
<a name="l17127"></a>17127 <span class="comment">//                         the inserting point. Construct new subfaces from  //</span>
<a name="l17128"></a>17128 <span class="comment">//                         these edges and the point.                        //</span>
<a name="l17129"></a>17129 <span class="comment">//                                                                           //</span>
<a name="l17130"></a>17130 <span class="comment">// Let T be the current Delaunay triangulation (of vertices of a facet F).   //</span>
<a name="l17131"></a>17131 <span class="comment">// &#39;shmark&#39;, the index of F in &#39;in-&gt;facetlist&#39; (starts from 1);  &#39;inspoint&#39;  //</span>
<a name="l17132"></a>17132 <span class="comment">// lies outside of T; &#39;horiz&#39; is a hull edge of T which is visible by it.    //</span>
<a name="l17133"></a>17133 <span class="comment">//                                                                           //</span>
<a name="l17135"></a>17135 <span class="comment"></span>
<a name="l17136"></a>17136 <span class="keywordtype">void</span> tetgenmesh::collectvisiblesubs(<span class="keywordtype">int</span> shmark, point inspoint, face* horiz,
<a name="l17137"></a>17137   queue* flipqueue)
<a name="l17138"></a>17138 {
<a name="l17139"></a>17139   face newsh, hullsh;
<a name="l17140"></a>17140   face rightsh, leftsh, spinedge;
<a name="l17141"></a>17141   point horg, hdest;
<a name="l17142"></a>17142   <span class="keywordtype">bool</span> aboveflag;
<a name="l17143"></a>17143   REAL ori, sign;
<a name="l17144"></a>17144 
<a name="l17145"></a>17145   <span class="comment">// Get the sign of abovepoint (so we can assume it is above the plane).</span>
<a name="l17146"></a>17146   adjustedgering(*horiz, CCW);
<a name="l17147"></a>17147   horg = sorg(*horiz);
<a name="l17148"></a>17148   hdest = sdest(*horiz);
<a name="l17149"></a>17149   ori = orient3d(horg, hdest, sapex(*horiz), abovepoint);
<a name="l17150"></a>17150   sign = ori &gt; 0.0 ? -1 : 1;
<a name="l17151"></a>17151 
<a name="l17152"></a>17152   <span class="comment">// Create a new subface above &#39;horiz&#39;.</span>
<a name="l17153"></a>17153   makeshellface(subfaces, &amp;newsh);
<a name="l17154"></a>17154   setsorg(newsh, hdest);
<a name="l17155"></a>17155   setsdest(newsh, horg);
<a name="l17156"></a>17156   setsapex(newsh, inspoint);
<a name="l17157"></a>17157   setshellmark(newsh, shmark);
<a name="l17158"></a>17158   <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l17159"></a>17159     setareabound(newsh, areabound(*horiz));
<a name="l17160"></a>17160   }
<a name="l17161"></a>17161   <span class="keywordflow">if</span> (checkpbcs) {
<a name="l17162"></a>17162     setshellpbcgroup(newsh, shellpbcgroup(*horiz));
<a name="l17163"></a>17163   }
<a name="l17164"></a>17164   <span class="comment">// Make the connection.</span>
<a name="l17165"></a>17165   sbond(newsh, *horiz);
<a name="l17166"></a>17166   <span class="comment">// &#39;horiz&#39; becomes interior edge.</span>
<a name="l17167"></a>17167   enqueueflipedge(*horiz, flipqueue);
<a name="l17168"></a>17168 
<a name="l17169"></a>17169   <span class="comment">// Finish the hull edges at the right side of the newsh.</span>
<a name="l17170"></a>17170   hullsh = *horiz;
<a name="l17171"></a>17171   <span class="keywordflow">while</span> (1) {
<a name="l17172"></a>17172     senext(newsh, rightsh);
<a name="l17173"></a>17173     <span class="comment">// Get the right hull edge of &#39;horiz&#39; by spinning inside edges around</span>
<a name="l17174"></a>17174     <span class="comment">//   &#39;horg&#39; until reaching the &#39;dummysh&#39;.</span>
<a name="l17175"></a>17175     spinedge = hullsh;
<a name="l17176"></a>17176     <span class="keywordflow">do</span> {
<a name="l17177"></a>17177       hullsh = spinedge;
<a name="l17178"></a>17178       senext2self(hullsh);
<a name="l17179"></a>17179       spivot(hullsh, spinedge);
<a name="l17180"></a>17180       <span class="keywordflow">if</span> (spinedge.sh == dummysh) <span class="keywordflow">break</span>;
<a name="l17181"></a>17181       <span class="keywordflow">if</span> (sorg(spinedge) != horg) sesymself(spinedge);
<a name="l17182"></a>17182       assert(sorg(spinedge) == horg);
<a name="l17183"></a>17183     } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l17184"></a>17184     horg = sorg(hullsh);
<a name="l17185"></a>17185     <span class="comment">// Test whether &#39;inspoint&#39; is visible by &#39;hullsh&#39;.</span>
<a name="l17186"></a>17186     ori = orient3d(horg, sdest(hullsh), abovepoint, inspoint);
<a name="l17187"></a>17187     ori *= sign;
<a name="l17188"></a>17188     aboveflag = ori &lt; 0.0;
<a name="l17189"></a>17189     <span class="keywordflow">if</span> (aboveflag) {
<a name="l17190"></a>17190       <span class="comment">// It&#39;s visible.</span>
<a name="l17191"></a>17191       makeshellface(subfaces, &amp;newsh);
<a name="l17192"></a>17192       setsorg(newsh, sdest(hullsh));
<a name="l17193"></a>17193       setsdest(newsh, horg);
<a name="l17194"></a>17194       setsapex(newsh, inspoint);
<a name="l17195"></a>17195       setshellmark(newsh, shmark);
<a name="l17196"></a>17196       <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l17197"></a>17197         setareabound(newsh, areabound(hullsh));
<a name="l17198"></a>17198       }
<a name="l17199"></a>17199       <span class="keywordflow">if</span> (checkpbcs) {
<a name="l17200"></a>17200         setshellpbcgroup(newsh, shellpbcgroup(hullsh));
<a name="l17201"></a>17201       }
<a name="l17202"></a>17202       <span class="comment">// Make the connection.</span>
<a name="l17203"></a>17203       sbond(newsh, hullsh);
<a name="l17204"></a>17204       senext2(newsh, leftsh);
<a name="l17205"></a>17205       sbond(leftsh, rightsh);
<a name="l17206"></a>17206       <span class="comment">// &#39;hullsh&#39; becomes interior edge.</span>
<a name="l17207"></a>17207       enqueueflipedge(hullsh, flipqueue);
<a name="l17208"></a>17208     } <span class="keywordflow">else</span> {
<a name="l17209"></a>17209       <span class="comment">// &#39;rightsh&#39; is a new hull edge.</span>
<a name="l17210"></a>17210       dummysh[0] = sencode(rightsh);
<a name="l17211"></a>17211       <span class="keywordflow">break</span>;
<a name="l17212"></a>17212     }
<a name="l17213"></a>17213   }
<a name="l17214"></a>17214 
<a name="l17215"></a>17215   <span class="comment">// Finish the hull edges at the left side of the newsh.</span>
<a name="l17216"></a>17216   hullsh = *horiz;
<a name="l17217"></a>17217   spivot(*horiz, newsh);
<a name="l17218"></a>17218   <span class="keywordflow">while</span> (1) {
<a name="l17219"></a>17219     senext2(newsh, leftsh);
<a name="l17220"></a>17220     <span class="comment">// Get the left hull edge of &#39;horiz&#39; by spinning edges around &#39;hdest&#39;.</span>
<a name="l17221"></a>17221     spinedge = hullsh;
<a name="l17222"></a>17222     <span class="keywordflow">do</span> {
<a name="l17223"></a>17223       hullsh = spinedge;
<a name="l17224"></a>17224       senextself(hullsh);
<a name="l17225"></a>17225       spivot(hullsh, spinedge);
<a name="l17226"></a>17226       <span class="keywordflow">if</span> (spinedge.sh == dummysh) <span class="keywordflow">break</span>;
<a name="l17227"></a>17227       <span class="keywordflow">if</span> (sdest(spinedge) != hdest) sesymself(spinedge);
<a name="l17228"></a>17228       assert(sdest(spinedge) == hdest);
<a name="l17229"></a>17229     } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l17230"></a>17230     <span class="comment">// Update &#39;hdest&#39;.</span>
<a name="l17231"></a>17231     hdest = sdest(hullsh);
<a name="l17232"></a>17232     <span class="comment">// Test whether &#39;inspoint&#39; is visible from &#39;hullsh&#39;.</span>
<a name="l17233"></a>17233     ori = orient3d(sorg(hullsh), hdest, abovepoint, inspoint);
<a name="l17234"></a>17234     ori *= sign;
<a name="l17235"></a>17235     aboveflag = ori &lt; 0.0;
<a name="l17236"></a>17236     <span class="keywordflow">if</span> (aboveflag) {
<a name="l17237"></a>17237       <span class="comment">// It&#39;s a visible hull edge.</span>
<a name="l17238"></a>17238       makeshellface(subfaces, &amp;newsh);
<a name="l17239"></a>17239       setsorg(newsh, hdest);
<a name="l17240"></a>17240       setsdest(newsh, sorg(hullsh));
<a name="l17241"></a>17241       setsapex(newsh, inspoint);
<a name="l17242"></a>17242       setshellmark(newsh, shmark);
<a name="l17243"></a>17243       <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l17244"></a>17244         setareabound(newsh, areabound(hullsh));
<a name="l17245"></a>17245       }
<a name="l17246"></a>17246       <span class="keywordflow">if</span> (checkpbcs) {
<a name="l17247"></a>17247         setshellpbcgroup(newsh, shellpbcgroup(hullsh));
<a name="l17248"></a>17248       }
<a name="l17249"></a>17249       <span class="comment">// Make the connection.</span>
<a name="l17250"></a>17250       sbond(newsh, hullsh);
<a name="l17251"></a>17251       senext(newsh, rightsh);
<a name="l17252"></a>17252       sbond(rightsh, leftsh);
<a name="l17253"></a>17253       <span class="comment">// &#39;horiz&#39; becomes interior edge.</span>
<a name="l17254"></a>17254       enqueueflipedge(hullsh, flipqueue);
<a name="l17255"></a>17255     } <span class="keywordflow">else</span> {
<a name="l17256"></a>17256       <span class="comment">// &#39;leftsh&#39; is a new hull edge.</span>
<a name="l17257"></a>17257       dummysh[0] = sencode(leftsh);
<a name="l17258"></a>17258       <span class="keywordflow">break</span>;
<a name="l17259"></a>17259     }
<a name="l17260"></a>17260   }
<a name="l17261"></a>17261 }
<a name="l17262"></a>17262 
<a name="l17264"></a>17264 <span class="comment">//                                                                           //</span>
<a name="l17265"></a>17265 <span class="comment">// incrflipdelaunaysub()    Create a DT from a 3D coplanar point set using   //</span>
<a name="l17266"></a>17266 <span class="comment">//                          the incremental flip algorithm.                  //</span>
<a name="l17267"></a>17267 <span class="comment">//                                                                           //</span>
<a name="l17268"></a>17268 <span class="comment">// Let T be the current Delaunay triangulation (of vertices of a facet F).   //</span>
<a name="l17269"></a>17269 <span class="comment">// &#39;shmark&#39;, the index of F in &#39;in-&gt;facetlist&#39; (starts from 1).              //</span>
<a name="l17270"></a>17270 <span class="comment">//                                                                           //</span>
<a name="l17272"></a>17272 <span class="comment"></span>
<a name="l17273"></a>17273 <span class="keywordtype">void</span> tetgenmesh::incrflipdelaunaysub(<span class="keywordtype">int</span> shmark, REAL eps, list* ptlist,
<a name="l17274"></a>17274   <span class="keywordtype">int</span> holes, REAL* holelist, queue* flipque)
<a name="l17275"></a>17275 {
<a name="l17276"></a>17276   face newsh, startsh;
<a name="l17277"></a>17277   point *insertarray;
<a name="l17278"></a>17278   point swappt;
<a name="l17279"></a>17279   pbcdata *pd;
<a name="l17280"></a>17280   <span class="keyword">enum</span> locateresult loc;
<a name="l17281"></a>17281   REAL det, area;
<a name="l17282"></a>17282   <span class="keywordtype">bool</span> aboveflag;
<a name="l17283"></a>17283   <span class="keywordtype">int</span> arraysize;
<a name="l17284"></a>17284   <span class="keywordtype">int</span> epscount;
<a name="l17285"></a>17285   <span class="keywordtype">int</span> fmarker;
<a name="l17286"></a>17286   <span class="keywordtype">int</span> idx, i, j, k;
<a name="l17287"></a>17287 
<a name="l17288"></a>17288   <span class="comment">// Get the point array (saved in &#39;ptlist&#39;).</span>
<a name="l17289"></a>17289   insertarray = (point *) ptlist-&gt;base;
<a name="l17290"></a>17290   arraysize = ptlist-&gt;len();
<a name="l17291"></a>17291   <span class="keywordflow">if</span> (arraysize &lt; 3) <span class="keywordflow">return</span>;
<a name="l17292"></a>17292 
<a name="l17293"></a>17293   <span class="comment">// Do calculation of &#39;abovepoint&#39; if number of points &gt; 3.</span>
<a name="l17294"></a>17294   aboveflag = (arraysize &gt; 3);
<a name="l17295"></a>17295 
<a name="l17296"></a>17296   <span class="comment">// The initial triangulation T only has one triangle formed by 3 not</span>
<a name="l17297"></a>17297   <span class="comment">//   cillinear points of the set V = &#39;insertarray&#39;. The first point:</span>
<a name="l17298"></a>17298   <span class="comment">//   a = insertarray[0].</span>
<a name="l17299"></a>17299 
<a name="l17300"></a>17300   epscount = 0;
<a name="l17301"></a>17301   <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l17302"></a>17302   <span class="keywordflow">for</span> (i = 1; i &lt; arraysize; i++) {
<a name="l17303"></a>17303     det = distance(insertarray[0], insertarray[i]);
<a name="l17304"></a>17304     <span class="keywordflow">if</span> (det &gt; (longest * eps)) <span class="keywordflow">break</span>;
<a name="l17305"></a>17305   }
<a name="l17306"></a>17306   <span class="keywordflow">if</span> (i &lt; arraysize) {
<a name="l17307"></a>17307     <span class="comment">// Swap to move b from index i to index 1.</span>
<a name="l17308"></a>17308     swappt = insertarray[i];
<a name="l17309"></a>17309     insertarray[i] = insertarray[1];
<a name="l17310"></a>17310     insertarray[1] = swappt;
<a name="l17311"></a>17311   }
<a name="l17312"></a>17312   <span class="comment">// Get the third point c, that is not collinear with a and b.</span>
<a name="l17313"></a>17313   <span class="keywordflow">for</span> (i++; i &lt; arraysize; i++) {
<a name="l17314"></a>17314     <span class="keywordflow">if</span> (!iscollinear(insertarray[0], insertarray[1], insertarray[i], eps))
<a name="l17315"></a>17315       <span class="keywordflow">break</span>;
<a name="l17316"></a>17316   }
<a name="l17317"></a>17317   <span class="keywordflow">if</span> (i &lt; arraysize) {
<a name="l17318"></a>17318     <span class="comment">// Swap to move c from index i to index 2.</span>
<a name="l17319"></a>17319     swappt = insertarray[i];
<a name="l17320"></a>17320     insertarray[i] = insertarray[2];
<a name="l17321"></a>17321     insertarray[2] = swappt;
<a name="l17322"></a>17322     i = 3; <span class="comment">// The next inserting point.</span>
<a name="l17323"></a>17323   } <span class="keywordflow">else</span> {
<a name="l17324"></a>17324     <span class="comment">// The set of vertices is not good (or nearly degenerate).  However,</span>
<a name="l17325"></a>17325     <span class="comment">//   a trivial triangulation can be formed (using 3 vertices). It may</span>
<a name="l17326"></a>17326     <span class="comment">//   be corrected (or deleted) by mergefacet().</span>
<a name="l17327"></a>17327     <span class="keywordflow">if</span> ((eps == 0.0) || (epscount &gt; 16)) {
<a name="l17328"></a>17328       printf(<span class="stringliteral">&quot;Error:  Invalid PLC.\n&quot;</span>);
<a name="l17329"></a>17329       printf(<span class="stringliteral">&quot;  Facet (%d, %d, %d&quot;</span>, pointmark(insertarray[0]),
<a name="l17330"></a>17330              pointmark(insertarray[1]), pointmark(insertarray[2]));
<a name="l17331"></a>17331       <span class="keywordflow">if</span> (ptlist-&gt;len() &gt; 3) {
<a name="l17332"></a>17332         printf(<span class="stringliteral">&quot;, ...&quot;</span>);
<a name="l17333"></a>17333       }
<a name="l17334"></a>17334       printf(<span class="stringliteral">&quot;) (%d) is not a valid polygon.\n&quot;</span>, shmark);
<a name="l17335"></a>17335       terminatetetgen(1);
<a name="l17336"></a>17336     }
<a name="l17337"></a>17337     <span class="comment">// Decrease the eps, and continue to try.</span>
<a name="l17338"></a>17338     eps *= 1e-2;
<a name="l17339"></a>17339     epscount++;
<a name="l17340"></a>17340     <span class="keywordflow">continue</span>;
<a name="l17341"></a>17341   }
<a name="l17342"></a>17342   <span class="keywordflow">break</span>;
<a name="l17343"></a>17343   } <span class="comment">// while (true);</span>
<a name="l17344"></a>17344 
<a name="l17345"></a>17345   <span class="comment">// Create the initial triangle.</span>
<a name="l17346"></a>17346   makeshellface(subfaces, &amp;newsh);
<a name="l17347"></a>17347   setsorg(newsh, insertarray[0]);
<a name="l17348"></a>17348   setsdest(newsh, insertarray[1]);
<a name="l17349"></a>17349   setsapex(newsh, insertarray[2]);
<a name="l17350"></a>17350   <span class="comment">// Remeber the facet it belongs to.</span>
<a name="l17351"></a>17351   setshellmark(newsh, shmark);
<a name="l17352"></a>17352   <span class="comment">// Set vertex type be FREESUBVERTEX if it has no type yet.</span>
<a name="l17353"></a>17353   <span class="keywordflow">if</span> (pointtype(insertarray[0]) == FREEVOLVERTEX) {
<a name="l17354"></a>17354     setpointtype(insertarray[0], FREESUBVERTEX);
<a name="l17355"></a>17355   }
<a name="l17356"></a>17356   <span class="keywordflow">if</span> (pointtype(insertarray[1]) == FREEVOLVERTEX) {
<a name="l17357"></a>17357     setpointtype(insertarray[1], FREESUBVERTEX);
<a name="l17358"></a>17358   }
<a name="l17359"></a>17359   <span class="keywordflow">if</span> (pointtype(insertarray[2]) == FREEVOLVERTEX) {
<a name="l17360"></a>17360     setpointtype(insertarray[2], FREESUBVERTEX);
<a name="l17361"></a>17361   }
<a name="l17362"></a>17362   <span class="comment">// Let &#39;dummysh&#39; point to it (for point location).</span>
<a name="l17363"></a>17363   dummysh[0] = sencode(newsh);
<a name="l17364"></a>17364 
<a name="l17365"></a>17365   <span class="comment">// Are there area constraints?</span>
<a name="l17366"></a>17366   <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; (in-&gt;facetconstraintlist != (REAL *) NULL)) {
<a name="l17367"></a>17367     idx = in-&gt;facetmarkerlist[shmark - 1]; <span class="comment">// The actual facet marker.</span>
<a name="l17368"></a>17368     <span class="keywordflow">for</span> (k = 0; k &lt; in-&gt;numberoffacetconstraints; k++) {
<a name="l17369"></a>17369       fmarker = (int) in-&gt;facetconstraintlist[k * 2];
<a name="l17370"></a>17370       if (fmarker == idx) {
<a name="l17371"></a>17371         area = in-&gt;facetconstraintlist[k * 2 + 1];
<a name="l17372"></a>17372         setareabound(newsh, area);
<a name="l17373"></a>17373         <span class="keywordflow">break</span>;
<a name="l17374"></a>17374       }
<a name="l17375"></a>17375     }
<a name="l17376"></a>17376   }
<a name="l17377"></a>17377 
<a name="l17378"></a>17378   <span class="comment">// Are there pbc conditions?</span>
<a name="l17379"></a>17379   <span class="keywordflow">if</span> (checkpbcs) {
<a name="l17380"></a>17380     idx = in-&gt;facetmarkerlist[shmark - 1]; <span class="comment">// The actual facet marker.</span>
<a name="l17381"></a>17381     <span class="keywordflow">for</span> (k = 0; k &lt; in-&gt;numberofpbcgroups; k++) {
<a name="l17382"></a>17382       pd = &amp;subpbcgrouptable[k];
<a name="l17383"></a>17383       <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l17384"></a>17384         <span class="keywordflow">if</span> (pd-&gt;fmark[j] == idx) {
<a name="l17385"></a>17385           setshellpbcgroup(newsh, k);
<a name="l17386"></a>17386           pd-&gt;ss[j] = newsh;
<a name="l17387"></a>17387         }
<a name="l17388"></a>17388       }
<a name="l17389"></a>17389     }
<a name="l17390"></a>17390   }
<a name="l17391"></a>17391 
<a name="l17392"></a>17392   <span class="keywordflow">if</span> (aboveflag) {
<a name="l17393"></a>17393     <span class="comment">// Compute the &#39;abovepoint&#39; for orient3d().</span>
<a name="l17394"></a>17394     abovepoint = facetabovepointarray[shmark];
<a name="l17395"></a>17395     <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l17396"></a>17396       getfacetabovepoint(&amp;newsh);
<a name="l17397"></a>17397     }
<a name="l17398"></a>17398   }
<a name="l17399"></a>17399 
<a name="l17400"></a>17400   <span class="keywordflow">if</span> (holes &gt; 0) {
<a name="l17401"></a>17401     <span class="comment">// Project hole points onto the plane containing the facet.</span>
<a name="l17402"></a>17402     REAL prj[3];
<a name="l17403"></a>17403     <span class="keywordflow">for</span> (k = 0; k &lt; holes; k++) {
<a name="l17404"></a>17404       projpt2face(&amp;(holelist[k * 3]), insertarray[0], insertarray[1],
<a name="l17405"></a>17405                   insertarray[2], prj);
<a name="l17406"></a>17406       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) holelist[k * 3 + j] = prj[j];
<a name="l17407"></a>17407     }
<a name="l17408"></a>17408   }
<a name="l17409"></a>17409 
<a name="l17410"></a>17410   <span class="comment">// Incrementally insert the rest of points into T.</span>
<a name="l17411"></a>17411   <span class="keywordflow">for</span> (; i &lt; arraysize; i++) {
<a name="l17412"></a>17412     <span class="comment">// Insert p_i.</span>
<a name="l17413"></a>17413     startsh.sh = dummysh;
<a name="l17414"></a>17414     loc = locatesub(insertarray[i], &amp;startsh, 0, 0.0);
<a name="l17415"></a>17415     <span class="keywordflow">if</span> (loc == ONFACE) {
<a name="l17416"></a>17416       splitsubface(insertarray[i], &amp;startsh, flipque);
<a name="l17417"></a>17417     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc == ONEDGE) {
<a name="l17418"></a>17418       splitsubedge(insertarray[i], &amp;startsh, flipque);
<a name="l17419"></a>17419     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc == OUTSIDE) {
<a name="l17420"></a>17420       collectvisiblesubs(shmark, insertarray[i], &amp;startsh, flipque);
<a name="l17421"></a>17421     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc == ONVERTEX) {
<a name="l17422"></a>17422       <span class="comment">// !should not happen!</span>
<a name="l17423"></a>17423     }
<a name="l17424"></a>17424     <span class="comment">// Set p_i&#39;s type FREESUBVERTEX if it has no type yet.</span>
<a name="l17425"></a>17425     <span class="keywordflow">if</span> (pointtype(insertarray[i]) == FREEVOLVERTEX) {
<a name="l17426"></a>17426       setpointtype(insertarray[i], FREESUBVERTEX);
<a name="l17427"></a>17427     }
<a name="l17428"></a>17428     flipsub(flipque);
<a name="l17429"></a>17429   }
<a name="l17430"></a>17430 }
<a name="l17431"></a>17431 
<a name="l17433"></a>17433 <span class="comment">//                                                                           //</span>
<a name="l17434"></a>17434 <span class="comment">// finddirectionsub()    Find the first subface in a facet on the path from  //</span>
<a name="l17435"></a>17435 <span class="comment">//                       one point to another.                               //</span>
<a name="l17436"></a>17436 <span class="comment">//                                                                           //</span>
<a name="l17437"></a>17437 <span class="comment">// Finds the subface in the facet that intersects a line segment drawn from  //</span>
<a name="l17438"></a>17438 <span class="comment">// the origin of `searchsh&#39; to the point `tend&#39;, and returns the result in   //</span>
<a name="l17439"></a>17439 <span class="comment">// `searchsh&#39;.  The origin of `searchsh&#39; does not change,  even though the   //</span>
<a name="l17440"></a>17440 <span class="comment">// subface returned may differ from the one passed in.                       //</span>
<a name="l17441"></a>17441 <span class="comment">//                                                                           //</span>
<a name="l17442"></a>17442 <span class="comment">// The return value notes whether the destination or apex of the found face  //</span>
<a name="l17443"></a>17443 <span class="comment">// is collinear with the two points in question.                             //</span>
<a name="l17444"></a>17444 <span class="comment">//                                                                           //</span>
<a name="l17446"></a>17446 <span class="comment"></span>
<a name="l17447"></a>17447 <span class="keyword">enum</span> tetgenmesh::finddirectionresult tetgenmesh::finddirectionsub(
<a name="l17448"></a>17448   face* searchsh, point tend)
<a name="l17449"></a>17449 {
<a name="l17450"></a>17450   face checksh;
<a name="l17451"></a>17451   point startpoint, leftpoint, rightpoint;
<a name="l17452"></a>17452   REAL leftccw, rightccw;
<a name="l17453"></a>17453   REAL ori, sign;
<a name="l17454"></a>17454   <span class="keywordtype">int</span> leftflag, rightflag;
<a name="l17455"></a>17455 
<a name="l17456"></a>17456   startpoint = sorg(*searchsh);
<a name="l17457"></a>17457   <span class="comment">// Find the sign to simulate that abovepoint is &#39;above&#39; the facet.</span>
<a name="l17458"></a>17458   adjustedgering(*searchsh, CCW);
<a name="l17459"></a>17459   <span class="comment">// Make sure &#39;startpoint&#39; is the origin.</span>
<a name="l17460"></a>17460   <span class="keywordflow">if</span> (sorg(*searchsh) != startpoint) senextself(*searchsh);
<a name="l17461"></a>17461   rightpoint = sdest(*searchsh);
<a name="l17462"></a>17462   leftpoint = sapex(*searchsh);
<a name="l17463"></a>17463   ori = orient3d(startpoint, rightpoint, leftpoint, abovepoint);
<a name="l17464"></a>17464   sign = ori &gt; 0.0 ? -1 : 1;
<a name="l17465"></a>17465 
<a name="l17466"></a>17466   <span class="comment">// Is `tend&#39; to the left?</span>
<a name="l17467"></a>17467   ori = orient3d(tend, startpoint, abovepoint, leftpoint);
<a name="l17468"></a>17468   leftccw = ori * sign;
<a name="l17469"></a>17469   leftflag = leftccw &gt; 0.0;
<a name="l17470"></a>17470   <span class="comment">// Is `tend&#39; to the right?</span>
<a name="l17471"></a>17471   ori = orient3d(startpoint, tend, abovepoint, rightpoint);
<a name="l17472"></a>17472   rightccw = ori * sign;
<a name="l17473"></a>17473   rightflag = rightccw &gt; 0.0;
<a name="l17474"></a>17474   <span class="keywordflow">if</span> (leftflag &amp;&amp; rightflag) {
<a name="l17475"></a>17475     <span class="comment">// `searchsh&#39; faces directly away from `tend&#39;.  We could go left or</span>
<a name="l17476"></a>17476     <span class="comment">//   right.  Ask whether it&#39;s a triangle or a boundary on the left.</span>
<a name="l17477"></a>17477     senext2(*searchsh, checksh);
<a name="l17478"></a>17478     spivotself(checksh);
<a name="l17479"></a>17479     <span class="keywordflow">if</span> (checksh.sh == dummysh) {
<a name="l17480"></a>17480       leftflag = 0;
<a name="l17481"></a>17481     } <span class="keywordflow">else</span> {
<a name="l17482"></a>17482       rightflag = 0;
<a name="l17483"></a>17483     }
<a name="l17484"></a>17484   }
<a name="l17485"></a>17485   <span class="keywordflow">while</span> (leftflag) {
<a name="l17486"></a>17486     <span class="comment">// Turn left until satisfied.</span>
<a name="l17487"></a>17487     senext2self(*searchsh);
<a name="l17488"></a>17488     spivotself(*searchsh);
<a name="l17489"></a>17489     <span class="keywordflow">if</span> (searchsh-&gt;sh == dummysh) {
<a name="l17490"></a>17490       printf(<span class="stringliteral">&quot;Internal error in finddirectionsub():  Unable to find a\n&quot;</span>);
<a name="l17491"></a>17491       printf(<span class="stringliteral">&quot;  subface leading from %d to %d.\n&quot;</span>, pointmark(startpoint),
<a name="l17492"></a>17492              pointmark(tend));
<a name="l17493"></a>17493       internalerror();
<a name="l17494"></a>17494     }
<a name="l17495"></a>17495     <span class="keywordflow">if</span> (sorg(*searchsh) != startpoint) sesymself(*searchsh);
<a name="l17496"></a>17496     assert(sorg(*searchsh) == startpoint);
<a name="l17497"></a>17497     leftpoint = sapex(*searchsh);
<a name="l17498"></a>17498     rightccw = leftccw;
<a name="l17499"></a>17499     ori = orient3d(tend, startpoint, abovepoint, leftpoint);
<a name="l17500"></a>17500     leftccw = ori * sign;
<a name="l17501"></a>17501     leftflag = leftccw &gt; 0.0;
<a name="l17502"></a>17502   }
<a name="l17503"></a>17503   <span class="keywordflow">while</span> (rightflag) {
<a name="l17504"></a>17504     <span class="comment">// Turn right until satisfied.</span>
<a name="l17505"></a>17505     spivotself(*searchsh);
<a name="l17506"></a>17506     <span class="keywordflow">if</span> (searchsh-&gt;sh == dummysh) {
<a name="l17507"></a>17507       printf(<span class="stringliteral">&quot;Internal error in finddirectionsub():  Unable to find a\n&quot;</span>);
<a name="l17508"></a>17508       printf(<span class="stringliteral">&quot;  subface leading from %d to %d.\n&quot;</span>, pointmark(startpoint),
<a name="l17509"></a>17509              pointmark(tend));
<a name="l17510"></a>17510       internalerror();
<a name="l17511"></a>17511     }
<a name="l17512"></a>17512     <span class="keywordflow">if</span> (sdest(*searchsh) != startpoint) sesymself(*searchsh);
<a name="l17513"></a>17513     assert(sdest(*searchsh) == startpoint);
<a name="l17514"></a>17514     senextself(*searchsh);
<a name="l17515"></a>17515     rightpoint = sdest(*searchsh);
<a name="l17516"></a>17516     leftccw = rightccw;
<a name="l17517"></a>17517     ori = orient3d(startpoint, tend, abovepoint, rightpoint);
<a name="l17518"></a>17518     rightccw = ori * sign;
<a name="l17519"></a>17519     rightflag = rightccw &gt; 0.0;
<a name="l17520"></a>17520   }
<a name="l17521"></a>17521   <span class="keywordflow">if</span> (leftccw == 0.0) {
<a name="l17522"></a>17522     <span class="keywordflow">return</span> LEFTCOLLINEAR;
<a name="l17523"></a>17523   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rightccw == 0.0) {
<a name="l17524"></a>17524     <span class="keywordflow">return</span> RIGHTCOLLINEAR;
<a name="l17525"></a>17525   } <span class="keywordflow">else</span> {
<a name="l17526"></a>17526     <span class="keywordflow">return</span> ACROSSEDGE;
<a name="l17527"></a>17527   }
<a name="l17528"></a>17528 }
<a name="l17529"></a>17529 
<a name="l17531"></a>17531 <span class="comment">//                                                                           //</span>
<a name="l17532"></a>17532 <span class="comment">// insertsubseg()    Create a subsegment and insert it between two subfaces. //</span>
<a name="l17533"></a>17533 <span class="comment">//                                                                           //</span>
<a name="l17534"></a>17534 <span class="comment">// The new subsegment ab is inserted at the edge of subface &#39;tri&#39;.  If ab is //</span>
<a name="l17535"></a>17535 <span class="comment">// not a hull edge, it is inserted between two subfaces.  If &#39;tri&#39; is a hull //</span>
<a name="l17536"></a>17536 <span class="comment">// face, the initial face ring of ab will be set only one face which is self-//</span>
<a name="l17537"></a>17537 <span class="comment">// bonded.  The final face ring will be constructed in &#39;unifysegments()&#39;.    //</span>
<a name="l17538"></a>17538 <span class="comment">//                                                                           //</span>
<a name="l17540"></a>17540 <span class="comment"></span>
<a name="l17541"></a>17541 <span class="keywordtype">void</span> tetgenmesh::insertsubseg(face* tri)
<a name="l17542"></a>17542 {
<a name="l17543"></a>17543   face oppotri;
<a name="l17544"></a>17544   face newsubseg;
<a name="l17545"></a>17545   point pa, pb;
<a name="l17546"></a>17546   REAL len;
<a name="l17547"></a>17547   <span class="keywordtype">int</span> e1, e2;
<a name="l17548"></a>17548   <span class="keywordtype">int</span> i;
<a name="l17549"></a>17549 
<a name="l17550"></a>17550   <span class="comment">// Check if there&#39;s already a subsegment here.</span>
<a name="l17551"></a>17551   sspivot(*tri, newsubseg);
<a name="l17552"></a>17552   <span class="keywordflow">if</span> (newsubseg.sh == dummysh) {
<a name="l17553"></a>17553     <span class="comment">// Make new subsegment and initialize its vertices.</span>
<a name="l17554"></a>17554     makeshellface(subsegs, &amp;newsubseg);
<a name="l17555"></a>17555     pa = sorg(*tri);
<a name="l17556"></a>17556     pb = sdest(*tri);
<a name="l17557"></a>17557     setsorg(newsubseg, pa);
<a name="l17558"></a>17558     setsdest(newsubseg, pb);
<a name="l17559"></a>17559     <span class="comment">// Are there length constraints?</span>
<a name="l17560"></a>17560     <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; (in-&gt;segmentconstraintlist != (REAL *) NULL)) {
<a name="l17561"></a>17561       <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofsegmentconstraints; i++) {
<a name="l17562"></a>17562         e1 = (int) in-&gt;segmentconstraintlist[i * 3];
<a name="l17563"></a>17563         e2 = (<span class="keywordtype">int</span>) in-&gt;segmentconstraintlist[i * 3 + 1];
<a name="l17564"></a>17564         <span class="keywordflow">if</span> (((pointmark(pa) == e1) &amp;&amp; (pointmark(pb) == e2)) ||
<a name="l17565"></a>17565             ((pointmark(pa) == e2) &amp;&amp; (pointmark(pb) == e1))) {
<a name="l17566"></a>17566           len = in-&gt;segmentconstraintlist[i * 3 + 2];
<a name="l17567"></a>17567           setareabound(newsubseg, len);
<a name="l17568"></a>17568           <span class="keywordflow">break</span>;
<a name="l17569"></a>17569         }
<a name="l17570"></a>17570       }
<a name="l17571"></a>17571     }
<a name="l17572"></a>17572     <span class="comment">// Bond new subsegment to the two subfaces it is sandwiched between.</span>
<a name="l17573"></a>17573     ssbond(*tri, newsubseg);
<a name="l17574"></a>17574     spivot(*tri, oppotri);
<a name="l17575"></a>17575     <span class="comment">// &#39;oppotri&#39; might be &quot;out space&quot;.</span>
<a name="l17576"></a>17576     <span class="keywordflow">if</span> (oppotri.sh != dummysh) {
<a name="l17577"></a>17577       ssbond(oppotri, newsubseg);
<a name="l17578"></a>17578     } <span class="comment">/* else {</span>
<a name="l17579"></a>17579 <span class="comment">      // Outside! Bond &#39;*tri&#39; to itself.</span>
<a name="l17580"></a>17580 <span class="comment">      sbond(*tri, *tri);</span>
<a name="l17581"></a>17581 <span class="comment">    } */</span>
<a name="l17582"></a>17582   }
<a name="l17583"></a>17583 }
<a name="l17584"></a>17584 
<a name="l17586"></a>17586 <span class="comment">//                                                                           //</span>
<a name="l17587"></a>17587 <span class="comment">// scoutsegmentsub()    Scout the first triangle on the path from one point  //</span>
<a name="l17588"></a>17588 <span class="comment">//                      to another, and check for completion (reaching the   //</span>
<a name="l17589"></a>17589 <span class="comment">//                      second point), a collinear point,or the intersection //</span>
<a name="l17590"></a>17590 <span class="comment">//                      of two segments.                                     //</span>
<a name="l17591"></a>17591 <span class="comment">//                                                                           //</span>
<a name="l17592"></a>17592 <span class="comment">// Returns true if the entire segment is successfully inserted, and false if //</span>
<a name="l17593"></a>17593 <span class="comment">// the job must be finished by constrainededge().                            //</span>
<a name="l17594"></a>17594 <span class="comment">//                                                                           //</span>
<a name="l17596"></a>17596 <span class="comment"></span>
<a name="l17597"></a>17597 <span class="keywordtype">bool</span> tetgenmesh::scoutsegmentsub(face* searchsh, point tend)
<a name="l17598"></a>17598 {
<a name="l17599"></a>17599   face newsubseg;
<a name="l17600"></a>17600   face crosssub, crosssubseg;
<a name="l17601"></a>17601   point leftpoint, rightpoint;
<a name="l17602"></a>17602   <span class="keyword">enum</span> finddirectionresult collinear;
<a name="l17603"></a>17603 
<a name="l17604"></a>17604   collinear = finddirectionsub(searchsh, tend);
<a name="l17605"></a>17605   rightpoint = sdest(*searchsh);
<a name="l17606"></a>17606   leftpoint = sapex(*searchsh);
<a name="l17607"></a>17607   <span class="keywordflow">if</span> (rightpoint == tend || leftpoint == tend) {
<a name="l17608"></a>17608     <span class="comment">// The segment is already an edge.</span>
<a name="l17609"></a>17609     <span class="keywordflow">if</span> (leftpoint == tend) {
<a name="l17610"></a>17610       senext2self(*searchsh);
<a name="l17611"></a>17611     }
<a name="l17612"></a>17612     <span class="comment">// Insert a subsegment.</span>
<a name="l17613"></a>17613     insertsubseg(searchsh);
<a name="l17614"></a>17614     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l17615"></a>17615   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == LEFTCOLLINEAR) {
<a name="l17616"></a>17616     <span class="comment">// We&#39;ve collided with a vertex between the segment&#39;s endpoints.</span>
<a name="l17617"></a>17617     <span class="comment">// Make the collinear vertex be the triangle&#39;s origin.</span>
<a name="l17618"></a>17618     senextself(*searchsh); <span class="comment">// lprevself(*searchtri);</span>
<a name="l17619"></a>17619     <span class="comment">// Insert a subsegment.</span>
<a name="l17620"></a>17620     insertsubseg(searchsh);
<a name="l17621"></a>17621     <span class="comment">// Insert the remainder of the segment.</span>
<a name="l17622"></a>17622     <span class="keywordflow">return</span> scoutsegmentsub(searchsh, tend);
<a name="l17623"></a>17623   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == RIGHTCOLLINEAR) {
<a name="l17624"></a>17624     <span class="comment">// We&#39;ve collided with a vertex between the segment&#39;s endpoints.</span>
<a name="l17625"></a>17625     <span class="comment">// Insert a subsegment.</span>
<a name="l17626"></a>17626     insertsubseg(searchsh);
<a name="l17627"></a>17627     <span class="comment">// Make the collinear vertex be the triangle&#39;s origin.</span>
<a name="l17628"></a>17628     senextself(*searchsh); <span class="comment">// lnextself(*searchtri);</span>
<a name="l17629"></a>17629     <span class="comment">// Insert the remainder of the segment.</span>
<a name="l17630"></a>17630     <span class="keywordflow">return</span> scoutsegmentsub(searchsh, tend);
<a name="l17631"></a>17631   } <span class="keywordflow">else</span> {
<a name="l17632"></a>17632     senext(*searchsh, crosssub); <span class="comment">// lnext(*searchtri, crosstri);</span>
<a name="l17633"></a>17633     <span class="comment">// Check for a crossing segment.</span>
<a name="l17634"></a>17634     sspivot(crosssub, crosssubseg);
<a name="l17635"></a>17635 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l17636"></a>17636 <span class="preprocessor"></span>    assert(crosssubseg.sh == dummysh);
<a name="l17637"></a>17637 <span class="preprocessor">#endif</span>
<a name="l17638"></a>17638 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l17639"></a>17639   }
<a name="l17640"></a>17640 }
<a name="l17641"></a>17641 
<a name="l17643"></a>17643 <span class="comment">//                                                                           //</span>
<a name="l17644"></a>17644 <span class="comment">// flipedgerecursive()    Flip an edge.                                      //</span>
<a name="l17645"></a>17645 <span class="comment">//                                                                           //</span>
<a name="l17646"></a>17646 <span class="comment">// This is a support routine for inserting segments into a CDT.              //</span>
<a name="l17647"></a>17647 <span class="comment">//                                                                           //</span>
<a name="l17648"></a>17648 <span class="comment">// Let &#39;flipedge&#39; be ab, and two triangles abc, abd share at it.  ab may not //</span>
<a name="l17649"></a>17649 <span class="comment">// flipable if the four vertices a, b, c, and d are non-convex. If it is the //</span>
<a name="l17650"></a>17650 <span class="comment">// case, recursively flip ad or bd. Return when ab is flipped.               //</span>
<a name="l17651"></a>17651 <span class="comment">//                                                                           //</span>
<a name="l17653"></a>17653 <span class="comment"></span>
<a name="l17654"></a>17654 <span class="keywordtype">void</span> tetgenmesh::flipedgerecursive(face* flipedge, queue* flipqueue)
<a name="l17655"></a>17655 {
<a name="l17656"></a>17656   face fixupsh;
<a name="l17657"></a>17657   point pa, pb, pc, pd;
<a name="l17658"></a>17658   REAL oria, orib;
<a name="l17659"></a>17659   <span class="keywordtype">bool</span> doflip;
<a name="l17660"></a>17660 
<a name="l17661"></a>17661   pa = sorg(*flipedge);
<a name="l17662"></a>17662   pb = sdest(*flipedge);
<a name="l17663"></a>17663   pc = sapex(*flipedge);
<a name="l17664"></a>17664   <span class="keywordflow">do</span> {
<a name="l17665"></a>17665     spivot(*flipedge, fixupsh);
<a name="l17666"></a>17666     pd = sapex(fixupsh);
<a name="l17667"></a>17667     oria = orient3d(pc, pd, abovepoint, pa);
<a name="l17668"></a>17668     orib = orient3d(pc, pd, abovepoint, pb);
<a name="l17669"></a>17669     doflip = (oria * orib &lt; 0.0);
<a name="l17670"></a>17670     <span class="keywordflow">if</span> (doflip) {
<a name="l17671"></a>17671       <span class="comment">// Flip the edge (a, b) away.</span>
<a name="l17672"></a>17672       flip22sub(flipedge, flipqueue);
<a name="l17673"></a>17673       <span class="comment">// Fix flipedge on edge e (c, d).</span>
<a name="l17674"></a>17674       findedge(flipedge, pc, pd);
<a name="l17675"></a>17675     } <span class="keywordflow">else</span> {
<a name="l17676"></a>17676       <span class="comment">// ab is unflipable. Get the next edge (bd, or da) to flip.</span>
<a name="l17677"></a>17677       <span class="keywordflow">if</span> (sorg(fixupsh) != pb) sesymself(fixupsh);
<a name="l17678"></a>17678       assert(sdest(fixupsh) == pa);
<a name="l17679"></a>17679       <span class="keywordflow">if</span> (fabs(oria) &gt; fabs(orib)) {
<a name="l17680"></a>17680         <span class="comment">// acd has larger area. Choose da.</span>
<a name="l17681"></a>17681         senextself(fixupsh);
<a name="l17682"></a>17682       } <span class="keywordflow">else</span> {
<a name="l17683"></a>17683         <span class="comment">// bcd has larger area. Choose bd.</span>
<a name="l17684"></a>17684         senext2self(fixupsh);
<a name="l17685"></a>17685       }
<a name="l17686"></a>17686       <span class="comment">// Flip the edge.</span>
<a name="l17687"></a>17687       flipedgerecursive(&amp;fixupsh, flipqueue);
<a name="l17688"></a>17688     }
<a name="l17689"></a>17689   } <span class="keywordflow">while</span> (!doflip);
<a name="l17690"></a>17690 }
<a name="l17691"></a>17691 
<a name="l17693"></a>17693 <span class="comment">//                                                                           //</span>
<a name="l17694"></a>17694 <span class="comment">// constrainededge()    Force a segment into a CDT.                          //</span>
<a name="l17695"></a>17695 <span class="comment">//                                                                           //</span>
<a name="l17696"></a>17696 <span class="comment">// The segment s is recovered by flipping away the edges it intersects, and  //</span>
<a name="l17697"></a>17697 <span class="comment">// triangulating the polygons that form on each side of it.                  //</span>
<a name="l17698"></a>17698 <span class="comment">//                                                                           //</span>
<a name="l17699"></a>17699 <span class="comment">// Generates a single subsegment connecting `tstart&#39; to `tend&#39;. The triangle //</span>
<a name="l17700"></a>17700 <span class="comment">// `startsh&#39; has `tstart&#39; as its origin.                                     //</span>
<a name="l17701"></a>17701 <span class="comment">//                                                                           //</span>
<a name="l17703"></a>17703 <span class="comment"></span>
<a name="l17704"></a>17704 <span class="keywordtype">void</span> tetgenmesh::constrainededge(face* startsh, point tend, queue* flipqueue)
<a name="l17705"></a>17705 {
<a name="l17706"></a>17706   point tstart, tright, tleft;
<a name="l17707"></a>17707   REAL rori, lori;
<a name="l17708"></a>17708   <span class="keywordtype">bool</span> collision;
<a name="l17709"></a>17709 
<a name="l17710"></a>17710   tstart = sorg(*startsh);
<a name="l17711"></a>17711   <span class="keywordflow">do</span> {
<a name="l17712"></a>17712     <span class="comment">// Loop edges oppo to tstart until find one crosses the segment.</span>
<a name="l17713"></a>17713     <span class="keywordflow">do</span> {
<a name="l17714"></a>17714       tright = sdest(*startsh);
<a name="l17715"></a>17715       tleft = sapex(*startsh);
<a name="l17716"></a>17716       <span class="comment">// Is edge (tright, tleft) corss the segment.</span>
<a name="l17717"></a>17717       rori = orient3d(tstart, tright, abovepoint, tend);
<a name="l17718"></a>17718       collision = (rori == 0.0);
<a name="l17719"></a>17719       <span class="keywordflow">if</span> (collision) <span class="keywordflow">break</span>; <span class="comment">// tright is on the segment.</span>
<a name="l17720"></a>17720       lori = orient3d(tstart, tleft, abovepoint, tend);
<a name="l17721"></a>17721       collision = (lori == 0.0);
<a name="l17722"></a>17722       <span class="keywordflow">if</span> (collision) { <span class="comment">//  tleft is on the segment.</span>
<a name="l17723"></a>17723         senext2self(*startsh);
<a name="l17724"></a>17724         <span class="keywordflow">break</span>;
<a name="l17725"></a>17725       }
<a name="l17726"></a>17726       <span class="keywordflow">if</span> (rori * lori &lt; 0.0) <span class="keywordflow">break</span>; <span class="comment">// Find the crossing edge.</span>
<a name="l17727"></a>17727       <span class="comment">// Both points are at one side of the segment.</span>
<a name="l17728"></a>17728       finddirectionsub(startsh, tend);
<a name="l17729"></a>17729     } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l17730"></a>17730     <span class="keywordflow">if</span> (collision) <span class="keywordflow">break</span>;
<a name="l17731"></a>17731     <span class="comment">// Get the neighbor face at edge e (tright, tleft).</span>
<a name="l17732"></a>17732     senextself(*startsh);
<a name="l17733"></a>17733     <span class="comment">// Flip the crossing edge.</span>
<a name="l17734"></a>17734     flipedgerecursive(startsh, flipqueue);
<a name="l17735"></a>17735     <span class="comment">// After flip, sorg(*startsh) == tstart.</span>
<a name="l17736"></a>17736     assert(sorg(*startsh) == tstart);
<a name="l17737"></a>17737   } <span class="keywordflow">while</span> (sdest(*startsh) != tend);
<a name="l17738"></a>17738 
<a name="l17739"></a>17739   <span class="comment">// Insert a subsegment to make the segment permanent.</span>
<a name="l17740"></a>17740   insertsubseg(startsh);
<a name="l17741"></a>17741   <span class="comment">// If there was a collision with an interceding vertex, install another</span>
<a name="l17742"></a>17742   <span class="comment">//   segment connecting that vertex with endpoint2.</span>
<a name="l17743"></a>17743   <span class="keywordflow">if</span> (collision) {
<a name="l17744"></a>17744     <span class="comment">// Insert the remainder of the segment.</span>
<a name="l17745"></a>17745     <span class="keywordflow">if</span> (!scoutsegmentsub(startsh, tend)) {
<a name="l17746"></a>17746       constrainededge(startsh, tend, flipqueue);
<a name="l17747"></a>17747     }
<a name="l17748"></a>17748   }
<a name="l17749"></a>17749 }
<a name="l17750"></a>17750 
<a name="l17752"></a>17752 <span class="comment">//                                                                           //</span>
<a name="l17753"></a>17753 <span class="comment">// recoversegment()    Recover a segment in the surface triangulation.       //</span>
<a name="l17754"></a>17754 <span class="comment">//                                                                           //</span>
<a name="l17756"></a>17756 <span class="comment"></span>
<a name="l17757"></a>17757 <span class="keywordtype">void</span> tetgenmesh::recoversegment(point tstart, point tend, queue* flipqueue)
<a name="l17758"></a>17758 {
<a name="l17759"></a>17759   face searchsh;
<a name="l17760"></a>17760 
<a name="l17761"></a>17761   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l17762"></a>17762     printf(<span class="stringliteral">&quot;    Insert seg (%d, %d).\n&quot;</span>, pointmark(tstart), pointmark(tend));
<a name="l17763"></a>17763   }
<a name="l17764"></a>17764 
<a name="l17765"></a>17765   <span class="comment">// Find a triangle whose origin is the segment&#39;s first endpoint.</span>
<a name="l17766"></a>17766   searchsh.sh = dummysh;
<a name="l17767"></a>17767   <span class="comment">// Search for the segment&#39;s first endpoint by point location.</span>
<a name="l17768"></a>17768   <span class="keywordflow">if</span> (locatesub(tstart, &amp;searchsh, 0, 0.0) != ONVERTEX) {
<a name="l17769"></a>17769     <span class="comment">// Possibly caused by a degenerate subface. Do a brute-force search.</span>
<a name="l17770"></a>17770     list *newshlist;
<a name="l17771"></a>17771     <span class="keywordtype">int</span> i, j;
<a name="l17772"></a>17772     newshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l17773"></a>17773     <span class="comment">// Get new subfaces, do not remove protected segments.</span>
<a name="l17774"></a>17774     retrievenewsubs(newshlist, <span class="keyword">false</span>);
<a name="l17775"></a>17775     <span class="comment">// Search for a sub contain tstart.</span>
<a name="l17776"></a>17776     <span class="keywordflow">for</span> (i = 0; i &lt; newshlist-&gt;len(); i++) {
<a name="l17777"></a>17777       searchsh = * (face *)(* newshlist)[i];
<a name="l17778"></a>17778       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l17779"></a>17779         <span class="keywordflow">if</span> (sorg(searchsh) == tstart) <span class="keywordflow">break</span>;
<a name="l17780"></a>17780         senextself(searchsh);
<a name="l17781"></a>17781       }
<a name="l17782"></a>17782       <span class="keywordflow">if</span> (j &lt; 3) <span class="keywordflow">break</span>;
<a name="l17783"></a>17783     }
<a name="l17784"></a>17784     <span class="keyword">delete</span> newshlist;
<a name="l17785"></a>17785     <span class="keywordflow">if</span> (sorg(searchsh) != tstart) {
<a name="l17786"></a>17786       printf(<span class="stringliteral">&quot;Internal error in recoversegment():  Vertex location failed.\n&quot;</span>);
<a name="l17787"></a>17787       internalerror();
<a name="l17788"></a>17788     }
<a name="l17789"></a>17789   }
<a name="l17790"></a>17790   <span class="comment">// Scout the segment and insert it if it is found.</span>
<a name="l17791"></a>17791   <span class="keywordflow">if</span> (scoutsegmentsub(&amp;searchsh, tend)) {
<a name="l17792"></a>17792     <span class="comment">// The segment was easily inserted.</span>
<a name="l17793"></a>17793     <span class="keywordflow">return</span>;
<a name="l17794"></a>17794   }
<a name="l17795"></a>17795   <span class="comment">// Insert the segment into the triangulation by flips.</span>
<a name="l17796"></a>17796   constrainededge(&amp;searchsh, tend, flipqueue);
<a name="l17797"></a>17797   <span class="comment">// Some edges may need flipping.</span>
<a name="l17798"></a>17798   flipsub(flipqueue);
<a name="l17799"></a>17799 }
<a name="l17800"></a>17800 
<a name="l17802"></a>17802 <span class="comment">//                                                                           //</span>
<a name="l17803"></a>17803 <span class="comment">// infecthullsub()    Virally infect all of the triangles of the convex hull //</span>
<a name="l17804"></a>17804 <span class="comment">//                    that are not protected by subsegments.                 //</span>
<a name="l17805"></a>17805 <span class="comment">//                                                                           //</span>
<a name="l17807"></a>17807 <span class="comment"></span>
<a name="l17808"></a>17808 <span class="keywordtype">void</span> tetgenmesh::infecthullsub(<a class="code" href="structmemorypool.html">memorypool</a>* viri)
<a name="l17809"></a>17809 {
<a name="l17810"></a>17810   face hulltri, nexttri, starttri;
<a name="l17811"></a>17811   face hullsubseg;
<a name="l17812"></a>17812   shellface **deadshellface;
<a name="l17813"></a>17813 
<a name="l17814"></a>17814   <span class="comment">// Find a triangle handle on the hull.</span>
<a name="l17815"></a>17815   hulltri.sh = dummysh;
<a name="l17816"></a>17816   hulltri.shver = 0;
<a name="l17817"></a>17817   spivotself(hulltri);
<a name="l17818"></a>17818   adjustedgering(hulltri, CCW);
<a name="l17819"></a>17819   <span class="comment">// Remember where we started so we know when to stop.</span>
<a name="l17820"></a>17820   starttri = hulltri;
<a name="l17821"></a>17821   <span class="comment">// Go once counterclockwise around the convex hull.</span>
<a name="l17822"></a>17822   <span class="keywordflow">do</span> {
<a name="l17823"></a>17823     <span class="comment">// Ignore triangles that are already infected.</span>
<a name="l17824"></a>17824     <span class="keywordflow">if</span> (!sinfected(hulltri)) {
<a name="l17825"></a>17825       <span class="comment">// Is the triangle protected by a subsegment?</span>
<a name="l17826"></a>17826       sspivot(hulltri, hullsubseg);
<a name="l17827"></a>17827       <span class="keywordflow">if</span> (hullsubseg.sh == dummysh) {
<a name="l17828"></a>17828         <span class="comment">// The triangle is not protected; infect it.</span>
<a name="l17829"></a>17829         <span class="keywordflow">if</span> (!sinfected(hulltri)) {
<a name="l17830"></a>17830           sinfect(hulltri);
<a name="l17831"></a>17831           deadshellface = (shellface **) viri-&gt;alloc();
<a name="l17832"></a>17832           *deadshellface = hulltri.sh;
<a name="l17833"></a>17833         }
<a name="l17834"></a>17834       }
<a name="l17835"></a>17835     }
<a name="l17836"></a>17836     <span class="comment">// To find the next hull edge, go clockwise around the next vertex.</span>
<a name="l17837"></a>17837     senextself(hulltri); <span class="comment">// lnextself(hulltri);</span>
<a name="l17838"></a>17838     spivot(hulltri, nexttri); <span class="comment">// oprev(hulltri, nexttri);</span>
<a name="l17839"></a>17839     <span class="keywordflow">if</span> (nexttri.sh == hulltri.sh) {
<a name="l17840"></a>17840       nexttri.sh = dummysh;  <span class="comment">// &#39;hulltri&#39; is self-bonded.</span>
<a name="l17841"></a>17841     } <span class="keywordflow">else</span> {
<a name="l17842"></a>17842       adjustedgering(nexttri, CCW);
<a name="l17843"></a>17843       senextself(nexttri);
<a name="l17844"></a>17844     }
<a name="l17845"></a>17845     <span class="keywordflow">while</span> (nexttri.sh != dummysh) {
<a name="l17846"></a>17846       hulltri = nexttri;
<a name="l17847"></a>17847       spivot(hulltri, nexttri); <span class="comment">// oprev(hulltri, nexttri);</span>
<a name="l17848"></a>17848       <span class="keywordflow">if</span> (nexttri.sh == hulltri.sh) {
<a name="l17849"></a>17849         nexttri.sh = dummysh;  <span class="comment">// &#39;hulltri&#39; is self-bonded.</span>
<a name="l17850"></a>17850       } <span class="keywordflow">else</span> {
<a name="l17851"></a>17851         adjustedgering(nexttri, CCW);
<a name="l17852"></a>17852         senextself(nexttri);
<a name="l17853"></a>17853       }
<a name="l17854"></a>17854     }
<a name="l17855"></a>17855   } <span class="keywordflow">while</span> (hulltri != starttri);
<a name="l17856"></a>17856 }
<a name="l17857"></a>17857 
<a name="l17859"></a>17859 <span class="comment">//                                                                           //</span>
<a name="l17860"></a>17860 <span class="comment">// plaguesub()    Spread the virus from all infected triangles to any        //</span>
<a name="l17861"></a>17861 <span class="comment">//                neighbors not protected by subsegments.  Delete all        //</span>
<a name="l17862"></a>17862 <span class="comment">//                infected triangles.                                        //</span>
<a name="l17863"></a>17863 <span class="comment">//                                                                           //</span>
<a name="l17864"></a>17864 <span class="comment">// This is the procedure that actually creates holes and concavities.        //</span>
<a name="l17865"></a>17865 <span class="comment">//                                                                           //</span>
<a name="l17867"></a>17867 <span class="comment"></span>
<a name="l17868"></a>17868 <span class="keywordtype">void</span> tetgenmesh::plaguesub(<a class="code" href="structmemorypool.html">memorypool</a>* viri)
<a name="l17869"></a>17869 {
<a name="l17870"></a>17870   face testtri, neighbor, ghostsh;
<a name="l17871"></a>17871   face neighborsubseg;
<a name="l17872"></a>17872   shellface **virusloop;
<a name="l17873"></a>17873   shellface **deadshellface;
<a name="l17874"></a>17874   <span class="keywordtype">int</span> i;
<a name="l17875"></a>17875 
<a name="l17876"></a>17876   <span class="comment">// Loop through all the infected triangles, spreading the virus to</span>
<a name="l17877"></a>17877   <span class="comment">//   their neighbors, then to their neighbors&#39; neighbors.</span>
<a name="l17878"></a>17878   viri-&gt;traversalinit();
<a name="l17879"></a>17879   virusloop = (shellface **) viri-&gt;traverse();
<a name="l17880"></a>17880   <span class="keywordflow">while</span> (virusloop != (shellface **) NULL) {
<a name="l17881"></a>17881     testtri.sh = *virusloop;
<a name="l17882"></a>17882     <span class="comment">// Check each of the triangle&#39;s three neighbors.</span>
<a name="l17883"></a>17883     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l17884"></a>17884       <span class="comment">// Find the neighbor.</span>
<a name="l17885"></a>17885       spivot(testtri, neighbor);
<a name="l17886"></a>17886       <span class="comment">// Check for a subsegment between the triangle and its neighbor.</span>
<a name="l17887"></a>17887       sspivot(testtri, neighborsubseg);
<a name="l17888"></a>17888       <span class="comment">// Check if the neighbor is nonexistent or already infected.</span>
<a name="l17889"></a>17889       <span class="keywordflow">if</span> ((neighbor.sh == dummysh) || sinfected(neighbor)) {
<a name="l17890"></a>17890         <span class="keywordflow">if</span> (neighborsubseg.sh != dummysh) {
<a name="l17891"></a>17891           <span class="comment">// There is a subsegment separating the triangle from its</span>
<a name="l17892"></a>17892           <span class="comment">//   neighbor, but both triangles are dying, so the subsegment</span>
<a name="l17893"></a>17893           <span class="comment">//   dies too.</span>
<a name="l17894"></a>17894           shellfacedealloc(subsegs, neighborsubseg.sh);
<a name="l17895"></a>17895           <span class="keywordflow">if</span> (neighbor.sh != dummysh) {
<a name="l17896"></a>17896             <span class="comment">// Make sure the subsegment doesn&#39;t get deallocated again</span>
<a name="l17897"></a>17897             <span class="comment">//   later when the infected neighbor is visited.</span>
<a name="l17898"></a>17898             ssdissolve(neighbor);
<a name="l17899"></a>17899           }
<a name="l17900"></a>17900         }
<a name="l17901"></a>17901       } <span class="keywordflow">else</span> {                   <span class="comment">// The neighbor exists and is not infected.</span>
<a name="l17902"></a>17902         <span class="keywordflow">if</span> (neighborsubseg.sh == dummysh) {
<a name="l17903"></a>17903           <span class="comment">// There is no subsegment protecting the neighbor, so the</span>
<a name="l17904"></a>17904           <span class="comment">//   neighbor becomes infected.</span>
<a name="l17905"></a>17905           sinfect(neighbor);
<a name="l17906"></a>17906           <span class="comment">// Ensure that the neighbor&#39;s neighbors will be infected.</span>
<a name="l17907"></a>17907           deadshellface = (shellface **) viri-&gt;alloc();
<a name="l17908"></a>17908           *deadshellface = neighbor.sh;
<a name="l17909"></a>17909         } <span class="keywordflow">else</span> {               <span class="comment">// The neighbor is protected by a subsegment.</span>
<a name="l17910"></a>17910           <span class="comment">// Remove this triangle from the subsegment.</span>
<a name="l17911"></a>17911           ssbond(neighbor, neighborsubseg);
<a name="l17912"></a>17912         }
<a name="l17913"></a>17913       }
<a name="l17914"></a>17914       senextself(testtri);
<a name="l17915"></a>17915     }
<a name="l17916"></a>17916     virusloop = (shellface **) viri-&gt;traverse();
<a name="l17917"></a>17917   }
<a name="l17918"></a>17918 
<a name="l17919"></a>17919   ghostsh.sh = dummysh; <span class="comment">// A handle of outer space.</span>
<a name="l17920"></a>17920   viri-&gt;traversalinit();
<a name="l17921"></a>17921   virusloop = (shellface **) viri-&gt;traverse();
<a name="l17922"></a>17922   <span class="keywordflow">while</span> (virusloop != (shellface **) NULL) {
<a name="l17923"></a>17923     testtri.sh = *virusloop;
<a name="l17924"></a>17924     <span class="comment">// Record changes in the number of boundary edges, and disconnect</span>
<a name="l17925"></a>17925     <span class="comment">//   dead triangles from their neighbors.</span>
<a name="l17926"></a>17926     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l17927"></a>17927       spivot(testtri, neighbor);
<a name="l17928"></a>17928       <span class="keywordflow">if</span> (neighbor.sh != dummysh) {
<a name="l17929"></a>17929         <span class="comment">// Disconnect the triangle from its neighbor.</span>
<a name="l17930"></a>17930         <span class="comment">// sdissolve(neighbor);</span>
<a name="l17931"></a>17931         sbond(neighbor, ghostsh);
<a name="l17932"></a>17932       }
<a name="l17933"></a>17933       senextself(testtri);
<a name="l17934"></a>17934     }
<a name="l17935"></a>17935     <span class="comment">// Return the dead triangle to the pool of triangles.</span>
<a name="l17936"></a>17936     shellfacedealloc(subfaces, testtri.sh);
<a name="l17937"></a>17937     virusloop = (shellface **) viri-&gt;traverse();
<a name="l17938"></a>17938   }
<a name="l17939"></a>17939   <span class="comment">// Empty the virus pool.</span>
<a name="l17940"></a>17940   viri-&gt;restart();
<a name="l17941"></a>17941 }
<a name="l17942"></a>17942 
<a name="l17944"></a>17944 <span class="comment">//                                                                           //</span>
<a name="l17945"></a>17945 <span class="comment">// carveholessub()    Find the holes and infect them.  Find the area         //</span>
<a name="l17946"></a>17946 <span class="comment">//                    constraints and infect them.  Infect the convex hull.  //</span>
<a name="l17947"></a>17947 <span class="comment">//                    Spread the infection and kill triangles.  Spread the   //</span>
<a name="l17948"></a>17948 <span class="comment">//                    area constraints.                                      //</span>
<a name="l17949"></a>17949 <span class="comment">//                                                                           //</span>
<a name="l17950"></a>17950 <span class="comment">// This routine mainly calls other routines to carry out all these functions.//</span>
<a name="l17951"></a>17951 <span class="comment">//                                                                           //</span>
<a name="l17953"></a>17953 <span class="comment"></span>
<a name="l17954"></a>17954 <span class="keywordtype">void</span> tetgenmesh::carveholessub(<span class="keywordtype">int</span> holes, REAL* holelist, <a class="code" href="structmemorypool.html">memorypool</a> *viri)
<a name="l17955"></a>17955 {
<a name="l17956"></a>17956   face searchtri, triangleloop;
<a name="l17957"></a>17957   shellface **holetri;
<a name="l17958"></a>17958   <span class="keyword">enum</span> locateresult intersect;
<a name="l17959"></a>17959   <span class="keywordtype">int</span> i;
<a name="l17960"></a>17960 
<a name="l17961"></a>17961   <span class="comment">// Mark as infected any unprotected triangles on the boundary.</span>
<a name="l17962"></a>17962   <span class="comment">//   This is one way by which concavities are created.</span>
<a name="l17963"></a>17963   infecthullsub(viri);
<a name="l17964"></a>17964 
<a name="l17965"></a>17965   <span class="keywordflow">if</span> (holes &gt; 0) {
<a name="l17966"></a>17966     <span class="comment">// Infect each triangle in which a hole lies.</span>
<a name="l17967"></a>17967     <span class="keywordflow">for</span> (i = 0; i &lt; 3 * holes; i += 3) {
<a name="l17968"></a>17968       <span class="comment">// Ignore holes that aren&#39;t within the bounds of the mesh.</span>
<a name="l17969"></a>17969       <span class="keywordflow">if</span> ((holelist[i] &gt;= xmin) &amp;&amp; (holelist[i] &lt;= xmax)
<a name="l17970"></a>17970           &amp;&amp; (holelist[i + 1] &gt;= ymin) &amp;&amp; (holelist[i + 1] &lt;= ymax)
<a name="l17971"></a>17971           &amp;&amp; (holelist[i + 2] &gt;= zmin) &amp;&amp; (holelist[i + 2] &lt;= zmax)) {
<a name="l17972"></a>17972         <span class="comment">// Start searching from some triangle on the outer boundary.</span>
<a name="l17973"></a>17973         searchtri.sh = dummysh;
<a name="l17974"></a>17974         <span class="comment">// Find a triangle that contains the hole.</span>
<a name="l17975"></a>17975         intersect = locatesub(&amp;holelist[i], &amp;searchtri, 0, 0.0);
<a name="l17976"></a>17976         <span class="keywordflow">if</span> ((intersect != OUTSIDE) &amp;&amp; (!sinfected(searchtri))) {
<a name="l17977"></a>17977           <span class="comment">// Infect the triangle.  This is done by marking the triangle</span>
<a name="l17978"></a>17978           <span class="comment">//   as infected and including the triangle in the virus pool.</span>
<a name="l17979"></a>17979           sinfect(searchtri);
<a name="l17980"></a>17980           holetri = (shellface **) viri-&gt;alloc();
<a name="l17981"></a>17981           *holetri = searchtri.sh;
<a name="l17982"></a>17982         }
<a name="l17983"></a>17983       }
<a name="l17984"></a>17984     }
<a name="l17985"></a>17985   }
<a name="l17986"></a>17986 
<a name="l17987"></a>17987   <span class="keywordflow">if</span> (viri-&gt;items &gt; 0) {
<a name="l17988"></a>17988     <span class="comment">// Carve the holes and concavities.</span>
<a name="l17989"></a>17989     plaguesub(viri);
<a name="l17990"></a>17990   }
<a name="l17991"></a>17991   <span class="comment">// The virus pool should be empty now.</span>
<a name="l17992"></a>17992 }
<a name="l17993"></a>17993 
<a name="l17995"></a>17995 <span class="comment">//                                                                           //</span>
<a name="l17996"></a>17996 <span class="comment">// triangulate()    Triangulate a PSLG into a CDT.                           //</span>
<a name="l17997"></a>17997 <span class="comment">//                                                                           //</span>
<a name="l17998"></a>17998 <span class="comment">// A Planar Straight Line Graph (PSLG) P is actually a 2D polygonal region,  //</span>
<a name="l17999"></a>17999 <span class="comment">// possibly contains holes, segments and vertices in its interior. P is tri- //</span>
<a name="l18000"></a>18000 <span class="comment">// angulated into a set of _subfaces_ forming a CDT of P.                    //</span>
<a name="l18001"></a>18001 <span class="comment">//                                                                           //</span>
<a name="l18002"></a>18002 <span class="comment">// The vertices and segments of P are found in &#39;ptlist&#39; and &#39;conlist&#39;, resp- //</span>
<a name="l18003"></a>18003 <span class="comment">// ectively. &#39;holelist&#39; contains a list of hole points. &#39;shmark&#39; will be set //</span>
<a name="l18004"></a>18004 <span class="comment">// to all subfaces of P.                                                     //</span>
<a name="l18005"></a>18005 <span class="comment">//                                                                           //</span>
<a name="l18006"></a>18006 <span class="comment">// The CDT is created directly in the pools &#39;subfaces&#39; and &#39;subsegs&#39;. It can //</span>
<a name="l18007"></a>18007 <span class="comment">// be retrived by a broadth-first searching starting from &#39;dummysh[0]&#39;(debug //</span>
<a name="l18008"></a>18008 <span class="comment">// function &#39;outsurfmesh()&#39; does it).                                        //</span>
<a name="l18009"></a>18009 <span class="comment">//                                                                           //</span>
<a name="l18011"></a>18011 <span class="comment"></span>
<a name="l18012"></a>18012 <span class="keywordtype">void</span> tetgenmesh::triangulate(<span class="keywordtype">int</span> shmark, REAL eps, list* ptlist, list* conlist,
<a name="l18013"></a>18013   <span class="keywordtype">int</span> holes, REAL* holelist, <a class="code" href="structmemorypool.html">memorypool</a>* viri, queue* flipqueue)
<a name="l18014"></a>18014 {
<a name="l18015"></a>18015   face newsh;
<a name="l18016"></a>18016   point *cons;
<a name="l18017"></a>18017   <span class="keywordtype">int</span> i;
<a name="l18018"></a>18018 
<a name="l18019"></a>18019   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l18020"></a>18020     printf(<span class="stringliteral">&quot;    %d vertices, %d segments&quot;</span>, ptlist-&gt;len(), conlist-&gt;len());
<a name="l18021"></a>18021     <span class="keywordflow">if</span> (holes &gt; 0) {
<a name="l18022"></a>18022       printf(<span class="stringliteral">&quot;, %d holes&quot;</span>, holes);
<a name="l18023"></a>18023     }
<a name="l18024"></a>18024     printf(<span class="stringliteral">&quot;, shmark: %d.\n&quot;</span>, shmark);
<a name="l18025"></a>18025   }
<a name="l18026"></a>18026 
<a name="l18027"></a>18027   <span class="comment">// Create the DT of V by the 2D incremental flip algorithm.</span>
<a name="l18028"></a>18028   incrflipdelaunaysub(shmark, eps, ptlist, holes, holelist, flipqueue);
<a name="l18029"></a>18029   <span class="comment">// Recover boundary edges.</span>
<a name="l18030"></a>18030   <span class="keywordflow">if</span> (ptlist-&gt;len() &gt; 3) {
<a name="l18031"></a>18031     <span class="comment">// Insert segments into the DT.</span>
<a name="l18032"></a>18032     <span class="keywordflow">for</span> (i = 0; i &lt; conlist-&gt;len(); i++) {
<a name="l18033"></a>18033       cons = (point *)(* conlist)[i];
<a name="l18034"></a>18034       recoversegment(cons[0], cons[1], flipqueue);
<a name="l18035"></a>18035     }
<a name="l18036"></a>18036     <span class="comment">// Carve holes and concavities.</span>
<a name="l18037"></a>18037     carveholessub(holes, holelist, viri);
<a name="l18038"></a>18038   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ptlist-&gt;len() == 3) {
<a name="l18039"></a>18039     <span class="comment">// Insert 3 segments directly.</span>
<a name="l18040"></a>18040     newsh.sh = dummysh;
<a name="l18041"></a>18041     newsh.shver = 0;
<a name="l18042"></a>18042     spivotself(newsh);
<a name="l18043"></a>18043     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l18044"></a>18044       insertsubseg(&amp;newsh);
<a name="l18045"></a>18045       senextself(newsh);
<a name="l18046"></a>18046     }
<a name="l18047"></a>18047   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ptlist-&gt;len() == 2) {
<a name="l18048"></a>18048     <span class="comment">// This facet is actually a segment. It is not support by the mesh data</span>
<a name="l18049"></a>18049     <span class="comment">//   strcuture. Hence the segment will not be maintained in the mesh.</span>
<a name="l18050"></a>18050     <span class="comment">//   However, during segment recovery, the segment can be processed.</span>
<a name="l18051"></a>18051     cons = (point *)(* conlist)[0];
<a name="l18052"></a>18052     makeshellface(subsegs, &amp;newsh);
<a name="l18053"></a>18053     setsorg(newsh, cons[0]);
<a name="l18054"></a>18054     setsdest(newsh, cons[1]);
<a name="l18055"></a>18055   }
<a name="l18056"></a>18056 }
<a name="l18057"></a>18057 
<a name="l18059"></a>18059 <span class="comment">//                                                                           //</span>
<a name="l18060"></a>18060 <span class="comment">// retrievenewsubs()    Retrieve newly created subfaces.                     //</span>
<a name="l18061"></a>18061 <span class="comment">//                                                                           //</span>
<a name="l18062"></a>18062 <span class="comment">// The new subfaces created by triangulate() can be found by a broadth-first //</span>
<a name="l18063"></a>18063 <span class="comment">// searching starting from &#39;dummysh[0]&#39;.                                     //</span>
<a name="l18064"></a>18064 <span class="comment">//                                                                           //</span>
<a name="l18065"></a>18065 <span class="comment">// &#39;newshlist&#39; (empty on input) returns the retrieved subfaces. Each edge on //</span>
<a name="l18066"></a>18066 <span class="comment">// the hull is bound to &#39;dummysh&#39; and protected by a segment. If &#39;removeseg&#39; //</span>
<a name="l18067"></a>18067 <span class="comment">// is TRUE, the segment is removed.                                          //</span>
<a name="l18068"></a>18068 <span class="comment">//                                                                           //</span>
<a name="l18070"></a>18070 <span class="comment"></span>
<a name="l18071"></a>18071 <span class="keywordtype">void</span> tetgenmesh::retrievenewsubs(list* newshlist, <span class="keywordtype">bool</span> removeseg)
<a name="l18072"></a>18072 {
<a name="l18073"></a>18073   face startsh, neighsh;
<a name="l18074"></a>18074   face deadseg;
<a name="l18075"></a>18075   <span class="keywordtype">int</span> i, j;
<a name="l18076"></a>18076 
<a name="l18077"></a>18077   <span class="comment">// The first new subface is found at dummysh[0].</span>
<a name="l18078"></a>18078   startsh.sh = dummysh;
<a name="l18079"></a>18079   startsh.shver = 0;
<a name="l18080"></a>18080   spivotself(startsh);
<a name="l18081"></a>18081   assert(startsh.sh != dummysh);
<a name="l18082"></a>18082   sinfect(startsh);
<a name="l18083"></a>18083   newshlist-&gt;append(&amp;startsh);
<a name="l18084"></a>18084 
<a name="l18085"></a>18085   <span class="comment">// Find the rest of new subfaces by a broadth-first searching.</span>
<a name="l18086"></a>18086   <span class="keywordflow">for</span> (i = 0; i &lt; newshlist-&gt;len(); i++) {
<a name="l18087"></a>18087     <span class="comment">// Get a new subface s.</span>
<a name="l18088"></a>18088     startsh = * (face *)(* newshlist)[i];
<a name="l18089"></a>18089     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l18090"></a>18090       spivot(startsh, neighsh);
<a name="l18091"></a>18091       <span class="keywordflow">if</span> (neighsh.sh != dummysh) {
<a name="l18092"></a>18092         <span class="keywordflow">if</span> (!sinfected(neighsh)) {
<a name="l18093"></a>18093           <span class="comment">// Discovered a new subface.</span>
<a name="l18094"></a>18094           sinfect(neighsh);
<a name="l18095"></a>18095           newshlist-&gt;append(&amp;neighsh);
<a name="l18096"></a>18096         }
<a name="l18097"></a>18097       } <span class="keywordflow">else</span> {
<a name="l18098"></a>18098         <span class="comment">// Found a boundary edge.</span>
<a name="l18099"></a>18099         <span class="keywordflow">if</span> (removeseg) {
<a name="l18100"></a>18100           <span class="comment">// This side of s may be protected by a segment.</span>
<a name="l18101"></a>18101           sspivot(startsh, deadseg);
<a name="l18102"></a>18102           <span class="keywordflow">if</span> (deadseg.sh != dummysh) {
<a name="l18103"></a>18103             <span class="comment">// Detach it from s.</span>
<a name="l18104"></a>18104             ssdissolve(startsh);
<a name="l18105"></a>18105             <span class="comment">// Delete the segment.</span>
<a name="l18106"></a>18106             shellfacedealloc(subsegs, deadseg.sh);
<a name="l18107"></a>18107           }
<a name="l18108"></a>18108         }
<a name="l18109"></a>18109       }
<a name="l18110"></a>18110       senextself(startsh);
<a name="l18111"></a>18111     }
<a name="l18112"></a>18112   }
<a name="l18113"></a>18113   <span class="keywordflow">for</span> (i = 0; i &lt; newshlist-&gt;len(); i++) {
<a name="l18114"></a>18114     startsh = * (face *)(* newshlist)[i];
<a name="l18115"></a>18115     suninfect(startsh);
<a name="l18116"></a>18116   }
<a name="l18117"></a>18117 }
<a name="l18118"></a>18118 
<a name="l18120"></a>18120 <span class="comment">//                                                                           //</span>
<a name="l18121"></a>18121 <span class="comment">// unifysegments()    Unify identical segments and build facet connections.  //</span>
<a name="l18122"></a>18122 <span class="comment">//                                                                           //</span>
<a name="l18123"></a>18123 <span class="comment">// After creating the surface mesh. Each facet has its own segments.  There  //</span>
<a name="l18124"></a>18124 <span class="comment">// are duplicated segments between adjacent facets.  This routine has three  //</span>
<a name="l18125"></a>18125 <span class="comment">// purposes:                                                                 //</span>
<a name="l18126"></a>18126 <span class="comment">//   (1) identify the set of segments which have the same endpoints and      //</span>
<a name="l18127"></a>18127 <span class="comment">//       unify them into one segment, remove redundant ones;                 //</span>
<a name="l18128"></a>18128 <span class="comment">//   (2) create the face rings of the unified segments, hence setup the      //</span>
<a name="l18129"></a>18129 <span class="comment">//       connections between facets; and                                     //</span>
<a name="l18130"></a>18130 <span class="comment">//   (3) set a unique marker (1-based) for each segment.                     //</span>
<a name="l18131"></a>18131 <span class="comment">// On finish, each segment is unique and the face ring around it (right-hand //</span>
<a name="l18132"></a>18132 <span class="comment">// rule) is constructed. The connections between facets-facets are setup.    //</span>
<a name="l18133"></a>18133 <span class="comment">//                                                                           //</span>
<a name="l18135"></a>18135 <span class="comment"></span>
<a name="l18136"></a>18136 <span class="keywordtype">void</span> tetgenmesh::unifysegments()
<a name="l18137"></a>18137 {
<a name="l18138"></a>18138   list *sfacelist;
<a name="l18139"></a>18139   shellface **facesperverlist;
<a name="l18140"></a>18140   face subsegloop, testseg;
<a name="l18141"></a>18141   face sface, sface1, sface2;
<a name="l18142"></a>18142   point torg, tdest;
<a name="l18143"></a>18143   REAL da1, da2;
<a name="l18144"></a>18144   <span class="keywordtype">int</span> *idx2facelist;
<a name="l18145"></a>18145   <span class="keywordtype">int</span> segmarker;
<a name="l18146"></a>18146   <span class="keywordtype">int</span> idx, k, m;
<a name="l18147"></a>18147 
<a name="l18148"></a>18148   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l18149"></a>18149     printf(<span class="stringliteral">&quot;  Unifying segments.\n&quot;</span>);
<a name="l18150"></a>18150   }
<a name="l18151"></a>18151 
<a name="l18152"></a>18152   <span class="comment">// Compute a mapping from indices of vertices to subfaces.</span>
<a name="l18153"></a>18153   makesubfacemap(idx2facelist, facesperverlist);
<a name="l18154"></a>18154   <span class="comment">// Initialize &#39;sfacelist&#39; for constructing the face link of each segment.</span>
<a name="l18155"></a>18155   sfacelist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL);
<a name="l18156"></a>18156 
<a name="l18157"></a>18157   segmarker = 1;
<a name="l18158"></a>18158   subsegs-&gt;traversalinit();
<a name="l18159"></a>18159   subsegloop.sh = shellfacetraverse(subsegs);
<a name="l18160"></a>18160   <span class="keywordflow">while</span> (subsegloop.sh != (shellface *) NULL) {
<a name="l18161"></a>18161     subsegloop.shver = 0; <span class="comment">// For sure.</span>
<a name="l18162"></a>18162     torg = sorg(subsegloop);
<a name="l18163"></a>18163     tdest = sdest(subsegloop);
<a name="l18164"></a>18164     idx = pointmark(torg) - in-&gt;firstnumber;
<a name="l18165"></a>18165     <span class="comment">// Loop through the set of subfaces containing &#39;torg&#39;.  Get all the</span>
<a name="l18166"></a>18166     <span class="comment">//   subfaces containing the edge (torg, tdest). Save and order them</span>
<a name="l18167"></a>18167     <span class="comment">//   in &#39;sfacelist&#39;, the ordering is defined by the right-hand rule</span>
<a name="l18168"></a>18168     <span class="comment">//   with thumb points from torg to tdest.</span>
<a name="l18169"></a>18169     <span class="keywordflow">for</span> (k = idx2facelist[idx]; k &lt; idx2facelist[idx + 1]; k++) {
<a name="l18170"></a>18170       sface.sh = facesperverlist[k];
<a name="l18171"></a>18171       sface.shver = 0;
<a name="l18172"></a>18172       <span class="comment">// sface may be died due to the removing of duplicated subfaces.</span>
<a name="l18173"></a>18173       <span class="keywordflow">if</span> (!isdead(&amp;sface) &amp;&amp; isfacehasedge(&amp;sface, torg, tdest)) {
<a name="l18174"></a>18174         <span class="comment">// &#39;sface&#39; contains this segment.</span>
<a name="l18175"></a>18175         findedge(&amp;sface, torg, tdest);
<a name="l18176"></a>18176         <span class="comment">// Save it in &#39;sfacelist&#39;.</span>
<a name="l18177"></a>18177         <span class="keywordflow">if</span> (sfacelist-&gt;len() &lt; 2) {
<a name="l18178"></a>18178           sfacelist-&gt;append(&amp;sface);
<a name="l18179"></a>18179         } <span class="keywordflow">else</span> {
<a name="l18180"></a>18180           <span class="keywordflow">for</span> (m = 0; m &lt; sfacelist-&gt;len() - 1; m++) {
<a name="l18181"></a>18181             sface1 = * (face *)(* sfacelist)[m];
<a name="l18182"></a>18182             sface2 = * (face *)(* sfacelist)[m + 1];
<a name="l18183"></a>18183             da1 = facedihedral(torg, tdest, sapex(sface1), sapex(sface));
<a name="l18184"></a>18184             da2 = facedihedral(torg, tdest, sapex(sface1), sapex(sface2));
<a name="l18185"></a>18185             <span class="keywordflow">if</span> (da1 &lt; da2) {
<a name="l18186"></a>18186               <span class="keywordflow">break</span>;  <span class="comment">// Insert it after m.</span>
<a name="l18187"></a>18187             }
<a name="l18188"></a>18188           }
<a name="l18189"></a>18189           sfacelist-&gt;insert(m + 1, &amp;sface);
<a name="l18190"></a>18190         }
<a name="l18191"></a>18191       }
<a name="l18192"></a>18192     }
<a name="l18193"></a>18193     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l18194"></a>18194       printf(<span class="stringliteral">&quot;    Identifying %d segments of (%d  %d).\n&quot;</span>, sfacelist-&gt;len(),
<a name="l18195"></a>18195              pointmark(torg), pointmark(tdest));
<a name="l18196"></a>18196     }
<a name="l18197"></a>18197     <span class="comment">// Set the connection between this segment and faces containing it,</span>
<a name="l18198"></a>18198     <span class="comment">//   at the same time, remove redundant segments.</span>
<a name="l18199"></a>18199     <span class="keywordflow">for</span> (k = 0; k &lt; sfacelist-&gt;len(); k++) {
<a name="l18200"></a>18200       sface = *(face *)(* sfacelist)[k];
<a name="l18201"></a>18201       sspivot(sface, testseg);
<a name="l18202"></a>18202       <span class="comment">// If &#39;testseg&#39; is not &#39;subsegloop&#39;, it is a redundant segment that</span>
<a name="l18203"></a>18203       <span class="comment">//   needs be removed. BE CAREFUL it may already be removed. Do not</span>
<a name="l18204"></a>18204       <span class="comment">//   remove it twice, i.e., do test &#39;isdead()&#39; together.</span>
<a name="l18205"></a>18205       <span class="keywordflow">if</span> ((testseg.sh != subsegloop.sh) &amp;&amp; !isdead(&amp;testseg)) {
<a name="l18206"></a>18206         shellfacedealloc(subsegs, testseg.sh);
<a name="l18207"></a>18207       }
<a name="l18208"></a>18208       <span class="comment">// &#39;ssbond&#39; bonds the subface and the segment together, and dissloves</span>
<a name="l18209"></a>18209       <span class="comment">//   the old bond as well.</span>
<a name="l18210"></a>18210       ssbond(sface, subsegloop);
<a name="l18211"></a>18211     }
<a name="l18212"></a>18212     <span class="comment">// Set connection between these faces.</span>
<a name="l18213"></a>18213     sface = *(face *)(* sfacelist)[0];
<a name="l18214"></a>18214     <span class="keywordflow">for</span> (k = 1; k &lt;= sfacelist-&gt;len(); k++) {
<a name="l18215"></a>18215       <span class="keywordflow">if</span> (k &lt; sfacelist-&gt;len()) {
<a name="l18216"></a>18216         sface1 = *(face *)(* sfacelist)[k];
<a name="l18217"></a>18217       } <span class="keywordflow">else</span> {
<a name="l18218"></a>18218         sface1 = *(face *)(* sfacelist)[0];    <span class="comment">// Form a face loop.</span>
<a name="l18219"></a>18219       }
<a name="l18220"></a>18220       <span class="comment">/*</span>
<a name="l18221"></a>18221 <span class="comment">      // Check if these two subfaces are the same. It is possible when user</span>
<a name="l18222"></a>18222 <span class="comment">      //   defines one facet (or polygon) two or more times. If they are,</span>
<a name="l18223"></a>18223 <span class="comment">      //   they should not be bonded together, instead of that, one of them</span>
<a name="l18224"></a>18224 <span class="comment">      //   should be delete from the surface mesh.</span>
<a name="l18225"></a>18225 <span class="comment">      if ((sfacelist-&gt;len() &gt; 1) &amp;&amp; sapex(sface) == sapex(sface1)) {</span>
<a name="l18226"></a>18226 <span class="comment">        // They are duplicated faces.</span>
<a name="l18227"></a>18227 <span class="comment">        if (b-&gt;verbose &gt; 0) {</span>
<a name="l18228"></a>18228 <span class="comment">          printf(&quot;  A duplicated subface (%d, %d, %d) is removed.\n&quot;,</span>
<a name="l18229"></a>18229 <span class="comment">                 pointmark(torg), pointmark(tdest), pointmark(sapex(sface)));</span>
<a name="l18230"></a>18230 <span class="comment">        }</span>
<a name="l18231"></a>18231 <span class="comment">        if (k == sfacelist-&gt;len()) {</span>
<a name="l18232"></a>18232 <span class="comment">          // &#39;sface&#39; is the last face, however, it is same as the first one.</span>
<a name="l18233"></a>18233 <span class="comment">          //   In order to form the ring, we have to let the second last</span>
<a name="l18234"></a>18234 <span class="comment">          //   face bond to the first one &#39;sface1&#39;.</span>
<a name="l18235"></a>18235 <span class="comment">          shellfacedealloc(subfaces, sface.sh);</span>
<a name="l18236"></a>18236 <span class="comment">          assert(sfacelist-&gt;len() &gt;= 2);</span>
<a name="l18237"></a>18237 <span class="comment">          assert(k == sfacelist-&gt;len());</span>
<a name="l18238"></a>18238 <span class="comment">          sface = *(face *)(* sfacelist)[k - 2];</span>
<a name="l18239"></a>18239 <span class="comment">        } else {</span>
<a name="l18240"></a>18240 <span class="comment">          // &#39;sface1&#39; is in the middle and may be the last one.</span>
<a name="l18241"></a>18241 <span class="comment">          shellfacedealloc(subfaces, sface1.sh);</span>
<a name="l18242"></a>18242 <span class="comment">          // Skip this face and go to the next one.</span>
<a name="l18243"></a>18243 <span class="comment">          continue;</span>
<a name="l18244"></a>18244 <span class="comment">        }</span>
<a name="l18245"></a>18245 <span class="comment">      }</span>
<a name="l18246"></a>18246 <span class="comment">      */</span>
<a name="l18247"></a>18247       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l18248"></a>18248         printf(<span class="stringliteral">&quot;    Bond subfaces (%d, %d, %d) and (%d, %d, %d).\n&quot;</span>,
<a name="l18249"></a>18249                pointmark(torg), pointmark(tdest), pointmark(sapex(sface)),
<a name="l18250"></a>18250                pointmark(torg), pointmark(tdest), pointmark(sapex(sface1)));
<a name="l18251"></a>18251       }
<a name="l18252"></a>18252       sbond1(sface, sface1);
<a name="l18253"></a>18253       sface = sface1;
<a name="l18254"></a>18254     }
<a name="l18255"></a>18255     <span class="comment">// Set the unique segment marker into the unified segment.</span>
<a name="l18256"></a>18256     setshellmark(subsegloop, segmarker);
<a name="l18257"></a>18257     <span class="comment">// Increase the marker.</span>
<a name="l18258"></a>18258     segmarker++;
<a name="l18259"></a>18259     <span class="comment">// Clear the working list.</span>
<a name="l18260"></a>18260     sfacelist-&gt;clear();
<a name="l18261"></a>18261     subsegloop.sh = shellfacetraverse(subsegs);
<a name="l18262"></a>18262   }
<a name="l18263"></a>18263 
<a name="l18264"></a>18264   <span class="keyword">delete</span> [] idx2facelist;
<a name="l18265"></a>18265   <span class="keyword">delete</span> [] facesperverlist;
<a name="l18266"></a>18266   <span class="keyword">delete</span> sfacelist;
<a name="l18267"></a>18267 }
<a name="l18268"></a>18268 
<a name="l18270"></a>18270 <span class="comment">//                                                                           //</span>
<a name="l18271"></a>18271 <span class="comment">// mergefacets()    Merge adjacent facets to be one facet if they are        //</span>
<a name="l18272"></a>18272 <span class="comment">//                  coplanar and have the same boundary marker.              //</span>
<a name="l18273"></a>18273 <span class="comment">//                                                                           //</span>
<a name="l18274"></a>18274 <span class="comment">// Segments between two merged facets will be removed from the mesh.  If all //</span>
<a name="l18275"></a>18275 <span class="comment">// segments around a vertex have been removed, change its vertex type to be  //</span>
<a name="l18276"></a>18276 <span class="comment">// FREESUBVERTEX. Edge flips will be performed to ensure the Delaunayness of //</span>
<a name="l18277"></a>18277 <span class="comment">// the triangulation of merged facets.                                       //</span>
<a name="l18278"></a>18278 <span class="comment">//                                                                           //</span>
<a name="l18280"></a>18280 <span class="comment"></span>
<a name="l18281"></a>18281 <span class="keywordtype">void</span> tetgenmesh::mergefacets(queue* flipqueue)
<a name="l18282"></a>18282 {
<a name="l18283"></a>18283   face parentsh, neighsh, neineighsh;
<a name="l18284"></a>18284   face segloop;
<a name="l18285"></a>18285   point eorg, edest;
<a name="l18286"></a>18286   REAL ori;
<a name="l18287"></a>18287   <span class="keywordtype">bool</span> mergeflag, pbcflag;
<a name="l18288"></a>18288   <span class="keywordtype">int</span>* segspernodelist;
<a name="l18289"></a>18289   <span class="keywordtype">int</span> fidx1, fidx2;
<a name="l18290"></a>18290   <span class="keywordtype">int</span> i, j;
<a name="l18291"></a>18291 
<a name="l18292"></a>18292   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l18293"></a>18293     printf(<span class="stringliteral">&quot;  Merging coplanar facets.\n&quot;</span>);
<a name="l18294"></a>18294   }
<a name="l18295"></a>18295   <span class="comment">// Create and initialize &#39;segspernodelist&#39;.</span>
<a name="l18296"></a>18296   segspernodelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l18297"></a>18297   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) segspernodelist[i] = 0;
<a name="l18298"></a>18298 
<a name="l18299"></a>18299   <span class="comment">// Loop the segments, counter the number of segments sharing each vertex.</span>
<a name="l18300"></a>18300   subsegs-&gt;traversalinit();
<a name="l18301"></a>18301   segloop.sh = shellfacetraverse(subsegs);
<a name="l18302"></a>18302   <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l18303"></a>18303     <span class="comment">// Increment the number of sharing segments for each endpoint.</span>
<a name="l18304"></a>18304     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l18305"></a>18305       j = pointmark((point) segloop.sh[3 + i]);
<a name="l18306"></a>18306       segspernodelist[j]++;
<a name="l18307"></a>18307     }
<a name="l18308"></a>18308     segloop.sh = shellfacetraverse(subsegs);
<a name="l18309"></a>18309   }
<a name="l18310"></a>18310 
<a name="l18311"></a>18311   <span class="comment">// Loop the segments, find out dead segments.</span>
<a name="l18312"></a>18312   subsegs-&gt;traversalinit();
<a name="l18313"></a>18313   segloop.sh = shellfacetraverse(subsegs);
<a name="l18314"></a>18314   <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l18315"></a>18315     eorg = sorg(segloop);
<a name="l18316"></a>18316     edest = sdest(segloop);
<a name="l18317"></a>18317     spivot(segloop, parentsh);
<a name="l18318"></a>18318     spivot(parentsh, neighsh);
<a name="l18319"></a>18319     spivot(neighsh, neineighsh);
<a name="l18320"></a>18320     <span class="keywordflow">if</span> (parentsh.sh != neighsh.sh &amp;&amp; parentsh.sh == neineighsh.sh) {
<a name="l18321"></a>18321       <span class="comment">// Exactly two subfaces at this segment.</span>
<a name="l18322"></a>18322       fidx1 = shellmark(parentsh) - 1;
<a name="l18323"></a>18323       fidx2 = shellmark(neighsh) - 1;
<a name="l18324"></a>18324       pbcflag = <span class="keyword">false</span>;
<a name="l18325"></a>18325       <span class="keywordflow">if</span> (checkpbcs) {
<a name="l18326"></a>18326         pbcflag = (shellpbcgroup(parentsh) &gt;= 0)
<a name="l18327"></a>18327           || (shellpbcgroup(neighsh) &gt;= 0);
<a name="l18328"></a>18328       }
<a name="l18329"></a>18329       <span class="comment">// Possibly merge them if they are not in the same facet.</span>
<a name="l18330"></a>18330       <span class="keywordflow">if</span> ((fidx1 != fidx2) &amp;&amp; !pbcflag) {
<a name="l18331"></a>18331         <span class="comment">// Test if they are coplanar.</span>
<a name="l18332"></a>18332         ori = orient3d(eorg, edest, sapex(parentsh), sapex(neighsh));
<a name="l18333"></a>18333         <span class="keywordflow">if</span> (ori != 0.0) {
<a name="l18334"></a>18334           <span class="keywordflow">if</span> (iscoplanar(eorg, edest, sapex(parentsh), sapex(neighsh), ori,
<a name="l18335"></a>18335                          b-&gt;epsilon)) {
<a name="l18336"></a>18336             ori = 0.0; <span class="comment">// They are assumed as coplanar.</span>
<a name="l18337"></a>18337           }
<a name="l18338"></a>18338         }
<a name="l18339"></a>18339         <span class="keywordflow">if</span> (ori == 0.0) {
<a name="l18340"></a>18340           mergeflag = (in-&gt;facetmarkerlist == (<span class="keywordtype">int</span> *) NULL ||
<a name="l18341"></a>18341           in-&gt;facetmarkerlist[fidx1] == in-&gt;facetmarkerlist[fidx2]);
<a name="l18342"></a>18342           <span class="keywordflow">if</span> (mergeflag) {
<a name="l18343"></a>18343             <span class="comment">// This segment becomes dead.</span>
<a name="l18344"></a>18344             <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l18345"></a>18345               printf(<span class="stringliteral">&quot;  Removing segment (%d, %d).\n&quot;</span>, pointmark(eorg),
<a name="l18346"></a>18346                      pointmark(edest));
<a name="l18347"></a>18347             }
<a name="l18348"></a>18348             ssdissolve(parentsh);
<a name="l18349"></a>18349             ssdissolve(neighsh);
<a name="l18350"></a>18350             shellfacedealloc(subsegs, segloop.sh);
<a name="l18351"></a>18351             j = pointmark(eorg);
<a name="l18352"></a>18352             segspernodelist[j]--;
<a name="l18353"></a>18353             <span class="keywordflow">if</span> (segspernodelist[j] == 0) {
<a name="l18354"></a>18354               setpointtype(eorg, FREESUBVERTEX);
<a name="l18355"></a>18355             }
<a name="l18356"></a>18356             j = pointmark(edest);
<a name="l18357"></a>18357             segspernodelist[j]--;
<a name="l18358"></a>18358             <span class="keywordflow">if</span> (segspernodelist[j] == 0) {
<a name="l18359"></a>18359               setpointtype(edest, FREESUBVERTEX);
<a name="l18360"></a>18360             }
<a name="l18361"></a>18361             <span class="comment">// Add &#39;parentsh&#39; to queue checking for flip.</span>
<a name="l18362"></a>18362             enqueueflipedge(parentsh, flipqueue);
<a name="l18363"></a>18363           }
<a name="l18364"></a>18364         }
<a name="l18365"></a>18365       }
<a name="l18366"></a>18366     }
<a name="l18367"></a>18367     segloop.sh = shellfacetraverse(subsegs);
<a name="l18368"></a>18368   }
<a name="l18369"></a>18369 
<a name="l18370"></a>18370   <span class="keywordflow">if</span> (!flipqueue-&gt;empty()) {
<a name="l18371"></a>18371     <span class="comment">// Restore the Delaunay property in the facet triangulation.</span>
<a name="l18372"></a>18372     flipsub(flipqueue);
<a name="l18373"></a>18373   }
<a name="l18374"></a>18374 
<a name="l18375"></a>18375   <span class="keyword">delete</span> [] segspernodelist;
<a name="l18376"></a>18376 }
<a name="l18377"></a>18377 
<a name="l18379"></a>18379 <span class="comment">//                                                                           //</span>
<a name="l18380"></a>18380 <span class="comment">// meshsurface()    Create the surface mesh of a PLC.                        //</span>
<a name="l18381"></a>18381 <span class="comment">//                                                                           //</span>
<a name="l18382"></a>18382 <span class="comment">// Let X be the PLC, the surface mesh S of X consists of triangulated facets.//</span>
<a name="l18383"></a>18383 <span class="comment">// S is created mainly in the following steps:                               //</span>
<a name="l18384"></a>18384 <span class="comment">//                                                                           //</span>
<a name="l18385"></a>18385 <span class="comment">// (1) Form the CDT of each facet of X separately (by routine triangulate()).//</span>
<a name="l18386"></a>18386 <span class="comment">// After it is done, the subfaces of each facet are connected to each other, //</span>
<a name="l18387"></a>18387 <span class="comment">// however there is no connection between facets yet.  Notice each facet has //</span>
<a name="l18388"></a>18388 <span class="comment">// its own segments, some of them are duplicated.                            //</span>
<a name="l18389"></a>18389 <span class="comment">//                                                                           //</span>
<a name="l18390"></a>18390 <span class="comment">// (2) Remove the redundant segments created in step (1) (by routine unify-  //</span>
<a name="l18391"></a>18391 <span class="comment">// segment()). The subface ring of each segment is created,  the connection  //</span>
<a name="l18392"></a>18392 <span class="comment">// between facets are established as well.                                   //</span>
<a name="l18393"></a>18393 <span class="comment">//                                                                           //</span>
<a name="l18394"></a>18394 <span class="comment">// The return value indicates the number of segments of X.                   //</span>
<a name="l18395"></a>18395 <span class="comment">//                                                                           //</span>
<a name="l18397"></a>18397 <span class="comment"></span>
<a name="l18398"></a>18398 <span class="keywordtype">long</span> tetgenmesh::meshsurface()
<a name="l18399"></a>18399 {
<a name="l18400"></a>18400   list *ptlist, *conlist;
<a name="l18401"></a>18401   queue *flipqueue;
<a name="l18402"></a>18402   tetgenio::facet *f;
<a name="l18403"></a>18403   tetgenio::polygon *p;
<a name="l18404"></a>18404   <a class="code" href="structmemorypool.html">memorypool</a> *viri;
<a name="l18405"></a>18405   point *idx2verlist;
<a name="l18406"></a>18406   point tstart, tend, *cons;
<a name="l18407"></a>18407   <span class="keywordtype">int</span> *worklist;
<a name="l18408"></a>18408   <span class="keywordtype">int</span> end1, end2;
<a name="l18409"></a>18409   <span class="keywordtype">int</span> shmark, i, j;
<a name="l18410"></a>18410 
<a name="l18411"></a>18411   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l18412"></a>18412     printf(<span class="stringliteral">&quot;Creating surface mesh.\n&quot;</span>);
<a name="l18413"></a>18413   }
<a name="l18414"></a>18414 
<a name="l18415"></a>18415   <span class="comment">// Compute a mapping from indices to points.</span>
<a name="l18416"></a>18416   makeindex2pointmap(idx2verlist);
<a name="l18417"></a>18417   <span class="comment">// Compute a mapping from points to tets for computing abovepoints.</span>
<a name="l18418"></a>18418   makepoint2tetmap();
<a name="l18419"></a>18419   <span class="comment">// Initialize &#39;facetabovepointarray&#39;.</span>
<a name="l18420"></a>18420   facetabovepointarray = <span class="keyword">new</span> point[in-&gt;numberoffacets + 1];
<a name="l18421"></a>18421   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoffacets + 1; i++) {
<a name="l18422"></a>18422     facetabovepointarray[i] = (point) NULL;
<a name="l18423"></a>18423   }
<a name="l18424"></a>18424   <span class="keywordflow">if</span> (checkpbcs) {
<a name="l18425"></a>18425     <span class="comment">// Initialize the global array &#39;subpbcgrouptable&#39;.</span>
<a name="l18426"></a>18426     createsubpbcgrouptable();
<a name="l18427"></a>18427   }
<a name="l18428"></a>18428 
<a name="l18429"></a>18429   <span class="comment">// Initialize working lists.</span>
<a name="l18430"></a>18430   viri = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(shellface *), 1024, POINTER, 0);
<a name="l18431"></a>18431   flipqueue = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l18432"></a>18432   ptlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL, 256);
<a name="l18433"></a>18433   conlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *) * 2, NULL, 256);
<a name="l18434"></a>18434   worklist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l18435"></a>18435   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) worklist[i] = 0;
<a name="l18436"></a>18436 
<a name="l18437"></a>18437   <span class="comment">// Loop the facet list, triangulate each facet. On finish, all subfaces</span>
<a name="l18438"></a>18438   <span class="comment">//   are in &#39;subfaces&#39;, all segments are in &#39;subsegs&#39;. Notice: there&#39;re</span>
<a name="l18439"></a>18439   <span class="comment">//   redundant segments.  Remember: All facet indices count from 1.</span>
<a name="l18440"></a>18440   <span class="keywordflow">for</span> (shmark = 1; shmark &lt;= in-&gt;numberoffacets; shmark++) {
<a name="l18441"></a>18441     <span class="comment">// Get a facet F.</span>
<a name="l18442"></a>18442     f = &amp;in-&gt;facetlist[shmark - 1];
<a name="l18443"></a>18443 
<a name="l18444"></a>18444     <span class="comment">// Process the duplicated points first, they are marked with type</span>
<a name="l18445"></a>18445     <span class="comment">//   DUPLICATEDVERTEX by incrflipdelaunay().  Let p and q are dup.</span>
<a name="l18446"></a>18446     <span class="comment">//   and the index of p is larger than q&#39;s, p is substituted by q.</span>
<a name="l18447"></a>18447     <span class="comment">//   In a STL mesh, duplicated points are implicitly included.</span>
<a name="l18448"></a>18448     <span class="keywordflow">if</span> ((b-&gt;object == tetgenbehavior::STL) || dupverts) {
<a name="l18449"></a>18449       <span class="comment">// Loop all polygons of this facet.</span>
<a name="l18450"></a>18450       <span class="keywordflow">for</span> (i = 0; i &lt; f-&gt;numberofpolygons; i++) {
<a name="l18451"></a>18451         p = &amp;(f-&gt;polygonlist[i]);
<a name="l18452"></a>18452         <span class="comment">// Loop other vertices of this polygon.</span>
<a name="l18453"></a>18453         <span class="keywordflow">for</span> (j = 0; j &lt; p-&gt;numberofvertices; j++) {
<a name="l18454"></a>18454           end1 = p-&gt;vertexlist[j];
<a name="l18455"></a>18455           tstart = idx2verlist[end1 - in-&gt;firstnumber];
<a name="l18456"></a>18456           <span class="keywordflow">if</span> (pointtype(tstart) == DUPLICATEDVERTEX) {
<a name="l18457"></a>18457             <span class="comment">// Reset the index of vertex-j.</span>
<a name="l18458"></a>18458             tend = point2ppt(tstart);
<a name="l18459"></a>18459             end2 = pointmark(tend);
<a name="l18460"></a>18460             p-&gt;vertexlist[j] = end2;
<a name="l18461"></a>18461           }
<a name="l18462"></a>18462         }
<a name="l18463"></a>18463       }
<a name="l18464"></a>18464     }
<a name="l18465"></a>18465 
<a name="l18466"></a>18466     <span class="comment">// Loop polygons of F, get the set V of vertices and S of segments.</span>
<a name="l18467"></a>18467     <span class="keywordflow">for</span> (i = 0; i &lt; f-&gt;numberofpolygons; i++) {
<a name="l18468"></a>18468       <span class="comment">// Get a polygon.</span>
<a name="l18469"></a>18469       p = &amp;(f-&gt;polygonlist[i]);
<a name="l18470"></a>18470       <span class="comment">// Get the first vertex.</span>
<a name="l18471"></a>18471       end1 = p-&gt;vertexlist[0];
<a name="l18472"></a>18472       <span class="keywordflow">if</span> ((end1 &lt; in-&gt;firstnumber) ||
<a name="l18473"></a>18473           (end1 &gt;= in-&gt;firstnumber + in-&gt;numberofpoints)) {
<a name="l18474"></a>18474         <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l18475"></a>18475           printf(<span class="stringliteral">&quot;Warning:  Invalid the 1st vertex %d of polygon&quot;</span>, end1);
<a name="l18476"></a>18476           printf(<span class="stringliteral">&quot; %d in facet %d.\n&quot;</span>, i + 1, shmark);
<a name="l18477"></a>18477         }
<a name="l18478"></a>18478         <span class="keywordflow">continue</span>; <span class="comment">// Skip this polygon.</span>
<a name="l18479"></a>18479       }
<a name="l18480"></a>18480       tstart = idx2verlist[end1 - in-&gt;firstnumber];
<a name="l18481"></a>18481       <span class="comment">// Add tstart to V if it haven&#39;t been added yet.</span>
<a name="l18482"></a>18482       <span class="keywordflow">if</span> (worklist[end1] == 0) {
<a name="l18483"></a>18483         ptlist-&gt;append(&amp;tstart);
<a name="l18484"></a>18484         worklist[end1] = 1;
<a name="l18485"></a>18485       }
<a name="l18486"></a>18486       <span class="comment">// Loop other vertices of this polygon.</span>
<a name="l18487"></a>18487       <span class="keywordflow">for</span> (j = 1; j &lt;= p-&gt;numberofvertices; j++) {
<a name="l18488"></a>18488         <span class="comment">// get a vertex.</span>
<a name="l18489"></a>18489         <span class="keywordflow">if</span> (j &lt; p-&gt;numberofvertices) {
<a name="l18490"></a>18490           end2 = p-&gt;vertexlist[j];
<a name="l18491"></a>18491         } <span class="keywordflow">else</span> {
<a name="l18492"></a>18492           end2 = p-&gt;vertexlist[0];  <span class="comment">// Form a loop from last to first.</span>
<a name="l18493"></a>18493         }
<a name="l18494"></a>18494         <span class="keywordflow">if</span> ((end2 &lt; in-&gt;firstnumber) ||
<a name="l18495"></a>18495             (end2 &gt;= in-&gt;firstnumber + in-&gt;numberofpoints)) {
<a name="l18496"></a>18496           <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l18497"></a>18497             printf(<span class="stringliteral">&quot;Warning:  Invalid vertex %d in polygon %d&quot;</span>, end2, i + 1);
<a name="l18498"></a>18498             printf(<span class="stringliteral">&quot; in facet %d.\n&quot;</span>, shmark);
<a name="l18499"></a>18499           }
<a name="l18500"></a>18500         } <span class="keywordflow">else</span> {
<a name="l18501"></a>18501           <span class="keywordflow">if</span> (end1 != end2) {
<a name="l18502"></a>18502             <span class="comment">// &#39;end1&#39; and &#39;end2&#39; form a segment.</span>
<a name="l18503"></a>18503             tend = idx2verlist[end2 - in-&gt;firstnumber];
<a name="l18504"></a>18504             <span class="comment">// Add tstart to V if it haven&#39;t been added yet.</span>
<a name="l18505"></a>18505             <span class="keywordflow">if</span> (worklist[end2] == 0) {
<a name="l18506"></a>18506               ptlist-&gt;append(&amp;tend);
<a name="l18507"></a>18507               worklist[end2] = 1;
<a name="l18508"></a>18508             }
<a name="l18509"></a>18509             <span class="comment">// Save the segment in S (conlist).</span>
<a name="l18510"></a>18510             cons = (point *) conlist-&gt;append(NULL);
<a name="l18511"></a>18511             cons[0] = tstart;
<a name="l18512"></a>18512             cons[1] = tend;
<a name="l18513"></a>18513             <span class="comment">// Set the start for next continuous segment.</span>
<a name="l18514"></a>18514             end1 = end2;
<a name="l18515"></a>18515             tstart = tend;
<a name="l18516"></a>18516           } <span class="keywordflow">else</span> {
<a name="l18517"></a>18517             <span class="comment">// Two identical vertices represent an isolated vertex of F.</span>
<a name="l18518"></a>18518             <span class="keywordflow">if</span> (p-&gt;numberofvertices &gt; 2) {
<a name="l18519"></a>18519               <span class="comment">// This may be an error in the input, anyway, we can continue</span>
<a name="l18520"></a>18520               <span class="comment">//   by simply skipping this segment.</span>
<a name="l18521"></a>18521               <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l18522"></a>18522                 printf(<span class="stringliteral">&quot;Warning:  Polygon %d has two identical verts&quot;</span>, i + 1);
<a name="l18523"></a>18523                 printf(<span class="stringliteral">&quot; in facet %d.\n&quot;</span>, shmark);
<a name="l18524"></a>18524               }
<a name="l18525"></a>18525             }
<a name="l18526"></a>18526             <span class="comment">// Ignore this vertex.</span>
<a name="l18527"></a>18527           }
<a name="l18528"></a>18528         }
<a name="l18529"></a>18529         <span class="comment">// Is the polygon degenerate (a segment or a vertex)?</span>
<a name="l18530"></a>18530         <span class="keywordflow">if</span> (p-&gt;numberofvertices == 2) <span class="keywordflow">break</span>;
<a name="l18531"></a>18531       }
<a name="l18532"></a>18532     }
<a name="l18533"></a>18533     <span class="comment">// Unmark vertices.</span>
<a name="l18534"></a>18534     <span class="keywordflow">for</span> (i = 0; i &lt; ptlist-&gt;len(); i++) {
<a name="l18535"></a>18535       tstart = * (point *)(* ptlist)[i];
<a name="l18536"></a>18536       end1 = pointmark(tstart);
<a name="l18537"></a>18537       assert(worklist[end1] == 1);
<a name="l18538"></a>18538       worklist[end1] = 0;
<a name="l18539"></a>18539     }
<a name="l18540"></a>18540 
<a name="l18541"></a>18541     <span class="comment">// Create a CDT of F.</span>
<a name="l18542"></a>18542     triangulate(shmark, b-&gt;epsilon * 1e+2, ptlist, conlist, f-&gt;numberofholes,
<a name="l18543"></a>18543                 f-&gt;holelist, viri, flipqueue);
<a name="l18544"></a>18544     <span class="comment">// Clear working lists.</span>
<a name="l18545"></a>18545     ptlist-&gt;clear();
<a name="l18546"></a>18546     conlist-&gt;clear();
<a name="l18547"></a>18547     viri-&gt;restart();
<a name="l18548"></a>18548   }
<a name="l18549"></a>18549 
<a name="l18550"></a>18550   <span class="comment">// Unify segments in &#39;subsegs&#39;, remove redundant segments.  Face links</span>
<a name="l18551"></a>18551   <span class="comment">//   of segments are also built.</span>
<a name="l18552"></a>18552   unifysegments();
<a name="l18553"></a>18553   <span class="comment">// Remember the number of input segments (for output).</span>
<a name="l18554"></a>18554   insegments = subsegs-&gt;items;
<a name="l18555"></a>18555 
<a name="l18556"></a>18556   <span class="keywordflow">if</span> (checkpbcs) {
<a name="l18557"></a>18557     <span class="comment">// Create the global array &#39;segpbcgrouptable&#39;.</span>
<a name="l18558"></a>18558     createsegpbcgrouptable();
<a name="l18559"></a>18559   }
<a name="l18560"></a>18560 
<a name="l18561"></a>18561   <span class="keywordflow">if</span> (b-&gt;object == tetgenbehavior::STL) {
<a name="l18562"></a>18562     <span class="comment">// Remove redundant vertices (for .stl input mesh).</span>
<a name="l18563"></a>18563     jettisonnodes();
<a name="l18564"></a>18564   }
<a name="l18565"></a>18565 
<a name="l18566"></a>18566   <span class="keywordflow">if</span> (!b-&gt;nomerge &amp;&amp; !b-&gt;nobisect &amp;&amp; !checkpbcs) {
<a name="l18567"></a>18567     <span class="comment">// No &#39;-M&#39; switch - merge adjacent facets if they are coplanar.</span>
<a name="l18568"></a>18568     mergefacets(flipqueue);
<a name="l18569"></a>18569   }
<a name="l18570"></a>18570 
<a name="l18571"></a>18571   <span class="keyword">delete</span> [] idx2verlist;
<a name="l18572"></a>18572   <span class="keyword">delete</span> [] worklist;
<a name="l18573"></a>18573   <span class="keyword">delete</span> ptlist;
<a name="l18574"></a>18574   <span class="keyword">delete</span> conlist;
<a name="l18575"></a>18575   <span class="keyword">delete</span> flipqueue;
<a name="l18576"></a>18576   <span class="keyword">delete</span> viri;
<a name="l18577"></a>18577 
<a name="l18578"></a>18578   <span class="keywordflow">return</span> subsegs-&gt;items;
<a name="l18579"></a>18579 }
<a name="l18580"></a>18580 
<a name="l18581"></a>18581 <span class="comment">//</span>
<a name="l18582"></a>18582 <span class="comment">// End of surface triangulation routines</span>
<a name="l18583"></a>18583 <span class="comment">//</span>
<a name="l18584"></a>18584 
<a name="l18586"></a>18586 <span class="comment">//                                                                           //</span>
<a name="l18587"></a>18587 <span class="comment">// interecursive()    Recursively do intersection test on a set of triangles.//</span>
<a name="l18588"></a>18588 <span class="comment">//                                                                           //</span>
<a name="l18589"></a>18589 <span class="comment">// Recursively split the set &#39;subfacearray&#39; of subfaces into two sets using  //</span>
<a name="l18590"></a>18590 <span class="comment">// a cut plane parallel to x-, or, y-, or z-axies.  The split criteria are   //</span>
<a name="l18591"></a>18591 <span class="comment">// follows. Assume the cut plane is H, and H+ denotes the left halfspace of  //</span>
<a name="l18592"></a>18592 <span class="comment">// H, and H- denotes the right halfspace of H; and s be a subface:           //</span>
<a name="l18593"></a>18593 <span class="comment">//                                                                           //</span>
<a name="l18594"></a>18594 <span class="comment">//    (1) If all points of s lie at H+, put it into left array;              //</span>
<a name="l18595"></a>18595 <span class="comment">//    (2) If all points of s lie at H-, put it into right array;             //</span>
<a name="l18596"></a>18596 <span class="comment">//    (3) If some points of s lie at H+ and some of lie at H-, or some       //</span>
<a name="l18597"></a>18597 <span class="comment">//        points lie on H, put it into both arraies.                         //</span>
<a name="l18598"></a>18598 <span class="comment">//                                                                           //</span>
<a name="l18599"></a>18599 <span class="comment">// Partitions by x-axis if axis == &#39;0&#39;; by y-axis if axis == &#39;1&#39;; by z-axis  //</span>
<a name="l18600"></a>18600 <span class="comment">// if axis == &#39;2&#39;. If current cut plane is parallel to the x-axis, the next  //</span>
<a name="l18601"></a>18601 <span class="comment">// one will be parallel to y-axis, and the next one after the next is z-axis,//</span>
<a name="l18602"></a>18602 <span class="comment">// and then alternately return back to x-axis.                               //</span>
<a name="l18603"></a>18603 <span class="comment">//                                                                           //</span>
<a name="l18604"></a>18604 <span class="comment">// Stop splitting when the number of triangles of the input array is not     //</span>
<a name="l18605"></a>18605 <span class="comment">// decreased anymore. Do tests on the current set.                           //</span>
<a name="l18606"></a>18606 <span class="comment">//                                                                           //</span>
<a name="l18608"></a>18608 <span class="comment"></span>
<a name="l18609"></a>18609 <span class="keywordtype">void</span> tetgenmesh::
<a name="l18610"></a>18610 interecursive(shellface** subfacearray, <span class="keywordtype">int</span> arraysize, <span class="keywordtype">int</span> axis, REAL bxmin,
<a name="l18611"></a>18611               REAL bxmax, REAL bymin, REAL bymax, REAL bzmin, REAL bzmax,
<a name="l18612"></a>18612               <span class="keywordtype">int</span>* internum)
<a name="l18613"></a>18613 {
<a name="l18614"></a>18614   shellface **leftarray, **rightarray;
<a name="l18615"></a>18615   face sface1, sface2;
<a name="l18616"></a>18616   point p1, p2, p3;
<a name="l18617"></a>18617   point p4, p5, p6;
<a name="l18618"></a>18618   <span class="keyword">enum</span> interresult intersect;
<a name="l18619"></a>18619   REAL split;
<a name="l18620"></a>18620   <span class="keywordtype">bool</span> toleft, toright;
<a name="l18621"></a>18621   <span class="keywordtype">int</span> leftsize, rightsize;
<a name="l18622"></a>18622   <span class="keywordtype">int</span> i, j;
<a name="l18623"></a>18623 
<a name="l18624"></a>18624   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l18625"></a>18625     printf(<span class="stringliteral">&quot;  Recur %d faces. Bbox (%g, %g, %g),(%g, %g, %g). %s-axis\n&quot;</span>,
<a name="l18626"></a>18626            arraysize, bxmin, bymin, bzmin, bxmax, bymax, bzmax,
<a name="l18627"></a>18627            axis == 0 ? <span class="stringliteral">&quot;x&quot;</span> : (axis == 1 ? <span class="stringliteral">&quot;y&quot;</span> : <span class="stringliteral">&quot;z&quot;</span>));
<a name="l18628"></a>18628   }
<a name="l18629"></a>18629 
<a name="l18630"></a>18630   leftarray = <span class="keyword">new</span> shellface*[arraysize];
<a name="l18631"></a>18631   <span class="keywordflow">if</span> (leftarray == NULL) {
<a name="l18632"></a>18632     printf(<span class="stringliteral">&quot;Error in interecursive():  Insufficient memory.\n&quot;</span>);
<a name="l18633"></a>18633     terminatetetgen(1);
<a name="l18634"></a>18634   }
<a name="l18635"></a>18635   rightarray = <span class="keyword">new</span> shellface*[arraysize];
<a name="l18636"></a>18636   <span class="keywordflow">if</span> (rightarray == NULL) {
<a name="l18637"></a>18637     printf(<span class="stringliteral">&quot;Error in interecursive():  Insufficient memory.\n&quot;</span>);
<a name="l18638"></a>18638     terminatetetgen(1);
<a name="l18639"></a>18639   }
<a name="l18640"></a>18640   leftsize = rightsize = 0;
<a name="l18641"></a>18641 
<a name="l18642"></a>18642   <span class="keywordflow">if</span> (axis == 0) {
<a name="l18643"></a>18643     <span class="comment">// Split along x-axis.</span>
<a name="l18644"></a>18644     split = 0.5 * (bxmin + bxmax);
<a name="l18645"></a>18645   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (axis == 1) {
<a name="l18646"></a>18646     <span class="comment">// Split along y-axis.</span>
<a name="l18647"></a>18647     split = 0.5 * (bymin + bymax);
<a name="l18648"></a>18648   } <span class="keywordflow">else</span> {
<a name="l18649"></a>18649     <span class="comment">// Split along z-axis.</span>
<a name="l18650"></a>18650     split = 0.5 * (bzmin + bzmax);
<a name="l18651"></a>18651   }
<a name="l18652"></a>18652 
<a name="l18653"></a>18653   <span class="keywordflow">for</span> (i = 0; i &lt; arraysize; i++) {
<a name="l18654"></a>18654     sface1.sh = subfacearray[i];
<a name="l18655"></a>18655     p1 = (point) sface1.sh[3];
<a name="l18656"></a>18656     p2 = (point) sface1.sh[4];
<a name="l18657"></a>18657     p3 = (point) sface1.sh[5];
<a name="l18658"></a>18658     toleft = toright = <span class="keyword">false</span>;
<a name="l18659"></a>18659     if (p1[axis] &lt; split) {
<a name="l18660"></a>18660       toleft = <span class="keyword">true</span>;
<a name="l18661"></a>18661       <span class="keywordflow">if</span> (p2[axis] &gt;= split || p3[axis] &gt;= split) {
<a name="l18662"></a>18662         toright = <span class="keyword">true</span>;
<a name="l18663"></a>18663       }
<a name="l18664"></a>18664     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (p1[axis] &gt; split) {
<a name="l18665"></a>18665       toright = <span class="keyword">true</span>;
<a name="l18666"></a>18666       <span class="keywordflow">if</span> (p2[axis] &lt;= split || p3[axis] &lt;= split) {
<a name="l18667"></a>18667         toleft = <span class="keyword">true</span>;
<a name="l18668"></a>18668       }
<a name="l18669"></a>18669     } <span class="keywordflow">else</span> {
<a name="l18670"></a>18670       <span class="comment">// p1[axis] == split;</span>
<a name="l18671"></a>18671       toleft = <span class="keyword">true</span>;
<a name="l18672"></a>18672       toright = <span class="keyword">true</span>;
<a name="l18673"></a>18673     }
<a name="l18674"></a>18674     <span class="comment">// At least one is true;</span>
<a name="l18675"></a>18675 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l18676"></a>18676 <span class="preprocessor"></span>    assert(!(toleft == <span class="keyword">false</span> &amp;&amp; toright == <span class="keyword">false</span>));
<a name="l18677"></a>18677 <span class="preprocessor">#endif</span>
<a name="l18678"></a>18678 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (toleft) {
<a name="l18679"></a>18679       leftarray[leftsize] = sface1.sh;
<a name="l18680"></a>18680       leftsize++;
<a name="l18681"></a>18681     }
<a name="l18682"></a>18682     <span class="keywordflow">if</span> (toright) {
<a name="l18683"></a>18683       rightarray[rightsize] = sface1.sh;
<a name="l18684"></a>18684       rightsize++;
<a name="l18685"></a>18685     }
<a name="l18686"></a>18686   }
<a name="l18687"></a>18687 
<a name="l18688"></a>18688   <span class="keywordflow">if</span> (leftsize &lt; arraysize &amp;&amp; rightsize &lt; arraysize) {
<a name="l18689"></a>18689     <span class="comment">// Continue to partition the input set. Now &#39;subfacearray&#39; has been</span>
<a name="l18690"></a>18690     <span class="comment">//   split into two sets, it&#39;s memory can be freed. &#39;leftarray&#39; and</span>
<a name="l18691"></a>18691     <span class="comment">//   &#39;rightarray&#39; will be freed in the next recursive (after they&#39;re</span>
<a name="l18692"></a>18692     <span class="comment">//   partitioned again or performing tests).</span>
<a name="l18693"></a>18693     <span class="keyword">delete</span> [] subfacearray;
<a name="l18694"></a>18694     <span class="comment">// Continue to split these two sets.</span>
<a name="l18695"></a>18695     <span class="keywordflow">if</span> (axis == 0) {
<a name="l18696"></a>18696       interecursive(leftarray, leftsize, 1, bxmin, split, bymin, bymax,
<a name="l18697"></a>18697                     bzmin, bzmax, internum);
<a name="l18698"></a>18698       interecursive(rightarray, rightsize, 1, split, bxmax, bymin, bymax,
<a name="l18699"></a>18699                     bzmin, bzmax, internum);
<a name="l18700"></a>18700     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (axis == 1) {
<a name="l18701"></a>18701       interecursive(leftarray, leftsize, 2, bxmin, bxmax, bymin, split,
<a name="l18702"></a>18702                     bzmin, bzmax, internum);
<a name="l18703"></a>18703       interecursive(rightarray, rightsize, 2, bxmin, bxmax, split, bymax,
<a name="l18704"></a>18704                     bzmin, bzmax, internum);
<a name="l18705"></a>18705     } <span class="keywordflow">else</span> {
<a name="l18706"></a>18706       interecursive(leftarray, leftsize, 0, bxmin, bxmax, bymin, bymax,
<a name="l18707"></a>18707                     bzmin, split, internum);
<a name="l18708"></a>18708       interecursive(rightarray, rightsize, 0, bxmin, bxmax, bymin, bymax,
<a name="l18709"></a>18709                     split, bzmax, internum);
<a name="l18710"></a>18710     }
<a name="l18711"></a>18711   } <span class="keywordflow">else</span> {
<a name="l18712"></a>18712     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l18713"></a>18713       printf(<span class="stringliteral">&quot;  Checking intersecting faces.\n&quot;</span>);
<a name="l18714"></a>18714     }
<a name="l18715"></a>18715     <span class="comment">// Perform a brute-force compare on the set.</span>
<a name="l18716"></a>18716     <span class="keywordflow">for</span> (i = 0; i &lt; arraysize; i++) {
<a name="l18717"></a>18717       sface1.sh = subfacearray[i];
<a name="l18718"></a>18718       p1 = (point) sface1.sh[3];
<a name="l18719"></a>18719       p2 = (point) sface1.sh[4];
<a name="l18720"></a>18720       p3 = (point) sface1.sh[5];
<a name="l18721"></a>18721       for (j = i + 1; j &lt; arraysize; j++) {
<a name="l18722"></a>18722         sface2.sh = subfacearray[j];
<a name="l18723"></a>18723         p4 = (point) sface2.sh[3];
<a name="l18724"></a>18724         p5 = (point) sface2.sh[4];
<a name="l18725"></a>18725         p6 = (point) sface2.sh[5];
<a name="l18726"></a>18726         intersect = tri_tri_inter(p1, p2, p3, p4, p5, p6);
<a name="l18727"></a>18727         <span class="keywordflow">if</span> (intersect == INTERSECT || intersect == SHAREFACE) {
<a name="l18728"></a>18728           <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l18729"></a>18729             <span class="keywordflow">if</span> (intersect == INTERSECT) {
<a name="l18730"></a>18730               printf(<span class="stringliteral">&quot;  Facet #%d intersects facet #%d at triangles:\n&quot;</span>,
<a name="l18731"></a>18731                      shellmark(sface1), shellmark(sface2));
<a name="l18732"></a>18732               printf(<span class="stringliteral">&quot;    (%4d, %4d, %4d) and (%4d, %4d, %4d)\n&quot;</span>,
<a name="l18733"></a>18733                      pointmark(p1), pointmark(p2), pointmark(p3),
<a name="l18734"></a>18734                      pointmark(p4), pointmark(p5), pointmark(p6));
<a name="l18735"></a>18735             } <span class="keywordflow">else</span> {
<a name="l18736"></a>18736               printf(<span class="stringliteral">&quot;  Facet #%d duplicates facet #%d at triangle:\n&quot;</span>,
<a name="l18737"></a>18737                      shellmark(sface1), shellmark(sface2));
<a name="l18738"></a>18738               printf(<span class="stringliteral">&quot;    (%4d, %4d, %4d)\n&quot;</span>, pointmark(p1), pointmark(p2),
<a name="l18739"></a>18739                      pointmark(p3));
<a name="l18740"></a>18740             }
<a name="l18741"></a>18741           }
<a name="l18742"></a>18742           <span class="comment">// Increase the number of intersecting pairs.</span>
<a name="l18743"></a>18743           (*internum)++;
<a name="l18744"></a>18744           <span class="comment">// Infect these two faces (although they may already be infected).</span>
<a name="l18745"></a>18745           sinfect(sface1);
<a name="l18746"></a>18746           sinfect(sface2);
<a name="l18747"></a>18747         }
<a name="l18748"></a>18748       }
<a name="l18749"></a>18749     }
<a name="l18750"></a>18750     <span class="comment">// Don&#39;t forget to free all three arrays. No further partition.</span>
<a name="l18751"></a>18751     <span class="keyword">delete</span> [] leftarray;
<a name="l18752"></a>18752     <span class="keyword">delete</span> [] rightarray;
<a name="l18753"></a>18753     <span class="keyword">delete</span> [] subfacearray;
<a name="l18754"></a>18754   }
<a name="l18755"></a>18755 }
<a name="l18756"></a>18756 
<a name="l18758"></a>18758 <span class="comment">//                                                                           //</span>
<a name="l18759"></a>18759 <span class="comment">// detectinterfaces()    Detect intersecting triangles.                      //</span>
<a name="l18760"></a>18760 <span class="comment">//                                                                           //</span>
<a name="l18761"></a>18761 <span class="comment">// Given a set of triangles,  find the pairs of intersecting triangles from  //</span>
<a name="l18762"></a>18762 <span class="comment">// them.  Here the set of triangles is in &#39;subfaces&#39; which is a surface mesh //</span>
<a name="l18763"></a>18763 <span class="comment">// of a PLC (.poly or .smesh).                                               //</span>
<a name="l18764"></a>18764 <span class="comment">//                                                                           //</span>
<a name="l18765"></a>18765 <span class="comment">// To detect whether two triangles are intersecting is done by the routine   //</span>
<a name="l18766"></a>18766 <span class="comment">// &#39;tri_tri_inter()&#39;.  The algorithm for the test is very simple and stable. //</span>
<a name="l18767"></a>18767 <span class="comment">// It is based on geometric orientation test which uses exact arithmetics.   //</span>
<a name="l18768"></a>18768 <span class="comment">//                                                                           //</span>
<a name="l18769"></a>18769 <span class="comment">// Use divide-and-conquer algorithm for reducing the number of intersection  //</span>
<a name="l18770"></a>18770 <span class="comment">// tests.  Start from the bounding box of the input point set, recursively   //</span>
<a name="l18771"></a>18771 <span class="comment">// partition the box into smaller boxes, until the number of triangles in a  //</span>
<a name="l18772"></a>18772 <span class="comment">// box is not decreased anymore. Then perform triangle-triangle tests on the //</span>
<a name="l18773"></a>18773 <span class="comment">// remaining set of triangles.  The memory allocated in the input set is     //</span>
<a name="l18774"></a>18774 <span class="comment">// freed immediately after it has been partitioned into two arrays.  So it   //</span>
<a name="l18775"></a>18775 <span class="comment">// can be re-used for the consequent partitions.                             //</span>
<a name="l18776"></a>18776 <span class="comment">//                                                                           //</span>
<a name="l18777"></a>18777 <span class="comment">// On return, the pool &#39;subfaces&#39; will be cleared, and only the intersecting //</span>
<a name="l18778"></a>18778 <span class="comment">// triangles remain for output (to a .face file).                            //</span>
<a name="l18779"></a>18779 <span class="comment">//                                                                           //</span>
<a name="l18781"></a>18781 <span class="comment"></span>
<a name="l18782"></a>18782 <span class="keywordtype">void</span> tetgenmesh::detectinterfaces()
<a name="l18783"></a>18783 {
<a name="l18784"></a>18784   shellface **subfacearray;
<a name="l18785"></a>18785   face shloop;
<a name="l18786"></a>18786   <span class="keywordtype">int</span> internum;
<a name="l18787"></a>18787   <span class="keywordtype">int</span> i;
<a name="l18788"></a>18788 
<a name="l18789"></a>18789   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l18790"></a>18790     printf(<span class="stringliteral">&quot;Detecting intersecting facets.\n&quot;</span>);
<a name="l18791"></a>18791   }
<a name="l18792"></a>18792 
<a name="l18793"></a>18793   <span class="comment">// Construct a map from indices to subfaces;</span>
<a name="l18794"></a>18794   subfacearray = <span class="keyword">new</span> shellface*[subfaces-&gt;items];
<a name="l18795"></a>18795   subfaces-&gt;traversalinit();
<a name="l18796"></a>18796   shloop.sh = shellfacetraverse(subfaces);
<a name="l18797"></a>18797   i = 0;
<a name="l18798"></a>18798   <span class="keywordflow">while</span> (shloop.sh != (shellface *) NULL) {
<a name="l18799"></a>18799     subfacearray[i] = shloop.sh;
<a name="l18800"></a>18800     shloop.sh = shellfacetraverse(subfaces);
<a name="l18801"></a>18801     i++;
<a name="l18802"></a>18802   }
<a name="l18803"></a>18803 
<a name="l18804"></a>18804   internum = 0;
<a name="l18805"></a>18805   <span class="comment">// Recursively split the set of triangles into two sets using a cut plane</span>
<a name="l18806"></a>18806   <span class="comment">//   parallel to x-, or, y-, or z-axies.  Stop splitting when the number</span>
<a name="l18807"></a>18807   <span class="comment">//   of subfaces is not decreasing anymore. Do tests on the current set.</span>
<a name="l18808"></a>18808   interecursive(subfacearray, subfaces-&gt;items, 0, xmin, xmax, ymin, ymax,
<a name="l18809"></a>18809                 zmin, zmax, &amp;internum);
<a name="l18810"></a>18810 
<a name="l18811"></a>18811   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l18812"></a>18812     <span class="keywordflow">if</span> (internum &gt; 0) {
<a name="l18813"></a>18813       printf(<span class="stringliteral">&quot;\n!! Found %d pairs of faces are intersecting.\n\n&quot;</span>, internum);
<a name="l18814"></a>18814     } <span class="keywordflow">else</span> {
<a name="l18815"></a>18815       printf(<span class="stringliteral">&quot;\nNo faces are intersecting.\n\n&quot;</span>);
<a name="l18816"></a>18816     }
<a name="l18817"></a>18817   }
<a name="l18818"></a>18818 
<a name="l18819"></a>18819   <span class="keywordflow">if</span> (internum &gt; 0) {
<a name="l18820"></a>18820     <span class="comment">// Traverse all subfaces, deallocate those have not been infected (they</span>
<a name="l18821"></a>18821     <span class="comment">//   are not intersecting faces). Uninfect those have been infected.</span>
<a name="l18822"></a>18822     <span class="comment">//   After this loop, only intersecting faces remain.</span>
<a name="l18823"></a>18823     subfaces-&gt;traversalinit();
<a name="l18824"></a>18824     shloop.sh = shellfacetraverse(subfaces);
<a name="l18825"></a>18825     <span class="keywordflow">while</span> (shloop.sh != (shellface *) NULL) {
<a name="l18826"></a>18826       <span class="keywordflow">if</span> (sinfected(shloop)) {
<a name="l18827"></a>18827         suninfect(shloop);
<a name="l18828"></a>18828       } <span class="keywordflow">else</span> {
<a name="l18829"></a>18829         shellfacedealloc(subfaces, shloop.sh);
<a name="l18830"></a>18830       }
<a name="l18831"></a>18831       shloop.sh = shellfacetraverse(subfaces);
<a name="l18832"></a>18832     }
<a name="l18833"></a>18833   } <span class="keywordflow">else</span> {
<a name="l18834"></a>18834     <span class="comment">// Deallocate all subfaces.</span>
<a name="l18835"></a>18835     subfaces-&gt;restart();
<a name="l18836"></a>18836   }
<a name="l18837"></a>18837 }
<a name="l18838"></a>18838 
<a name="l18839"></a>18839 <span class="comment">//</span>
<a name="l18840"></a>18840 <span class="comment">// Begin of periodic boundary condition routines</span>
<a name="l18841"></a>18841 <span class="comment">//</span>
<a name="l18842"></a>18842 
<a name="l18844"></a>18844 <span class="comment">//                                                                           //</span>
<a name="l18845"></a>18845 <span class="comment">// createsubpbcgrouptable()    Create the &#39;subpbcgrouptable&#39;.                //</span>
<a name="l18846"></a>18846 <span class="comment">//                                                                           //</span>
<a name="l18847"></a>18847 <span class="comment">// Allocate the memory for &#39;subpbcgrouptable&#39;.  Each entry i (a pbcdata) of  //</span>
<a name="l18848"></a>18848 <span class="comment">// the table represents a pbcgroup.  Most of the fields of a group-i are set //</span>
<a name="l18849"></a>18849 <span class="comment">// in this routine. &#39;fmark[0]&#39;, &#39;fmark[1]&#39;, and &#39;transmat[0]&#39; are directly   //</span>
<a name="l18850"></a>18850 <span class="comment">// copied from the corresponding data of &#39;in-&gt;numberofpbcgroups&#39;. &#39;transmat  //</span>
<a name="l18851"></a>18851 <span class="comment">// [1]&#39; is calculated as the inverse matrix of &#39;transmat[0]&#39;.  &#39;ss[0]&#39; and   //</span>
<a name="l18852"></a>18852 <span class="comment">// &#39;ss[1]&#39; are initilized be &#39;dummysh&#39;. They are set in &#39;trangulatefacet()&#39;  //</span>
<a name="l18853"></a>18853 <span class="comment">// (when -p is in use) or &#39;reconstructmesh()&#39; (when -r is in use).           //</span>
<a name="l18854"></a>18854 <span class="comment">//                                                                           //</span>
<a name="l18856"></a>18856 <span class="comment"></span>
<a name="l18857"></a>18857 <span class="keywordtype">void</span> tetgenmesh::createsubpbcgrouptable()
<a name="l18858"></a>18858 {
<a name="l18859"></a>18859   tetgenio::pbcgroup *pg;
<a name="l18860"></a>18860   pbcdata *pd;
<a name="l18861"></a>18861   REAL A[4][4], rhs[4], D;
<a name="l18862"></a>18862   <span class="keywordtype">int</span> indx[4];
<a name="l18863"></a>18863   <span class="keywordtype">int</span> i, j, k;
<a name="l18864"></a>18864 
<a name="l18865"></a>18865   subpbcgrouptable = <span class="keyword">new</span> pbcdata[in-&gt;numberofpbcgroups];
<a name="l18866"></a>18866   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofpbcgroups; i++) {
<a name="l18867"></a>18867     pg = &amp;(in-&gt;pbcgrouplist[i]);
<a name="l18868"></a>18868     pd = &amp;(subpbcgrouptable[i]);
<a name="l18869"></a>18869     <span class="comment">// Copy data from pg to pd.</span>
<a name="l18870"></a>18870     pd-&gt;fmark[0] = pg-&gt;fmark1;
<a name="l18871"></a>18871     pd-&gt;fmark[1] = pg-&gt;fmark2;
<a name="l18872"></a>18872     <span class="comment">// Initialize array &#39;pd-&gt;ss&#39;.</span>
<a name="l18873"></a>18873     pd-&gt;ss[0].sh = dummysh;
<a name="l18874"></a>18874     pd-&gt;ss[1].sh = dummysh;
<a name="l18875"></a>18875     <span class="comment">// Copy the transform matrix from pg to pd-&gt;transmat[0].</span>
<a name="l18876"></a>18876     <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l18877"></a>18877       <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) {
<a name="l18878"></a>18878         pd-&gt;transmat[0][j][k] = pg-&gt;transmat[j][k];
<a name="l18879"></a>18879         <span class="comment">// Prepare for inverting the matrix.</span>
<a name="l18880"></a>18880         A[j][k] = pg-&gt;transmat[j][k];
<a name="l18881"></a>18881       }
<a name="l18882"></a>18882     }
<a name="l18883"></a>18883     <span class="comment">// Calculate the inverse matrix (pd-&gt;transmat[1]) of pd-&gt;transmat[0].</span>
<a name="l18884"></a>18884     lu_decmp(A, 4, indx, &amp;D, 0);
<a name="l18885"></a>18885     <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l18886"></a>18886       <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) rhs[k] = 0.0;
<a name="l18887"></a>18887       rhs[j] = 1.0;
<a name="l18888"></a>18888       lu_solve(A, 4, indx, rhs, 0);
<a name="l18889"></a>18889       <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) pd-&gt;transmat[1][k][j] = rhs[k];
<a name="l18890"></a>18890     }
<a name="l18891"></a>18891   }
<a name="l18892"></a>18892 }
<a name="l18893"></a>18893 
<a name="l18895"></a>18895 <span class="comment">//                                                                           //</span>
<a name="l18896"></a>18896 <span class="comment">// getsubpbcgroup()    Get the pbcgroup of a subface.                        //</span>
<a name="l18897"></a>18897 <span class="comment">//                                                                           //</span>
<a name="l18898"></a>18898 <span class="comment">// &#39;pbcsub&#39; has pbc defined. Its pbcgroup is returned in &#39;pd&#39;. In addition,  //</span>
<a name="l18899"></a>18899 <span class="comment">// &#39;f1&#39; (0 or 1) indicates the position of &#39;pbcsub&#39; in &#39;pd&#39;; &#39;f2&#39; (= 1 - f1) //</span>
<a name="l18900"></a>18900 <span class="comment">// is the position where the symmetric subface of &#39;pbcsub&#39; is found.         //</span>
<a name="l18901"></a>18901 <span class="comment">//                                                                           //</span>
<a name="l18903"></a>18903 <span class="comment"></span>
<a name="l18904"></a>18904 <span class="keywordtype">void</span> tetgenmesh::getsubpbcgroup(face* pbcsub, pbcdata** pd, <span class="keywordtype">int</span> *f1, <span class="keywordtype">int</span> *f2)
<a name="l18905"></a>18905 {
<a name="l18906"></a>18906   <span class="keywordtype">int</span> groupid, fmark, idx;
<a name="l18907"></a>18907 
<a name="l18908"></a>18908   groupid = shellpbcgroup(*pbcsub);
<a name="l18909"></a>18909   *pd = &amp;subpbcgrouptable[groupid];
<a name="l18910"></a>18910 
<a name="l18911"></a>18911   <span class="comment">// Get the facet index (1 - based).</span>
<a name="l18912"></a>18912   idx = shellmark(*pbcsub);
<a name="l18913"></a>18913   <span class="comment">// Get the facet marker from array (0 - based).</span>
<a name="l18914"></a>18914   fmark = in-&gt;facetmarkerlist[idx - 1];
<a name="l18915"></a>18915   <span class="keywordflow">if</span> ((*pd)-&gt;fmark[0] == fmark) {
<a name="l18916"></a>18916     *f1 = 0;
<a name="l18917"></a>18917   } <span class="keywordflow">else</span> {
<a name="l18918"></a>18918 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l18919"></a>18919 <span class="preprocessor"></span>    assert((*pd)-&gt;fmark[1] == fmark);
<a name="l18920"></a>18920 <span class="preprocessor">#endif</span>
<a name="l18921"></a>18921 <span class="preprocessor"></span>    *f1 = 1;
<a name="l18922"></a>18922   }
<a name="l18923"></a>18923   *f2 = 1 - (*f1);
<a name="l18924"></a>18924 }
<a name="l18925"></a>18925 
<a name="l18927"></a>18927 <span class="comment">//                                                                           //</span>
<a name="l18928"></a>18928 <span class="comment">// getsubpbcsympoint()    Compute the symmetric point for a subface point.   //</span>
<a name="l18929"></a>18929 <span class="comment">//                                                                           //</span>
<a name="l18930"></a>18930 <span class="comment">// &#39;newpoint&#39; lies on &#39;splitsub&#39;. This routine calculates a &#39;sympoint&#39; which //</span>
<a name="l18931"></a>18931 <span class="comment">// locates on &#39;symsplitsub&#39; and symmtric to &#39;newpoint&#39;.  Return the location //</span>
<a name="l18932"></a>18932 <span class="comment">// of sympoint wrt. symsplitsub.                                             //</span>
<a name="l18933"></a>18933 <span class="comment">//                                                                           //</span>
<a name="l18935"></a>18935 <span class="comment"></span>
<a name="l18936"></a>18936 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh:: getsubpbcsympoint(point newpoint,
<a name="l18937"></a>18937   face* splitsub, point sympoint, face* symsplitsub)
<a name="l18938"></a>18938 {
<a name="l18939"></a>18939   pbcdata *pd;
<a name="l18940"></a>18940   face subloop;
<a name="l18941"></a>18941   point pa, pb, pc;
<a name="l18942"></a>18942   <span class="keyword">enum</span> locateresult symloc;
<a name="l18943"></a>18943   REAL ori;
<a name="l18944"></a>18944   <span class="keywordtype">int</span> f1, f2, i;
<a name="l18945"></a>18945 
<a name="l18946"></a>18946   <span class="comment">// Get the pbcgroup of &#39;splitsub&#39;.</span>
<a name="l18947"></a>18947   getsubpbcgroup(splitsub, &amp;pd, &amp;f1, &amp;f2);
<a name="l18948"></a>18948 
<a name="l18949"></a>18949   <span class="comment">// Transform newpoint from f1 -&gt; f2.</span>
<a name="l18950"></a>18950   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l18951"></a>18951     sympoint[i] = pd-&gt;transmat[f1][i][0] * newpoint[0]
<a name="l18952"></a>18952                 + pd-&gt;transmat[f1][i][1] * newpoint[1]
<a name="l18953"></a>18953                 + pd-&gt;transmat[f1][i][2] * newpoint[2]
<a name="l18954"></a>18954                 + pd-&gt;transmat[f1][i][3] * 1.0;
<a name="l18955"></a>18955   }
<a name="l18956"></a>18956   <span class="comment">// Locate sympoint in f2.</span>
<a name="l18957"></a>18957   symloc = OUTSIDE;
<a name="l18958"></a>18958   *symsplitsub = pd-&gt;ss[f2];
<a name="l18959"></a>18959   <span class="comment">// Is the stored subface valid? Hole removal may delete the subface.</span>
<a name="l18960"></a>18960   <span class="keywordflow">if</span> ((symsplitsub-&gt;sh != dummysh) &amp;&amp; !isdead(symsplitsub)) {
<a name="l18961"></a>18961     <span class="comment">// &#39;symsplitsub&#39; should lie on the symmetric facet. Check it.</span>
<a name="l18962"></a>18962     i = shellmark(*symsplitsub);
<a name="l18963"></a>18963     <span class="keywordflow">if</span> (in-&gt;facetmarkerlist[i - 1] == pd-&gt;fmark[f2]) {
<a name="l18964"></a>18964       <span class="comment">// &#39;symsplitsub&#39; has the symmetric boundary marker.</span>
<a name="l18965"></a>18965       pa = sorg(*symsplitsub);
<a name="l18966"></a>18966       pb = sdest(*symsplitsub);
<a name="l18967"></a>18967       pc = sapex(*symsplitsub);
<a name="l18968"></a>18968       <span class="comment">// Test if they are (nearly) coplanar. Some facets may have the</span>
<a name="l18969"></a>18969       <span class="comment">//   same boundary marker but not coplanar with this point.</span>
<a name="l18970"></a>18970       ori = orient3d(pa, pb, pc, sympoint);
<a name="l18971"></a>18971       <span class="keywordflow">if</span> (iscoplanar(pa, pb, pc, sympoint, ori, b-&gt;epsilon * 1e+2)) {
<a name="l18972"></a>18972         <span class="comment">// Locate sympoint in facet. Don&#39;t stop at subsegment.</span>
<a name="l18973"></a>18973         abovepoint = facetabovepointarray[shellmark(*symsplitsub)];
<a name="l18974"></a>18974         <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l18975"></a>18975           getfacetabovepoint(symsplitsub);
<a name="l18976"></a>18976         }
<a name="l18977"></a>18977         symloc = locatesub(sympoint, symsplitsub, 0, b-&gt;epsilon * 1e+2);
<a name="l18978"></a>18978       }
<a name="l18979"></a>18979     }
<a name="l18980"></a>18980   }
<a name="l18981"></a>18981   <span class="keywordflow">if</span> (symloc == OUTSIDE) {
<a name="l18982"></a>18982     <span class="comment">// Do a brute-force searching for the symmetric subface.</span>
<a name="l18983"></a>18983     REAL epspp = b-&gt;epsilon * 1e+2;
<a name="l18984"></a>18984     <span class="keywordtype">int</span> lcount = 0;
<a name="l18985"></a>18985     <span class="keywordflow">do</span> {
<a name="l18986"></a>18986       <span class="comment">// Locate sympoint in the pool of subfaces (with fmark pd-&gt;fmark[f2]).</span>
<a name="l18987"></a>18987       subfaces-&gt;traversalinit();
<a name="l18988"></a>18988       subloop.sh = shellfacetraverse(subfaces);
<a name="l18989"></a>18989       <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l18990"></a>18990         i = shellmark(subloop);
<a name="l18991"></a>18991         <span class="keywordflow">if</span> (in-&gt;facetmarkerlist[i - 1] == pd-&gt;fmark[f2]) {
<a name="l18992"></a>18992           <span class="comment">// Found a facet have the symmetric boundary marker.</span>
<a name="l18993"></a>18993           pa = sorg(subloop);
<a name="l18994"></a>18994           pb = sdest(subloop);
<a name="l18995"></a>18995           pc = sapex(subloop);
<a name="l18996"></a>18996           <span class="comment">// Test if they are (nearly) coplanar. Some facets may have the</span>
<a name="l18997"></a>18997           <span class="comment">//   same boundary marker but not coplanar with this point.</span>
<a name="l18998"></a>18998           ori = orient3d(pa, pb, pc, sympoint);
<a name="l18999"></a>18999           <span class="keywordflow">if</span> (iscoplanar(pa, pb, pc, sympoint, ori, epspp)) {
<a name="l19000"></a>19000             <span class="comment">// Test if sympoint is (nearly) inside this facet.</span>
<a name="l19001"></a>19001             <span class="comment">// Get the abovepoint of the facet.</span>
<a name="l19002"></a>19002             abovepoint = facetabovepointarray[shellmark(subloop)];
<a name="l19003"></a>19003             <span class="comment">// Do we need to calculate the abovepoint?</span>
<a name="l19004"></a>19004             <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l19005"></a>19005               getfacetabovepoint(&amp;subloop);
<a name="l19006"></a>19006             }
<a name="l19007"></a>19007             <span class="comment">// subloop is on the facet, search sympoint.</span>
<a name="l19008"></a>19008             symloc = locatesub(sympoint, &amp;subloop, 0, epspp);
<a name="l19009"></a>19009             <span class="keywordflow">if</span> (symloc != OUTSIDE) <span class="keywordflow">break</span>;
<a name="l19010"></a>19010           }
<a name="l19011"></a>19011         }
<a name="l19012"></a>19012         subloop.sh = shellfacetraverse(subfaces);
<a name="l19013"></a>19013       }
<a name="l19014"></a>19014       lcount++;
<a name="l19015"></a>19015       epspp *= 10.0;
<a name="l19016"></a>19016     } <span class="keywordflow">while</span> ((symloc == OUTSIDE) &amp;&amp; (lcount &lt; 3));
<a name="l19017"></a>19017 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19018"></a>19018 <span class="preprocessor"></span>    <span class="comment">// sympoint should be inside the facet.</span>
<a name="l19019"></a>19019     assert(symloc != OUTSIDE);
<a name="l19020"></a>19020 <span class="preprocessor">#endif</span>
<a name="l19021"></a>19021 <span class="preprocessor"></span>    <span class="comment">// Set the returning subface.</span>
<a name="l19022"></a>19022     *symsplitsub = subloop;
<a name="l19023"></a>19023     <span class="comment">// Update the stored subface for next searching.</span>
<a name="l19024"></a>19024     pd-&gt;ss[f2] = *symsplitsub;
<a name="l19025"></a>19025   }
<a name="l19026"></a>19026 
<a name="l19027"></a>19027   <span class="keywordflow">return</span> adjustlocatesub(sympoint, symsplitsub, symloc, b-&gt;epsilon);
<a name="l19028"></a>19028 }
<a name="l19029"></a>19029 
<a name="l19031"></a>19031 <span class="comment">//                                                                           //</span>
<a name="l19032"></a>19032 <span class="comment">// createsegpbcgrouptable()    Create the &#39;segpbcgrouptable&#39;.                //</span>
<a name="l19033"></a>19033 <span class="comment">//                                                                           //</span>
<a name="l19034"></a>19034 <span class="comment">// Each segment may belong to more than one pbcgroups.  For example, segment //</span>
<a name="l19035"></a>19035 <span class="comment">// ab may need to be symmteric to both segments cd, and ef, then  ab and cd, //</span>
<a name="l19036"></a>19036 <span class="comment">// cd and ef, ef and ab form three pbcgroups.                                //</span>
<a name="l19037"></a>19037 <span class="comment">//                                                                           //</span>
<a name="l19038"></a>19038 <span class="comment">// &#39;segpbcgrouptable&#39; is  implemented as a list of pbcdatas. Each item i is  //</span>
<a name="l19039"></a>19039 <span class="comment">// a pbcgroup.                                                               //</span>
<a name="l19040"></a>19040 <span class="comment">//                                                                           //</span>
<a name="l19042"></a>19042 <span class="comment"></span>
<a name="l19043"></a>19043 <span class="keywordtype">void</span> tetgenmesh::createsegpbcgrouptable()
<a name="l19044"></a>19044 {
<a name="l19045"></a>19045   shellface** segsperverlist;
<a name="l19046"></a>19046   pbcdata *pd, *ppd, pd1, pd2;
<a name="l19047"></a>19047   face segloop, symseg;
<a name="l19048"></a>19048   face startsh, spinsh, symsh;
<a name="l19049"></a>19049   point pa, pb, syma, symb;
<a name="l19050"></a>19050   <span class="keyword">enum</span> locateresult symloc;
<a name="l19051"></a>19051   REAL testpt[3], sympt[3];
<a name="l19052"></a>19052   <span class="keywordtype">bool</span> inflag;
<a name="l19053"></a>19053   <span class="keywordtype">int</span> *idx2seglist;
<a name="l19054"></a>19054   <span class="keywordtype">int</span> segid1, segid2;
<a name="l19055"></a>19055   <span class="keywordtype">int</span> f1, f2;
<a name="l19056"></a>19056   <span class="keywordtype">int</span> i, j, k, l;
<a name="l19057"></a>19057 
<a name="l19058"></a>19058   <span class="comment">// Allocate memory for &#39;subpbcgrouptable&#39;.</span>
<a name="l19059"></a>19059   segpbcgrouptable = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(pbcdata), NULL, 256);
<a name="l19060"></a>19060 
<a name="l19061"></a>19061   <span class="keywordflow">if</span> (b-&gt;refine) {
<a name="l19062"></a>19062     <span class="comment">// Create a point-to-seg map for quickly finding PBC seg pairs.</span>
<a name="l19063"></a>19063     makesegmentmap(idx2seglist, segsperverlist);
<a name="l19064"></a>19064   }
<a name="l19065"></a>19065 
<a name="l19066"></a>19066   <span class="comment">// Loop through the segment list.</span>
<a name="l19067"></a>19067   subsegs-&gt;traversalinit();
<a name="l19068"></a>19068   segloop.sh = shellfacetraverse(subsegs);
<a name="l19069"></a>19069   <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l19070"></a>19070     <span class="comment">// Loop the subface ring of segloop ab.</span>
<a name="l19071"></a>19071     pa = sorg(segloop);
<a name="l19072"></a>19072     pb = sdest(segloop);
<a name="l19073"></a>19073     segid1 = shellmark(segloop);
<a name="l19074"></a>19074     spivot(segloop, startsh);
<a name="l19075"></a>19075     spinsh = startsh;
<a name="l19076"></a>19076     <span class="keywordflow">do</span> {
<a name="l19077"></a>19077       <span class="comment">// Adjust spinsh be edge ab.</span>
<a name="l19078"></a>19078       <span class="keywordflow">if</span> (sorg(spinsh) != pa) {
<a name="l19079"></a>19079         sesymself(spinsh);
<a name="l19080"></a>19080       }
<a name="l19081"></a>19081       <span class="comment">// Does spinsh belong to a pbcgroup?</span>
<a name="l19082"></a>19082       <span class="keywordflow">if</span> (shellpbcgroup(spinsh) != -1) {
<a name="l19083"></a>19083         <span class="comment">// Yes! There exists a segment cd. ab and cd form a pbcgroup.</span>
<a name="l19084"></a>19084         <span class="keywordflow">if</span> (b-&gt;refine) {
<a name="l19085"></a>19085           getsubpbcgroup(&amp;spinsh, &amp;pd, &amp;f1, &amp;f2);
<a name="l19086"></a>19086           <span class="comment">// Transform pa from f1 -&gt; f2.</span>
<a name="l19087"></a>19087           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l19088"></a>19088             sympt[i] = pd-&gt;transmat[f1][i][0] * pa[0]
<a name="l19089"></a>19089                      + pd-&gt;transmat[f1][i][1] * pa[1]
<a name="l19090"></a>19090                      + pd-&gt;transmat[f1][i][2] * pa[2]
<a name="l19091"></a>19091                      + pd-&gt;transmat[f1][i][3] * 1.0;
<a name="l19092"></a>19092           }
<a name="l19093"></a>19093           syma = point2pbcpt(pa);
<a name="l19094"></a>19094           <span class="comment">// Is &#39;sympt == syma&#39;?</span>
<a name="l19095"></a>19095           <span class="keywordflow">if</span> (distance(sympt, syma) &gt; (longest * b-&gt;epsilon)) {
<a name="l19096"></a>19096             <span class="comment">// No. Search the symmetric vertex of pa.</span>
<a name="l19097"></a>19097             symloc = getsubpbcsympoint(pa, &amp;spinsh, sympt, &amp;symsh);
<a name="l19098"></a>19098             syma = sorg(symsh);
<a name="l19099"></a>19099             <span class="keywordflow">if</span> (symloc != ONVERTEX) {
<a name="l19100"></a>19100               <span class="comment">// Do a brute force search. Not done yet.</span>
<a name="l19101"></a>19101               assert(0);
<a name="l19102"></a>19102             }
<a name="l19103"></a>19103           }
<a name="l19104"></a>19104           <span class="comment">// Transform pb from f1 -&gt; f2.</span>
<a name="l19105"></a>19105           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l19106"></a>19106             sympt[i] = pd-&gt;transmat[f1][i][0] * pb[0]
<a name="l19107"></a>19107                      + pd-&gt;transmat[f1][i][1] * pb[1]
<a name="l19108"></a>19108                      + pd-&gt;transmat[f1][i][2] * pb[2]
<a name="l19109"></a>19109                      + pd-&gt;transmat[f1][i][3] * 1.0;
<a name="l19110"></a>19110           }
<a name="l19111"></a>19111           <span class="comment">// Search sym subface from the point-to-subface map.</span>
<a name="l19112"></a>19112           symseg.shver = 0;
<a name="l19113"></a>19113           j = pointmark(syma) - in-&gt;firstnumber;
<a name="l19114"></a>19114           <span class="keywordflow">for</span> (i = idx2seglist[j]; i &lt; idx2seglist[j + 1]; i++) {
<a name="l19115"></a>19115             symseg.sh = segsperverlist[i];
<a name="l19116"></a>19116             <span class="keywordflow">if</span> (sorg(symseg) == syma) symb = sdest(symseg);
<a name="l19117"></a>19117             <span class="keywordflow">else</span> symb = sorg(symseg);
<a name="l19118"></a>19118             <span class="keywordflow">if</span> (distance(sympt, symb) &lt;= (longest * b-&gt;epsilon)) <span class="keywordflow">break</span>;
<a name="l19119"></a>19119           }
<a name="l19120"></a>19120           assert(i &lt; idx2seglist[j + 1]);
<a name="l19121"></a>19121         } <span class="keywordflow">else</span> {
<a name="l19122"></a>19122           <span class="comment">//   &#39;testpt&#39; is the midpoint of ab used to find cd.</span>
<a name="l19123"></a>19123           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) testpt[i] = 0.5 * (pa[i] + pb[i]);
<a name="l19124"></a>19124           symloc = getsubpbcsympoint(testpt, &amp;spinsh, sympt, &amp;symsh);
<a name="l19125"></a>19125 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19126"></a>19126 <span class="preprocessor"></span>          assert(symloc == ONEDGE);
<a name="l19127"></a>19127 <span class="preprocessor">#endif</span>
<a name="l19128"></a>19128 <span class="preprocessor"></span>          sspivot(symsh, symseg);
<a name="l19129"></a>19129         }
<a name="l19130"></a>19130 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19131"></a>19131 <span class="preprocessor"></span>        assert(symseg.sh != dummysh);
<a name="l19132"></a>19132 <span class="preprocessor">#endif</span>
<a name="l19133"></a>19133 <span class="preprocessor"></span>        <span class="comment">// Check whether this group has already been created in list.</span>
<a name="l19134"></a>19134         segid2 = shellmark(symseg);
<a name="l19135"></a>19135         inflag = <span class="keyword">false</span>;
<a name="l19136"></a>19136         <span class="keywordflow">for</span> (i = 0; i &lt; segpbcgrouptable-&gt;len() &amp;&amp; !inflag; i++) {
<a name="l19137"></a>19137           pd = (pbcdata *)(* segpbcgrouptable)[i];
<a name="l19138"></a>19138           <span class="keywordflow">if</span> (pd-&gt;segid[0] == segid1) {
<a name="l19139"></a>19139             <span class="keywordflow">if</span> (pd-&gt;segid[1] == segid2) inflag = <span class="keyword">true</span>;
<a name="l19140"></a>19140           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pd-&gt;segid[0] == segid2) {
<a name="l19141"></a>19141             <span class="keywordflow">if</span> (pd-&gt;segid[1] == segid1) inflag = <span class="keyword">true</span>;
<a name="l19142"></a>19142           }
<a name="l19143"></a>19143         }
<a name="l19144"></a>19144         <span class="keywordflow">if</span> (!inflag) {
<a name="l19145"></a>19145           <span class="comment">// Create a segment pbcgroup in list for ab and cd.</span>
<a name="l19146"></a>19146           pd = (pbcdata *) segpbcgrouptable-&gt;append(NULL);
<a name="l19147"></a>19147           <span class="comment">// Save the markers of ab and cd.</span>
<a name="l19148"></a>19148           pd-&gt;segid[0] = segid1;
<a name="l19149"></a>19149           pd-&gt;segid[1] = segid2;
<a name="l19150"></a>19150           <span class="comment">// Save the handles of ab and cd.</span>
<a name="l19151"></a>19151           pd-&gt;ss[0] = segloop;
<a name="l19152"></a>19152           pd-&gt;ss[1] = symseg;
<a name="l19153"></a>19153           <span class="comment">// Find the map from ab to cd.</span>
<a name="l19154"></a>19154           getsubpbcgroup(&amp;spinsh, &amp;ppd, &amp;f1, &amp;f2);
<a name="l19155"></a>19155           pd-&gt;fmark[0] = ppd-&gt;fmark[f1];
<a name="l19156"></a>19156           pd-&gt;fmark[1] = ppd-&gt;fmark[f2];
<a name="l19157"></a>19157           <span class="comment">// Set the map from ab to cd.</span>
<a name="l19158"></a>19158           <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l19159"></a>19159             <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l19160"></a>19160               pd-&gt;transmat[0][i][j] = ppd-&gt;transmat[f1][i][j];
<a name="l19161"></a>19161             }
<a name="l19162"></a>19162           }
<a name="l19163"></a>19163           <span class="comment">// Set the map from cd to ab.</span>
<a name="l19164"></a>19164           <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l19165"></a>19165             <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l19166"></a>19166               pd-&gt;transmat[1][i][j] = ppd-&gt;transmat[f2][i][j];
<a name="l19167"></a>19167             }
<a name="l19168"></a>19168           }
<a name="l19169"></a>19169         }
<a name="l19170"></a>19170       }
<a name="l19171"></a>19171       <span class="comment">// Go to the next subface in the ring of ab.</span>
<a name="l19172"></a>19172       spivotself(spinsh);
<a name="l19173"></a>19173     } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l19174"></a>19174     segloop.sh = shellfacetraverse(subsegs);
<a name="l19175"></a>19175   }
<a name="l19176"></a>19176 
<a name="l19177"></a>19177   <span class="keywordflow">if</span> (b-&gt;refine) {
<a name="l19178"></a>19178     <span class="keyword">delete</span> [] segsperverlist;
<a name="l19179"></a>19179     <span class="keyword">delete</span> [] idx2seglist;
<a name="l19180"></a>19180   }
<a name="l19181"></a>19181 
<a name="l19182"></a>19182   <span class="comment">// Create the indirect segment pbcgroups.</span>
<a name="l19183"></a>19183   <span class="comment">// Bug-fixed (08 Sept. 2006). The total size of &#39;segpbcgrouptable&#39; may get</span>
<a name="l19184"></a>19184   <span class="comment">//   increased. Do not use pointers for &#39;pd1&#39; and &#39;pd2&#39;. The addresses may</span>
<a name="l19185"></a>19185   <span class="comment">//   be invaild after realloc().</span>
<a name="l19186"></a>19186   <span class="keywordflow">for</span> (i = 0; i &lt; segpbcgrouptable-&gt;len(); i++) {
<a name="l19187"></a>19187     pd1 = * (pbcdata *)(* segpbcgrouptable)[i];
<a name="l19188"></a>19188     <span class="keywordflow">for</span> (f1 = 0; f1 &lt; 2; f1++) {
<a name="l19189"></a>19189       <span class="comment">// Search for a group (except i) contains pd1.segid[f1].</span>
<a name="l19190"></a>19190       <span class="keywordflow">for</span> (j = 0; j &lt; segpbcgrouptable-&gt;len(); j++) {
<a name="l19191"></a>19191         <span class="keywordflow">if</span> (j == i) <span class="keywordflow">continue</span>;
<a name="l19192"></a>19192         pd2 = * (pbcdata *)(* segpbcgrouptable)[j];
<a name="l19193"></a>19193         f2 = -1;
<a name="l19194"></a>19194         <span class="keywordflow">if</span> (pd1.segid[f1] == pd2.segid[0]) {
<a name="l19195"></a>19195           f2 = 0;
<a name="l19196"></a>19196         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pd1.segid[f1] == pd2.segid[1]) {
<a name="l19197"></a>19197           f2 = 1;
<a name="l19198"></a>19198         }
<a name="l19199"></a>19199         <span class="keywordflow">if</span> (f2 != -1) {
<a name="l19200"></a>19200 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19201"></a>19201 <span class="preprocessor"></span>          assert(pd1.segid[f1] == pd2.segid[f2]);
<a name="l19202"></a>19202 <span class="preprocessor">#endif</span>
<a name="l19203"></a>19203 <span class="preprocessor"></span>          segid1 = pd1.segid[1 - f1];
<a name="l19204"></a>19204           segid2 = pd2.segid[1 - f2];
<a name="l19205"></a>19205           <span class="comment">// Search for the existence of segment pbcgroup (segid1, segid2).</span>
<a name="l19206"></a>19206           inflag = <span class="keyword">false</span>;
<a name="l19207"></a>19207           <span class="keywordflow">for</span> (k = 0; k &lt; segpbcgrouptable-&gt;len() &amp;&amp; !inflag; k++) {
<a name="l19208"></a>19208             pd = (pbcdata *)(* segpbcgrouptable)[k];
<a name="l19209"></a>19209             <span class="keywordflow">if</span> (pd-&gt;segid[0] == segid1) {
<a name="l19210"></a>19210               <span class="keywordflow">if</span> (pd-&gt;segid[1] == segid2) inflag = <span class="keyword">true</span>;
<a name="l19211"></a>19211             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pd-&gt;segid[0] == segid2) {
<a name="l19212"></a>19212               <span class="keywordflow">if</span> (pd-&gt;segid[1] == segid1) inflag = <span class="keyword">true</span>;
<a name="l19213"></a>19213             }
<a name="l19214"></a>19214           }
<a name="l19215"></a>19215           <span class="keywordflow">if</span> (!inflag) {
<a name="l19216"></a>19216             pd = (pbcdata *) segpbcgrouptable-&gt;append(NULL);
<a name="l19217"></a>19217             pd-&gt;segid[0] = pd1.segid[1 - f1];
<a name="l19218"></a>19218             pd-&gt;segid[1] = pd2.segid[1 - f2];
<a name="l19219"></a>19219             pd-&gt;ss[0] = pd1.ss[1 - f1];
<a name="l19220"></a>19220             pd-&gt;ss[1] = pd2.ss[1 - f2];
<a name="l19221"></a>19221             <span class="comment">// Invalid the fmark[0] == fmark[1].</span>
<a name="l19222"></a>19222             pd-&gt;fmark[0] = pd-&gt;fmark[1] = 0;
<a name="l19223"></a>19223             <span class="comment">// Translate matrix pd-&gt;transmat[0] = m2 * m1, where m1 =</span>
<a name="l19224"></a>19224             <span class="comment">//   pd1.transmat[1 - f1], m2 = pd2.transmat[f2].</span>
<a name="l19225"></a>19225             <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) {
<a name="l19226"></a>19226               <span class="keywordflow">for</span> (l = 0; l &lt; 4; l++) {
<a name="l19227"></a>19227                 pd-&gt;transmat[0][k][l] = pd2.transmat[f2][k][l];
<a name="l19228"></a>19228               }
<a name="l19229"></a>19229             }
<a name="l19230"></a>19230             m4xm4(pd-&gt;transmat[0], pd1.transmat[1 - f1]);
<a name="l19231"></a>19231             <span class="comment">// Translate matrix pd-&gt;transmat[1] = m4 * m3, where m3 =</span>
<a name="l19232"></a>19232             <span class="comment">//   pd2.transmat[1 - f2], m4 = pd1.transmat[f1].</span>
<a name="l19233"></a>19233             <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) {
<a name="l19234"></a>19234               <span class="keywordflow">for</span> (l = 0; l &lt; 4; l++) {
<a name="l19235"></a>19235                 pd-&gt;transmat[1][k][l] = pd1.transmat[f1][k][l];
<a name="l19236"></a>19236               }
<a name="l19237"></a>19237             }
<a name="l19238"></a>19238             m4xm4(pd-&gt;transmat[1], pd2.transmat[1 - f2]);
<a name="l19239"></a>19239           }
<a name="l19240"></a>19240         }
<a name="l19241"></a>19241       }
<a name="l19242"></a>19242     }
<a name="l19243"></a>19243   }
<a name="l19244"></a>19244 
<a name="l19245"></a>19245   <span class="comment">// Form a map from segment index to pbcgroup list of this segment.</span>
<a name="l19246"></a>19246   idx2segpglist = <span class="keyword">new</span> <span class="keywordtype">int</span>[subsegs-&gt;items + 1];
<a name="l19247"></a>19247   <span class="keywordflow">for</span> (i = 0; i &lt; subsegs-&gt;items + 1; i++) idx2segpglist[i] = 0;
<a name="l19248"></a>19248   <span class="comment">// Loop through &#39;segpbcgrouptable&#39;, counter the number of pbcgroups of</span>
<a name="l19249"></a>19249   <span class="comment">//   each segment.</span>
<a name="l19250"></a>19250   <span class="keywordflow">for</span> (i = 0; i &lt; segpbcgrouptable-&gt;len(); i++) {
<a name="l19251"></a>19251     pd = (pbcdata *)(* segpbcgrouptable)[i];
<a name="l19252"></a>19252     <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l19253"></a>19253       k = pd-&gt;segid[j] - 1;
<a name="l19254"></a>19254       idx2segpglist[k]++;
<a name="l19255"></a>19255     }
<a name="l19256"></a>19256   }
<a name="l19257"></a>19257   <span class="comment">// Calculate the total length of array &#39;segpglist&#39;.</span>
<a name="l19258"></a>19258   j = idx2segpglist[0];
<a name="l19259"></a>19259   idx2segpglist[0] = 0;  <span class="comment">// Array starts from 0 element.</span>
<a name="l19260"></a>19260   <span class="keywordflow">for</span> (i = 0; i &lt; subsegs-&gt;items; i++) {
<a name="l19261"></a>19261     k = idx2segpglist[i + 1];
<a name="l19262"></a>19262     idx2segpglist[i + 1] = idx2segpglist[i] + j;
<a name="l19263"></a>19263     j = k;
<a name="l19264"></a>19264   }
<a name="l19265"></a>19265   <span class="comment">// The total length is in the last unit of idx2segpglist.</span>
<a name="l19266"></a>19266   segpglist = <span class="keyword">new</span> <span class="keywordtype">int</span>[idx2segpglist[i]];
<a name="l19267"></a>19267   <span class="comment">// Loop the set of pbcgroups again, set the data into segpglist.</span>
<a name="l19268"></a>19268   <span class="keywordflow">for</span> (i = 0; i &lt; segpbcgrouptable-&gt;len(); i++) {
<a name="l19269"></a>19269     pd = (pbcdata *)(* segpbcgrouptable)[i];
<a name="l19270"></a>19270     <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l19271"></a>19271       k = pd-&gt;segid[j] - 1;
<a name="l19272"></a>19272       segpglist[idx2segpglist[k]] = i;
<a name="l19273"></a>19273       idx2segpglist[k]++;
<a name="l19274"></a>19274     }
<a name="l19275"></a>19275   }
<a name="l19276"></a>19276   <span class="comment">// Contents in &#39;idx2segpglist&#39; are shifted, now shift them back.</span>
<a name="l19277"></a>19277   <span class="keywordflow">for</span> (i = subsegs-&gt;items - 1; i &gt;= 0; i--) {
<a name="l19278"></a>19278     idx2segpglist[i + 1] = idx2segpglist[i];
<a name="l19279"></a>19279   }
<a name="l19280"></a>19280   idx2segpglist[0] = 0;
<a name="l19281"></a>19281 }
<a name="l19282"></a>19282 
<a name="l19284"></a>19284 <span class="comment">//                                                                           //</span>
<a name="l19285"></a>19285 <span class="comment">// getsegpbcsympoint()    Compute the symmetric point for a segment point.   //</span>
<a name="l19286"></a>19286 <span class="comment">//                                                                           //</span>
<a name="l19287"></a>19287 <span class="comment">// &#39;newpoint&#39; lies on &#39;splitseg&#39;. This routine calculates a &#39;sympoint&#39; which //</span>
<a name="l19288"></a>19288 <span class="comment">// locates on &#39;symsplitseg&#39; and symmtric to &#39;newpoint&#39;.  Return the location //</span>
<a name="l19289"></a>19289 <span class="comment">// of sympoint wrt. symsplitseg.                                             //</span>
<a name="l19290"></a>19290 <span class="comment">//                                                                           //</span>
<a name="l19292"></a>19292 <span class="comment"></span>
<a name="l19293"></a>19293 <span class="keyword">enum</span> tetgenmesh::locateresult tetgenmesh::
<a name="l19294"></a>19294 getsegpbcsympoint(point newpoint, face* splitseg, point sympoint,
<a name="l19295"></a>19295                   face* symsplitseg, <span class="keywordtype">int</span> groupid)
<a name="l19296"></a>19296 {
<a name="l19297"></a>19297   pbcdata *pd;
<a name="l19298"></a>19298   <span class="keyword">enum</span> locateresult symloc;
<a name="l19299"></a>19299   <span class="keywordtype">int</span> segid, f1, f2, i;
<a name="l19300"></a>19300 
<a name="l19301"></a>19301   pd = (pbcdata *)(* segpbcgrouptable)[groupid];
<a name="l19302"></a>19302   segid = shellmark(*splitseg);
<a name="l19303"></a>19303   <span class="keywordflow">if</span> (pd-&gt;segid[0] == segid) {
<a name="l19304"></a>19304     f1 = 0;
<a name="l19305"></a>19305   } <span class="keywordflow">else</span> {
<a name="l19306"></a>19306 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19307"></a>19307 <span class="preprocessor"></span>    assert(pd-&gt;segid[1] == segid);
<a name="l19308"></a>19308 <span class="preprocessor">#endif</span>
<a name="l19309"></a>19309 <span class="preprocessor"></span>    f1 = 1;
<a name="l19310"></a>19310   }
<a name="l19311"></a>19311   f2 = 1 - f1;
<a name="l19312"></a>19312 
<a name="l19313"></a>19313   <span class="comment">// Transform newpoint from f1 -&gt; f2.</span>
<a name="l19314"></a>19314   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l19315"></a>19315     sympoint[i] = pd-&gt;transmat[f1][i][0] * newpoint[0]
<a name="l19316"></a>19316                 + pd-&gt;transmat[f1][i][1] * newpoint[1]
<a name="l19317"></a>19317                 + pd-&gt;transmat[f1][i][2] * newpoint[2]
<a name="l19318"></a>19318                 + pd-&gt;transmat[f1][i][3] * 1.0;
<a name="l19319"></a>19319   }
<a name="l19320"></a>19320   <span class="comment">// Locate sympoint in f2.</span>
<a name="l19321"></a>19321   *symsplitseg = pd-&gt;ss[f2];
<a name="l19322"></a>19322 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19323"></a>19323 <span class="preprocessor"></span>  assert(symsplitseg-&gt;sh != dummysh);
<a name="l19324"></a>19324 <span class="preprocessor">#endif</span>
<a name="l19325"></a>19325 <span class="preprocessor"></span>  <span class="comment">// Locate sympoint in facet. Stop at subsegment.</span>
<a name="l19326"></a>19326   symloc = locateseg(sympoint, symsplitseg);
<a name="l19327"></a>19327   symloc = adjustlocateseg(sympoint, symsplitseg, symloc, b-&gt;epsilon * 1e+2);
<a name="l19328"></a>19328   <span class="keywordflow">return</span> symloc;
<a name="l19329"></a>19329 }
<a name="l19330"></a>19330 
<a name="l19331"></a>19331 <span class="comment">//</span>
<a name="l19332"></a>19332 <span class="comment">// End of periodic boundary condition routines</span>
<a name="l19333"></a>19333 <span class="comment">//</span>
<a name="l19334"></a>19334 
<a name="l19335"></a>19335 <span class="comment">//</span>
<a name="l19336"></a>19336 <span class="comment">// Begin of vertex perturbation routines</span>
<a name="l19337"></a>19337 <span class="comment">//</span>
<a name="l19338"></a>19338 
<a name="l19340"></a>19340 <span class="comment">//                                                                           //</span>
<a name="l19341"></a>19341 <span class="comment">// randgenerator()    Generate a random REAL number between (0, |range|).    //</span>
<a name="l19342"></a>19342 <span class="comment">//                                                                           //</span>
<a name="l19344"></a>19344 <span class="comment"></span>
<a name="l19345"></a>19345 REAL tetgenmesh::randgenerator(REAL range)
<a name="l19346"></a>19346 {
<a name="l19347"></a>19347   REAL worknumber, result;
<a name="l19348"></a>19348   <span class="keywordtype">int</span> expo;
<a name="l19349"></a>19349 
<a name="l19350"></a>19350   <span class="keywordflow">if</span> (range == 0.0) <span class="keywordflow">return</span> 0.0;
<a name="l19351"></a>19351 
<a name="l19352"></a>19352   expo = 0;
<a name="l19353"></a>19353   worknumber = fabs(range);
<a name="l19354"></a>19354   <span class="comment">// Normalize worknumber (i.e., 1.xxxExx)</span>
<a name="l19355"></a>19355   <span class="keywordflow">if</span> (worknumber &gt; 10.0) {
<a name="l19356"></a>19356     <span class="keywordflow">while</span> (worknumber &gt; 10.0) {
<a name="l19357"></a>19357       worknumber /= 10.0;
<a name="l19358"></a>19358       expo++;
<a name="l19359"></a>19359     }
<a name="l19360"></a>19360   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (worknumber &lt; 1.0) {
<a name="l19361"></a>19361     <span class="keywordflow">while</span> (worknumber &lt; 1.0) {
<a name="l19362"></a>19362       worknumber *= 10.0;
<a name="l19363"></a>19363       expo--;
<a name="l19364"></a>19364     }
<a name="l19365"></a>19365   }
<a name="l19366"></a>19366 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19367"></a>19367 <span class="preprocessor"></span>  assert(worknumber &gt;= 1.0 &amp;&amp; worknumber &lt;= 10.0);
<a name="l19368"></a>19368 <span class="preprocessor">#endif</span>
<a name="l19369"></a>19369 <span class="preprocessor"></span>
<a name="l19370"></a>19370   <span class="comment">// Enlarge worknumber 1000 times.</span>
<a name="l19371"></a>19371   worknumber *= 1e+3;
<a name="l19372"></a>19372   expo -= 3;
<a name="l19373"></a>19373   <span class="comment">// Generate a randome number between (0, worknumber).</span>
<a name="l19374"></a>19374   result = (<a class="code" href="classdouble.html">double</a>) randomnation((<span class="keywordtype">int</span>) worknumber);
<a name="l19375"></a>19375 
<a name="l19376"></a>19376   <span class="comment">// Scale result back into the original size.</span>
<a name="l19377"></a>19377   <span class="keywordflow">if</span> (expo &gt; 0) {
<a name="l19378"></a>19378     <span class="keywordflow">while</span> (expo != 0) {
<a name="l19379"></a>19379       result *= 10.0;
<a name="l19380"></a>19380       expo--;
<a name="l19381"></a>19381     }
<a name="l19382"></a>19382   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (expo &lt; 0) {
<a name="l19383"></a>19383     <span class="keywordflow">while</span> (expo != 0) {
<a name="l19384"></a>19384       result /= 10.0;
<a name="l19385"></a>19385       expo++;
<a name="l19386"></a>19386     }
<a name="l19387"></a>19387   }
<a name="l19388"></a>19388 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19389"></a>19389 <span class="preprocessor"></span>  assert((result &gt;= 0.0) &amp;&amp; (result &lt;= fabs(range)));
<a name="l19390"></a>19390 <span class="preprocessor">#endif</span>
<a name="l19391"></a>19391 <span class="preprocessor"></span>
<a name="l19392"></a>19392   <span class="keywordflow">return</span> result;
<a name="l19393"></a>19393 }
<a name="l19394"></a>19394 
<a name="l19396"></a>19396 <span class="comment">//                                                                           //</span>
<a name="l19397"></a>19397 <span class="comment">// checksub4cocir()    Test a subface to find co-circular pair of subfaces.  //</span>
<a name="l19398"></a>19398 <span class="comment">//                                                                           //</span>
<a name="l19399"></a>19399 <span class="comment">// &#39;eps&#39; is a relative tolerance for testing approximately cospherical case. //</span>
<a name="l19400"></a>19400 <span class="comment">// Set it to zero if only exact test is desired.                             //</span>
<a name="l19401"></a>19401 <span class="comment">//                                                                           //</span>
<a name="l19402"></a>19402 <span class="comment">// An edge(not a segment) of &#39;testsub&#39; is locally degenerate if the opposite //</span>
<a name="l19403"></a>19403 <span class="comment">// vertex of the adjacent subface is cocircular with the vertices of testsub.//</span>
<a name="l19404"></a>19404 <span class="comment">// If &#39;once&#39; is TRUE, operate on the edge only if the pointer &#39;testsub-&gt;sh&#39;  //</span>
<a name="l19405"></a>19405 <span class="comment">// is smaller than its neighbor (for each edge is considered only once).     //</span>
<a name="l19406"></a>19406 <span class="comment">//                                                                           //</span>
<a name="l19407"></a>19407 <span class="comment">// Return TRUE if find an edge of testsub is locally degenerate.             //</span>
<a name="l19408"></a>19408 <span class="comment">//                                                                           //</span>
<a name="l19410"></a>19410 <span class="comment"></span>
<a name="l19411"></a>19411 <span class="keywordtype">bool</span> tetgenmesh::checksub4cocir(face* testsub, REAL eps, <span class="keywordtype">bool</span> once,
<a name="l19412"></a>19412   <span class="keywordtype">bool</span> enqflag)
<a name="l19413"></a>19413 {
<a name="l19414"></a>19414   badface *cocirsub;
<a name="l19415"></a>19415   face subloop, neighsub;
<a name="l19416"></a>19416   face checkseg;
<a name="l19417"></a>19417   point pa, pb, pc, pd;
<a name="l19418"></a>19418   REAL sign;
<a name="l19419"></a>19419   <span class="keywordtype">int</span> i;
<a name="l19420"></a>19420 
<a name="l19421"></a>19421   subloop = *testsub;
<a name="l19422"></a>19422   subloop.shver = 0; <span class="comment">// Keep the CCW orientation.</span>
<a name="l19423"></a>19423   <span class="comment">// Get the abovepoint of the facet.</span>
<a name="l19424"></a>19424   abovepoint = facetabovepointarray[shellmark(subloop)];
<a name="l19425"></a>19425   <span class="comment">// Do we need to calculate the abovepoint?</span>
<a name="l19426"></a>19426   <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l19427"></a>19427     getfacetabovepoint(&amp;subloop);
<a name="l19428"></a>19428   }
<a name="l19429"></a>19429   <span class="comment">// Check the three edges of subloop.</span>
<a name="l19430"></a>19430   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l19431"></a>19431     sspivot(subloop, checkseg);
<a name="l19432"></a>19432     <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l19433"></a>19433       <span class="comment">// It is not a segment, get the adjacent subface.</span>
<a name="l19434"></a>19434       spivot(subloop, neighsub);
<a name="l19435"></a>19435       <span class="comment">// assert(neighsub.sh != dummysh);</span>
<a name="l19436"></a>19436       <span class="keywordflow">if</span> (!once || (once &amp;&amp; (neighsub.sh &gt; subloop.sh))) {
<a name="l19437"></a>19437         pa = sorg(subloop);
<a name="l19438"></a>19438         pb = sdest(subloop);
<a name="l19439"></a>19439         pc = sapex(subloop);
<a name="l19440"></a>19440         pd = sapex(neighsub);
<a name="l19441"></a>19441         sign = insphere(pa, pb, pc, abovepoint, pd);
<a name="l19442"></a>19442         <span class="keywordflow">if</span> ((sign != 0.0) &amp;&amp; (eps &gt; 0.0)) {
<a name="l19443"></a>19443           <span class="keywordflow">if</span> (iscospheric(pa, pb, pc, abovepoint, pd, sign, eps)) sign = 0.0;
<a name="l19444"></a>19444         }
<a name="l19445"></a>19445         <span class="keywordflow">if</span> (sign == 0.0) {
<a name="l19446"></a>19446           <span class="comment">// It&#39;s locally degenerate!</span>
<a name="l19447"></a>19447           <span class="keywordflow">if</span> (enqflag &amp;&amp; badsubfaces != (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL) {
<a name="l19448"></a>19448             <span class="comment">// Save it.</span>
<a name="l19449"></a>19449             cocirsub = (badface *) badsubfaces-&gt;alloc();
<a name="l19450"></a>19450             cocirsub-&gt;ss = subloop;
<a name="l19451"></a>19451             cocirsub-&gt;forg = pa;
<a name="l19452"></a>19452             cocirsub-&gt;fdest = pb;
<a name="l19453"></a>19453             cocirsub-&gt;fapex = pc;
<a name="l19454"></a>19454             cocirsub-&gt;foppo = pd;
<a name="l19455"></a>19455             setshell2badface(cocirsub-&gt;ss, cocirsub);
<a name="l19456"></a>19456           }
<a name="l19457"></a>19457           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l19458"></a>19458             printf(<span class="stringliteral">&quot;    Found set (%d, %d, %d, %d).\n&quot;</span>, pointmark(pa),
<a name="l19459"></a>19459                    pointmark(pb), pointmark(pc), pointmark(pd));
<a name="l19460"></a>19460           }
<a name="l19461"></a>19461           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l19462"></a>19462         }
<a name="l19463"></a>19463       }
<a name="l19464"></a>19464     }
<a name="l19465"></a>19465     senextself(subloop);
<a name="l19466"></a>19466   }
<a name="l19467"></a>19467 
<a name="l19468"></a>19468   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l19469"></a>19469 }
<a name="l19470"></a>19470 
<a name="l19472"></a>19472 <span class="comment">//                                                                           //</span>
<a name="l19473"></a>19473 <span class="comment">// tallcocirsubs()    Find all co-circular subfaces and save them in list.   //</span>
<a name="l19474"></a>19474 <span class="comment">//                                                                           //</span>
<a name="l19476"></a>19476 <span class="comment"></span>
<a name="l19477"></a>19477 <span class="keywordtype">void</span> tetgenmesh::tallcocirsubs(REAL eps, <span class="keywordtype">bool</span> enqflag)
<a name="l19478"></a>19478 {
<a name="l19479"></a>19479   face subloop;
<a name="l19480"></a>19480 
<a name="l19481"></a>19481   <span class="comment">// Loop over all subfaces.</span>
<a name="l19482"></a>19482   subfaces-&gt;traversalinit();
<a name="l19483"></a>19483   subloop.sh = shellfacetraverse(subfaces);
<a name="l19484"></a>19484   <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l19485"></a>19485     checksub4cocir(&amp;subloop, eps, <span class="keyword">true</span>, enqflag);
<a name="l19486"></a>19486     subloop.sh = shellfacetraverse(subfaces);
<a name="l19487"></a>19487   }
<a name="l19488"></a>19488 }
<a name="l19489"></a>19489 
<a name="l19491"></a>19491 <span class="comment">//                                                                           //</span>
<a name="l19492"></a>19492 <span class="comment">// tallencsegsfsubs()    Check for encroached segs from a list of subfaces.  //</span>
<a name="l19493"></a>19493 <span class="comment">//                                                                           //</span>
<a name="l19495"></a>19495 <span class="comment"></span>
<a name="l19496"></a>19496 <span class="keywordtype">bool</span> tetgenmesh::tallencsegsfsubs(point testpt, list* cavsublist)
<a name="l19497"></a>19497 {
<a name="l19498"></a>19498   face startsub, checkseg;
<a name="l19499"></a>19499   <span class="keywordtype">long</span> oldencnum;
<a name="l19500"></a>19500   <span class="keywordtype">int</span> i, j;
<a name="l19501"></a>19501 
<a name="l19502"></a>19502   <span class="comment">// Remember the current number of encroached segments.</span>
<a name="l19503"></a>19503   oldencnum = badsubsegs-&gt;items;
<a name="l19504"></a>19504 
<a name="l19505"></a>19505   <span class="comment">// Check segments in the list of subfaces.</span>
<a name="l19506"></a>19506   <span class="keywordflow">for</span> (i = 0; i &lt; cavsublist-&gt;len(); i++) {
<a name="l19507"></a>19507     startsub = * (face *)(* cavsublist)[i];
<a name="l19508"></a>19508     <span class="comment">// Test all three edges of startsub.</span>
<a name="l19509"></a>19509     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l19510"></a>19510       sspivot(startsub, checkseg);
<a name="l19511"></a>19511       <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l19512"></a>19512         <span class="keywordflow">if</span> (!shell2badface(checkseg)) {
<a name="l19513"></a>19513           checkseg4encroach(&amp;checkseg, testpt, NULL, <span class="keyword">true</span>);
<a name="l19514"></a>19514         }
<a name="l19515"></a>19515       }
<a name="l19516"></a>19516       senextself(startsub);
<a name="l19517"></a>19517     }
<a name="l19518"></a>19518   }
<a name="l19519"></a>19519 
<a name="l19520"></a>19520   <span class="keywordflow">return</span> (badsubsegs-&gt;items &gt; oldencnum);
<a name="l19521"></a>19521 }
<a name="l19522"></a>19522 
<a name="l19524"></a>19524 <span class="comment">//                                                                           //</span>
<a name="l19525"></a>19525 <span class="comment">// collectflipedges()    Collect edges of split subfaces for flip checking.  //</span>
<a name="l19526"></a>19526 <span class="comment">//                                                                           //</span>
<a name="l19527"></a>19527 <span class="comment">// &#39;inspoint&#39; is a newly inserted segment point (inserted by insertsite()).  //</span>
<a name="l19528"></a>19528 <span class="comment">// &#39;splitseg&#39; is one of the two split subsegments. Some subfaces may be non- //</span>
<a name="l19529"></a>19529 <span class="comment">// Delaunay since they&#39;re still not bonded to CDT. This routine collect all  //</span>
<a name="l19530"></a>19530 <span class="comment">// such possible subfaces in &#39;flipqueue&#39;.                                    //</span>
<a name="l19531"></a>19531 <span class="comment">//                                                                           //</span>
<a name="l19533"></a>19533 <span class="comment"></span>
<a name="l19534"></a>19534 <span class="keywordtype">void</span> tetgenmesh::
<a name="l19535"></a>19535 collectflipedges(point inspoint, face* splitseg, queue* flipqueue)
<a name="l19536"></a>19536 {
<a name="l19537"></a>19537   face startsh, spinsh, checksh;
<a name="l19538"></a>19538   face nextseg;
<a name="l19539"></a>19539   point pa, pb;
<a name="l19540"></a>19540 
<a name="l19541"></a>19541   <span class="comment">// Let the dest of splitseg be inspoint.</span>
<a name="l19542"></a>19542   splitseg-&gt;shver = 0;
<a name="l19543"></a>19543   <span class="keywordflow">if</span> (sdest(*splitseg) != inspoint) {
<a name="l19544"></a>19544     sesymself(*splitseg);
<a name="l19545"></a>19545   }
<a name="l19546"></a>19546 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19547"></a>19547 <span class="preprocessor"></span>  assert(sdest(*splitseg) == inspoint);
<a name="l19548"></a>19548 <span class="preprocessor">#endif</span>
<a name="l19549"></a>19549 <span class="preprocessor"></span>  pa = sorg(*splitseg);
<a name="l19550"></a>19550   spivot(*splitseg, startsh);
<a name="l19551"></a>19551   spinsh = startsh;
<a name="l19552"></a>19552   <span class="keywordflow">do</span> {
<a name="l19553"></a>19553     findedge(&amp;spinsh, pa, inspoint);
<a name="l19554"></a>19554     senext2(spinsh, checksh);
<a name="l19555"></a>19555     enqueueflipedge(checksh, flipqueue);
<a name="l19556"></a>19556     spivotself(spinsh);
<a name="l19557"></a>19557   } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l19558"></a>19558 
<a name="l19559"></a>19559   <span class="comment">// Get the next subsegment.</span>
<a name="l19560"></a>19560   senext(*splitseg, nextseg);
<a name="l19561"></a>19561   spivotself(nextseg);
<a name="l19562"></a>19562 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19563"></a>19563 <span class="preprocessor"></span>  assert(nextseg.sh != (shellface *) NULL);
<a name="l19564"></a>19564 <span class="preprocessor">#endif</span>
<a name="l19565"></a>19565 <span class="preprocessor"></span>
<a name="l19566"></a>19566   <span class="comment">// Let the org of nextseg be inspoint.</span>
<a name="l19567"></a>19567   nextseg.shver = 0;
<a name="l19568"></a>19568   <span class="keywordflow">if</span> (sorg(nextseg) != inspoint) {
<a name="l19569"></a>19569     sesymself(nextseg);
<a name="l19570"></a>19570   }
<a name="l19571"></a>19571 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19572"></a>19572 <span class="preprocessor"></span>  assert(sorg(nextseg) == inspoint);
<a name="l19573"></a>19573 <span class="preprocessor">#endif</span>
<a name="l19574"></a>19574 <span class="preprocessor"></span>  pb = sdest(nextseg);
<a name="l19575"></a>19575   spivot(nextseg, startsh);
<a name="l19576"></a>19576   spinsh = startsh;
<a name="l19577"></a>19577   <span class="keywordflow">do</span> {
<a name="l19578"></a>19578     findedge(&amp;spinsh, inspoint, pb);
<a name="l19579"></a>19579     senext(spinsh, checksh);
<a name="l19580"></a>19580     enqueueflipedge(checksh, flipqueue);
<a name="l19581"></a>19581     spivotself(spinsh);
<a name="l19582"></a>19582   } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l19583"></a>19583 }
<a name="l19584"></a>19584 
<a name="l19586"></a>19586 <span class="comment">//                                                                           //</span>
<a name="l19587"></a>19587 <span class="comment">// perturbrepairencsegs()    Repair all encroached segments.                 //</span>
<a name="l19588"></a>19588 <span class="comment">//                                                                           //</span>
<a name="l19589"></a>19589 <span class="comment">// All encroached segments are stored in &#39;badsubsegs&#39;.  Each segment will be //</span>
<a name="l19590"></a>19590 <span class="comment">// split by adding a perturbed point near its circumcenter.                  //</span>
<a name="l19591"></a>19591 <span class="comment">//                                                                           //</span>
<a name="l19593"></a>19593 <span class="comment"></span>
<a name="l19594"></a>19594 <span class="keywordtype">void</span> tetgenmesh::perturbrepairencsegs(queue* flipqueue)
<a name="l19595"></a>19595 {
<a name="l19596"></a>19596   badface *encloop;
<a name="l19597"></a>19597   tetrahedron encodedtet;
<a name="l19598"></a>19598   triface splittet;
<a name="l19599"></a>19599   face splitsub, symsplitsub;
<a name="l19600"></a>19600   face splitseg, symsplitseg;
<a name="l19601"></a>19601   point newpoint, sympoint;
<a name="l19602"></a>19602   point pa, pb, pc;
<a name="l19603"></a>19603   <span class="keyword">enum</span> insertsiteresult success;
<a name="l19604"></a>19604   <span class="keyword">enum</span> locateresult loc, symloc;
<a name="l19605"></a>19605   REAL cent[3], d1, ps, rs;
<a name="l19606"></a>19606   <span class="keywordtype">int</span> i, j;
<a name="l19607"></a>19607 
<a name="l19608"></a>19608   <span class="comment">// Note that steinerleft == -1 if an unlimited number of Steiner points</span>
<a name="l19609"></a>19609   <span class="comment">//   is allowed.  Loop until &#39;badsubsegs&#39; is empty.</span>
<a name="l19610"></a>19610   badsubsegs-&gt;traversalinit();
<a name="l19611"></a>19611   encloop = badfacetraverse(badsubsegs);
<a name="l19612"></a>19612   <span class="keywordflow">while</span> ((encloop != (badface *) NULL) &amp;&amp; (steinerleft != 0)) {
<a name="l19613"></a>19613     splitseg = encloop-&gt;ss;
<a name="l19614"></a>19614 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19615"></a>19615 <span class="preprocessor"></span>    assert(shell2badface(splitseg) == encloop);
<a name="l19616"></a>19616 <span class="preprocessor">#endif</span>
<a name="l19617"></a>19617 <span class="preprocessor"></span>    setshell2badface(splitseg, NULL);
<a name="l19618"></a>19618     pa = sorg(splitseg);
<a name="l19619"></a>19619     pb = sdest(splitseg);
<a name="l19620"></a>19620     <span class="keywordflow">if</span> ((pa == encloop-&gt;forg) &amp;&amp; (pb == encloop-&gt;fdest)) {
<a name="l19621"></a>19621       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l19622"></a>19622         printf(<span class="stringliteral">&quot;  Get seg (%d, %d).\n&quot;</span>, pointmark(pa), pointmark(pb));
<a name="l19623"></a>19623       }
<a name="l19624"></a>19624       <span class="comment">// Create the newpoint.</span>
<a name="l19625"></a>19625       makepoint(&amp;newpoint);
<a name="l19626"></a>19626       <span class="comment">// Get the circumcenter and radius of ab.</span>
<a name="l19627"></a>19627       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) cent[i] = 0.5 * (pa[i] + pb[i]);
<a name="l19628"></a>19628       d1 = 0.5 * distance(pa, pb);
<a name="l19629"></a>19629       <span class="comment">// Add a random perturbation to newpoint along the vector ab.</span>
<a name="l19630"></a>19630       ps = randgenerator(d1 * 1.0e-3);
<a name="l19631"></a>19631       rs = ps / d1;
<a name="l19632"></a>19632       <span class="comment">// Set newpoint (be at the perturbed circumcenter of ab).</span>
<a name="l19633"></a>19633       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpoint[i] = cent[i] + rs * (cent[i] - pa[i]);
<a name="l19634"></a>19634       setpointtype(newpoint, FREESEGVERTEX);
<a name="l19635"></a>19635       <span class="comment">// Set splitseg into the newpoint.</span>
<a name="l19636"></a>19636       setpoint2sh(newpoint, sencode(splitseg));
<a name="l19637"></a>19637 
<a name="l19638"></a>19638       <span class="comment">// Is there periodic boundary condition?</span>
<a name="l19639"></a>19639       <span class="keywordflow">if</span> (checkpbcs) {
<a name="l19640"></a>19640         <span class="comment">// Insert points on other segments of incident pbcgroups.</span>
<a name="l19641"></a>19641         i = shellmark(splitseg) - 1;
<a name="l19642"></a>19642         <span class="keywordflow">for</span> (j = idx2segpglist[i]; j &lt; idx2segpglist[i + 1]; j++) {
<a name="l19643"></a>19643           makepoint(&amp;sympoint);
<a name="l19644"></a>19644           symloc = getsegpbcsympoint(newpoint, &amp;splitseg, sympoint,
<a name="l19645"></a>19645                                      &amp;symsplitseg, segpglist[j]);
<a name="l19646"></a>19646 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19647"></a>19647 <span class="preprocessor"></span>          assert(symloc != OUTSIDE);
<a name="l19648"></a>19648 <span class="preprocessor">#endif</span>
<a name="l19649"></a>19649 <span class="preprocessor"></span>          <span class="comment">// Note: the symsplitseg and splitseg may be identical, in case</span>
<a name="l19650"></a>19650           <span class="comment">//   when the the splitseg is the axis of the rotational sym.</span>
<a name="l19651"></a>19651           <span class="keywordflow">if</span> ((symloc == ONEDGE) &amp;&amp; (symsplitseg.sh != splitseg.sh)) {
<a name="l19652"></a>19652             setpointtype(sympoint, FREESEGVERTEX);
<a name="l19653"></a>19653             setpoint2sh(sympoint, sencode(symsplitseg));
<a name="l19654"></a>19654             <span class="comment">// Insert sympoint into DT.</span>
<a name="l19655"></a>19655             pc = sorg(symsplitseg);
<a name="l19656"></a>19656             splittet.tet = dummytet;
<a name="l19657"></a>19657             <span class="comment">// Find a good start point to search.</span>
<a name="l19658"></a>19658             encodedtet = point2tet(pc);
<a name="l19659"></a>19659             <span class="keywordflow">if</span> (encodedtet != (tetrahedron) NULL) {
<a name="l19660"></a>19660               decode(encodedtet, splittet);
<a name="l19661"></a>19661               <span class="keywordflow">if</span> (isdead(&amp;splittet)) {
<a name="l19662"></a>19662                 splittet.tet = dummytet;
<a name="l19663"></a>19663               }
<a name="l19664"></a>19664             }
<a name="l19665"></a>19665             <span class="comment">// Locate sympoint in DT.  Do exact location.</span>
<a name="l19666"></a>19666             success = insertsite(sympoint, &amp;splittet, <span class="keyword">false</span>, flipqueue);
<a name="l19667"></a>19667 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19668"></a>19668 <span class="preprocessor"></span>            assert(success != DUPLICATEPOINT);
<a name="l19669"></a>19669 <span class="preprocessor">#endif</span>
<a name="l19670"></a>19670 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (success == OUTSIDEPOINT) {
<a name="l19671"></a>19671               inserthullsite(sympoint, &amp;splittet, flipqueue);
<a name="l19672"></a>19672             }
<a name="l19673"></a>19673             <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l19674"></a>19674             <span class="comment">// Let sympoint remember splittet.</span>
<a name="l19675"></a>19675             setpoint2tet(sympoint, encode(splittet));
<a name="l19676"></a>19676             <span class="comment">// Do flip in DT.</span>
<a name="l19677"></a>19677             flip(flipqueue, NULL);
<a name="l19678"></a>19678             <span class="comment">// Insert sympoint into F.</span>
<a name="l19679"></a>19679             symloc = locateseg(sympoint, &amp;symsplitseg);
<a name="l19680"></a>19680             <span class="keywordflow">if</span> (symloc == ONEDGE) {
<a name="l19681"></a>19681               symsplitseg.shver = 0;
<a name="l19682"></a>19682               spivot(symsplitseg, symsplitsub);
<a name="l19683"></a>19683               <span class="comment">// sympoint should on the edge of symsplitsub.</span>
<a name="l19684"></a>19684               splitsubedge(sympoint, &amp;symsplitsub, flipqueue);
<a name="l19685"></a>19685             } <span class="keywordflow">else</span> {
<a name="l19686"></a>19686               <span class="comment">// insertsite() has done the whole job.</span>
<a name="l19687"></a>19687 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19688"></a>19688 <span class="preprocessor"></span>              assert(symloc == ONVERTEX);
<a name="l19689"></a>19689               assert(checksubfaces);
<a name="l19690"></a>19690 <span class="preprocessor">#endif</span>
<a name="l19691"></a>19691 <span class="preprocessor"></span>              <span class="comment">// Some edges may need to be flipped.</span>
<a name="l19692"></a>19692               collectflipedges(sympoint, &amp;symsplitseg, flipqueue);
<a name="l19693"></a>19693             }
<a name="l19694"></a>19694             <span class="comment">// Do flip in facet.</span>
<a name="l19695"></a>19695             flipsub(flipqueue);
<a name="l19696"></a>19696           } <span class="keywordflow">else</span> { <span class="comment">// if (symloc == ONVERTEX) {</span>
<a name="l19697"></a>19697             <span class="comment">// The symmtric point already exists. It is possible when two</span>
<a name="l19698"></a>19698             <span class="comment">//   pbc group are idebtical. Omit sympoint.</span>
<a name="l19699"></a>19699             pointdealloc(sympoint);
<a name="l19700"></a>19700           }
<a name="l19701"></a>19701         }
<a name="l19702"></a>19702       }
<a name="l19703"></a>19703 
<a name="l19704"></a>19704       <span class="comment">// Insert newpoint into DT.</span>
<a name="l19705"></a>19705       splittet.tet = dummytet;
<a name="l19706"></a>19706       <span class="comment">// Find a good start point to search.</span>
<a name="l19707"></a>19707       encodedtet = point2tet(pa);
<a name="l19708"></a>19708       <span class="keywordflow">if</span> (encodedtet != (tetrahedron) NULL) {
<a name="l19709"></a>19709         decode(encodedtet, splittet);
<a name="l19710"></a>19710         <span class="keywordflow">if</span> (isdead(&amp;splittet)) {
<a name="l19711"></a>19711           splittet.tet = dummytet;
<a name="l19712"></a>19712         }
<a name="l19713"></a>19713       }
<a name="l19714"></a>19714       <span class="keywordflow">if</span> (splittet.tet == dummytet) { <span class="comment">// Try pb.</span>
<a name="l19715"></a>19715         encodedtet = point2tet(pb);
<a name="l19716"></a>19716         <span class="keywordflow">if</span> (encodedtet != (tetrahedron) NULL) {
<a name="l19717"></a>19717           decode(encodedtet, splittet);
<a name="l19718"></a>19718           <span class="keywordflow">if</span> (isdead(&amp;splittet)) {
<a name="l19719"></a>19719             splittet.tet = dummytet;
<a name="l19720"></a>19720           }
<a name="l19721"></a>19721         }
<a name="l19722"></a>19722       }
<a name="l19723"></a>19723       <span class="comment">// Locate the newpoint in DT.  Do exact location.</span>
<a name="l19724"></a>19724       success = insertsite(newpoint, &amp;splittet, <span class="keyword">false</span>, flipqueue);
<a name="l19725"></a>19725 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19726"></a>19726 <span class="preprocessor"></span>      assert(success != DUPLICATEPOINT);
<a name="l19727"></a>19727 <span class="preprocessor">#endif</span>
<a name="l19728"></a>19728 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (success == OUTSIDEPOINT) {
<a name="l19729"></a>19729         <span class="comment">// A convex hull edge is mssing, and the inserting point lies</span>
<a name="l19730"></a>19730         <span class="comment">//   (slightly) outside the convex hull due to the significant</span>
<a name="l19731"></a>19731         <span class="comment">//   digits lost in the calculation. Enlarge the convex hull.</span>
<a name="l19732"></a>19732         inserthullsite(newpoint, &amp;splittet, flipqueue);
<a name="l19733"></a>19733       }
<a name="l19734"></a>19734       <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l19735"></a>19735       <span class="comment">// Let newpoint remember splittet.</span>
<a name="l19736"></a>19736       setpoint2tet(newpoint, encode(splittet));
<a name="l19737"></a>19737       <span class="comment">// Do flip in DT.</span>
<a name="l19738"></a>19738       flip(flipqueue, NULL);
<a name="l19739"></a>19739       <span class="comment">// Insert newpoint into F.</span>
<a name="l19740"></a>19740       loc = locateseg(newpoint, &amp;splitseg);
<a name="l19741"></a>19741       <span class="keywordflow">if</span> (loc == ONEDGE) {
<a name="l19742"></a>19742         splitseg.shver = 0;
<a name="l19743"></a>19743         spivot(splitseg, splitsub);
<a name="l19744"></a>19744         <span class="comment">// newpoint should on the edge of splitsub.</span>
<a name="l19745"></a>19745         splitsubedge(newpoint, &amp;splitsub, flipqueue);
<a name="l19746"></a>19746       } <span class="keywordflow">else</span> {
<a name="l19747"></a>19747         <span class="comment">// insertsite() has done the whole job.</span>
<a name="l19748"></a>19748 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19749"></a>19749 <span class="preprocessor"></span>        assert(loc == ONVERTEX);
<a name="l19750"></a>19750         assert(checksubfaces);
<a name="l19751"></a>19751 <span class="preprocessor">#endif</span>
<a name="l19752"></a>19752 <span class="preprocessor"></span>        <span class="comment">// Some edges may need to be flipped.</span>
<a name="l19753"></a>19753         collectflipedges(newpoint, &amp;splitseg, flipqueue);
<a name="l19754"></a>19754       }
<a name="l19755"></a>19755       <span class="comment">// Do flip in facet.</span>
<a name="l19756"></a>19756       flipsub(flipqueue);
<a name="l19757"></a>19757     }
<a name="l19758"></a>19758     <span class="comment">// Remove this entry from list.</span>
<a name="l19759"></a>19759     badfacedealloc(badsubsegs, encloop);
<a name="l19760"></a>19760     <span class="comment">// Get the next encroached segments.</span>
<a name="l19761"></a>19761     encloop = badfacetraverse(badsubsegs);
<a name="l19762"></a>19762   }
<a name="l19763"></a>19763 }
<a name="l19764"></a>19764 
<a name="l19766"></a>19766 <span class="comment">//                                                                           //</span>
<a name="l19767"></a>19767 <span class="comment">// perturbrepairencsubs()    Repair all encroached subfaces.                 //</span>
<a name="l19768"></a>19768 <span class="comment">//                                                                           //</span>
<a name="l19769"></a>19769 <span class="comment">// All encroached subfaces are stored in &#39;badsubfaces&#39;. Each subface will be //</span>
<a name="l19770"></a>19770 <span class="comment">// split by adding a perturbed point near its circumcenter. However, if the  //</span>
<a name="l19771"></a>19771 <span class="comment">// point encroaches some segments, it will not be inserted.  Instead, the    //</span>
<a name="l19772"></a>19772 <span class="comment">// encroached segments are split.                                            //</span>
<a name="l19773"></a>19773 <span class="comment">//                                                                           //</span>
<a name="l19775"></a>19775 <span class="comment"></span>
<a name="l19776"></a>19776 <span class="keywordtype">void</span> tetgenmesh::perturbrepairencsubs(list* cavsublist, queue* flipqueue)
<a name="l19777"></a>19777 {
<a name="l19778"></a>19778   badface *encloop, *encsubseg;
<a name="l19779"></a>19779   tetrahedron encodedtet;
<a name="l19780"></a>19780   triface splittet;
<a name="l19781"></a>19781   face splitsub, symsplitsub;
<a name="l19782"></a>19782   face checkseg, symsplitseg;
<a name="l19783"></a>19783   point newpoint, sympoint;
<a name="l19784"></a>19784   point pa, pb, pc, pd;
<a name="l19785"></a>19785   <span class="keyword">enum</span> insertsiteresult success;
<a name="l19786"></a>19786   <span class="keyword">enum</span> locateresult loc, symloc;
<a name="l19787"></a>19787   REAL cent[3], d1, ps, rs;
<a name="l19788"></a>19788   <span class="keywordtype">bool</span> reject;
<a name="l19789"></a>19789   <span class="keywordtype">int</span> i;
<a name="l19790"></a>19790 
<a name="l19791"></a>19791   <span class="comment">// Note that steinerleft == -1 if an unlimited number of Steiner points</span>
<a name="l19792"></a>19792   <span class="comment">//   is allowed.  Loop until the list &#39;badsubfaces&#39; is empty.</span>
<a name="l19793"></a>19793   <span class="keywordflow">while</span> ((badsubfaces-&gt;items &gt; 0) &amp;&amp; (steinerleft != 0)) {
<a name="l19794"></a>19794     badsubfaces-&gt;traversalinit();
<a name="l19795"></a>19795     encloop = badfacetraverse(badsubfaces);
<a name="l19796"></a>19796     <span class="keywordflow">while</span> ((encloop != (badface *) NULL) &amp;&amp; (steinerleft != 0)) {
<a name="l19797"></a>19797       splitsub = encloop-&gt;ss;
<a name="l19798"></a>19798 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19799"></a>19799 <span class="preprocessor"></span>      assert(shell2badface(splitsub) == encloop);
<a name="l19800"></a>19800 <span class="preprocessor">#endif</span>
<a name="l19801"></a>19801 <span class="preprocessor"></span>      setshell2badface(splitsub, NULL);
<a name="l19802"></a>19802       pa = sorg(splitsub);
<a name="l19803"></a>19803       pb = sdest(splitsub);
<a name="l19804"></a>19804       pc = sapex(splitsub);
<a name="l19805"></a>19805       <span class="comment">// The subface may be not the same one when it was determined to be</span>
<a name="l19806"></a>19806       <span class="comment">//   encroached.  If its adjacent encroached subface was split, the</span>
<a name="l19807"></a>19807       <span class="comment">//   consequent flips may change it into another subface.</span>
<a name="l19808"></a>19808       <span class="keywordflow">if</span> ((pa == encloop-&gt;forg) &amp;&amp; (pb == encloop-&gt;fdest) &amp;&amp;
<a name="l19809"></a>19809           (pc == encloop-&gt;fapex)) {
<a name="l19810"></a>19810         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l19811"></a>19811           printf(<span class="stringliteral">&quot;  Get subface (%d, %d, %d).\n&quot;</span>, pointmark(pa),
<a name="l19812"></a>19812                  pointmark(pb), pointmark(pc));
<a name="l19813"></a>19813         }
<a name="l19814"></a>19814         <span class="comment">// Create the newpoint.</span>
<a name="l19815"></a>19815         makepoint(&amp;newpoint);
<a name="l19816"></a>19816         <span class="comment">// Get the circumcenter of abc.</span>
<a name="l19817"></a>19817         circumsphere(pa, pb, pc, NULL, cent, &amp;d1);
<a name="l19818"></a>19818 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19819"></a>19819 <span class="preprocessor"></span>        assert(d1 &gt; 0.0);
<a name="l19820"></a>19820 <span class="preprocessor">#endif</span>
<a name="l19821"></a>19821 <span class="preprocessor"></span>        <span class="comment">// Add a random perturbation to newpoint along the vector a-&gt;cent.</span>
<a name="l19822"></a>19822         <span class="comment">//   This way, the perturbed point still lies in the plane of abc.</span>
<a name="l19823"></a>19823         ps = randgenerator(d1 * 1.0e-3);
<a name="l19824"></a>19824         rs = ps / d1;
<a name="l19825"></a>19825         <span class="comment">// Set newpoint (be at the perturbed circumcenter of abc).</span>
<a name="l19826"></a>19826         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpoint[i] = cent[i] + rs * (cent[i] - pa[i]);
<a name="l19827"></a>19827         <span class="comment">// Get the abovepoint of the facet.</span>
<a name="l19828"></a>19828         abovepoint = facetabovepointarray[shellmark(splitsub)];
<a name="l19829"></a>19829         <span class="comment">// Do we need to calculate the abovepoint?</span>
<a name="l19830"></a>19830         <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l19831"></a>19831           getfacetabovepoint(&amp;splitsub);
<a name="l19832"></a>19832         }
<a name="l19833"></a>19833         loc = locatesub(newpoint, &amp;splitsub, 1, 0.0);
<a name="l19834"></a>19834 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19835"></a>19835 <span class="preprocessor"></span>        assert(loc != ONVERTEX);
<a name="l19836"></a>19836 <span class="preprocessor">#endif</span>
<a name="l19837"></a>19837 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (loc != OUTSIDE) {
<a name="l19838"></a>19838           <span class="comment">// Add &#39;splitsub&#39; into &#39;cavsublist&#39;.</span>
<a name="l19839"></a>19839           cavsublist-&gt;append(&amp;splitsub);
<a name="l19840"></a>19840           <span class="comment">// Collect all subfaces that encroached by newpoint.</span>
<a name="l19841"></a>19841           collectcavsubs(newpoint, cavsublist);
<a name="l19842"></a>19842           <span class="comment">// Find if there are encroached segments.</span>
<a name="l19843"></a>19843           reject = tallencsegsfsubs(newpoint, cavsublist);
<a name="l19844"></a>19844           <span class="comment">// Clear cavsublist for the next use.</span>
<a name="l19845"></a>19845           cavsublist-&gt;clear();
<a name="l19846"></a>19846         } <span class="keywordflow">else</span> {
<a name="l19847"></a>19847           <span class="comment">// newpoint lies outside. splitsub contains the boundary segment.</span>
<a name="l19848"></a>19848           sspivot(splitsub, checkseg);
<a name="l19849"></a>19849 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19850"></a>19850 <span class="preprocessor"></span>          assert(checkseg.sh != dummysh);
<a name="l19851"></a>19851 <span class="preprocessor">#endif</span>
<a name="l19852"></a>19852 <span class="preprocessor"></span>          <span class="comment">// Add this segment into list for splitting.</span>
<a name="l19853"></a>19853           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l19854"></a>19854             printf(<span class="stringliteral">&quot;    Queuing boundary segment (%d, %d).\n&quot;</span>,
<a name="l19855"></a>19855                    pointmark(sorg(checkseg)), pointmark(sdest(checkseg)));
<a name="l19856"></a>19856           }
<a name="l19857"></a>19857           encsubseg = (badface *) badsubsegs-&gt;alloc();
<a name="l19858"></a>19858           encsubseg-&gt;ss = checkseg;
<a name="l19859"></a>19859           encsubseg-&gt;forg = sorg(checkseg);
<a name="l19860"></a>19860           encsubseg-&gt;fdest = sdest(checkseg);
<a name="l19861"></a>19861           encsubseg-&gt;foppo = (point) NULL;
<a name="l19862"></a>19862           setshell2badface(encsubseg-&gt;ss, encsubseg);
<a name="l19863"></a>19863           <span class="comment">// Reject newpoint.</span>
<a name="l19864"></a>19864           reject = <span class="keyword">true</span>;
<a name="l19865"></a>19865         }
<a name="l19866"></a>19866 
<a name="l19867"></a>19867         <span class="keywordflow">if</span> (!reject) {
<a name="l19868"></a>19868           <span class="comment">// newpoint is going to be inserted.</span>
<a name="l19869"></a>19869 
<a name="l19870"></a>19870           <span class="comment">// Is there periodic boundary condition?</span>
<a name="l19871"></a>19871           <span class="keywordflow">if</span> (checkpbcs) {
<a name="l19872"></a>19872             <span class="keywordflow">if</span> (shellpbcgroup(splitsub) &gt;= 0) {
<a name="l19873"></a>19873               <span class="comment">// Insert a point on another facet of the pbcgroup.</span>
<a name="l19874"></a>19874               makepoint(&amp;sympoint);
<a name="l19875"></a>19875               <span class="comment">// Note: &#39;abovepoint&#39; will be changed.</span>
<a name="l19876"></a>19876               symloc = getsubpbcsympoint(newpoint, &amp;splitsub, sympoint,
<a name="l19877"></a>19877                                          &amp;symsplitsub);
<a name="l19878"></a>19878 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19879"></a>19879 <span class="preprocessor"></span>              assert(symloc != ONVERTEX);
<a name="l19880"></a>19880 <span class="preprocessor">#endif</span>
<a name="l19881"></a>19881 <span class="preprocessor"></span>              setpoint2pbcpt(newpoint, sympoint);
<a name="l19882"></a>19882               setpoint2pbcpt(sympoint, newpoint);
<a name="l19883"></a>19883               setpointtype(sympoint, FREESUBVERTEX);
<a name="l19884"></a>19884               <span class="comment">// setpoint2sh(sympoint, sencode(symsplitsub));</span>
<a name="l19885"></a>19885               <span class="comment">// Insert sympoint into DT.</span>
<a name="l19886"></a>19886               pd = sorg(symsplitsub);
<a name="l19887"></a>19887               splittet.tet = dummytet;
<a name="l19888"></a>19888               <span class="comment">// Find a good start point to search.</span>
<a name="l19889"></a>19889               encodedtet = point2tet(pd);
<a name="l19890"></a>19890               <span class="keywordflow">if</span> (encodedtet != (tetrahedron) NULL) {
<a name="l19891"></a>19891                 decode(encodedtet, splittet);
<a name="l19892"></a>19892                 <span class="keywordflow">if</span> (isdead(&amp;splittet)) {
<a name="l19893"></a>19893                   splittet.tet = dummytet;
<a name="l19894"></a>19894                 }
<a name="l19895"></a>19895               }
<a name="l19896"></a>19896               <span class="comment">// Locate sympoint in DT.  Do exact location.</span>
<a name="l19897"></a>19897               success = insertsite(sympoint, &amp;splittet, <span class="keyword">false</span>, flipqueue);
<a name="l19898"></a>19898 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19899"></a>19899 <span class="preprocessor"></span>              assert(success != DUPLICATEPOINT);
<a name="l19900"></a>19900 <span class="preprocessor">#endif</span>
<a name="l19901"></a>19901 <span class="preprocessor"></span>              <span class="keywordflow">if</span> (success == OUTSIDEPOINT) {
<a name="l19902"></a>19902                 inserthullsite(sympoint, &amp;splittet, flipqueue);
<a name="l19903"></a>19903               }
<a name="l19904"></a>19904               <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l19905"></a>19905               <span class="comment">// Let sympoint remember splittet.</span>
<a name="l19906"></a>19906               setpoint2tet(sympoint, encode(splittet));
<a name="l19907"></a>19907               <span class="comment">// Do flip in DT.</span>
<a name="l19908"></a>19908               flip(flipqueue, NULL);
<a name="l19909"></a>19909               <span class="comment">// Insert sympoint into F.</span>
<a name="l19910"></a>19910               <span class="comment">// getabovepoint(&amp;symsplitsub);</span>
<a name="l19911"></a>19911               <span class="comment">// symloc = locatesub(sympoint, &amp;symsplitsub, 1, 0.0);</span>
<a name="l19912"></a>19912               <span class="keywordflow">if</span> (symloc == ONFACE) {
<a name="l19913"></a>19913                 splitsubface(sympoint, &amp;symsplitsub, flipqueue);
<a name="l19914"></a>19914               } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (symloc == ONEDGE) {
<a name="l19915"></a>19915                 splitsubedge(sympoint, &amp;symsplitsub, flipqueue);
<a name="l19916"></a>19916               } <span class="keywordflow">else</span> {
<a name="l19917"></a>19917                 <span class="comment">// &#39;insertsite()&#39; has done the whole job.</span>
<a name="l19918"></a>19918 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19919"></a>19919 <span class="preprocessor"></span>                assert(symloc == ONVERTEX);
<a name="l19920"></a>19920                 assert(checksubfaces);
<a name="l19921"></a>19921 <span class="preprocessor">#endif</span>
<a name="l19922"></a>19922 <span class="preprocessor"></span>                <span class="comment">// Split subfaces have been flipped.</span>
<a name="l19923"></a>19923                 flipqueue-&gt;clear();
<a name="l19924"></a>19924               }
<a name="l19925"></a>19925               <span class="comment">// Do flip in facet.</span>
<a name="l19926"></a>19926               flipsub(flipqueue);
<a name="l19927"></a>19927             }
<a name="l19928"></a>19928           }
<a name="l19929"></a>19929 
<a name="l19930"></a>19930           <span class="comment">// Insert newpoint into DT.</span>
<a name="l19931"></a>19931           splittet.tet = dummytet;
<a name="l19932"></a>19932           <span class="comment">// Find a good start point to search.</span>
<a name="l19933"></a>19933           encodedtet = point2tet(pa);
<a name="l19934"></a>19934           <span class="keywordflow">if</span> (encodedtet != (tetrahedron) NULL) {
<a name="l19935"></a>19935             decode(encodedtet, splittet);
<a name="l19936"></a>19936             <span class="keywordflow">if</span> (isdead(&amp;splittet)) {
<a name="l19937"></a>19937               splittet.tet = dummytet;
<a name="l19938"></a>19938             }
<a name="l19939"></a>19939           }
<a name="l19940"></a>19940           <span class="keywordflow">if</span> (splittet.tet == dummytet) { <span class="comment">// Try pb.</span>
<a name="l19941"></a>19941             encodedtet = point2tet(pb);
<a name="l19942"></a>19942             <span class="keywordflow">if</span> (encodedtet != (tetrahedron) NULL) {
<a name="l19943"></a>19943               decode(encodedtet, splittet);
<a name="l19944"></a>19944               <span class="keywordflow">if</span> (isdead(&amp;splittet)) {
<a name="l19945"></a>19945                 splittet.tet = dummytet;
<a name="l19946"></a>19946               }
<a name="l19947"></a>19947             }
<a name="l19948"></a>19948           }
<a name="l19949"></a>19949           <span class="comment">// Locate the newpoint in DT.  Do exact location.</span>
<a name="l19950"></a>19950           success = insertsite(newpoint, &amp;splittet, <span class="keyword">false</span>, flipqueue);
<a name="l19951"></a>19951 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19952"></a>19952 <span class="preprocessor"></span>          assert(success != DUPLICATEPOINT);
<a name="l19953"></a>19953 <span class="preprocessor">#endif</span>
<a name="l19954"></a>19954 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (success == OUTSIDEPOINT) {
<a name="l19955"></a>19955             inserthullsite(newpoint, &amp;splittet, flipqueue);
<a name="l19956"></a>19956           }
<a name="l19957"></a>19957           <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l19958"></a>19958           <span class="comment">// Let newpoint remember splittet.</span>
<a name="l19959"></a>19959           setpoint2tet(newpoint, encode(splittet));
<a name="l19960"></a>19960           <span class="comment">// Do flip in DT.</span>
<a name="l19961"></a>19961           flip(flipqueue, NULL);
<a name="l19962"></a>19962           <span class="comment">// Insert newpoint into F.</span>
<a name="l19963"></a>19963           <span class="comment">// if (checkpbcs) {</span>
<a name="l19964"></a>19964             <span class="comment">// &#39;abovepoint&#39; has been changed.</span>
<a name="l19965"></a>19965             <span class="comment">// getabovepoint(&amp;splitsub);</span>
<a name="l19966"></a>19966             <span class="comment">// loc = locatesub(newpoint, &amp;splitsub, 1, 0.0);</span>
<a name="l19967"></a>19967           <span class="comment">// }</span>
<a name="l19968"></a>19968           <span class="keywordflow">if</span> (loc == ONFACE) {
<a name="l19969"></a>19969             <span class="comment">// Insert the newpoint in facet.</span>
<a name="l19970"></a>19970             splitsubface(newpoint, &amp;splitsub, flipqueue);
<a name="l19971"></a>19971           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (loc == ONEDGE) {
<a name="l19972"></a>19972             <span class="comment">// Insert the newpoint in facet.</span>
<a name="l19973"></a>19973             splitsubedge(newpoint, &amp;splitsub, flipqueue);
<a name="l19974"></a>19974           } <span class="keywordflow">else</span> {
<a name="l19975"></a>19975             <span class="comment">// &#39;insertsite()&#39; has done the whole job.</span>
<a name="l19976"></a>19976 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l19977"></a>19977 <span class="preprocessor"></span>            assert(loc == ONVERTEX);
<a name="l19978"></a>19978             assert(checksubfaces);
<a name="l19979"></a>19979 <span class="preprocessor">#endif</span>
<a name="l19980"></a>19980 <span class="preprocessor"></span>            <span class="comment">// Split subfaces have been flipped.</span>
<a name="l19981"></a>19981             flipqueue-&gt;clear();
<a name="l19982"></a>19982           }
<a name="l19983"></a>19983           <span class="comment">// Set the type of the newpoint.</span>
<a name="l19984"></a>19984           setpointtype(newpoint, FREESUBVERTEX);
<a name="l19985"></a>19985           <span class="comment">// Set splitsub into the newpoint.</span>
<a name="l19986"></a>19986           <span class="comment">// setpoint2sh(newpoint, sencode(splitsub));</span>
<a name="l19987"></a>19987           <span class="comment">// Do flip in the facet.</span>
<a name="l19988"></a>19988           flipsub(flipqueue);
<a name="l19989"></a>19989 
<a name="l19990"></a>19990           <span class="comment">// Remove this entry from list.</span>
<a name="l19991"></a>19991           badfacedealloc(badsubfaces, encloop);
<a name="l19992"></a>19992         } <span class="keywordflow">else</span> {
<a name="l19993"></a>19993           <span class="comment">// newpoint is rejected. Remove it from points.</span>
<a name="l19994"></a>19994           pointdealloc(newpoint);
<a name="l19995"></a>19995           <span class="comment">// Repair all encroached segments.</span>
<a name="l19996"></a>19996           perturbrepairencsegs(flipqueue);
<a name="l19997"></a>19997           <span class="comment">// Do not remove &#39;encloop&#39;. Later it will be tested again.</span>
<a name="l19998"></a>19998           setshell2badface(encloop-&gt;ss, encloop);
<a name="l19999"></a>19999         }
<a name="l20000"></a>20000       } <span class="keywordflow">else</span> {
<a name="l20001"></a>20001         <span class="comment">// This subface has been changed. Remove this entry from list.</span>
<a name="l20002"></a>20002         badfacedealloc(badsubfaces, encloop);
<a name="l20003"></a>20003         <span class="comment">// It may be co-circular with its neighbors.</span>
<a name="l20004"></a>20004         <span class="comment">// checksub4cocir(&amp;splitsub, eps, false, true);</span>
<a name="l20005"></a>20005       }
<a name="l20006"></a>20006       <span class="comment">// Get the next encroached subfaces.</span>
<a name="l20007"></a>20007       encloop = badfacetraverse(badsubfaces);
<a name="l20008"></a>20008     }
<a name="l20009"></a>20009   }
<a name="l20010"></a>20010 }
<a name="l20011"></a>20011 
<a name="l20013"></a>20013 <span class="comment">//                                                                           //</span>
<a name="l20014"></a>20014 <span class="comment">// incrperturbvertices()    Remove the local degeneracies in DT.             //</span>
<a name="l20015"></a>20015 <span class="comment">//                                                                           //</span>
<a name="l20016"></a>20016 <span class="comment">// A local degeneracy of a DT D is a set of 5 or more vertices which share a //</span>
<a name="l20017"></a>20017 <span class="comment">// common sphere S and no other vertex of D in S.  D is not unique if it has //</span>
<a name="l20018"></a>20018 <span class="comment">// local degeneracies. This routine removes the local degeneracies from D by //</span>
<a name="l20019"></a>20019 <span class="comment">// inserting break points (as described in reference [2]).                   //</span>
<a name="l20020"></a>20020 <span class="comment">//                                                                           //</span>
<a name="l20021"></a>20021 <span class="comment">// &#39;eps&#39; is a user-provided error tolerance. It is used to detect whether or //</span>
<a name="l20022"></a>20022 <span class="comment">// not five points are approximate cospherical (evaluated in iscospheric()). //</span>
<a name="l20023"></a>20023 <span class="comment">// Set it to 0.0 to disable it, i.e., only test pure degenerate point set.   //</span>
<a name="l20024"></a>20024 <span class="comment">//                                                                           //</span>
<a name="l20026"></a>20026 <span class="comment"></span>
<a name="l20027"></a>20027 <span class="keywordtype">void</span> tetgenmesh::incrperturbvertices(REAL eps)
<a name="l20028"></a>20028 {
<a name="l20029"></a>20029   queue *flipqueue;
<a name="l20030"></a>20030   list *cavsublist;
<a name="l20031"></a>20031   <span class="keywordtype">long</span> vertcount;
<a name="l20032"></a>20032 
<a name="l20033"></a>20033   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l20034"></a>20034     printf(<span class="stringliteral">&quot;Perturbing vertices.\n&quot;</span>);
<a name="l20035"></a>20035   }
<a name="l20036"></a>20036 
<a name="l20037"></a>20037   vertcount = points-&gt;items;
<a name="l20038"></a>20038   <span class="comment">// Create a map from points to tets for fastening search.</span>
<a name="l20039"></a>20039   <span class="comment">// makepoint2tetmap();  // This has been done in meshsurface().</span>
<a name="l20040"></a>20040 
<a name="l20041"></a>20041   <span class="comment">// Initialize working queues, lists.</span>
<a name="l20042"></a>20042   flipqueue = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l20043"></a>20043   cavsublist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l20044"></a>20044   <span class="comment">// Initialize the pool of encroached subfaces and subsegments.</span>
<a name="l20045"></a>20045   badsubsegs = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(badface), SUBPERBLOCK, POINTER, 0);
<a name="l20046"></a>20046   badsubfaces = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(badface), SUBPERBLOCK, POINTER, 0);
<a name="l20047"></a>20047   <span class="comment">// Find all pairs of co-circular subfaces.</span>
<a name="l20048"></a>20048   tallcocirsubs(eps, <span class="keyword">true</span>);
<a name="l20049"></a>20049   <span class="keywordflow">if</span> (b-&gt;verbose &amp;&amp; badsubfaces-&gt;items &gt; 0) {
<a name="l20050"></a>20050     printf(<span class="stringliteral">&quot;  Removing degenerate subfaces.\n&quot;</span>);
<a name="l20051"></a>20051   }
<a name="l20052"></a>20052   perturbrepairencsubs(cavsublist, flipqueue);
<a name="l20053"></a>20053 
<a name="l20054"></a>20054   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l20055"></a>20055     printf(<span class="stringliteral">&quot;  %ld break points.\n&quot;</span>, points-&gt;items - vertcount);
<a name="l20056"></a>20056   }
<a name="l20057"></a>20057 
<a name="l20058"></a>20058   <span class="keyword">delete</span> cavsublist;
<a name="l20059"></a>20059   <span class="keyword">delete</span> flipqueue;
<a name="l20060"></a>20060   <span class="keyword">delete</span> badsubfaces;
<a name="l20061"></a>20061   <span class="keyword">delete</span> badsubsegs;
<a name="l20062"></a>20062   badsubsegs = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l20063"></a>20063   badsubfaces = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l20064"></a>20064 }
<a name="l20065"></a>20065 
<a name="l20066"></a>20066 <span class="comment">//</span>
<a name="l20067"></a>20067 <span class="comment">// End of vertex perturbation routines</span>
<a name="l20068"></a>20068 <span class="comment">//</span>
<a name="l20069"></a>20069 
<a name="l20070"></a>20070 <span class="comment">//</span>
<a name="l20071"></a>20071 <span class="comment">// Begin of segment recovery routines</span>
<a name="l20072"></a>20072 <span class="comment">//</span>
<a name="l20073"></a>20073 
<a name="l20075"></a>20075 <span class="comment">//                                                                           //</span>
<a name="l20076"></a>20076 <span class="comment">// markacutevertices()    Mark acute vertices.                               //</span>
<a name="l20077"></a>20077 <span class="comment">//                                                                           //</span>
<a name="l20078"></a>20078 <span class="comment">// A vertex v is called acute if there are two segments sharing at v forming //</span>
<a name="l20079"></a>20079 <span class="comment">// an acute angle (i.e. smaller than 90 degree).                             //</span>
<a name="l20080"></a>20080 <span class="comment">//                                                                           //</span>
<a name="l20081"></a>20081 <span class="comment">// This routine finds all acute vertices in the PLC and marks them as point- //</span>
<a name="l20082"></a>20082 <span class="comment">// type ACUTEVERTEX. The other vertices of segments which are non-acute will //</span>
<a name="l20083"></a>20083 <span class="comment">// be marked as NACUTEVERTEX.  Vertices which are not endpoints of segments  //</span>
<a name="l20084"></a>20084 <span class="comment">// (such as DUPLICATEDVERTEX, UNUSEDVERTEX, etc) are not infected.           //</span>
<a name="l20085"></a>20085 <span class="comment">//                                                                           //</span>
<a name="l20086"></a>20086 <span class="comment">// NOTE: This routine should be called before Steiner points are introduced. //</span>
<a name="l20087"></a>20087 <span class="comment">// That is, no point has type like FREESEGVERTEX, etc.                       //</span>
<a name="l20088"></a>20088 <span class="comment">//                                                                           //</span>
<a name="l20090"></a>20090 <span class="comment"></span>
<a name="l20091"></a>20091 <span class="keywordtype">void</span> tetgenmesh::markacutevertices(REAL acuteangle)
<a name="l20092"></a>20092 {
<a name="l20093"></a>20093   shellface **segsperverlist;
<a name="l20094"></a>20094   face segloop, nextseg;
<a name="l20095"></a>20095   point pointloop, edest, eapex;
<a name="l20096"></a>20096   REAL cosbound, anglearc;
<a name="l20097"></a>20097   REAL v1[3], v2[3], L, D;
<a name="l20098"></a>20098   <span class="keywordtype">bool</span> isacute;
<a name="l20099"></a>20099   <span class="keywordtype">int</span> *idx2seglist;
<a name="l20100"></a>20100   <span class="keywordtype">int</span> acutecount;
<a name="l20101"></a>20101   <span class="keywordtype">int</span> idx, i, j, k;
<a name="l20102"></a>20102 
<a name="l20103"></a>20103   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l20104"></a>20104     printf(<span class="stringliteral">&quot;  Marking acute vertices.\n&quot;</span>);
<a name="l20105"></a>20105   }
<a name="l20106"></a>20106 
<a name="l20107"></a>20107   anglearc = acuteangle * PI / 180.0;
<a name="l20108"></a>20108   cosbound = cos(anglearc);
<a name="l20109"></a>20109   acutecount = 0;
<a name="l20110"></a>20110   <span class="comment">// Constructing a map from vertex to segments.</span>
<a name="l20111"></a>20111   makesegmentmap(idx2seglist, segsperverlist);
<a name="l20112"></a>20112 
<a name="l20113"></a>20113   <span class="comment">// Loop over the set of vertices.</span>
<a name="l20114"></a>20114   points-&gt;traversalinit();
<a name="l20115"></a>20115   pointloop = pointtraverse();
<a name="l20116"></a>20116   <span class="keywordflow">while</span> (pointloop != (point) NULL) {
<a name="l20117"></a>20117     idx = pointmark(pointloop) - in-&gt;firstnumber;
<a name="l20118"></a>20118     <span class="comment">// Only do test if p is an endpoint of some segments.</span>
<a name="l20119"></a>20119     <span class="keywordflow">if</span> (idx2seglist[idx + 1] &gt; idx2seglist[idx]) {
<a name="l20120"></a>20120       <span class="comment">// Init p to be non-acute.</span>
<a name="l20121"></a>20121       setpointtype(pointloop, NACUTEVERTEX);
<a name="l20122"></a>20122       isacute = <span class="keyword">false</span>;
<a name="l20123"></a>20123       <span class="comment">// Loop through all segments sharing at p.</span>
<a name="l20124"></a>20124       <span class="keywordflow">for</span> (i = idx2seglist[idx]; i &lt; idx2seglist[idx + 1] &amp;&amp; !isacute; i++) {
<a name="l20125"></a>20125         segloop.sh = segsperverlist[i];
<a name="l20126"></a>20126         <span class="comment">// segloop.shver = 0;</span>
<a name="l20127"></a>20127         <span class="keywordflow">if</span> (sorg(segloop) != pointloop) sesymself(segloop);
<a name="l20128"></a>20128         edest = sdest(segloop);
<a name="l20129"></a>20129         <span class="keywordflow">for</span> (j = i + 1; j &lt; idx2seglist[idx + 1] &amp;&amp; !isacute; j++) {
<a name="l20130"></a>20130           nextseg.sh = segsperverlist[j];
<a name="l20131"></a>20131           <span class="comment">// nextseg.shver = 0;</span>
<a name="l20132"></a>20132           <span class="keywordflow">if</span> (sorg(nextseg) != pointloop) sesymself(nextseg);
<a name="l20133"></a>20133           eapex = sdest(nextseg);
<a name="l20134"></a>20134           <span class="comment">// Check the angle formed by segs (p, edest) and (p, eapex).</span>
<a name="l20135"></a>20135           <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) {
<a name="l20136"></a>20136             v1[k] = edest[k] - pointloop[k];
<a name="l20137"></a>20137             v2[k] = eapex[k] - pointloop[k];
<a name="l20138"></a>20138           }
<a name="l20139"></a>20139           L = sqrt(v1[0] * v1[0] + v1[1] * v1[1] + v1[2] * v1[2]);
<a name="l20140"></a>20140           <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) v1[k] /= L;
<a name="l20141"></a>20141           L = sqrt(v2[0] * v2[0] + v2[1] * v2[1] + v2[2] * v2[2]);
<a name="l20142"></a>20142           <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) v2[k] /= L;
<a name="l20143"></a>20143           D = v1[0] * v2[0] + v1[1] * v2[1] + v1[2] * v2[2];
<a name="l20144"></a>20144           <span class="comment">// Is D acute?</span>
<a name="l20145"></a>20145           isacute = (D &gt;= cosbound);
<a name="l20146"></a>20146         }
<a name="l20147"></a>20147       }
<a name="l20148"></a>20148       <span class="keywordflow">if</span> (isacute) {
<a name="l20149"></a>20149         <span class="comment">// Mark p to be acute.</span>
<a name="l20150"></a>20150         setpointtype(pointloop, ACUTEVERTEX);
<a name="l20151"></a>20151         acutecount++;
<a name="l20152"></a>20152       }
<a name="l20153"></a>20153     }
<a name="l20154"></a>20154     pointloop = pointtraverse();
<a name="l20155"></a>20155   }
<a name="l20156"></a>20156 
<a name="l20157"></a>20157   <span class="keyword">delete</span> [] idx2seglist;
<a name="l20158"></a>20158   <span class="keyword">delete</span> [] segsperverlist;
<a name="l20159"></a>20159 
<a name="l20160"></a>20160   <span class="keywordflow">if</span> ((b-&gt;verbose &gt; 0) &amp;&amp; (acutecount &gt; 0)) {
<a name="l20161"></a>20161     printf(<span class="stringliteral">&quot;  %d acute vertices.\n&quot;</span>, acutecount);
<a name="l20162"></a>20162   }
<a name="l20163"></a>20163 }
<a name="l20164"></a>20164 
<a name="l20166"></a>20166 <span class="comment">//                                                                           //</span>
<a name="l20167"></a>20167 <span class="comment">// finddirection()    Find the first tetrahedron on the path from one point  //</span>
<a name="l20168"></a>20168 <span class="comment">//                    to another.                                            //</span>
<a name="l20169"></a>20169 <span class="comment">//                                                                           //</span>
<a name="l20170"></a>20170 <span class="comment">// Find the tetrahedron that intersects a line segment L (from the origin of //</span>
<a name="l20171"></a>20171 <span class="comment">// &#39;searchtet&#39; to the point &#39;tend&#39;), and returns the result in &#39;searchtet&#39;.  //</span>
<a name="l20172"></a>20172 <span class="comment">// The origin of &#39;searchtet&#39; does not change, even though the tetrahedron    //</span>
<a name="l20173"></a>20173 <span class="comment">// returned may differ from the one passed in.  This routine is used to find //</span>
<a name="l20174"></a>20174 <span class="comment">// the direction to move in to get from one point to another.                //</span>
<a name="l20175"></a>20175 <span class="comment">//                                                                           //</span>
<a name="l20176"></a>20176 <span class="comment">// The return value notes the location of the line segment L with respect to //</span>
<a name="l20177"></a>20177 <span class="comment">// &#39;searchtet&#39;:                                                              //</span>
<a name="l20178"></a>20178 <span class="comment">//   - Returns RIGHTCOLLINEAR indicates L is collinear with the line segment //</span>
<a name="l20179"></a>20179 <span class="comment">//     from the origin to the destination of &#39;searchtet&#39;.                    //</span>
<a name="l20180"></a>20180 <span class="comment">//   - Returns LEFTCOLLINEAR indicates L is collinear with the line segment  //</span>
<a name="l20181"></a>20181 <span class="comment">//     from the origin to the apex of &#39;searchtet&#39;.                           //</span>
<a name="l20182"></a>20182 <span class="comment">//   - Returns TOPCOLLINEAR indicates L is collinear with the line segment   //</span>
<a name="l20183"></a>20183 <span class="comment">//     from the origin to the opposite of &#39;searchtet&#39;.                       //</span>
<a name="l20184"></a>20184 <span class="comment">//   - Returns ACROSSEDGE indicates L intersects with the line segment from  //</span>
<a name="l20185"></a>20185 <span class="comment">//     the destination to the apex of &#39;searchtet&#39;.                           //</span>
<a name="l20186"></a>20186 <span class="comment">//   - Returns ACROSSFACE indicates L intersects with the face opposite to   //</span>
<a name="l20187"></a>20187 <span class="comment">//     the origin of &#39;searchtet&#39;.                                            //</span>
<a name="l20188"></a>20188 <span class="comment">//   - Returns BELOWHULL indicates L crosses outside the mesh domain. This   //</span>
<a name="l20189"></a>20189 <span class="comment">//     can only happen when the domain is non-convex.                        //</span>
<a name="l20190"></a>20190 <span class="comment">//                                                                           //</span>
<a name="l20191"></a>20191 <span class="comment">// NOTE: This routine only works correctly when the mesh is exactly Delaunay.//</span>
<a name="l20192"></a>20192 <span class="comment">//                                                                           //</span>
<a name="l20193"></a>20193 <span class="comment">// If &#39;maxtetnumber&#39; &gt; 0, stop the searching process if the number of passed //</span>
<a name="l20194"></a>20194 <span class="comment">// tets is larger than it. Return BELOWHULL.                                 //</span>
<a name="l20195"></a>20195 <span class="comment">//                                                                           //</span>
<a name="l20197"></a>20197 <span class="comment"></span>
<a name="l20198"></a>20198 <span class="keyword">enum</span> tetgenmesh::finddirectionresult tetgenmesh::
<a name="l20199"></a>20199 finddirection(triface *searchtet, point tend, <span class="keywordtype">long</span> maxtetnumber)
<a name="l20200"></a>20200 {
<a name="l20201"></a>20201   triface neightet;
<a name="l20202"></a>20202   point tstart, tdest, tapex, toppo;
<a name="l20203"></a>20203   REAL ori1, ori2, ori3;
<a name="l20204"></a>20204   <span class="keywordtype">long</span> tetnumber;
<a name="l20205"></a>20205 
<a name="l20206"></a>20206   tstart = org(*searchtet);
<a name="l20207"></a>20207 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20208"></a>20208 <span class="preprocessor"></span>  assert(tstart != tend);
<a name="l20209"></a>20209 <span class="preprocessor">#endif</span>
<a name="l20210"></a>20210 <span class="preprocessor"></span>  adjustedgering(*searchtet, CCW);
<a name="l20211"></a>20211   <span class="keywordflow">if</span> (tstart != org(*searchtet)) {
<a name="l20212"></a>20212     enextself(*searchtet); <span class="comment">// For keeping the same origin.</span>
<a name="l20213"></a>20213   }
<a name="l20214"></a>20214   tdest = dest(*searchtet);
<a name="l20215"></a>20215   <span class="keywordflow">if</span> (tdest == tend) {
<a name="l20216"></a>20216     <span class="keywordflow">return</span> RIGHTCOLLINEAR;
<a name="l20217"></a>20217   }
<a name="l20218"></a>20218   tapex = apex(*searchtet);
<a name="l20219"></a>20219   <span class="keywordflow">if</span> (tapex == tend) {
<a name="l20220"></a>20220     <span class="keywordflow">return</span> LEFTCOLLINEAR;
<a name="l20221"></a>20221   }
<a name="l20222"></a>20222 
<a name="l20223"></a>20223   ori1 = orient3d(tstart, tdest, tapex, tend);
<a name="l20224"></a>20224   <span class="keywordflow">if</span> (ori1 &gt; 0.0) {
<a name="l20225"></a>20225     <span class="comment">// &#39;tend&#39; is below the face, get the neighbor of this side.</span>
<a name="l20226"></a>20226     sym(*searchtet, neightet);
<a name="l20227"></a>20227     <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l20228"></a>20228       findorg(&amp;neightet, tstart);
<a name="l20229"></a>20229       adjustedgering(neightet, CCW);
<a name="l20230"></a>20230       <span class="keywordflow">if</span> (org(neightet) != tstart) {
<a name="l20231"></a>20231         enextself(neightet); <span class="comment">// keep the same origin.</span>
<a name="l20232"></a>20232       }
<a name="l20233"></a>20233       <span class="comment">// Set the changed configuratiuon.</span>
<a name="l20234"></a>20234       *searchtet = neightet;
<a name="l20235"></a>20235       ori1 = -1.0;
<a name="l20236"></a>20236       tdest = dest(*searchtet);
<a name="l20237"></a>20237       tapex = apex(*searchtet);
<a name="l20238"></a>20238     } <span class="keywordflow">else</span> {
<a name="l20239"></a>20239       <span class="comment">// A hull face. Only possible for a nonconvex mesh.</span>
<a name="l20240"></a>20240 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20241"></a>20241 <span class="preprocessor"></span>      assert(nonconvex);
<a name="l20242"></a>20242 <span class="preprocessor">#endif</span>
<a name="l20243"></a>20243 <span class="preprocessor"></span>      <span class="keywordflow">return</span> BELOWHULL;
<a name="l20244"></a>20244     }
<a name="l20245"></a>20245   }
<a name="l20246"></a>20246 
<a name="l20247"></a>20247   <span class="comment">// Repeatedly change the &#39;searchtet&#39;, remain &#39;tstart&#39; be its origin, until</span>
<a name="l20248"></a>20248   <span class="comment">//   find a tetrahedron contains &#39;tend&#39; or is crossed by the line segment</span>
<a name="l20249"></a>20249   <span class="comment">//   from &#39;tstart&#39; to &#39;tend&#39;.</span>
<a name="l20250"></a>20250   tetnumber = 0l;
<a name="l20251"></a>20251   <span class="keywordflow">while</span> ((maxtetnumber &gt; 0) &amp;&amp; (tetnumber &lt;= maxtetnumber)) {
<a name="l20252"></a>20252     tetnumber++;
<a name="l20253"></a>20253     toppo = oppo(*searchtet);
<a name="l20254"></a>20254     <span class="keywordflow">if</span> (toppo == tend) {
<a name="l20255"></a>20255       <span class="keywordflow">return</span> TOPCOLLINEAR;
<a name="l20256"></a>20256     }
<a name="l20257"></a>20257     ori2 = orient3d(tstart, toppo, tdest, tend);
<a name="l20258"></a>20258     <span class="keywordflow">if</span> (ori2 &gt; 0.0) {
<a name="l20259"></a>20259       <span class="comment">// &#39;tend&#39; is below the face, get the neighbor at this side.</span>
<a name="l20260"></a>20260       fnext(*searchtet, neightet);
<a name="l20261"></a>20261       symself(neightet);
<a name="l20262"></a>20262       <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l20263"></a>20263         findorg(&amp;neightet, tstart);
<a name="l20264"></a>20264         adjustedgering(neightet, CCW);
<a name="l20265"></a>20265         <span class="keywordflow">if</span> (org(neightet) != tstart) {
<a name="l20266"></a>20266           enextself(neightet); <span class="comment">// keep the same origin.</span>
<a name="l20267"></a>20267         }
<a name="l20268"></a>20268         <span class="comment">// Set the changed configuration.</span>
<a name="l20269"></a>20269         *searchtet = neightet;
<a name="l20270"></a>20270         ori1 = -1.0;
<a name="l20271"></a>20271         tdest = dest(*searchtet);
<a name="l20272"></a>20272         tapex = apex(*searchtet);
<a name="l20273"></a>20273         <span class="comment">// Continue the search from the changed &#39;searchtet&#39;.</span>
<a name="l20274"></a>20274         <span class="keywordflow">continue</span>;
<a name="l20275"></a>20275       } <span class="keywordflow">else</span> {
<a name="l20276"></a>20276         <span class="comment">// A hull face. Only possible for a nonconvex mesh.</span>
<a name="l20277"></a>20277 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20278"></a>20278 <span class="preprocessor"></span>        assert(nonconvex);
<a name="l20279"></a>20279 <span class="preprocessor">#endif</span>
<a name="l20280"></a>20280 <span class="preprocessor"></span>        <span class="keywordflow">return</span> BELOWHULL;
<a name="l20281"></a>20281       }
<a name="l20282"></a>20282     }
<a name="l20283"></a>20283     ori3 = orient3d(tapex, toppo, tstart, tend);
<a name="l20284"></a>20284     <span class="keywordflow">if</span> (ori3 &gt; 0.0) {
<a name="l20285"></a>20285       <span class="comment">// &#39;tend&#39; is below the face, get the neighbor at this side.</span>
<a name="l20286"></a>20286       enext2fnext(*searchtet, neightet);
<a name="l20287"></a>20287       symself(neightet);
<a name="l20288"></a>20288       <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l20289"></a>20289         findorg(&amp;neightet, tstart);
<a name="l20290"></a>20290         adjustedgering(neightet, CCW);
<a name="l20291"></a>20291         <span class="keywordflow">if</span> (org(neightet) != tstart) {
<a name="l20292"></a>20292           enextself(neightet); <span class="comment">// keep the same origin.</span>
<a name="l20293"></a>20293         }
<a name="l20294"></a>20294         <span class="comment">// Set the changed configuration.</span>
<a name="l20295"></a>20295         *searchtet = neightet;
<a name="l20296"></a>20296         ori1 = -1.0;
<a name="l20297"></a>20297         tdest = dest(*searchtet);
<a name="l20298"></a>20298         tapex = apex(*searchtet);
<a name="l20299"></a>20299         <span class="comment">// Continue the search from the changed &#39;searchtet&#39;.</span>
<a name="l20300"></a>20300         <span class="keywordflow">continue</span>;
<a name="l20301"></a>20301       } <span class="keywordflow">else</span> {
<a name="l20302"></a>20302         <span class="comment">// A hull face. Only possible for a nonconvex mesh.</span>
<a name="l20303"></a>20303 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20304"></a>20304 <span class="preprocessor"></span>        assert(nonconvex);
<a name="l20305"></a>20305 <span class="preprocessor">#endif</span>
<a name="l20306"></a>20306 <span class="preprocessor"></span>        <span class="keywordflow">return</span> BELOWHULL;
<a name="l20307"></a>20307       }
<a name="l20308"></a>20308     }
<a name="l20309"></a>20309     <span class="comment">// Now &#39;ori1&#39;, &#39;ori2&#39; and &#39;ori3&#39; are possible be 0.0 or all &lt; 0.0;</span>
<a name="l20310"></a>20310     <span class="keywordflow">if</span> (ori1 &lt; 0.0) {
<a name="l20311"></a>20311       <span class="comment">// Possible cases are: ACROSSFACE, ACROSSEDGE, TOPCOLLINEAR.</span>
<a name="l20312"></a>20312       <span class="keywordflow">if</span> (ori2 &lt; 0.0) {
<a name="l20313"></a>20313         <span class="keywordflow">if</span> (ori3 &lt; 0.0) {
<a name="l20314"></a>20314           <span class="keywordflow">return</span> ACROSSFACE;
<a name="l20315"></a>20315         } <span class="keywordflow">else</span> { <span class="comment">// ori3 == 0.0;</span>
<a name="l20316"></a>20316           <span class="comment">// Cross edge (apex, oppo)</span>
<a name="l20317"></a>20317           enext2fnextself(*searchtet);
<a name="l20318"></a>20318           esymself(*searchtet); <span class="comment">// org(*searchtet) == tstart;</span>
<a name="l20319"></a>20319           <span class="keywordflow">return</span> ACROSSEDGE;
<a name="l20320"></a>20320         }
<a name="l20321"></a>20321       } <span class="keywordflow">else</span> { <span class="comment">// ori2 == 0.0;</span>
<a name="l20322"></a>20322         <span class="keywordflow">if</span> (ori3 &lt; 0.0) {
<a name="l20323"></a>20323           <span class="comment">// Cross edge (dest, oppo)</span>
<a name="l20324"></a>20324           fnextself(*searchtet);
<a name="l20325"></a>20325           esymself(*searchtet);
<a name="l20326"></a>20326           enextself(*searchtet); <span class="comment">// org(*searchtet) == tstart;</span>
<a name="l20327"></a>20327           <span class="keywordflow">return</span> ACROSSEDGE;
<a name="l20328"></a>20328         } <span class="keywordflow">else</span> { <span class="comment">// ori3 == 0.0;</span>
<a name="l20329"></a>20329           <span class="comment">// Collinear with edge (org, oppo)</span>
<a name="l20330"></a>20330           <span class="keywordflow">return</span> TOPCOLLINEAR;
<a name="l20331"></a>20331         }
<a name="l20332"></a>20332       }
<a name="l20333"></a>20333     } <span class="keywordflow">else</span> { <span class="comment">// ori1 == 0.0;</span>
<a name="l20334"></a>20334       <span class="comment">// Possible cases are: RIGHTCOLLINEAR, LEFTCOLLINEAR, ACROSSEDGE.</span>
<a name="l20335"></a>20335       <span class="keywordflow">if</span> (ori2 &lt; 0.0) {
<a name="l20336"></a>20336         <span class="keywordflow">if</span> (ori3 &lt; 0.0) {
<a name="l20337"></a>20337           <span class="comment">// Cross edge (tdest, tapex)</span>
<a name="l20338"></a>20338           <span class="keywordflow">return</span> ACROSSEDGE;
<a name="l20339"></a>20339         } <span class="keywordflow">else</span> { <span class="comment">// ori3 == 0.0</span>
<a name="l20340"></a>20340           <span class="comment">// Collinear with edge (torg, tapex)</span>
<a name="l20341"></a>20341           <span class="keywordflow">return</span> LEFTCOLLINEAR;
<a name="l20342"></a>20342         }
<a name="l20343"></a>20343       } <span class="keywordflow">else</span> { <span class="comment">// ori2 == 0.0;</span>
<a name="l20344"></a>20344 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20345"></a>20345 <span class="preprocessor"></span>        assert(ori3 != 0.0);
<a name="l20346"></a>20346 <span class="preprocessor">#endif</span>
<a name="l20347"></a>20347 <span class="preprocessor"></span>        <span class="comment">// Collinear with edge (torg, tdest)</span>
<a name="l20348"></a>20348         <span class="keywordflow">return</span> RIGHTCOLLINEAR;
<a name="l20349"></a>20349       }
<a name="l20350"></a>20350     }
<a name="l20351"></a>20351   }
<a name="l20352"></a>20352   <span class="comment">// Loop breakout. It may happen when the mesh is non-Delaunay.</span>
<a name="l20353"></a>20353   <span class="keywordflow">return</span> BELOWHULL;
<a name="l20354"></a>20354 }
<a name="l20355"></a>20355 
<a name="l20357"></a>20357 <span class="comment">//                                                                           //</span>
<a name="l20358"></a>20358 <span class="comment">// getsearchtet()    Find a tetrahedron whose origin is either &#39;p1&#39; or &#39;p2&#39;. //</span>
<a name="l20359"></a>20359 <span class="comment">//                                                                           //</span>
<a name="l20360"></a>20360 <span class="comment">// On return, the origin of &#39;searchtet&#39; is either &#39;p1&#39; or &#39;p2&#39;,  and &#39;tend&#39;  //</span>
<a name="l20361"></a>20361 <span class="comment">// returns the other point.  &#39;searchtet&#39; serves as the starting tetrahedron  //</span>
<a name="l20362"></a>20362 <span class="comment">// for searching of the line segment from &#39;p1&#39; to &#39;p2&#39; or vice versa.        //</span>
<a name="l20363"></a>20363 <span class="comment">//                                                                           //</span>
<a name="l20365"></a>20365 <span class="comment"></span>
<a name="l20366"></a>20366 <span class="keywordtype">void</span> tetgenmesh::getsearchtet(point p1, point p2, triface* searchtet,
<a name="l20367"></a>20367   point* tend)
<a name="l20368"></a>20368 {
<a name="l20369"></a>20369   tetrahedron encodedtet1, encodedtet2;
<a name="l20370"></a>20370 
<a name="l20371"></a>20371   <span class="comment">// Is there a valid handle provided by the user?</span>
<a name="l20372"></a>20372   <span class="keywordflow">if</span> ((searchtet-&gt;tet != (tetrahedron *) NULL) &amp;&amp; !isdead(searchtet)) {
<a name="l20373"></a>20373     <span class="comment">// Find which endpoint the handle holds.</span>
<a name="l20374"></a>20374     <span class="keywordflow">if</span> (findorg(searchtet, p1)) {
<a name="l20375"></a>20375       *tend = p2;
<a name="l20376"></a>20376       <span class="keywordflow">return</span>;
<a name="l20377"></a>20377     } <span class="keywordflow">else</span> {
<a name="l20378"></a>20378       <span class="keywordflow">if</span> (findorg(searchtet, p2)) {
<a name="l20379"></a>20379         *tend = p1;
<a name="l20380"></a>20380         <span class="keywordflow">return</span>;
<a name="l20381"></a>20381       }
<a name="l20382"></a>20382     }
<a name="l20383"></a>20383   }
<a name="l20384"></a>20384   <span class="comment">// If not, search the tet handle stored in &#39;p1&#39; or &#39;p2&#39;.</span>
<a name="l20385"></a>20385   *tend = (point) NULL;
<a name="l20386"></a>20386   encodedtet1 = point2tet(p1);
<a name="l20387"></a>20387   encodedtet2 = point2tet(p2);
<a name="l20388"></a>20388   <span class="keywordflow">if</span> (encodedtet1 != (tetrahedron) NULL) {
<a name="l20389"></a>20389     decode(encodedtet1, *searchtet);
<a name="l20390"></a>20390     <span class="comment">// Be careful, here &#39;searchtet&#39; may be dead.</span>
<a name="l20391"></a>20391     <span class="keywordflow">if</span> (findorg(searchtet, p1)) {
<a name="l20392"></a>20392       *tend = p2;
<a name="l20393"></a>20393     }
<a name="l20394"></a>20394   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (encodedtet2 != (tetrahedron) NULL) {
<a name="l20395"></a>20395     decode(encodedtet2, *searchtet);
<a name="l20396"></a>20396     <span class="comment">// Be careful, here &#39;searchtet&#39; may be dead.</span>
<a name="l20397"></a>20397     <span class="keywordflow">if</span> (findorg(searchtet, p2)) {
<a name="l20398"></a>20398       *tend = p1;
<a name="l20399"></a>20399     }
<a name="l20400"></a>20400   }
<a name="l20401"></a>20401   <span class="comment">// If still not, perform a full point location.  The starting tet is</span>
<a name="l20402"></a>20402   <span class="comment">//   chosen as follows: Use the handle stored in &#39;p1&#39; or &#39;p2&#39; if it is</span>
<a name="l20403"></a>20403   <span class="comment">//   alive; otherwise, start from a tet on the convex hull.</span>
<a name="l20404"></a>20404   <span class="keywordflow">if</span> (*tend == (point) NULL) {
<a name="l20405"></a>20405     <span class="keywordflow">if</span> (encodedtet1 != (tetrahedron) NULL) {
<a name="l20406"></a>20406       decode(encodedtet1, *searchtet);
<a name="l20407"></a>20407       <span class="comment">// Be careful, here &#39;searchtet&#39; may be dead.</span>
<a name="l20408"></a>20408     }
<a name="l20409"></a>20409     <span class="keywordflow">if</span> (isdead(searchtet)) {
<a name="l20410"></a>20410       <span class="keywordflow">if</span> (encodedtet2 != (tetrahedron) NULL) {
<a name="l20411"></a>20411         decode(encodedtet2, *searchtet);
<a name="l20412"></a>20412         <span class="comment">// Be careful, here &#39;searchtet&#39; may be dead.</span>
<a name="l20413"></a>20413       }
<a name="l20414"></a>20414       <span class="keywordflow">if</span> (isdead(searchtet)) {
<a name="l20415"></a>20415         searchtet-&gt;tet = dummytet;
<a name="l20416"></a>20416         searchtet-&gt;loc = 0;
<a name="l20417"></a>20417         symself(*searchtet);
<a name="l20418"></a>20418       }
<a name="l20419"></a>20419 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20420"></a>20420 <span class="preprocessor"></span>      assert(!isdead(searchtet));
<a name="l20421"></a>20421 <span class="preprocessor">#endif</span>
<a name="l20422"></a>20422 <span class="preprocessor"></span>    }
<a name="l20423"></a>20423     <span class="keywordflow">if</span> (locate(p1, searchtet) != ONVERTEX) {
<a name="l20424"></a>20424       printf(<span class="stringliteral">&quot;Internal error in getsearchtet():  Failed to locate point\n&quot;</span>);
<a name="l20425"></a>20425       internalerror();
<a name="l20426"></a>20426     }
<a name="l20427"></a>20427     <span class="comment">// Remember this handle in &#39;p1&#39; to enhance the search speed.</span>
<a name="l20428"></a>20428     setpoint2tet(p1, encode(*searchtet));
<a name="l20429"></a>20429     *tend = p2;
<a name="l20430"></a>20430   }
<a name="l20431"></a>20431 }
<a name="l20432"></a>20432 
<a name="l20434"></a>20434 <span class="comment">//                                                                           //</span>
<a name="l20435"></a>20435 <span class="comment">// isedgeencroached()    Check whether or not a subsegment is encroached.    //</span>
<a name="l20436"></a>20436 <span class="comment">//                                                                           //</span>
<a name="l20437"></a>20437 <span class="comment">// A segment with endpoints &#39;p1&#39; and &#39;p2&#39; is encroached by the point &#39;testpt&#39;//</span>
<a name="l20438"></a>20438 <span class="comment">// if it lies in the diametral sphere of this segment.  The degenerate case  //</span>
<a name="l20439"></a>20439 <span class="comment">// that &#39;testpt&#39; lies on the sphere is treated as encroached if &#39;degflag&#39; is //</span>
<a name="l20440"></a>20440 <span class="comment">// set to be TRUE.                                                           //</span>
<a name="l20441"></a>20441 <span class="comment">//                                                                           //</span>
<a name="l20443"></a>20443 <span class="comment"></span>
<a name="l20444"></a>20444 <span class="keywordtype">bool</span> tetgenmesh::isedgeencroached(point p1, point p2, point testpt,
<a name="l20445"></a>20445   <span class="keywordtype">bool</span> degflag)
<a name="l20446"></a>20446 {
<a name="l20447"></a>20447   REAL dotproduct;
<a name="l20448"></a>20448 
<a name="l20449"></a>20449   <span class="comment">// Check if the segment is facing an angle larger than 90 degree?</span>
<a name="l20450"></a>20450   dotproduct = (p1[0] - testpt[0]) * (p2[0] - testpt[0])
<a name="l20451"></a>20451              + (p1[1] - testpt[1]) * (p2[1] - testpt[1])
<a name="l20452"></a>20452              + (p1[2] - testpt[2]) * (p2[2] - testpt[2]);
<a name="l20453"></a>20453   <span class="keywordflow">if</span> (dotproduct &lt; 0) {
<a name="l20454"></a>20454     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l20455"></a>20455   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dotproduct == 0 &amp;&amp; degflag) {
<a name="l20456"></a>20456     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l20457"></a>20457   } <span class="keywordflow">else</span> {
<a name="l20458"></a>20458     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l20459"></a>20459   }
<a name="l20460"></a>20460 }
<a name="l20461"></a>20461 
<a name="l20463"></a>20463 <span class="comment">//                                                                           //</span>
<a name="l20464"></a>20464 <span class="comment">// scoutrefpoint()    Search the reference point of a missing segment.       //</span>
<a name="l20465"></a>20465 <span class="comment">//                                                                           //</span>
<a name="l20466"></a>20466 <span class="comment">// A segment S is missing in current Delaunay tetrahedralization DT and will //</span>
<a name="l20467"></a>20467 <span class="comment">// be split by inserting a point V in it.  The two end points of S are the   //</span>
<a name="l20468"></a>20468 <span class="comment">// origin of &#39;searchtet&#39; and &#39;tend&#39;. And we know that S is crossing the face //</span>
<a name="l20469"></a>20469 <span class="comment">// of &#39;searchtet&#39; opposite to its origin (may be intersecting with the edge  //</span>
<a name="l20470"></a>20470 <span class="comment">// from the destination to the apex of the &#39;searchtet&#39;).  The search of P is //</span>
<a name="l20471"></a>20471 <span class="comment">// completed by walking through all faces of DT across by S.                 //</span>
<a name="l20472"></a>20472 <span class="comment">//                                                                           //</span>
<a name="l20473"></a>20473 <span class="comment">// Warning:  This routine is correct when the tetrahedralization is Delaunay //</span>
<a name="l20474"></a>20474 <span class="comment">// and convex. Otherwise, the search loop may not terminate.                 //</span>
<a name="l20475"></a>20475 <span class="comment">//                                                                           //</span>
<a name="l20477"></a>20477 <span class="comment"></span>
<a name="l20478"></a>20478 tetgenmesh::point tetgenmesh::scoutrefpoint(triface* searchtet, point tend)
<a name="l20479"></a>20479 {
<a name="l20480"></a>20480   triface checkface;
<a name="l20481"></a>20481   point tstart, testpt, refpoint;
<a name="l20482"></a>20482   REAL cent[3], radius, largest;
<a name="l20483"></a>20483   REAL ahead;
<a name="l20484"></a>20484   <span class="keywordtype">bool</span> ncollinear;
<a name="l20485"></a>20485   <span class="keywordtype">int</span> sides;
<a name="l20486"></a>20486 
<a name="l20487"></a>20487   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l20488"></a>20488     printf(<span class="stringliteral">&quot;  Scout the reference point of segment (%d, %d).\n&quot;</span>,
<a name="l20489"></a>20489            pointmark(org(*searchtet)), pointmark(tend));
<a name="l20490"></a>20490   }
<a name="l20491"></a>20491 
<a name="l20492"></a>20492   tstart = org(*searchtet);
<a name="l20493"></a>20493   refpoint = (point) NULL;
<a name="l20494"></a>20494   largest = 0; <span class="comment">// avoid compile warning.</span>
<a name="l20495"></a>20495 
<a name="l20496"></a>20496   <span class="comment">// Check the three vertices of the crossing face.</span>
<a name="l20497"></a>20497   testpt = apex(*searchtet);
<a name="l20498"></a>20498   <span class="keywordflow">if</span> (isedgeencroached(tstart, tend, testpt, <span class="keyword">true</span>)) {
<a name="l20499"></a>20499     ncollinear = circumsphere(tstart, tend, testpt, NULL, cent, &amp;radius);
<a name="l20500"></a>20500 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20501"></a>20501 <span class="preprocessor"></span>    assert(ncollinear);
<a name="l20502"></a>20502 <span class="preprocessor">#endif</span>
<a name="l20503"></a>20503 <span class="preprocessor"></span>    refpoint = testpt;
<a name="l20504"></a>20504     largest = radius;
<a name="l20505"></a>20505   }
<a name="l20506"></a>20506   testpt = dest(*searchtet);
<a name="l20507"></a>20507   <span class="keywordflow">if</span> (isedgeencroached(tstart, tend, testpt, <span class="keyword">true</span>)) {
<a name="l20508"></a>20508     ncollinear = circumsphere(tstart, tend, testpt, NULL, cent, &amp;radius);
<a name="l20509"></a>20509 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20510"></a>20510 <span class="preprocessor"></span>    assert(ncollinear);
<a name="l20511"></a>20511 <span class="preprocessor">#endif</span>
<a name="l20512"></a>20512 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (refpoint == (point) NULL) {
<a name="l20513"></a>20513       refpoint = testpt;
<a name="l20514"></a>20514       largest = radius;
<a name="l20515"></a>20515     } <span class="keywordflow">else</span> {
<a name="l20516"></a>20516       <span class="keywordflow">if</span> (radius &gt; largest) {
<a name="l20517"></a>20517         refpoint = testpt;
<a name="l20518"></a>20518         largest = radius;
<a name="l20519"></a>20519       }
<a name="l20520"></a>20520     }
<a name="l20521"></a>20521   }
<a name="l20522"></a>20522   testpt = oppo(*searchtet);
<a name="l20523"></a>20523   <span class="keywordflow">if</span> (isedgeencroached(tstart, tend, testpt, <span class="keyword">true</span>)) {
<a name="l20524"></a>20524     ncollinear = circumsphere(tstart, tend, testpt, NULL, cent, &amp;radius);
<a name="l20525"></a>20525 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20526"></a>20526 <span class="preprocessor"></span>    assert(ncollinear);
<a name="l20527"></a>20527 <span class="preprocessor">#endif</span>
<a name="l20528"></a>20528 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (refpoint == (point) NULL) {
<a name="l20529"></a>20529       refpoint = testpt;
<a name="l20530"></a>20530       largest = radius;
<a name="l20531"></a>20531     } <span class="keywordflow">else</span> {
<a name="l20532"></a>20532       <span class="keywordflow">if</span> (radius &gt; largest) {
<a name="l20533"></a>20533         refpoint = testpt;
<a name="l20534"></a>20534         largest = radius;
<a name="l20535"></a>20535       }
<a name="l20536"></a>20536     }
<a name="l20537"></a>20537   }
<a name="l20538"></a>20538   <span class="comment">// Check the opposite vertex of the neighboring tet in case the segment</span>
<a name="l20539"></a>20539   <span class="comment">//   crosses the edge (leftpoint, rightpoint) of the crossing face.</span>
<a name="l20540"></a>20540   sym(*searchtet, checkface);
<a name="l20541"></a>20541   <span class="keywordflow">if</span> (checkface.tet != dummytet) {
<a name="l20542"></a>20542     testpt = oppo(checkface);
<a name="l20543"></a>20543     <span class="keywordflow">if</span> (isedgeencroached(tstart, tend, testpt, <span class="keyword">true</span>)) {
<a name="l20544"></a>20544       ncollinear = circumsphere(tstart, tend, testpt, NULL, cent, &amp;radius);
<a name="l20545"></a>20545 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20546"></a>20546 <span class="preprocessor"></span>      assert(ncollinear);
<a name="l20547"></a>20547 <span class="preprocessor">#endif</span>
<a name="l20548"></a>20548 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (refpoint == (point) NULL) {
<a name="l20549"></a>20549         refpoint = testpt;
<a name="l20550"></a>20550         largest = radius;
<a name="l20551"></a>20551       } <span class="keywordflow">else</span> {
<a name="l20552"></a>20552         <span class="keywordflow">if</span> (radius &gt; largest) {
<a name="l20553"></a>20553           refpoint = testpt;
<a name="l20554"></a>20554           largest = radius;
<a name="l20555"></a>20555         }
<a name="l20556"></a>20556       }
<a name="l20557"></a>20557     }
<a name="l20558"></a>20558   }
<a name="l20559"></a>20559 
<a name="l20560"></a>20560   <span class="comment">// Walk through all crossing faces.</span>
<a name="l20561"></a>20561   enextfnext(*searchtet, checkface);
<a name="l20562"></a>20562   sym(checkface, *searchtet);
<a name="l20563"></a>20563   <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l20564"></a>20564     <span class="comment">// Check if we are reaching the boundary of the triangulation.</span>
<a name="l20565"></a>20565 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20566"></a>20566 <span class="preprocessor"></span>    assert(searchtet-&gt;tet != dummytet);
<a name="l20567"></a>20567 <span class="preprocessor">#endif</span>
<a name="l20568"></a>20568 <span class="preprocessor"></span>    <span class="comment">// Search for an adjoining tetrahedron we can walk through.</span>
<a name="l20569"></a>20569     searchtet-&gt;ver = 0;
<a name="l20570"></a>20570     <span class="comment">// &#39;testpt&#39; is the shared vertex for the following orientation tests.</span>
<a name="l20571"></a>20571     testpt = oppo(*searchtet);
<a name="l20572"></a>20572     <span class="keywordflow">if</span> (testpt == tend) {
<a name="l20573"></a>20573       <span class="comment">// The searching is finished.</span>
<a name="l20574"></a>20574       <span class="keywordflow">break</span>;
<a name="l20575"></a>20575     } <span class="keywordflow">else</span> {
<a name="l20576"></a>20576       <span class="comment">// &#39;testpt&#39; may encroach the segment.</span>
<a name="l20577"></a>20577       <span class="keywordflow">if</span> ((testpt != tstart) &amp;&amp; (testpt != refpoint)) {
<a name="l20578"></a>20578         <span class="keywordflow">if</span> (isedgeencroached(tstart, tend, testpt, <span class="keyword">true</span>)) {
<a name="l20579"></a>20579           ncollinear = circumsphere(tstart, tend, testpt, NULL, cent, &amp;radius);
<a name="l20580"></a>20580           <span class="keywordflow">if</span> (!ncollinear) {
<a name="l20581"></a>20581             <span class="comment">// &#39;testpt&#39; is collinear with the segment. It may happen when a</span>
<a name="l20582"></a>20582             <span class="comment">//   set of collinear and continuous segments is defined by two</span>
<a name="l20583"></a>20583             <span class="comment">//   extreme endpoints.  In this case, we should choose &#39;testpt&#39;</span>
<a name="l20584"></a>20584             <span class="comment">//   as the splitting point immediately.  No new point should be</span>
<a name="l20585"></a>20585             <span class="comment">//   created.</span>
<a name="l20586"></a>20586             refpoint = testpt;
<a name="l20587"></a>20587             <span class="keywordflow">break</span>;
<a name="l20588"></a>20588           }
<a name="l20589"></a>20589           <span class="keywordflow">if</span> (refpoint == (point) NULL) {
<a name="l20590"></a>20590             refpoint = testpt;
<a name="l20591"></a>20591             largest = radius;
<a name="l20592"></a>20592           } <span class="keywordflow">else</span> {
<a name="l20593"></a>20593             <span class="keywordflow">if</span> (radius &gt; largest) {
<a name="l20594"></a>20594               refpoint = testpt;
<a name="l20595"></a>20595               largest = radius;
<a name="l20596"></a>20596             }
<a name="l20597"></a>20597           }
<a name="l20598"></a>20598         }
<a name="l20599"></a>20599       }
<a name="l20600"></a>20600     }
<a name="l20601"></a>20601     <span class="comment">// Check three side-faces of &#39;searchtet&#39; to find the one through</span>
<a name="l20602"></a>20602     <span class="comment">//   which we can walk next.</span>
<a name="l20603"></a>20603     <span class="keywordflow">for</span> (sides = 0; sides &lt; 3; sides++) {
<a name="l20604"></a>20604       fnext(*searchtet, checkface);
<a name="l20605"></a>20605       ahead = orient3d(org(checkface), dest(checkface), testpt, tend);
<a name="l20606"></a>20606       <span class="keywordflow">if</span> (ahead &lt; 0.0) {
<a name="l20607"></a>20607         <span class="comment">// We can walk through this face and continue the searching.</span>
<a name="l20608"></a>20608         sym(checkface, *searchtet);
<a name="l20609"></a>20609         <span class="keywordflow">break</span>;
<a name="l20610"></a>20610       }
<a name="l20611"></a>20611       enextself(*searchtet);
<a name="l20612"></a>20612     }
<a name="l20613"></a>20613 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20614"></a>20614 <span class="preprocessor"></span>    assert (sides &lt; 3);
<a name="l20615"></a>20615 <span class="preprocessor">#endif</span>
<a name="l20616"></a>20616 <span class="preprocessor"></span>  }
<a name="l20617"></a>20617 
<a name="l20618"></a>20618 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20619"></a>20619 <span class="preprocessor"></span>  assert(refpoint != (point) NULL);
<a name="l20620"></a>20620 <span class="preprocessor">#endif</span>
<a name="l20621"></a>20621 <span class="preprocessor"></span>  <span class="keywordflow">return</span> refpoint;
<a name="l20622"></a>20622 }
<a name="l20623"></a>20623 
<a name="l20625"></a>20625 <span class="comment">//                                                                           //</span>
<a name="l20626"></a>20626 <span class="comment">// getsegmentorigin()    Return the origin of the (unsplit) segment.         //</span>
<a name="l20627"></a>20627 <span class="comment">//                                                                           //</span>
<a name="l20628"></a>20628 <span class="comment">// After a segment (or a subsegment) is split. Two resulting subsegments are //</span>
<a name="l20629"></a>20629 <span class="comment">// connecting each other through the pointers saved in their data fields.    //</span>
<a name="l20630"></a>20630 <span class="comment">// With these pointers, the whole (unsplit) segment can be found. &#39;splitseg&#39; //</span>
<a name="l20631"></a>20631 <span class="comment">// may be a split subsegment.  Returns the origin of the unsplit segment.    //</span>
<a name="l20632"></a>20632 <span class="comment">//                                                                           //</span>
<a name="l20634"></a>20634 <span class="comment"></span>
<a name="l20635"></a>20635 tetgenmesh::point tetgenmesh::getsegmentorigin(face* splitseg)
<a name="l20636"></a>20636 {
<a name="l20637"></a>20637   face workseg;
<a name="l20638"></a>20638   point farorg;
<a name="l20639"></a>20639 
<a name="l20640"></a>20640   farorg = sorg(*splitseg);
<a name="l20641"></a>20641   <span class="keywordflow">if</span> ((pointtype(farorg) != ACUTEVERTEX) &amp;&amp;
<a name="l20642"></a>20642       (pointtype(farorg) != NACUTEVERTEX)) {
<a name="l20643"></a>20643     workseg = *splitseg;
<a name="l20644"></a>20644     <span class="keywordflow">do</span> {
<a name="l20645"></a>20645       senext2self(workseg);
<a name="l20646"></a>20646       spivotself(workseg);
<a name="l20647"></a>20647       <span class="keywordflow">if</span> (workseg.sh != dummysh) {
<a name="l20648"></a>20648         workseg.shver = 0;  <span class="comment">// It&#39;s a subsegment.</span>
<a name="l20649"></a>20649         <span class="keywordflow">if</span> (sdest(workseg) != farorg) {
<a name="l20650"></a>20650           sesymself(workseg);
<a name="l20651"></a>20651 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20652"></a>20652 <span class="preprocessor"></span>          assert(sdest(workseg) == farorg);
<a name="l20653"></a>20653 <span class="preprocessor">#endif</span>
<a name="l20654"></a>20654 <span class="preprocessor"></span>        }
<a name="l20655"></a>20655         farorg = sorg(workseg);
<a name="l20656"></a>20656         <span class="keywordflow">if</span> ((pointtype(farorg) == ACUTEVERTEX) ||
<a name="l20657"></a>20657             (pointtype(farorg) == NACUTEVERTEX)) <span class="keywordflow">break</span>;
<a name="l20658"></a>20658       }
<a name="l20659"></a>20659     } <span class="keywordflow">while</span> (workseg.sh != dummysh);
<a name="l20660"></a>20660   }
<a name="l20661"></a>20661 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20662"></a>20662 <span class="preprocessor"></span>  assert((pointtype(farorg) == ACUTEVERTEX) ||
<a name="l20663"></a>20663          (pointtype(farorg) == NACUTEVERTEX));
<a name="l20664"></a>20664 <span class="preprocessor">#endif</span>
<a name="l20665"></a>20665 <span class="preprocessor"></span>  <span class="keywordflow">return</span> farorg;
<a name="l20666"></a>20666 }
<a name="l20667"></a>20667 
<a name="l20669"></a>20669 <span class="comment">//                                                                           //</span>
<a name="l20670"></a>20670 <span class="comment">// getsplitpoint()    Get a point for splitting a segment.                   //</span>
<a name="l20671"></a>20671 <span class="comment">//                                                                           //</span>
<a name="l20672"></a>20672 <span class="comment">// &#39;splitseg&#39; is the segment will be split. &#39;refpoint&#39; is a reference point  //</span>
<a name="l20673"></a>20673 <span class="comment">// for splitting this segment. Moreover, it should not collinear with the    //</span>
<a name="l20674"></a>20674 <span class="comment">// splitting segment. (The collinear case will be detected by iscollinear()  //</span>
<a name="l20675"></a>20675 <span class="comment">// before entering this routine.)  The calculation of the splitting point is //</span>
<a name="l20676"></a>20676 <span class="comment">// governed by three rules introduced in my paper.                           //</span>
<a name="l20677"></a>20677 <span class="comment">//                                                                           //</span>
<a name="l20678"></a>20678 <span class="comment">// After the position is calculated, a new point is created at this location.//</span>
<a name="l20679"></a>20679 <span class="comment">// The new point has one of the two pointtypes: FREESEGVERTEX indicating it  //</span>
<a name="l20680"></a>20680 <span class="comment">// is an inserting vertex on segment, and NACUTEVERTEX indicating it is an   //</span>
<a name="l20681"></a>20681 <span class="comment">// endpoint of a segment which original has type-3 now becomes type-2.       //</span>
<a name="l20682"></a>20682 <span class="comment">//                                                                           //</span>
<a name="l20684"></a>20684 <span class="comment"></span>
<a name="l20685"></a>20685 tetgenmesh::point tetgenmesh::getsplitpoint(face* splitseg, point refpoint)
<a name="l20686"></a>20686 {
<a name="l20687"></a>20687   point splitpoint;
<a name="l20688"></a>20688   point farorg, fardest;
<a name="l20689"></a>20689   point ei, ej, ek, c;
<a name="l20690"></a>20690   REAL v[3], r, split;
<a name="l20691"></a>20691   REAL d1, d2, ps, rs;
<a name="l20692"></a>20692   <span class="keywordtype">bool</span> acuteorg, acutedest;
<a name="l20693"></a>20693   <span class="keywordtype">int</span> stype, rule;
<a name="l20694"></a>20694   <span class="keywordtype">int</span> i;
<a name="l20695"></a>20695 
<a name="l20696"></a>20696   <span class="comment">// First determine the type of the segment (type-1, type-2, or type-3).</span>
<a name="l20697"></a>20697   farorg = getsegmentorigin(splitseg);
<a name="l20698"></a>20698   acuteorg = (pointtype(farorg) == ACUTEVERTEX);
<a name="l20699"></a>20699   sesymself(*splitseg);
<a name="l20700"></a>20700   fardest = getsegmentorigin(splitseg);
<a name="l20701"></a>20701   acutedest = (pointtype(fardest) == ACUTEVERTEX);
<a name="l20702"></a>20702   sesymself(*splitseg);
<a name="l20703"></a>20703 
<a name="l20704"></a>20704   ek = (point) NULL; <span class="comment">// avoid a compilation warning.</span>
<a name="l20705"></a>20705 
<a name="l20706"></a>20706   <span class="keywordflow">if</span> (acuteorg) {
<a name="l20707"></a>20707     <span class="keywordflow">if</span> (acutedest) {
<a name="l20708"></a>20708       stype = 3;
<a name="l20709"></a>20709     } <span class="keywordflow">else</span> {
<a name="l20710"></a>20710       stype = 2;
<a name="l20711"></a>20711       ek = farorg;
<a name="l20712"></a>20712     }
<a name="l20713"></a>20713   } <span class="keywordflow">else</span> {
<a name="l20714"></a>20714     <span class="keywordflow">if</span> (acutedest) {
<a name="l20715"></a>20715       stype = 2;
<a name="l20716"></a>20716       <span class="comment">// Adjust splitseg, so that its origin is acute.</span>
<a name="l20717"></a>20717       sesymself(*splitseg);
<a name="l20718"></a>20718       ek = fardest;
<a name="l20719"></a>20719     } <span class="keywordflow">else</span> {
<a name="l20720"></a>20720       stype = 1;
<a name="l20721"></a>20721     }
<a name="l20722"></a>20722   }
<a name="l20723"></a>20723   ei = sorg(*splitseg);
<a name="l20724"></a>20724   ej = sdest(*splitseg);
<a name="l20725"></a>20725 
<a name="l20726"></a>20726   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l20727"></a>20727     printf(<span class="stringliteral">&quot;  Splitting segment (%d, %d) type-%d with refpoint %d.\n&quot;</span>,
<a name="l20728"></a>20728            pointmark(ei), pointmark(ej), stype, pointmark(refpoint));
<a name="l20729"></a>20729   }
<a name="l20730"></a>20730 
<a name="l20731"></a>20731   <span class="keywordflow">if</span> (stype == 1 || stype == 3) {
<a name="l20732"></a>20732     <span class="comment">// Use rule-1.</span>
<a name="l20733"></a>20733     REAL eij, eip, ejp;
<a name="l20734"></a>20734     eij = distance(ei, ej);
<a name="l20735"></a>20735     eip = distance(ei, refpoint);
<a name="l20736"></a>20736     ejp = distance(ej, refpoint);
<a name="l20737"></a>20737     <span class="keywordflow">if</span> ((eip &lt; ejp) &amp;&amp; (eip &lt; 0.5 * eij)) {
<a name="l20738"></a>20738       c = ei;
<a name="l20739"></a>20739       r = eip;
<a name="l20740"></a>20740     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((eip &gt; ejp) &amp;&amp; (ejp &lt; 0.5 * eij)) {
<a name="l20741"></a>20741       c = ej;
<a name="l20742"></a>20742       ej = ei;
<a name="l20743"></a>20743       r = ejp;
<a name="l20744"></a>20744     } <span class="keywordflow">else</span> {
<a name="l20745"></a>20745       c = ei;
<a name="l20746"></a>20746       r = 0.5 * eij;
<a name="l20747"></a>20747     }
<a name="l20748"></a>20748     split = r / eij;
<a name="l20749"></a>20749     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l20750"></a>20750       v[i] = c[i] + split * (ej[i] - c[i]);
<a name="l20751"></a>20751     }
<a name="l20752"></a>20752     rule = 1;
<a name="l20753"></a>20753   } <span class="keywordflow">else</span> {
<a name="l20754"></a>20754     <span class="comment">// Use rule-2 or rule-3.</span>
<a name="l20755"></a>20755     REAL eki, ekj, ekp, evj, evp, eiv;
<a name="l20756"></a>20756     c = ek;
<a name="l20757"></a>20757     eki = distance(ek, ei);  <span class="comment">// eki may equal zero.</span>
<a name="l20758"></a>20758     ekj = distance(ek, ej);
<a name="l20759"></a>20759     ekp = distance(ek, refpoint);
<a name="l20760"></a>20760     <span class="comment">// Calculate v (the going to split position between ei, ej).</span>
<a name="l20761"></a>20761     r = ekp;
<a name="l20762"></a>20762     <span class="comment">// Check the validity of the position.</span>
<a name="l20763"></a>20763     <span class="keywordflow">if</span> (!(eki &lt; r &amp;&amp; r &lt; ekj)) {
<a name="l20764"></a>20764       printf(<span class="stringliteral">&quot;Error:  Invalid PLC.\n&quot;</span>);
<a name="l20765"></a>20765       printf(<span class="stringliteral">&quot;  Hint:  Use -d switch to check it.\n&quot;</span>);
<a name="l20766"></a>20766       terminatetetgen(1);
<a name="l20767"></a>20767     }
<a name="l20768"></a>20768     split = r / ekj;
<a name="l20769"></a>20769     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l20770"></a>20770       v[i] = c[i] + split * (ej[i] - c[i]);
<a name="l20771"></a>20771     }
<a name="l20772"></a>20772     rule = 2;
<a name="l20773"></a>20773     evj = ekj - r; <span class="comment">// distance(v, ej);</span>
<a name="l20774"></a>20774     evp = distance(v, refpoint);
<a name="l20775"></a>20775     <span class="keywordflow">if</span> (evj &lt; evp) {
<a name="l20776"></a>20776       <span class="comment">// v is rejected, use rule-3.</span>
<a name="l20777"></a>20777       eiv = distance(ei, v);
<a name="l20778"></a>20778       <span class="keywordflow">if</span> (evp &lt;= 0.5 * eiv) {
<a name="l20779"></a>20779         r = eki + eiv - evp;
<a name="l20780"></a>20780       } <span class="keywordflow">else</span> {
<a name="l20781"></a>20781         r = eki + 0.5 * eiv;
<a name="l20782"></a>20782       }
<a name="l20783"></a>20783 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l20784"></a>20784 <span class="preprocessor"></span>      assert(eki &lt; r &amp;&amp; r &lt; ekj);
<a name="l20785"></a>20785 <span class="preprocessor">#endif</span>
<a name="l20786"></a>20786 <span class="preprocessor"></span>      split = r / ekj;
<a name="l20787"></a>20787       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l20788"></a>20788         v[i] = c[i] + split * (ej[i] - c[i]);
<a name="l20789"></a>20789       }
<a name="l20790"></a>20790       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l20791"></a>20791         printf(<span class="stringliteral">&quot;    Using rule-3.\n&quot;</span>);
<a name="l20792"></a>20792       }
<a name="l20793"></a>20793       rule = 3;
<a name="l20794"></a>20794     }
<a name="l20795"></a>20795   }
<a name="l20796"></a>20796 
<a name="l20797"></a>20797   <span class="comment">// Accumulate the corresponding counters.</span>
<a name="l20798"></a>20798   <span class="keywordflow">if</span> (rule == 1) r1count++;
<a name="l20799"></a>20799   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rule == 2) r2count++;
<a name="l20800"></a>20800   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rule == 3) r3count++;
<a name="l20801"></a>20801 
<a name="l20802"></a>20802   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l20803"></a>20803     <span class="keywordflow">if</span> (stype == 2) {
<a name="l20804"></a>20804       printf(<span class="stringliteral">&quot;    Split = %.12g.\n&quot;</span>, distance(ei, v) / distance(ei, ej));
<a name="l20805"></a>20805     } <span class="keywordflow">else</span> {
<a name="l20806"></a>20806       printf(<span class="stringliteral">&quot;    Split = %.12g.\n&quot;</span>, distance(c, v) / distance(c, ej));
<a name="l20807"></a>20807     }
<a name="l20808"></a>20808   }
<a name="l20809"></a>20809 
<a name="l20810"></a>20810   <span class="comment">// Create the newpoint.</span>
<a name="l20811"></a>20811   makepoint(&amp;splitpoint);
<a name="l20812"></a>20812   <span class="comment">// Add a random perturbation on splitpoint.</span>
<a name="l20813"></a>20813   d1 = distance(c, v);
<a name="l20814"></a>20814   d2 = distance(refpoint, v);
<a name="l20815"></a>20815   <span class="keywordflow">if</span> (stype == 1 || stype == 3) {
<a name="l20816"></a>20816     ps = randgenerator(d1 * 1.0e-3);
<a name="l20817"></a>20817   } <span class="keywordflow">else</span> {
<a name="l20818"></a>20818     <span class="comment">// For type-2 segment, add a smaller perturbation.</span>
<a name="l20819"></a>20819     <span class="comment">// ps = randgenerator(d1 * 1.0e-5);</span>
<a name="l20820"></a>20820     <span class="comment">// REAL d2 = distance(refpoint, v);</span>
<a name="l20821"></a>20821     ps = randgenerator(d2 * 1.0e-5);
<a name="l20822"></a>20822   }
<a name="l20823"></a>20823   rs = ps / d1;
<a name="l20824"></a>20824   <span class="comment">// Perturb splitpoint away from c.</span>
<a name="l20825"></a>20825   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l20826"></a>20826     splitpoint[i] = c[i] + (1.0 + rs) * (v[i] - c[i]);
<a name="l20827"></a>20827   }
<a name="l20828"></a>20828   <span class="comment">// for (i = 0; i &lt; in-&gt;numberofpointattributes; i++) {</span>
<a name="l20829"></a>20829   <span class="comment">//   splitpoint[i + 3] = c[i + 3] + (split + rs) * (ej[i + 3] - c[i + 3]);</span>
<a name="l20830"></a>20830   <span class="comment">// }</span>
<a name="l20831"></a>20831   <span class="keywordflow">if</span> (stype == 3) {
<a name="l20832"></a>20832     <span class="comment">// Change a type-3 segment into two type-2 segments.</span>
<a name="l20833"></a>20833     setpointtype(splitpoint, NACUTEVERTEX);
<a name="l20834"></a>20834   } <span class="keywordflow">else</span> {
<a name="l20835"></a>20835     <span class="comment">// Set it&#39;s type be FREESEGVERTEX.</span>
<a name="l20836"></a>20836     setpointtype(splitpoint, FREESEGVERTEX);
<a name="l20837"></a>20837   }
<a name="l20838"></a>20838   setpoint2sh(splitpoint, sencode(*splitseg));
<a name="l20839"></a>20839 
<a name="l20840"></a>20840   <span class="keywordflow">return</span> splitpoint;
<a name="l20841"></a>20841 }
<a name="l20842"></a>20842 
<a name="l20844"></a>20844 <span class="comment">//                                                                           //</span>
<a name="l20845"></a>20845 <span class="comment">// insertsegment()    Insert segment into DT. Queue it if it does not exist. //</span>
<a name="l20846"></a>20846 <span class="comment">//                                                                           //</span>
<a name="l20848"></a>20848 <span class="comment"></span>
<a name="l20849"></a>20849 <span class="keywordtype">bool</span> tetgenmesh::insertsegment(face *insseg, list *misseglist)
<a name="l20850"></a>20850 {
<a name="l20851"></a>20851   badface *misseg;
<a name="l20852"></a>20852   triface searchtet, spintet;
<a name="l20853"></a>20853   point tend, checkpoint;
<a name="l20854"></a>20854   point p1, p2;
<a name="l20855"></a>20855   <span class="keyword">enum</span> finddirectionresult collinear;
<a name="l20856"></a>20856   <span class="keywordtype">int</span> hitbdry;
<a name="l20857"></a>20857 
<a name="l20858"></a>20858   <span class="comment">// Search segment ab in DT.</span>
<a name="l20859"></a>20859   p1 = (point) insseg-&gt;sh[3];
<a name="l20860"></a>20860   p2 = (point) insseg-&gt;sh[4];
<a name="l20861"></a>20861   getsearchtet(p1, p2, &amp;searchtet, &amp;tend);
<a name="l20862"></a>20862   collinear = finddirection(&amp;searchtet, tend, tetrahedrons-&gt;items);
<a name="l20863"></a>20863   <span class="keywordflow">if</span> (collinear == LEFTCOLLINEAR) {
<a name="l20864"></a>20864     checkpoint = apex(searchtet);
<a name="l20865"></a>20865     enext2self(searchtet);
<a name="l20866"></a>20866     esymself(searchtet);
<a name="l20867"></a>20867   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == RIGHTCOLLINEAR) {
<a name="l20868"></a>20868     checkpoint = dest(searchtet);
<a name="l20869"></a>20869   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == TOPCOLLINEAR) {
<a name="l20870"></a>20870     checkpoint = oppo(searchtet);
<a name="l20871"></a>20871     fnextself(searchtet);
<a name="l20872"></a>20872     enext2self(searchtet);
<a name="l20873"></a>20873     esymself(searchtet);
<a name="l20874"></a>20874   } <span class="keywordflow">else</span> {
<a name="l20875"></a>20875     <span class="comment">// assert(collinear == ACROSSFACE || collinear == ACROSSEDGE);</span>
<a name="l20876"></a>20876     checkpoint = (point) NULL;
<a name="l20877"></a>20877   }
<a name="l20878"></a>20878   <span class="keywordflow">if</span> (checkpoint == tend) {
<a name="l20879"></a>20879     <span class="comment">// Segment exist. Bond it to all tets containing it.</span>
<a name="l20880"></a>20880     hitbdry = 0;
<a name="l20881"></a>20881     adjustedgering(searchtet, CCW);
<a name="l20882"></a>20882     fnextself(searchtet);
<a name="l20883"></a>20883     spintet = searchtet;
<a name="l20884"></a>20884     <span class="keywordflow">do</span> {
<a name="l20885"></a>20885       tssbond1(spintet, *insseg);
<a name="l20886"></a>20886       <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l20887"></a>20887         hitbdry++;
<a name="l20888"></a>20888         <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l20889"></a>20889           esym(searchtet, spintet);
<a name="l20890"></a>20890           <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l20891"></a>20891             hitbdry++;
<a name="l20892"></a>20892           }
<a name="l20893"></a>20893         }
<a name="l20894"></a>20894       }
<a name="l20895"></a>20895     } <span class="keywordflow">while</span> ((apex(spintet) != apex(searchtet)) &amp;&amp; (hitbdry &lt; 2));
<a name="l20896"></a>20896     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l20897"></a>20897   } <span class="keywordflow">else</span> {
<a name="l20898"></a>20898     <span class="comment">// Segment is missing.</span>
<a name="l20899"></a>20899     <span class="keywordflow">if</span> (misseglist != (list *) NULL) {
<a name="l20900"></a>20900       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l20901"></a>20901         printf(<span class="stringliteral">&quot;    Queuing missing segment (%d, %d).\n&quot;</span>, pointmark(p1),
<a name="l20902"></a>20902                pointmark(p2));
<a name="l20903"></a>20903       }
<a name="l20904"></a>20904       misseg = (badface *) misseglist-&gt;append(NULL);
<a name="l20905"></a>20905       misseg-&gt;ss = *insseg;
<a name="l20906"></a>20906       misseg-&gt;forg = p1;
<a name="l20907"></a>20907       misseg-&gt;fdest = p2;
<a name="l20908"></a>20908       misseg-&gt;foppo = (point) NULL; <span class="comment">// Not used.</span>
<a name="l20909"></a>20909       <span class="comment">// setshell2badface(misseg-&gt;ss, misseg);</span>
<a name="l20910"></a>20910     }
<a name="l20911"></a>20911     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l20912"></a>20912   }
<a name="l20913"></a>20913 }
<a name="l20914"></a>20914 
<a name="l20916"></a>20916 <span class="comment">//                                                                           //</span>
<a name="l20917"></a>20917 <span class="comment">// tallmissegs()    Find and queue all missing segments in DT.               //</span>
<a name="l20918"></a>20918 <span class="comment">//                                                                           //</span>
<a name="l20920"></a>20920 <span class="comment"></span>
<a name="l20921"></a>20921 <span class="keywordtype">void</span> tetgenmesh::tallmissegs(list *misseglist)
<a name="l20922"></a>20922 {
<a name="l20923"></a>20923   face segloop;
<a name="l20924"></a>20924 
<a name="l20925"></a>20925   <span class="keywordflow">if</span> (b-&gt;verbose) {
<a name="l20926"></a>20926     printf(<span class="stringliteral">&quot;  Queuing missing segments.\n&quot;</span>);
<a name="l20927"></a>20927   }
<a name="l20928"></a>20928 
<a name="l20929"></a>20929   subsegs-&gt;traversalinit();
<a name="l20930"></a>20930   segloop.sh = shellfacetraverse(subsegs);
<a name="l20931"></a>20931   <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l20932"></a>20932     insertsegment(&amp;segloop, misseglist);
<a name="l20933"></a>20933     segloop.sh = shellfacetraverse(subsegs);
<a name="l20934"></a>20934   }
<a name="l20935"></a>20935 }
<a name="l20936"></a>20936 
<a name="l20938"></a>20938 <span class="comment">//                                                                           //</span>
<a name="l20939"></a>20939 <span class="comment">// delaunizesegments()    Split segments repeatedly until they appear in a   //</span>
<a name="l20940"></a>20940 <span class="comment">//                        Delaunay tetrahedralization.                       //</span>
<a name="l20941"></a>20941 <span class="comment">//                                                                           //</span>
<a name="l20942"></a>20942 <span class="comment">// Given a PLC X, which has a set V of vertices and a set of segments. Start //</span>
<a name="l20943"></a>20943 <span class="comment">// from a Delaunay tetrahedralization D of V, this routine recovers segments //</span>
<a name="l20944"></a>20944 <span class="comment">// of X in D by incrementally inserting points on missing segments, updating //</span>
<a name="l20945"></a>20945 <span class="comment">// D with the newly inserted points into D&#39;, which remains to be a Delaunay  //</span>
<a name="l20946"></a>20946 <span class="comment">// tetrahedralization and respects the segments of X. Hence, each segment of //</span>
<a name="l20947"></a>20947 <span class="comment">// X appears as a union of edges in D&#39;.                                      //</span>
<a name="l20948"></a>20948 <span class="comment">//                                                                           //</span>
<a name="l20949"></a>20949 <span class="comment">// This routine dynamically maintains two meshes, one is DT, another is the  //</span>
<a name="l20950"></a>20950 <span class="comment">// surface mesh F of X.  DT and F have exactly the same vertices.  They are  //</span>
<a name="l20951"></a>20951 <span class="comment">// updated simultaneously with the newly inserted points.                    //</span>
<a name="l20952"></a>20952 <span class="comment">//                                                                           //</span>
<a name="l20953"></a>20953 <span class="comment">// Missing segments are found by looping the set S of segments, checking the //</span>
<a name="l20954"></a>20954 <span class="comment">// existence of each segment in DT.  Once a segment is found missing in DT,  //</span>
<a name="l20955"></a>20955 <span class="comment">// it is split into two subsegments by inserting a point into both DT and F, //</span>
<a name="l20956"></a>20956 <span class="comment">// and S is updated accordingly.  However, the inserted point may cause some //</span>
<a name="l20957"></a>20957 <span class="comment">// other existing segments be non-Delaunay,  hence are missing from the DT.  //</span>
<a name="l20958"></a>20958 <span class="comment">// In order to force all segments to appear in DT, we have to loop S again   //</span>
<a name="l20959"></a>20959 <span class="comment">// after some segments are split. (A little ugly method)  Use a handle to    //</span>
<a name="l20960"></a>20960 <span class="comment">// remember the last segment be split in one loop, hence all segments after  //</span>
<a name="l20961"></a>20961 <span class="comment">// it are existing and need not be checked.                                  //</span>
<a name="l20962"></a>20962 <span class="comment">//                                                                           //</span>
<a name="l20963"></a>20963 <span class="comment">// In priciple, a segment on the convex hull should exist in DT. However, if //</span>
<a name="l20964"></a>20964 <span class="comment">// there are four coplanar points on the convex hull, and the DT only can    //</span>
<a name="l20965"></a>20965 <span class="comment">// contain one diagonal edge which is unfortunately not the segment, then it //</span>
<a name="l20966"></a>20966 <span class="comment">// is missing. During the recovery of the segment, it is possible that the   //</span>
<a name="l20967"></a>20967 <span class="comment">// calculated inserting point for recovering this convex hull segment is not //</span>
<a name="l20968"></a>20968 <span class="comment">// exact enough and lies (slightly) outside the DT. In order to insert the   //</span>
<a name="l20969"></a>20969 <span class="comment">// point, we enlarge the convex hull of the DT, so it can contain the point  //</span>
<a name="l20970"></a>20970 <span class="comment">// and remains convex.  &#39;inserthullsite()&#39; is called for this case.          //</span>
<a name="l20971"></a>20971 <span class="comment">//                                                                           //</span>
<a name="l20973"></a>20973 <span class="comment"></span>
<a name="l20974"></a>20974 <span class="keywordtype">void</span> tetgenmesh::delaunizesegments()
<a name="l20975"></a>20975 {
<a name="l20976"></a>20976   list *misseglist;
<a name="l20977"></a>20977   queue *flipqueue;
<a name="l20978"></a>20978   badface *misloop;
<a name="l20979"></a>20979   tetrahedron encodedtet;
<a name="l20980"></a>20980   triface searchtet, splittet;
<a name="l20981"></a>20981   face splitsh, symsplitsub;
<a name="l20982"></a>20982   face segloop, symsplitseg;
<a name="l20983"></a>20983   point refpoint, splitpoint, sympoint;
<a name="l20984"></a>20984   point tend, checkpoint;
<a name="l20985"></a>20985   point p1, p2, pa;
<a name="l20986"></a>20986   <span class="keyword">enum</span> finddirectionresult collinear;
<a name="l20987"></a>20987   <span class="keyword">enum</span> insertsiteresult success;
<a name="l20988"></a>20988   <span class="keyword">enum</span> locateresult symloc;
<a name="l20989"></a>20989   <span class="keywordtype">bool</span> coll;
<a name="l20990"></a>20990   <span class="keywordtype">long</span> vertcount;
<a name="l20991"></a>20991   <span class="keywordtype">int</span> i, j;
<a name="l20992"></a>20992 
<a name="l20993"></a>20993   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l20994"></a>20994     printf(<span class="stringliteral">&quot;Delaunizing segments.\n&quot;</span>);
<a name="l20995"></a>20995   }
<a name="l20996"></a>20996 
<a name="l20997"></a>20997   <span class="comment">// Construct a map from points to tets for speeding point location.</span>
<a name="l20998"></a>20998   makepoint2tetmap();
<a name="l20999"></a>20999   <span class="comment">// Initialize a flipqueue.</span>
<a name="l21000"></a>21000   flipqueue = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l21001"></a>21001   <span class="comment">// Initialize the pool of missing segments.</span>
<a name="l21002"></a>21002   misseglist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(badface), NULL, SUBPERBLOCK);
<a name="l21003"></a>21003   <span class="comment">// Looking for missing segments.</span>
<a name="l21004"></a>21004   tallmissegs(misseglist);
<a name="l21005"></a>21005   <span class="comment">// The DT contains segments now.</span>
<a name="l21006"></a>21006   checksubsegs = 1;
<a name="l21007"></a>21007   <span class="comment">// Remember the current number of points.</span>
<a name="l21008"></a>21008   vertcount = points-&gt;items;
<a name="l21009"></a>21009   <span class="comment">// Initialize the counters.</span>
<a name="l21010"></a>21010   r1count = r2count = r3count = 0l;
<a name="l21011"></a>21011 
<a name="l21012"></a>21012   <span class="comment">// Loop until &#39;misseglist&#39; is empty.</span>
<a name="l21013"></a>21013   <span class="keywordflow">while</span> (misseglist-&gt;items &gt; 0) {
<a name="l21014"></a>21014     <span class="comment">// Randomly pick a missing segment to recover.</span>
<a name="l21015"></a>21015     i = randomnation(misseglist-&gt;items);
<a name="l21016"></a>21016     misloop = (badface *)(* misseglist)[i];
<a name="l21017"></a>21017     segloop = misloop-&gt;ss;
<a name="l21018"></a>21018     <span class="comment">// Fill the &quot;hole&quot; in the list by filling the last one.</span>
<a name="l21019"></a>21019     *misloop = *(badface *)(* misseglist)[misseglist-&gt;items - 1];
<a name="l21020"></a>21020     misseglist-&gt;items--;
<a name="l21021"></a>21021     <span class="comment">// Now recover the segment.</span>
<a name="l21022"></a>21022       p1 = (point) segloop.sh[3];
<a name="l21023"></a>21023       p2 = (point) segloop.sh[4];
<a name="l21024"></a>21024       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l21025"></a>21025         printf(<span class="stringliteral">&quot;  Recover segment (%d, %d).\n&quot;</span>, pointmark(p1), pointmark(p2));
<a name="l21026"></a>21026       }
<a name="l21027"></a>21027       getsearchtet(p1, p2, &amp;searchtet, &amp;tend);
<a name="l21028"></a>21028       collinear = finddirection(&amp;searchtet, tend, tetrahedrons-&gt;items);
<a name="l21029"></a>21029       <span class="keywordflow">if</span> (collinear == LEFTCOLLINEAR) {
<a name="l21030"></a>21030         checkpoint = apex(searchtet);
<a name="l21031"></a>21031       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == RIGHTCOLLINEAR) {
<a name="l21032"></a>21032         checkpoint = dest(searchtet);
<a name="l21033"></a>21033       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == TOPCOLLINEAR) {
<a name="l21034"></a>21034         checkpoint = oppo(searchtet);
<a name="l21035"></a>21035       } <span class="keywordflow">else</span> {
<a name="l21036"></a>21036 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l21037"></a>21037 <span class="preprocessor"></span>        assert(collinear == ACROSSFACE || collinear == ACROSSEDGE);
<a name="l21038"></a>21038 <span class="preprocessor">#endif</span>
<a name="l21039"></a>21039 <span class="preprocessor"></span>        checkpoint = (point) NULL;
<a name="l21040"></a>21040       }
<a name="l21041"></a>21041       <span class="keywordflow">if</span> (checkpoint != tend) {
<a name="l21042"></a>21042         <span class="comment">// ab is missing.</span>
<a name="l21043"></a>21043         splitpoint = (point) NULL;
<a name="l21044"></a>21044         <span class="keywordflow">if</span> (checkpoint != (point) NULL) {
<a name="l21045"></a>21045           <span class="comment">// An existing point c is found on the segment. It can happen when</span>
<a name="l21046"></a>21046           <span class="comment">//   ab is defined by a long segment with c inside it. Use c to</span>
<a name="l21047"></a>21047           <span class="comment">//   split ab. No new point is created.</span>
<a name="l21048"></a>21048           splitpoint = checkpoint;
<a name="l21049"></a>21049           <span class="keywordflow">if</span> (pointtype(checkpoint) == FREEVOLVERTEX) {
<a name="l21050"></a>21050             <span class="comment">// c is not a segment vertex yet. It becomes NACUTEVERTEX.</span>
<a name="l21051"></a>21051             setpointtype(splitpoint, NACUTEVERTEX);
<a name="l21052"></a>21052           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pointtype(checkpoint) == ACUTEVERTEX) {
<a name="l21053"></a>21053             <span class="comment">// c is an acute vertex. The definition of PLC is wrong.</span>
<a name="l21054"></a>21054           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pointtype(checkpoint) == NACUTEVERTEX) {
<a name="l21055"></a>21055             <span class="comment">// c is an nonacute vertex. The definition of PLC is wrong.</span>
<a name="l21056"></a>21056           } <span class="keywordflow">else</span> {
<a name="l21057"></a>21057             <span class="comment">// assert(0);</span>
<a name="l21058"></a>21058           }
<a name="l21059"></a>21059         } <span class="keywordflow">else</span> {
<a name="l21060"></a>21060           <span class="comment">// Find a reference point p of ab.</span>
<a name="l21061"></a>21061           refpoint = scoutrefpoint(&amp;searchtet, tend);
<a name="l21062"></a>21062           <span class="keywordflow">if</span> (pointtype(refpoint) == FREEVOLVERTEX) {
<a name="l21063"></a>21063             <span class="comment">// p is an input point, check if it is nearly collinear with ab.</span>
<a name="l21064"></a>21064             coll = iscollinear(p1, p2, refpoint, b-&gt;epsilon);
<a name="l21065"></a>21065             <span class="keywordflow">if</span> (coll) {
<a name="l21066"></a>21066               <span class="comment">// a, b, and p are collinear. We insert p into ab. p becomes</span>
<a name="l21067"></a>21067               <span class="comment">//   a segment vertex with type NACUTEVERTEX.</span>
<a name="l21068"></a>21068               splitpoint = refpoint;
<a name="l21069"></a>21069               setpointtype(splitpoint, NACUTEVERTEX);
<a name="l21070"></a>21070             }
<a name="l21071"></a>21071           }
<a name="l21072"></a>21072           <span class="keywordflow">if</span> (splitpoint == (point) NULL) {
<a name="l21073"></a>21073             <span class="comment">// Calculate a split point v using rule 1, or 2, or 3.</span>
<a name="l21074"></a>21074             splitpoint = getsplitpoint(&amp;segloop, refpoint);
<a name="l21075"></a>21075 
<a name="l21076"></a>21076             <span class="comment">// Is there periodic boundary conditions?</span>
<a name="l21077"></a>21077             <span class="keywordflow">if</span> (checkpbcs) {
<a name="l21078"></a>21078               <span class="comment">// Yes! Insert points on other segments of incident pbcgroups.</span>
<a name="l21079"></a>21079               i = shellmark(segloop) - 1;
<a name="l21080"></a>21080               <span class="keywordflow">for</span> (j = idx2segpglist[i]; j &lt; idx2segpglist[i + 1]; j++) {
<a name="l21081"></a>21081                 makepoint(&amp;sympoint);
<a name="l21082"></a>21082                 symloc = getsegpbcsympoint(splitpoint, &amp;segloop, sympoint,
<a name="l21083"></a>21083                                            &amp;symsplitseg, segpglist[j]);
<a name="l21084"></a>21084 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l21085"></a>21085 <span class="preprocessor"></span>                assert(symloc != OUTSIDE);
<a name="l21086"></a>21086 <span class="preprocessor">#endif</span>
<a name="l21087"></a>21087 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ((symloc == ONEDGE) &amp;&amp; (symsplitseg.sh != segloop.sh)) {
<a name="l21088"></a>21088 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l21089"></a>21089 <span class="preprocessor"></span>                  assert(symsplitseg.sh != dummysh);
<a name="l21090"></a>21090 <span class="preprocessor">#endif</span>
<a name="l21091"></a>21091 <span class="preprocessor"></span>                  setpointtype(sympoint, FREESEGVERTEX);
<a name="l21092"></a>21092                   setpoint2sh(sympoint, sencode(symsplitseg));
<a name="l21093"></a>21093                   <span class="comment">// Insert sympoint into DT.</span>
<a name="l21094"></a>21094                   pa = sorg(symsplitseg);
<a name="l21095"></a>21095                   splittet.tet = dummytet;
<a name="l21096"></a>21096                   <span class="comment">// Find a good start point to search.</span>
<a name="l21097"></a>21097                   encodedtet = point2tet(pa);
<a name="l21098"></a>21098                   <span class="keywordflow">if</span> (encodedtet != (tetrahedron) NULL) {
<a name="l21099"></a>21099                     decode(encodedtet, splittet);
<a name="l21100"></a>21100                     <span class="keywordflow">if</span> (isdead(&amp;splittet)) {
<a name="l21101"></a>21101                       splittet.tet = dummytet;
<a name="l21102"></a>21102                     }
<a name="l21103"></a>21103                   }
<a name="l21104"></a>21104                   <span class="comment">// Locate sympoint in DT.  Do exact location.</span>
<a name="l21105"></a>21105                   success = insertsite(sympoint, &amp;splittet, <span class="keyword">false</span>, flipqueue);
<a name="l21106"></a>21106 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l21107"></a>21107 <span class="preprocessor"></span>                  assert(success != DUPLICATEPOINT);
<a name="l21108"></a>21108 <span class="preprocessor">#endif</span>
<a name="l21109"></a>21109 <span class="preprocessor"></span>                  <span class="keywordflow">if</span> (success == OUTSIDEPOINT) {
<a name="l21110"></a>21110                     inserthullsite(sympoint, &amp;splittet, flipqueue);
<a name="l21111"></a>21111                   }
<a name="l21112"></a>21112                   <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l21113"></a>21113                   <span class="comment">// Let sympoint remember splittet.</span>
<a name="l21114"></a>21114                   setpoint2tet(sympoint, encode(splittet));
<a name="l21115"></a>21115                   <span class="comment">// Do flip in DT.</span>
<a name="l21116"></a>21116                   lawson(misseglist, flipqueue);
<a name="l21117"></a>21117                   <span class="comment">// Insert sympoint into F.</span>
<a name="l21118"></a>21118                   symsplitseg.shver = 0;
<a name="l21119"></a>21119                   spivot(symsplitseg, symsplitsub);
<a name="l21120"></a>21120                   <span class="comment">// sympoint should on the edge of symsplitsub.</span>
<a name="l21121"></a>21121                   splitsubedge(sympoint, &amp;symsplitsub, flipqueue);
<a name="l21122"></a>21122                   <span class="comment">// Do flip in facet.</span>
<a name="l21123"></a>21123                   flipsub(flipqueue);
<a name="l21124"></a>21124                   <span class="comment">// Insert the two subsegments.</span>
<a name="l21125"></a>21125                   symsplitseg.shver = 0;
<a name="l21126"></a>21126                   insertsegment(&amp;symsplitseg, misseglist);
<a name="l21127"></a>21127                   senextself(symsplitseg);
<a name="l21128"></a>21128                   spivotself(symsplitseg);
<a name="l21129"></a>21129                   symsplitseg.shver = 0;
<a name="l21130"></a>21130                   insertsegment(&amp;symsplitseg, misseglist);
<a name="l21131"></a>21131                 } <span class="keywordflow">else</span> { <span class="comment">// if (symloc == ONVERTEX) {</span>
<a name="l21132"></a>21132                   <span class="comment">// The sympoint already exists. It is possible when two</span>
<a name="l21133"></a>21133                   <span class="comment">//   pbc groups are exactly the same. Omit this point.</span>
<a name="l21134"></a>21134                   pointdealloc(sympoint);
<a name="l21135"></a>21135                 }
<a name="l21136"></a>21136               }
<a name="l21137"></a>21137             }
<a name="l21138"></a>21138 
<a name="l21139"></a>21139             <span class="comment">// Insert &#39;splitpoint&#39; into DT.</span>
<a name="l21140"></a>21140             <span class="keywordflow">if</span> (isdead(&amp;searchtet)) searchtet.tet = dummytet;
<a name="l21141"></a>21141             success = insertsite(splitpoint, &amp;searchtet, <span class="keyword">false</span>, flipqueue);
<a name="l21142"></a>21142             <span class="keywordflow">if</span> (success == OUTSIDEPOINT) {
<a name="l21143"></a>21143               <span class="comment">// A convex hull edge is missing, and the inserting point lies</span>
<a name="l21144"></a>21144               <span class="comment">//   (slightly) outside the convex hull due to the significant</span>
<a name="l21145"></a>21145               <span class="comment">//   digits lost in the calculation. Enlarge the convex hull.</span>
<a name="l21146"></a>21146               inserthullsite(splitpoint, &amp;searchtet, flipqueue);
<a name="l21147"></a>21147             }
<a name="l21148"></a>21148             <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l21149"></a>21149             <span class="comment">// Remember a handle in &#39;splitpoint&#39; to enhance the speed of</span>
<a name="l21150"></a>21150             <span class="comment">//   consequent point location.</span>
<a name="l21151"></a>21151             setpoint2tet(splitpoint, encode(searchtet));
<a name="l21152"></a>21152             <span class="comment">// Maintain Delaunayness in DT.</span>
<a name="l21153"></a>21153             lawson(misseglist, flipqueue);
<a name="l21154"></a>21154           }
<a name="l21155"></a>21155         }
<a name="l21156"></a>21156         <span class="comment">// Insert &#39;splitpoint&#39; into F.</span>
<a name="l21157"></a>21157         spivot(segloop, splitsh);
<a name="l21158"></a>21158         splitsubedge(splitpoint, &amp;splitsh, flipqueue);
<a name="l21159"></a>21159         flipsub(flipqueue);
<a name="l21160"></a>21160         <span class="comment">// Insert the two subsegments.</span>
<a name="l21161"></a>21161         segloop.shver = 0;
<a name="l21162"></a>21162         insertsegment(&amp;segloop, misseglist);
<a name="l21163"></a>21163         senextself(segloop);
<a name="l21164"></a>21164         spivotself(segloop);
<a name="l21165"></a>21165         segloop.shver = 0;
<a name="l21166"></a>21166         insertsegment(&amp;segloop, misseglist);
<a name="l21167"></a>21167       }
<a name="l21168"></a>21168   }
<a name="l21169"></a>21169 
<a name="l21170"></a>21170   <span class="comment">// Detach all segments from tets.</span>
<a name="l21171"></a>21171   tetrahedrons-&gt;traversalinit();
<a name="l21172"></a>21172   searchtet.tet = tetrahedrontraverse();
<a name="l21173"></a>21173   <span class="keywordflow">while</span> (searchtet.tet != (tetrahedron *) NULL) {
<a name="l21174"></a>21174     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l21175"></a>21175       searchtet.tet[8 + i] = (tetrahedron) dummysh;
<a name="l21176"></a>21176     }
<a name="l21177"></a>21177     searchtet.tet = tetrahedrontraverse();
<a name="l21178"></a>21178   }
<a name="l21179"></a>21179   <span class="comment">// No segments now.</span>
<a name="l21180"></a>21180   checksubsegs = 0;
<a name="l21181"></a>21181 
<a name="l21182"></a>21182   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l21183"></a>21183     printf(<span class="stringliteral">&quot;  %ld protect points.\n&quot;</span>, points-&gt;items - vertcount);
<a name="l21184"></a>21184     printf(<span class="stringliteral">&quot;  R1: %ld,  R2: %ld,  R3: %ld.\n&quot;</span>, r1count, r2count, r3count);
<a name="l21185"></a>21185   }
<a name="l21186"></a>21186 
<a name="l21187"></a>21187   <span class="keyword">delete</span> flipqueue;
<a name="l21188"></a>21188   <span class="keyword">delete</span> misseglist;
<a name="l21189"></a>21189 }
<a name="l21190"></a>21190 
<a name="l21191"></a>21191 <span class="comment">//</span>
<a name="l21192"></a>21192 <span class="comment">// End of segments recovery routines</span>
<a name="l21193"></a>21193 <span class="comment">//</span>
<a name="l21194"></a>21194 
<a name="l21195"></a>21195 <span class="comment">//</span>
<a name="l21196"></a>21196 <span class="comment">// Begin of facet recovery routines</span>
<a name="l21197"></a>21197 <span class="comment">//</span>
<a name="l21198"></a>21198 
<a name="l21200"></a>21200 <span class="comment">//                                                                           //</span>
<a name="l21201"></a>21201 <span class="comment">// insertsubface()    Fix a subface in place.                                //</span>
<a name="l21202"></a>21202 <span class="comment">//                                                                           //</span>
<a name="l21203"></a>21203 <span class="comment">// Search a subface s in current tetrahedralization T.  If s is found a face //</span>
<a name="l21204"></a>21204 <span class="comment">// face of T, it is inserted into T.  Return FALSE if s is not found in T.   //</span>
<a name="l21205"></a>21205 <span class="comment">//                                                                           //</span>
<a name="l21207"></a>21207 <span class="comment"></span>
<a name="l21208"></a>21208 <span class="keywordtype">bool</span> tetgenmesh::insertsubface(face* insertsh, triface* searchtet)
<a name="l21209"></a>21209 {
<a name="l21210"></a>21210   triface spintet, symtet;
<a name="l21211"></a>21211   face testsh, testseg;
<a name="l21212"></a>21212   face spinsh, casin, casout;
<a name="l21213"></a>21213   point tapex, checkpoint;
<a name="l21214"></a>21214   <span class="keyword">enum</span> finddirectionresult collinear;
<a name="l21215"></a>21215   <span class="keywordtype">int</span> hitbdry;
<a name="l21216"></a>21216 
<a name="l21217"></a>21217   <span class="comment">// Search an edge of s.</span>
<a name="l21218"></a>21218   getsearchtet(sorg(*insertsh), sdest(*insertsh), searchtet, &amp;checkpoint);
<a name="l21219"></a>21219   collinear = finddirection(searchtet, checkpoint, tetrahedrons-&gt;items);
<a name="l21220"></a>21220   <span class="keywordflow">if</span> (collinear == LEFTCOLLINEAR) {
<a name="l21221"></a>21221     enext2self(*searchtet);
<a name="l21222"></a>21222     esymself(*searchtet);
<a name="l21223"></a>21223   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == TOPCOLLINEAR) {
<a name="l21224"></a>21224     fnextself(*searchtet);
<a name="l21225"></a>21225     enext2self(*searchtet);
<a name="l21226"></a>21226     esymself(*searchtet);
<a name="l21227"></a>21227   }
<a name="l21228"></a>21228   <span class="keywordflow">if</span> (dest(*searchtet) != checkpoint) {
<a name="l21229"></a>21229     <span class="comment">// The edge doesn&#39;t exist =&gt; s is missing.</span>
<a name="l21230"></a>21230     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l21231"></a>21231   }
<a name="l21232"></a>21232 
<a name="l21233"></a>21233   <span class="comment">// Search s by spinning faces around the edge.</span>
<a name="l21234"></a>21234   tapex = sapex(*insertsh);
<a name="l21235"></a>21235   spintet = *searchtet;
<a name="l21236"></a>21236   hitbdry = 0;
<a name="l21237"></a>21237   <span class="keywordflow">do</span> {
<a name="l21238"></a>21238     <span class="keywordflow">if</span> (apex(spintet) == tapex) {
<a name="l21239"></a>21239       <span class="comment">// Found s in T. Check if s has already been inserted.</span>
<a name="l21240"></a>21240       tspivot(spintet, testsh);
<a name="l21241"></a>21241       <span class="keywordflow">if</span> (testsh.sh == dummysh) {
<a name="l21242"></a>21242         adjustedgering(spintet, CCW);
<a name="l21243"></a>21243         findedge(insertsh, org(spintet), dest(spintet));
<a name="l21244"></a>21244         tsbond(spintet, *insertsh);
<a name="l21245"></a>21245         sym(spintet, symtet); <span class="comment">// &#39;symtet&#39; maybe outside, use it anyway.</span>
<a name="l21246"></a>21246         sesymself(*insertsh);
<a name="l21247"></a>21247         tsbond(symtet, *insertsh);
<a name="l21248"></a>21248       } <span class="keywordflow">else</span> {
<a name="l21249"></a>21249         <span class="comment">// Found a duplicated subface (due to the redundant input).</span>
<a name="l21250"></a>21250         <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l21251"></a>21251           printf(<span class="stringliteral">&quot;Warning:  Two subfaces are found duplicated at &quot;</span>);
<a name="l21252"></a>21252           printf(<span class="stringliteral">&quot;(%d, %d, %d)\n&quot;</span>, pointmark(sorg(testsh)),
<a name="l21253"></a>21253                  pointmark(sdest(testsh)), pointmark(sapex(testsh)));
<a name="l21254"></a>21254           printf(<span class="stringliteral">&quot;  Subface of facet #%d is deleted.\n&quot;</span>, shellmark(*insertsh));
<a name="l21255"></a>21255           <span class="comment">// printf(&quot;  Hint: -d switch can find all duplicated facets.\n&quot;);</span>
<a name="l21256"></a>21256         }
<a name="l21257"></a>21257         shellfacedealloc(subfaces, insertsh-&gt;sh);
<a name="l21258"></a>21258       }
<a name="l21259"></a>21259       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l21260"></a>21260     }
<a name="l21261"></a>21261     <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l21262"></a>21262       hitbdry ++;
<a name="l21263"></a>21263       <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l21264"></a>21264         esym(*searchtet, spintet);
<a name="l21265"></a>21265         <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l21266"></a>21266           hitbdry ++;
<a name="l21267"></a>21267         }
<a name="l21268"></a>21268       }
<a name="l21269"></a>21269     }
<a name="l21270"></a>21270   } <span class="keywordflow">while</span> (hitbdry &lt; 2 &amp;&amp; apex(spintet) != apex(*searchtet));
<a name="l21271"></a>21271 
<a name="l21272"></a>21272   <span class="comment">// s is missing.</span>
<a name="l21273"></a>21273   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l21274"></a>21274 }
<a name="l21275"></a>21275 
<a name="l21277"></a>21277 <span class="comment">//                                                                           //</span>
<a name="l21278"></a>21278 <span class="comment">// tritritest()    Test if two triangles are intersecting in their interior. //</span>
<a name="l21279"></a>21279 <span class="comment">//                                                                           //</span>
<a name="l21280"></a>21280 <span class="comment">// One triangle t1 is the face of &#39;checktet&#39;, the other t2 is given by three //</span>
<a name="l21281"></a>21281 <span class="comment">// corners &#39;p1&#39;, &#39;p2&#39; and &#39;p3&#39;. This routine calls tri_tri_inter() to detect //</span>
<a name="l21282"></a>21282 <span class="comment">// whether t1 and t2 exactly intersect in their interior. Cases like share a //</span>
<a name="l21283"></a>21283 <span class="comment">// vertex, share an edge, or coincidence are considered not intersect.       //</span>
<a name="l21284"></a>21284 <span class="comment">//                                                                           //</span>
<a name="l21286"></a>21286 <span class="comment"></span>
<a name="l21287"></a>21287 <span class="keywordtype">bool</span> tetgenmesh::tritritest(triface* checktet, point p1, point p2, point p3)
<a name="l21288"></a>21288 {
<a name="l21289"></a>21289   point forg, fdest, fapex;
<a name="l21290"></a>21290   <span class="keyword">enum</span> interresult intersect;
<a name="l21291"></a>21291 
<a name="l21292"></a>21292   forg = org(*checktet);
<a name="l21293"></a>21293   fdest = dest(*checktet);
<a name="l21294"></a>21294   fapex = apex(*checktet);
<a name="l21295"></a>21295 
<a name="l21296"></a>21296 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l21297"></a>21297 <span class="preprocessor"></span>  REAL ax, ay, az, bx, by, bz;
<a name="l21298"></a>21298   REAL n[3];
<a name="l21299"></a>21299   <span class="comment">// face (torg, tdest, tapex) should not be degenerate. However p1, p2,</span>
<a name="l21300"></a>21300   <span class="comment">//   and p3 may be collinear. Check it.</span>
<a name="l21301"></a>21301   ax = forg[0] - fdest[0];
<a name="l21302"></a>21302   ay = forg[1] - fdest[1];
<a name="l21303"></a>21303   az = forg[2] - fdest[2];
<a name="l21304"></a>21304   bx = forg[0] - fapex[0];
<a name="l21305"></a>21305   by = forg[1] - fapex[1];
<a name="l21306"></a>21306   bz = forg[2] - fapex[2];
<a name="l21307"></a>21307   n[0] = ay * bz - by * az;
<a name="l21308"></a>21308   n[1] = az * bx - bz * ax;
<a name="l21309"></a>21309   n[2] = ax * by - bx * ay;
<a name="l21310"></a>21310   assert(fabs(n[0]) + fabs(n[1]) + fabs(n[2]) &gt; 0.0);
<a name="l21311"></a>21311   <span class="comment">// The components of n should not smaller than the machine epsilon.</span>
<a name="l21312"></a>21312 
<a name="l21313"></a>21313   ax = p1[0] - p2[0];
<a name="l21314"></a>21314   ay = p1[1] - p2[1];
<a name="l21315"></a>21315   az = p1[2] - p2[2];
<a name="l21316"></a>21316   bx = p1[0] - p3[0];
<a name="l21317"></a>21317   by = p1[1] - p3[1];
<a name="l21318"></a>21318   bz = p1[2] - p3[2];
<a name="l21319"></a>21319   n[0] = ay * bz - by * az;
<a name="l21320"></a>21320   n[1] = az * bx - bz * ax;
<a name="l21321"></a>21321   n[2] = ax * by - bx * ay;
<a name="l21322"></a>21322   assert(fabs(n[0]) + fabs(n[1]) + fabs(n[2]) &gt; 0.0);
<a name="l21323"></a>21323   <span class="comment">// The components of n should not smaller than the machine epsilon.</span>
<a name="l21324"></a>21324 <span class="preprocessor">#endif</span>
<a name="l21325"></a>21325 <span class="preprocessor"></span>
<a name="l21326"></a>21326   intersect = tri_tri_inter(forg, fdest, fapex, p1, p2, p3);
<a name="l21327"></a>21327   <span class="keywordflow">return</span> intersect == INTERSECT;
<a name="l21328"></a>21328 }
<a name="l21329"></a>21329 
<a name="l21331"></a>21331 <span class="comment">//                                                                           //</span>
<a name="l21332"></a>21332 <span class="comment">// initializecavity()    Initialize the cavity.                              //</span>
<a name="l21333"></a>21333 <span class="comment">//                                                                           //</span>
<a name="l21334"></a>21334 <span class="comment">// A cavity C is bounded by a list of faces, called fronts.  Each front f is //</span>
<a name="l21335"></a>21335 <span class="comment">// hold by a tet t adjacent to C, t is not in C (uninfected). If f is a hull //</span>
<a name="l21336"></a>21336 <span class="comment">// face, t does&#39;t exist, a fake tet t&#39; is created to hold f. t&#39; has the same //</span>
<a name="l21337"></a>21337 <span class="comment">// vertices as f but no opposite.  t&#39; will be removed automatically after C  //</span>
<a name="l21338"></a>21338 <span class="comment">// is filled with new tets (by carvecavity()).                               //</span>
<a name="l21339"></a>21339 <span class="comment">//                                                                           //</span>
<a name="l21340"></a>21340 <span class="comment">// The faces of C are given in two lists. &#39;floorlist&#39; is a set of subfaces,  //</span>
<a name="l21341"></a>21341 <span class="comment">// each subface has been oriented to face to the inside of C.  &#39;ceillist&#39; is //</span>
<a name="l21342"></a>21342 <span class="comment">// a set of tetrahedral faces. &#39;frontlist&#39; returns the initialized fronts.   //</span>
<a name="l21343"></a>21343 <span class="comment">//                                                                           //</span>
<a name="l21345"></a>21345 <span class="comment"></span>
<a name="l21346"></a>21346 <span class="keywordtype">void</span> tetgenmesh::initializecavity(list* floorlist, list* ceillist,
<a name="l21347"></a>21347   list* frontlist)
<a name="l21348"></a>21348 {
<a name="l21349"></a>21349   triface neightet, casingtet;
<a name="l21350"></a>21350   triface faketet;
<a name="l21351"></a>21351   face worksh;
<a name="l21352"></a>21352   <span class="keywordtype">int</span> i;
<a name="l21353"></a>21353 
<a name="l21354"></a>21354   <span class="comment">// Initialize subfaces of C.</span>
<a name="l21355"></a>21355   <span class="keywordflow">for</span> (i = 0; i &lt; floorlist-&gt;len(); i++) {
<a name="l21356"></a>21356     <span class="comment">// Get a subface s.</span>
<a name="l21357"></a>21357     worksh = * (face *)(* floorlist)[i];
<a name="l21358"></a>21358 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l21359"></a>21359 <span class="preprocessor"></span>    <span class="comment">// Current side of s should be empty.</span>
<a name="l21360"></a>21360     stpivot(worksh, neightet);
<a name="l21361"></a>21361     assert(neightet.tet == dummytet);
<a name="l21362"></a>21362 <span class="preprocessor">#endif</span>
<a name="l21363"></a>21363 <span class="preprocessor"></span>    <span class="comment">// Get the adjacent tet t.</span>
<a name="l21364"></a>21364     sesymself(worksh);
<a name="l21365"></a>21365     stpivot(worksh, casingtet);
<a name="l21366"></a>21366     <span class="comment">// Does t exist?</span>
<a name="l21367"></a>21367     <span class="keywordflow">if</span> (casingtet.tet == dummytet) {
<a name="l21368"></a>21368       <span class="comment">// Create a fake tet t&#39; to hold f temporarily.</span>
<a name="l21369"></a>21369       maketetrahedron(&amp;faketet);
<a name="l21370"></a>21370       setorg(faketet, sorg(worksh));
<a name="l21371"></a>21371       setdest(faketet, sdest(worksh));
<a name="l21372"></a>21372       setapex(faketet, sapex(worksh));
<a name="l21373"></a>21373       setoppo(faketet, (point) NULL); <span class="comment">// Indicates it is &#39;fake&#39;.</span>
<a name="l21374"></a>21374       tsbond(faketet, worksh);
<a name="l21375"></a>21375       frontlist-&gt;append(&amp;faketet);
<a name="l21376"></a>21376     } <span class="keywordflow">else</span> {
<a name="l21377"></a>21377       frontlist-&gt;append(&amp;casingtet);
<a name="l21378"></a>21378     }
<a name="l21379"></a>21379   }
<a name="l21380"></a>21380   <span class="comment">// Initialize tet faces of C.</span>
<a name="l21381"></a>21381   <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l21382"></a>21382     <span class="comment">// Get a tet face c.</span>
<a name="l21383"></a>21383     neightet = * (triface *) (* ceillist)[i];
<a name="l21384"></a>21384 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l21385"></a>21385 <span class="preprocessor"></span>    <span class="comment">// The tet of c must be inside C (going to be deleted).</span>
<a name="l21386"></a>21386     assert(infected(neightet));
<a name="l21387"></a>21387 <span class="preprocessor">#endif</span>
<a name="l21388"></a>21388 <span class="preprocessor"></span>    <span class="comment">// Get the adjacent tet t.</span>
<a name="l21389"></a>21389     sym(neightet, casingtet);
<a name="l21390"></a>21390     <span class="comment">// Does t exist?</span>
<a name="l21391"></a>21391     <span class="keywordflow">if</span> (casingtet.tet == dummytet) {
<a name="l21392"></a>21392       <span class="comment">// No. Create a fake tet t&#39; to hold f temporarily.</span>
<a name="l21393"></a>21393       maketetrahedron(&amp;faketet);
<a name="l21394"></a>21394       <span class="comment">// Be sure that the vertices of t&#39; are CCW oriented.</span>
<a name="l21395"></a>21395       adjustedgering(neightet, CW); <span class="comment">// CW edge ring.</span>
<a name="l21396"></a>21396       setorg(faketet, org(neightet));
<a name="l21397"></a>21397       setdest(faketet, dest(neightet));
<a name="l21398"></a>21398       setapex(faketet, apex(neightet));
<a name="l21399"></a>21399       setoppo(faketet, (point) NULL); <span class="comment">// Indicates it is &#39;fake&#39;.</span>
<a name="l21400"></a>21400       <span class="comment">// Bond t&#39; to a subface if it exists.</span>
<a name="l21401"></a>21401       tspivot(neightet, worksh);
<a name="l21402"></a>21402       <span class="keywordflow">if</span> (worksh.sh != dummysh) {
<a name="l21403"></a>21403         sesymself(worksh);
<a name="l21404"></a>21404         tsbond(faketet, worksh);
<a name="l21405"></a>21405       }
<a name="l21406"></a>21406       <span class="comment">// Bond c &lt;--&gt; t&#39;. So we&#39;re able to find t&#39; and remove it.</span>
<a name="l21407"></a>21407       bond(faketet, neightet);
<a name="l21408"></a>21408       <span class="comment">// c may become uninfected due to the bond().</span>
<a name="l21409"></a>21409       infect(neightet);
<a name="l21410"></a>21410       frontlist-&gt;append(&amp;faketet);
<a name="l21411"></a>21411     } <span class="keywordflow">else</span> {
<a name="l21412"></a>21412       frontlist-&gt;append(&amp;casingtet);
<a name="l21413"></a>21413     }
<a name="l21414"></a>21414   }
<a name="l21415"></a>21415 }
<a name="l21416"></a>21416 
<a name="l21418"></a>21418 <span class="comment">//                                                                           //</span>
<a name="l21419"></a>21419 <span class="comment">// retrievenewtets()    Retrieve the newly created tets.                     //</span>
<a name="l21420"></a>21420 <span class="comment">//                                                                           //</span>
<a name="l21421"></a>21421 <span class="comment">// On input, &#39;newtetlist&#39; contains at least one alive new tet. From this tet,//</span>
<a name="l21422"></a>21422 <span class="comment">// other new tets can be found by a broadth-first searching.                 //</span>
<a name="l21423"></a>21423 <span class="comment">//                                                                           //</span>
<a name="l21425"></a>21425 <span class="comment"></span>
<a name="l21426"></a>21426 <span class="keywordtype">void</span> tetgenmesh::retrievenewtets(list* newtetlist)
<a name="l21427"></a>21427 {
<a name="l21428"></a>21428   triface searchtet, casingtet;
<a name="l21429"></a>21429   <span class="keywordtype">int</span> i;
<a name="l21430"></a>21430 
<a name="l21431"></a>21431   <span class="comment">// There may be dead tets due to flip32(). Delete them first.</span>
<a name="l21432"></a>21432   <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l21433"></a>21433     searchtet = * (triface *)(* newtetlist)[i];
<a name="l21434"></a>21434     <span class="keywordflow">if</span> (isdead(&amp;searchtet)) {
<a name="l21435"></a>21435       newtetlist-&gt;del(i, 0); i--;
<a name="l21436"></a>21436       <span class="keywordflow">continue</span>;
<a name="l21437"></a>21437     }
<a name="l21438"></a>21438     infect(searchtet);
<a name="l21439"></a>21439   }
<a name="l21440"></a>21440   <span class="comment">// Find all new tets.</span>
<a name="l21441"></a>21441   <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l21442"></a>21442     searchtet = * (triface *)(* newtetlist)[i];
<a name="l21443"></a>21443     <span class="keywordflow">for</span> (searchtet.loc = 0; searchtet.loc &lt; 4; searchtet.loc++) {
<a name="l21444"></a>21444       sym(searchtet, casingtet);
<a name="l21445"></a>21445       <span class="keywordflow">if</span> ((casingtet.tet != dummytet) &amp;&amp; !infected(casingtet)) {
<a name="l21446"></a>21446         infect(casingtet);
<a name="l21447"></a>21447         newtetlist-&gt;append(&amp;casingtet);
<a name="l21448"></a>21448       }
<a name="l21449"></a>21449     }
<a name="l21450"></a>21450   }
<a name="l21451"></a>21451   <span class="comment">// Uninfect new tets.</span>
<a name="l21452"></a>21452   <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l21453"></a>21453     searchtet = * (triface *)(* newtetlist)[i];
<a name="l21454"></a>21454     uninfect(searchtet);
<a name="l21455"></a>21455   }
<a name="l21456"></a>21456 }
<a name="l21457"></a>21457 
<a name="l21459"></a>21459 <span class="comment">//                                                                           //</span>
<a name="l21460"></a>21460 <span class="comment">// delaunizecavvertices()    Form a DT of the vertices of a cavity.          //</span>
<a name="l21461"></a>21461 <span class="comment">//                                                                           //</span>
<a name="l21462"></a>21462 <span class="comment">// &#39;floorptlist&#39; and &#39;ceilptlist&#39; are the vertices of the cavity.            //</span>
<a name="l21463"></a>21463 <span class="comment">//                                                                           //</span>
<a name="l21464"></a>21464 <span class="comment">// The tets of the DT are created directly in the pool &#39;tetrahedrons&#39;, i.e., //</span>
<a name="l21465"></a>21465 <span class="comment">// no auxiliary data structure and memory are required.  The trick is at the //</span>
<a name="l21466"></a>21466 <span class="comment">// time they&#39;re created, there are no connections between them to the other  //</span>
<a name="l21467"></a>21467 <span class="comment">// tets in the pool. You can imagine they form an ioslated island.           //</span>
<a name="l21468"></a>21468 <span class="comment">//                                                                           //</span>
<a name="l21470"></a>21470 <span class="comment"></span>
<a name="l21471"></a>21471 <span class="keywordtype">void</span> tetgenmesh::delaunizecavvertices(triface* oldtet, list* floorptlist,
<a name="l21472"></a>21472   list* ceilptlist, list* newtetlist, queue* flipque)
<a name="l21473"></a>21473 {
<a name="l21474"></a>21474   point *insertarray;
<a name="l21475"></a>21475   triface bakhulltet, newtet;
<a name="l21476"></a>21476   <span class="keywordtype">long</span> bakhullsize;
<a name="l21477"></a>21477   <span class="keywordtype">long</span> arraysize;
<a name="l21478"></a>21478   <span class="keywordtype">int</span> bakchksub;
<a name="l21479"></a>21479   <span class="keywordtype">int</span> i, j;
<a name="l21480"></a>21480 
<a name="l21481"></a>21481   <span class="comment">// Prepare the array of points for inserting.</span>
<a name="l21482"></a>21482   arraysize = floorptlist-&gt;len();
<a name="l21483"></a>21483   <span class="keywordflow">if</span> (ceilptlist != (list *) NULL) {
<a name="l21484"></a>21484     arraysize += ceilptlist-&gt;len();
<a name="l21485"></a>21485   }
<a name="l21486"></a>21486   insertarray = <span class="keyword">new</span> point[arraysize];
<a name="l21487"></a>21487   <span class="keywordflow">for</span> (i = 0; i &lt; floorptlist-&gt;len(); i++) {
<a name="l21488"></a>21488     insertarray[i] = * (point *)(* floorptlist)[i];
<a name="l21489"></a>21489   }
<a name="l21490"></a>21490   <span class="keywordflow">if</span> (ceilptlist != (list *) NULL) {
<a name="l21491"></a>21491     <span class="keywordflow">for</span> (j = 0; j &lt; ceilptlist-&gt;len(); j++) {
<a name="l21492"></a>21492       insertarray[i + j] = * (point *)(* ceilptlist)[j];
<a name="l21493"></a>21493     }
<a name="l21494"></a>21494   }
<a name="l21495"></a>21495 
<a name="l21496"></a>21496   <span class="comment">// The incrflipdelaunay() is re-used. Backup global variables.</span>
<a name="l21497"></a>21497   decode(dummytet[0], bakhulltet);
<a name="l21498"></a>21498   bakhullsize = hullsize;
<a name="l21499"></a>21499   bakchksub = checksubfaces;
<a name="l21500"></a>21500   checksubfaces = 0;
<a name="l21501"></a>21501   b-&gt;verbose--;
<a name="l21502"></a>21502 
<a name="l21503"></a>21503   <span class="comment">// Form the DT by incremental flip Delaunay algorithm. Do not jump for</span>
<a name="l21504"></a>21504   <span class="comment">//   point location, do not merge points.</span>
<a name="l21505"></a>21505   incrflipdelaunay(oldtet, insertarray, arraysize, <span class="keyword">false</span>, <span class="keyword">false</span>, 0.0, flipque);
<a name="l21506"></a>21506 
<a name="l21507"></a>21507   <span class="comment">// Get a tet in D.</span>
<a name="l21508"></a>21508   decode(dummytet[0], newtet);
<a name="l21509"></a>21509   newtetlist-&gt;append(&amp;newtet);
<a name="l21510"></a>21510   <span class="comment">// Get all tets of D.</span>
<a name="l21511"></a>21511   retrievenewtets(newtetlist);
<a name="l21512"></a>21512 
<a name="l21513"></a>21513   <span class="comment">// Restore global variables.</span>
<a name="l21514"></a>21514   dummytet[0] = encode(bakhulltet);
<a name="l21515"></a>21515   hullsize = bakhullsize;
<a name="l21516"></a>21516   checksubfaces = bakchksub;
<a name="l21517"></a>21517   b-&gt;verbose++;
<a name="l21518"></a>21518 
<a name="l21519"></a>21519   <span class="keyword">delete</span> [] insertarray;
<a name="l21520"></a>21520 }
<a name="l21521"></a>21521 
<a name="l21523"></a>21523 <span class="comment">//                                                                           //</span>
<a name="l21524"></a>21524 <span class="comment">// insertauxsubface()    Fix an auxilary subface in place.                   //</span>
<a name="l21525"></a>21525 <span class="comment">//                                                                           //</span>
<a name="l21526"></a>21526 <span class="comment">// An auxilary subface s is fixed in D as it is a real subface, but s has no //</span>
<a name="l21527"></a>21527 <span class="comment">// vertices and neighbors. It has two uses: (1) it protects an identfied     //</span>
<a name="l21528"></a>21528 <span class="comment">// front f in D; (2) it serves the link to bond a tet in C and f later. The  //</span>
<a name="l21529"></a>21529 <span class="comment">// first neighbor of s (s-&gt;sh[0]) stores a pointer to f.                     //</span>
<a name="l21530"></a>21530 <span class="comment">//                                                                           //</span>
<a name="l21531"></a>21531 <span class="comment">// &#39;front&#39; is a front f of C. idfront&#39; t is a tet in D where f is identified //</span>
<a name="l21532"></a>21532 <span class="comment">// be a face of it. s will be fixed between t and its neighbor.              //</span>
<a name="l21533"></a>21533 <span class="comment">//                                                                           //</span>
<a name="l21535"></a>21535 <span class="comment"></span>
<a name="l21536"></a>21536 <span class="keywordtype">void</span> tetgenmesh::insertauxsubface(triface* front, triface* idfront)
<a name="l21537"></a>21537 {
<a name="l21538"></a>21538   triface neightet;
<a name="l21539"></a>21539   face auxsh;
<a name="l21540"></a>21540 
<a name="l21541"></a>21541   <span class="comment">// Create the aux subface s.</span>
<a name="l21542"></a>21542   makeshellface(subfaces, &amp;auxsh);
<a name="l21543"></a>21543   <span class="comment">// Bond s &lt;--&gt; t.</span>
<a name="l21544"></a>21544   tsbond(*idfront, auxsh);
<a name="l21545"></a>21545   <span class="comment">// Does t&#39;s neighbor n exist?</span>
<a name="l21546"></a>21546   sym(*idfront, neightet);
<a name="l21547"></a>21547   <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l21548"></a>21548     <span class="comment">// Bond s &lt;--&gt; n.</span>
<a name="l21549"></a>21549     sesymself(auxsh);
<a name="l21550"></a>21550     tsbond(neightet, auxsh);
<a name="l21551"></a>21551   }
<a name="l21552"></a>21552   <span class="comment">// Let s remember f.</span>
<a name="l21553"></a>21553   auxsh.sh[0] = (shellface) encode(*front);
<a name="l21554"></a>21554 }
<a name="l21555"></a>21555 
<a name="l21557"></a>21557 <span class="comment">//                                                                           //</span>
<a name="l21558"></a>21558 <span class="comment">// scoutfront()    Scout a face in D.                                        //</span>
<a name="l21559"></a>21559 <span class="comment">//                                                                           //</span>
<a name="l21560"></a>21560 <span class="comment">// Search a &#39;front&#39; f in D. If f is found, return TRUE and the face of D is  //</span>
<a name="l21561"></a>21561 <span class="comment">// returned in &#39;idfront&#39;. Otherwise, return FALSE.                           //</span>
<a name="l21562"></a>21562 <span class="comment">//                                                                           //</span>
<a name="l21564"></a>21564 <span class="comment"></span>
<a name="l21565"></a>21565 <span class="keywordtype">bool</span> tetgenmesh::scoutfront(triface* front, triface* idfront, list* newtetlist)
<a name="l21566"></a>21566 {
<a name="l21567"></a>21567   triface spintet;
<a name="l21568"></a>21568   point pa, pb, pc;
<a name="l21569"></a>21569   <span class="keyword">enum</span> locateresult loc;
<a name="l21570"></a>21570   <span class="keyword">enum</span> finddirectionresult col;
<a name="l21571"></a>21571   <span class="keywordtype">int</span> hitbdry;
<a name="l21572"></a>21572   <span class="keywordtype">int</span> i;
<a name="l21573"></a>21573 
<a name="l21574"></a>21574   <span class="comment">// Let the front we&#39;re searching is abc.</span>
<a name="l21575"></a>21575   pa = org(*front);
<a name="l21576"></a>21576   pb = dest(*front);
<a name="l21577"></a>21577   <span class="comment">// Get a tet in D for searching.</span>
<a name="l21578"></a>21578   *idfront = recenttet;
<a name="l21579"></a>21579   <span class="comment">// Make sure the tet is valid (it may be killed by flips).</span>
<a name="l21580"></a>21580   <span class="keywordflow">if</span> (isdead(idfront)) {
<a name="l21581"></a>21581     <span class="comment">// The tet is dead. Search a live tet in D. !!!</span>
<a name="l21582"></a>21582     <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l21583"></a>21583       recenttet = * (triface *)(* newtetlist)[i];
<a name="l21584"></a>21584       <span class="keywordflow">if</span> (!isdead(&amp;recenttet)) <span class="keywordflow">break</span>;
<a name="l21585"></a>21585     }
<a name="l21586"></a>21586     assert(i &lt; newtetlist-&gt;len());
<a name="l21587"></a>21587   }
<a name="l21588"></a>21588 
<a name="l21589"></a>21589   <span class="comment">// Search a tet having vertex a.</span>
<a name="l21590"></a>21590   loc = preciselocate(pa, idfront, (<span class="keywordtype">long</span>) newtetlist-&gt;len());
<a name="l21591"></a>21591   assert(loc == ONVERTEX);
<a name="l21592"></a>21592   recenttet = *idfront;
<a name="l21593"></a>21593   <span class="comment">// Search a tet having edge ab.</span>
<a name="l21594"></a>21594   col = finddirection(idfront, pb, (<span class="keywordtype">long</span>) newtetlist-&gt;len());
<a name="l21595"></a>21595   <span class="keywordflow">if</span> (col == RIGHTCOLLINEAR) {
<a name="l21596"></a>21596     <span class="comment">// b is just the destination.</span>
<a name="l21597"></a>21597   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (col == LEFTCOLLINEAR) {
<a name="l21598"></a>21598     enext2self(*idfront);
<a name="l21599"></a>21599     esymself(*idfront);
<a name="l21600"></a>21600   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (col == TOPCOLLINEAR) {
<a name="l21601"></a>21601     fnextself(*idfront);
<a name="l21602"></a>21602     enext2self(*idfront);
<a name="l21603"></a>21603     esymself(*idfront);
<a name="l21604"></a>21604   }
<a name="l21605"></a>21605 
<a name="l21606"></a>21606   <span class="keywordflow">if</span> (dest(*idfront) == pb) {
<a name="l21607"></a>21607     <span class="comment">// Search a tet having face abc</span>
<a name="l21608"></a>21608     pc = apex(*front);
<a name="l21609"></a>21609     spintet = *idfront;
<a name="l21610"></a>21610     hitbdry = 0;
<a name="l21611"></a>21611     <span class="keywordflow">do</span> {
<a name="l21612"></a>21612       <span class="keywordflow">if</span> (apex(spintet) == pc) {
<a name="l21613"></a>21613         <span class="comment">// Found abc. Insert an auxilary subface s at idfront.</span>
<a name="l21614"></a>21614         <span class="comment">// insertauxsubface(front, &amp;spintet);</span>
<a name="l21615"></a>21615         *idfront = spintet;
<a name="l21616"></a>21616         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l21617"></a>21617       }
<a name="l21618"></a>21618       <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l21619"></a>21619         hitbdry ++;
<a name="l21620"></a>21620         <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l21621"></a>21621           esym(*idfront, spintet);
<a name="l21622"></a>21622           <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l21623"></a>21623             hitbdry ++;
<a name="l21624"></a>21624           }
<a name="l21625"></a>21625         }
<a name="l21626"></a>21626       }
<a name="l21627"></a>21627       <span class="keywordflow">if</span> (apex(spintet) == apex(*idfront)) <span class="keywordflow">break</span>;
<a name="l21628"></a>21628     } <span class="keywordflow">while</span> (hitbdry &lt; 2);
<a name="l21629"></a>21629   }
<a name="l21630"></a>21630 
<a name="l21631"></a>21631   <span class="comment">// f is missing in D.</span>
<a name="l21632"></a>21632   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l21633"></a>21633     printf(<span class="stringliteral">&quot;    Front (%d, %d, %d) is missing.\n&quot;</span>, pointmark(pa),
<a name="l21634"></a>21634            pointmark(pb), pointmark(apex(*front)));
<a name="l21635"></a>21635   }
<a name="l21636"></a>21636   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l21637"></a>21637 }
<a name="l21638"></a>21638 
<a name="l21640"></a>21640 <span class="comment">//                                                                           //</span>
<a name="l21641"></a>21641 <span class="comment">// gluefronts()    Glue two fronts together.                                 //</span>
<a name="l21642"></a>21642 <span class="comment">//                                                                           //</span>
<a name="l21643"></a>21643 <span class="comment">// This is a support routine for identifyfront().  Two fronts f and f1 are   //</span>
<a name="l21644"></a>21644 <span class="comment">// found indentical. This is caused by the non-coplanarity of vertices of a  //</span>
<a name="l21645"></a>21645 <span class="comment">// facet. Hence f and f1 are a subface and a tet. They are not fronts of the //</span>
<a name="l21646"></a>21646 <span class="comment">// cavity anymore. This routine glues f and f1 together.                     //</span>
<a name="l21647"></a>21647 <span class="comment">//                                                                           //</span>
<a name="l21649"></a>21649 <span class="comment"></span>
<a name="l21650"></a>21650 <span class="keywordtype">void</span> tetgenmesh::gluefronts(triface* front, triface* front1)
<a name="l21651"></a>21651 {
<a name="l21652"></a>21652   face consh;
<a name="l21653"></a>21653 
<a name="l21654"></a>21654   <span class="comment">// Glue f and f1 together. There&#39;re four cases:</span>
<a name="l21655"></a>21655   <span class="comment">//   (1) both f and f1 are not fake;</span>
<a name="l21656"></a>21656   <span class="comment">//   (2) f is not fake, f1 is fake;</span>
<a name="l21657"></a>21657   <span class="comment">//   (3) f is fake and f1 is not fake;</span>
<a name="l21658"></a>21658   <span class="comment">//   (4) both f and f1 are fake.</span>
<a name="l21659"></a>21659   <span class="comment">// Case (4) should be not possible.</span>
<a name="l21660"></a>21660 
<a name="l21661"></a>21661   <span class="comment">// Is there a concrete subface c at f.</span>
<a name="l21662"></a>21662   tspivot(*front, consh);
<a name="l21663"></a>21663   <span class="keywordflow">if</span> (consh.sh != dummysh) {
<a name="l21664"></a>21664     sesymself(consh);
<a name="l21665"></a>21665     tsbond(*front1, consh); <span class="comment">// Bond: f1 &lt;--&gt; c.</span>
<a name="l21666"></a>21666     sesymself(consh);
<a name="l21667"></a>21667   }
<a name="l21668"></a>21668   <span class="comment">// Does f hold by a fake tet.</span>
<a name="l21669"></a>21669   <span class="keywordflow">if</span> (oppo(*front) == (point) NULL) {
<a name="l21670"></a>21670     <span class="comment">// f is fake. Case (3) or (4).</span>
<a name="l21671"></a>21671     assert(oppo(*front1) != (point) NULL); <span class="comment">// Eliminate (4).</span>
<a name="l21672"></a>21672     <span class="comment">// Case (3).</span>
<a name="l21673"></a>21673     <span class="keywordflow">if</span> (consh.sh != dummysh) {
<a name="l21674"></a>21674       stdissolve(consh);  <span class="comment">// Dissolve: c -x-&gt; f.</span>
<a name="l21675"></a>21675     }
<a name="l21676"></a>21676     <span class="comment">// Dealloc f.</span>
<a name="l21677"></a>21677     tetrahedrondealloc(front-&gt;tet);
<a name="l21678"></a>21678     <span class="comment">// f1 becomes a hull. let &#39;dummytet&#39; bond to it.</span>
<a name="l21679"></a>21679     dummytet[0] = encode(*front1);
<a name="l21680"></a>21680   } <span class="keywordflow">else</span> {
<a name="l21681"></a>21681     <span class="comment">// Case (1) or (2).</span>
<a name="l21682"></a>21682     bond(*front, *front1); <span class="comment">// Bond f1 &lt;--&gt; f.</span>
<a name="l21683"></a>21683   }
<a name="l21684"></a>21684   <span class="comment">// Is f a fake tet?</span>
<a name="l21685"></a>21685   <span class="keywordflow">if</span> (!isdead(front)) {
<a name="l21686"></a>21686     <span class="comment">// No. Check for case (2).</span>
<a name="l21687"></a>21687     tspivot(*front1, consh);
<a name="l21688"></a>21688     <span class="comment">// Is f1 fake?</span>
<a name="l21689"></a>21689     <span class="keywordflow">if</span> (oppo(*front1) == (point) NULL) {
<a name="l21690"></a>21690       <span class="comment">// Case (2) or (4)</span>
<a name="l21691"></a>21691       assert(oppo(*front) != (point) NULL); <span class="comment">// Eliminate (4).</span>
<a name="l21692"></a>21692       <span class="comment">// Case (2).</span>
<a name="l21693"></a>21693       <span class="keywordflow">if</span> (consh.sh != dummysh) {
<a name="l21694"></a>21694         stdissolve(consh);  <span class="comment">// Dissolve: c -x-&gt; f1.</span>
<a name="l21695"></a>21695         sesymself(consh); <span class="comment">// Bond: f &lt;--&gt; c.</span>
<a name="l21696"></a>21696         tsbond(*front, consh);
<a name="l21697"></a>21697       }
<a name="l21698"></a>21698       <span class="comment">// Dissolve: f -x-&gt;f1.</span>
<a name="l21699"></a>21699       dissolve(*front);
<a name="l21700"></a>21700       <span class="comment">// Dealloc f1.</span>
<a name="l21701"></a>21701       tetrahedrondealloc(front1-&gt;tet);
<a name="l21702"></a>21702       <span class="comment">// f becomes a hull. let &#39;dummytet&#39; bond to it.</span>
<a name="l21703"></a>21703       dummytet[0] = encode(*front);
<a name="l21704"></a>21704     } <span class="keywordflow">else</span> {
<a name="l21705"></a>21705       <span class="comment">// Case (1).</span>
<a name="l21706"></a>21706       <span class="keywordflow">if</span> (consh.sh != dummysh) {
<a name="l21707"></a>21707         sesymself(consh);
<a name="l21708"></a>21708         tsbond(*front, consh); <span class="comment">// Bond: f &lt;--&gt; c.</span>
<a name="l21709"></a>21709       }
<a name="l21710"></a>21710     }
<a name="l21711"></a>21711   }
<a name="l21712"></a>21712 }
<a name="l21713"></a>21713 
<a name="l21715"></a>21715 <span class="comment">//                                                                           //</span>
<a name="l21716"></a>21716 <span class="comment">// identifyfronts()    Identify cavity faces in D.                           //</span>
<a name="l21717"></a>21717 <span class="comment">//                                                                           //</span>
<a name="l21718"></a>21718 <span class="comment">// &#39;frontlist&#39; are fronts of C need indentfying.  This routine searches each //</span>
<a name="l21719"></a>21719 <span class="comment">// front f in D. Once f is found, an auxilary subface s is inserted in D at  //</span>
<a name="l21720"></a>21720 <span class="comment">// the face. If f is not found in D, remove it from frontlist and save it in //</span>
<a name="l21721"></a>21721 <span class="comment">// &#39;misfrontlist&#39;.                                                           //</span>
<a name="l21722"></a>21722 <span class="comment">//                                                                           //</span>
<a name="l21724"></a>21724 <span class="comment"></span>
<a name="l21725"></a>21725 <span class="keywordtype">bool</span> tetgenmesh::identifyfronts(list* frontlist, list* misfrontlist,
<a name="l21726"></a>21726   list* newtetlist)
<a name="l21727"></a>21727 {
<a name="l21728"></a>21728   triface front, front1, tfront;
<a name="l21729"></a>21729   triface idfront, neightet;
<a name="l21730"></a>21730   face auxsh;
<a name="l21731"></a>21731   <span class="keywordtype">int</span> len, i, j;
<a name="l21732"></a>21732 
<a name="l21733"></a>21733   misfrontlist-&gt;clear();
<a name="l21734"></a>21734   <span class="comment">// Set a new tet in D for searching.</span>
<a name="l21735"></a>21735   recenttet = * (triface *)(* newtetlist)[0];
<a name="l21736"></a>21736 
<a name="l21737"></a>21737   <span class="comment">// Identify all fronts in D.</span>
<a name="l21738"></a>21738   <span class="keywordflow">for</span> (i = 0; i &lt; frontlist-&gt;len(); i++) {
<a name="l21739"></a>21739     <span class="comment">// Get a front f.</span>
<a name="l21740"></a>21740     front = * (triface *)( *frontlist)[i];
<a name="l21741"></a>21741     <span class="keywordflow">if</span> (scoutfront(&amp;front, &amp;idfront, newtetlist)) {
<a name="l21742"></a>21742       <span class="comment">// Found f. Insert an aux subface s.</span>
<a name="l21743"></a>21743       assert((idfront.tet != dummytet) &amp;&amp; !isdead(&amp;idfront));
<a name="l21744"></a>21744       <span class="comment">// Does s already exist?</span>
<a name="l21745"></a>21745       tspivot(idfront, auxsh);
<a name="l21746"></a>21746       <span class="keywordflow">if</span> (auxsh.sh != dummysh) {
<a name="l21747"></a>21747         <span class="comment">// There&#39;re two identical fronts, f (front) and f1 (s.sh[0])!</span>
<a name="l21748"></a>21748         decode((tetrahedron) auxsh.sh[0], front1);
<a name="l21749"></a>21749         assert((front1.tet != dummytet) &amp;&amp; !infected(front1));
<a name="l21750"></a>21750         <span class="comment">// Detach s in D.</span>
<a name="l21751"></a>21751         tsdissolve(idfront);
<a name="l21752"></a>21752         sym(idfront, neightet);
<a name="l21753"></a>21753         <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l21754"></a>21754           tsdissolve(neightet);
<a name="l21755"></a>21755         }
<a name="l21756"></a>21756         <span class="comment">// s has fulfilled its duty. Can be deleted.</span>
<a name="l21757"></a>21757         shellfacedealloc(subfaces, auxsh.sh);
<a name="l21758"></a>21758         <span class="comment">// Remove f from frontlist.</span>
<a name="l21759"></a>21759         frontlist-&gt;del(i, 1); i--;
<a name="l21760"></a>21760         <span class="comment">// Remove f1 from frontlist.</span>
<a name="l21761"></a>21761         len = frontlist-&gt;len();
<a name="l21762"></a>21762         <span class="keywordflow">for</span> (j = 0; j &lt; frontlist-&gt;len(); j++) {
<a name="l21763"></a>21763           tfront = * (triface *)(* frontlist)[j];
<a name="l21764"></a>21764           <span class="keywordflow">if</span> ((tfront.tet == front1.tet) &amp;&amp; (tfront.loc == front1.loc)) {
<a name="l21765"></a>21765             <span class="comment">// Found f1 in list.  Check f1 != f.</span>
<a name="l21766"></a>21766             assert((tfront.tet != front.tet) || (tfront.loc != front.loc));
<a name="l21767"></a>21767             frontlist-&gt;del(j, 1); i--;
<a name="l21768"></a>21768             <span class="keywordflow">break</span>;
<a name="l21769"></a>21769           }
<a name="l21770"></a>21770         }
<a name="l21771"></a>21771         assert((frontlist-&gt;len() + 1) == len);
<a name="l21772"></a>21772         <span class="comment">// Glue f and f1 together.</span>
<a name="l21773"></a>21773         gluefronts(&amp;front, &amp;front1);
<a name="l21774"></a>21774       } <span class="keywordflow">else</span> {
<a name="l21775"></a>21775         <span class="comment">// Insert an aux subface to protect f in D.</span>
<a name="l21776"></a>21776         insertauxsubface(&amp;front, &amp;idfront);
<a name="l21777"></a>21777       }
<a name="l21778"></a>21778     } <span class="keywordflow">else</span> {
<a name="l21779"></a>21779       <span class="comment">// f is missing.</span>
<a name="l21780"></a>21780       frontlist-&gt;del(i, 1); i--;
<a name="l21781"></a>21781       <span class="comment">// Are there two identical fronts, f (front) and f1 (front1)?</span>
<a name="l21782"></a>21782       <span class="keywordflow">for</span> (j = 0; j &lt; misfrontlist-&gt;len(); j++) {
<a name="l21783"></a>21783         front1 = * (triface *)(* misfrontlist)[j];
<a name="l21784"></a>21784         <span class="keywordflow">if</span> (isfacehaspoint(&amp;front1, org(front)) &amp;&amp;
<a name="l21785"></a>21785             isfacehaspoint(&amp;front1, dest(front)) &amp;&amp;
<a name="l21786"></a>21786             isfacehaspoint(&amp;front1, apex(front))) <span class="keywordflow">break</span>;
<a name="l21787"></a>21787       }
<a name="l21788"></a>21788       <span class="keywordflow">if</span> (j &lt; misfrontlist-&gt;len()) {
<a name="l21789"></a>21789         <span class="comment">// Found an identical front f1. Remove f1 from the list.</span>
<a name="l21790"></a>21790         misfrontlist-&gt;del(j, 1);
<a name="l21791"></a>21791         <span class="comment">// Glue f and f1 together.</span>
<a name="l21792"></a>21792         gluefronts(&amp;front, &amp;front1);
<a name="l21793"></a>21793       } <span class="keywordflow">else</span> {
<a name="l21794"></a>21794         <span class="comment">// Add f into misfrontlist.</span>
<a name="l21795"></a>21795         misfrontlist-&gt;append(&amp;front);
<a name="l21796"></a>21796       }
<a name="l21797"></a>21797     }
<a name="l21798"></a>21798   }
<a name="l21799"></a>21799   <span class="keywordflow">return</span> misfrontlist-&gt;len() == 0;
<a name="l21800"></a>21800 }
<a name="l21801"></a>21801 
<a name="l21803"></a>21803 <span class="comment">//                                                                           //</span>
<a name="l21804"></a>21804 <span class="comment">// detachauxsubfaces()    Detach auxilary subfaces in D.                     //</span>
<a name="l21805"></a>21805 <span class="comment">//                                                                           //</span>
<a name="l21806"></a>21806 <span class="comment">// This is a reverse routine of identifyfronts(). Some fronts are missing in //</span>
<a name="l21807"></a>21807 <span class="comment">// D. C can not be easily tetrahedralized. It needs remediation (expansion,  //</span>
<a name="l21808"></a>21808 <span class="comment">// or constrained flips, or adding a Steiner point).  This routine detaches  //</span>
<a name="l21809"></a>21809 <span class="comment">// the auxilary subfaces have been inserted in D and delete them.            //</span>
<a name="l21810"></a>21810 <span class="comment">//                                                                           //</span>
<a name="l21812"></a>21812 <span class="comment"></span>
<a name="l21813"></a>21813 <span class="keywordtype">void</span> tetgenmesh::detachauxsubfaces(list* newtetlist)
<a name="l21814"></a>21814 {
<a name="l21815"></a>21815   triface newtet, neightet;
<a name="l21816"></a>21816   face auxsh;
<a name="l21817"></a>21817   <span class="keywordtype">int</span> i;
<a name="l21818"></a>21818 
<a name="l21819"></a>21819   <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l21820"></a>21820     <span class="comment">// Get a new tet t.</span>
<a name="l21821"></a>21821     newtet = * (triface *)(* newtetlist)[i];
<a name="l21822"></a>21822     <span class="comment">// t may e dead due to flips.</span>
<a name="l21823"></a>21823     <span class="keywordflow">if</span> (isdead(&amp;newtet)) <span class="keywordflow">continue</span>;
<a name="l21824"></a>21824     assert(!infected(newtet));
<a name="l21825"></a>21825     <span class="comment">// Check the four faces of t.</span>
<a name="l21826"></a>21826     <span class="keywordflow">for</span> (newtet.loc = 0; newtet.loc &lt; 4; newtet.loc++) {
<a name="l21827"></a>21827       tspivot(newtet, auxsh);
<a name="l21828"></a>21828       <span class="keywordflow">if</span> (auxsh.sh != dummysh) {
<a name="l21829"></a>21829         <span class="comment">// An auxilary subface s.</span>
<a name="l21830"></a>21830         assert(sorg(auxsh) == (point) NULL);
<a name="l21831"></a>21831         tsdissolve(newtet);  <span class="comment">// t -x-&gt; s.</span>
<a name="l21832"></a>21832         sym(newtet, neightet);
<a name="l21833"></a>21833         <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l21834"></a>21834           assert(!isdead(&amp;neightet));
<a name="l21835"></a>21835           tsdissolve(neightet); <span class="comment">// n -x-&gt; s.</span>
<a name="l21836"></a>21836         }
<a name="l21837"></a>21837         <span class="comment">// Delete s.</span>
<a name="l21838"></a>21838         shellfacedealloc(subfaces, auxsh.sh);
<a name="l21839"></a>21839       }
<a name="l21840"></a>21840     }
<a name="l21841"></a>21841   }
<a name="l21842"></a>21842 }
<a name="l21843"></a>21843 
<a name="l21845"></a>21845 <span class="comment">//                                                                           //</span>
<a name="l21846"></a>21846 <span class="comment">// expandcavity()    Expand the cavity by adding new fronts.                 //</span>
<a name="l21847"></a>21847 <span class="comment">//                                                                           //</span>
<a name="l21848"></a>21848 <span class="comment">// This is the support routine for delaunizecavity().  Some fronts of C are  //</span>
<a name="l21849"></a>21849 <span class="comment">// missing in D since they&#39;re not strongly Delaunay. Such fronts are removed //</span>
<a name="l21850"></a>21850 <span class="comment">// and the faces of the tets abutting to them are added. C is then expanded. //</span>
<a name="l21851"></a>21851 <span class="comment">// Some removed faces may be subfaces, they&#39;re queued to recover later. D is //</span>
<a name="l21852"></a>21852 <span class="comment">// expanded simultaneously with the new vertices of the new fronts.          //</span>
<a name="l21853"></a>21853 <span class="comment">//                                                                           //</span>
<a name="l21855"></a>21855 <span class="comment"></span>
<a name="l21856"></a>21856 <span class="keywordtype">void</span> tetgenmesh::expandcavity(list* frontlist, list* misfrontlist,
<a name="l21857"></a>21857   list* newtetlist, list* crosstetlist, queue* missingshqueue, queue* flipque)
<a name="l21858"></a>21858 {
<a name="l21859"></a>21859   triface misfront, newfront, casingtet, crosstet;
<a name="l21860"></a>21860   triface searchtet, faketet, bakhulltet;
<a name="l21861"></a>21861   face checksh;
<a name="l21862"></a>21862   point pd;
<a name="l21863"></a>21863   <span class="keyword">enum</span> insertsiteresult success;
<a name="l21864"></a>21864   <span class="keywordtype">long</span> bakhullsize;
<a name="l21865"></a>21865   <span class="keywordtype">int</span> bakchksub;
<a name="l21866"></a>21866   <span class="keywordtype">int</span> i, j, k;
<a name="l21867"></a>21867 
<a name="l21868"></a>21868   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l21869"></a>21869     printf(<span class="stringliteral">&quot;    Expand cavity (%d missing fronts).\n&quot;</span>, misfrontlist-&gt;len());
<a name="l21870"></a>21870   }
<a name="l21871"></a>21871   <span class="comment">// Increase the number of expanded times.</span>
<a name="l21872"></a>21872   expcavcount++;
<a name="l21873"></a>21873   <span class="comment">// The incrflipdelaunay() is re-used. Backup global variables.</span>
<a name="l21874"></a>21874   decode(dummytet[0], bakhulltet);
<a name="l21875"></a>21875   bakhullsize = hullsize;
<a name="l21876"></a>21876   bakchksub = checksubfaces;
<a name="l21877"></a>21877   checksubfaces = 0;
<a name="l21878"></a>21878   b-&gt;verbose--;
<a name="l21879"></a>21879 
<a name="l21880"></a>21880   <span class="comment">// Choose a tet in D for searching.</span>
<a name="l21881"></a>21881   recenttet = * (triface *)(* newtetlist)[0];
<a name="l21882"></a>21882   assert((recenttet.tet != dummytet) &amp;&amp; !isdead(&amp;recenttet));
<a name="l21883"></a>21883 
<a name="l21884"></a>21884   <span class="comment">// Loop through &#39;misfrontlist&#39;.</span>
<a name="l21885"></a>21885   <span class="keywordflow">for</span> (i = 0; i &lt; misfrontlist-&gt;len(); i++) {
<a name="l21886"></a>21886     <span class="comment">// Get a missing front f.</span>
<a name="l21887"></a>21887     misfront = * (triface *)(* misfrontlist)[i];
<a name="l21888"></a>21888     <span class="comment">// C will be expanded at f.</span>
<a name="l21889"></a>21889     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l21890"></a>21890       printf(<span class="stringliteral">&quot;    Get misfront (%d, %d, %d).\n&quot;</span>, pointmark(org(misfront)),
<a name="l21891"></a>21891              pointmark(dest(misfront)), pointmark(apex(misfront)));
<a name="l21892"></a>21892     }
<a name="l21893"></a>21893     <span class="comment">// Is f has a subface s?</span>
<a name="l21894"></a>21894     tspivot(misfront, checksh);
<a name="l21895"></a>21895     <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l21896"></a>21896       <span class="comment">// A subface s is found. Check whether f is expandable at s.</span>
<a name="l21897"></a>21897       sym(misfront, crosstet);
<a name="l21898"></a>21898       <span class="keywordflow">if</span> (!infected(crosstet)) {
<a name="l21899"></a>21899         <span class="comment">// f is not expandable. In principle is should not happen. However,</span>
<a name="l21900"></a>21900         <span class="comment">//   it can happen when PBC is in use.</span>
<a name="l21901"></a>21901         assert(checkpbcs);
<a name="l21902"></a>21902         <span class="comment">// Skip expanding f. It will be processed later.</span>
<a name="l21903"></a>21903         <span class="keywordflow">continue</span>;
<a name="l21904"></a>21904       }
<a name="l21905"></a>21905       <span class="comment">// Temporarily remove s. Queue and recover it later.</span>
<a name="l21906"></a>21906       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l21907"></a>21907         printf(<span class="stringliteral">&quot;    Queuing subface (%d, %d, %d).\n&quot;</span>,
<a name="l21908"></a>21908                pointmark(sorg(checksh)), pointmark(sdest(checksh)),
<a name="l21909"></a>21909                pointmark(sapex(checksh)));
<a name="l21910"></a>21910       }
<a name="l21911"></a>21911       <span class="comment">// Detach s from tets at its both sides.</span>
<a name="l21912"></a>21912       tsdissolve(misfront);
<a name="l21913"></a>21913       tsdissolve(crosstet);
<a name="l21914"></a>21914       <span class="comment">// Detach tets at from s.</span>
<a name="l21915"></a>21915       stdissolve(checksh);
<a name="l21916"></a>21916       sesymself(checksh);
<a name="l21917"></a>21917       stdissolve(checksh);
<a name="l21918"></a>21918       <span class="comment">// Mark and queue it.</span>
<a name="l21919"></a>21919       sinfect(checksh);
<a name="l21920"></a>21920       missingshqueue-&gt;push(&amp;checksh);
<a name="l21921"></a>21921     }
<a name="l21922"></a>21922     <span class="comment">// f may already be processed (become a cross tet of C).</span>
<a name="l21923"></a>21923     <span class="keywordflow">if</span> (infected(misfront)) <span class="keywordflow">continue</span>;
<a name="l21924"></a>21924     <span class="comment">// Get the point p = oppo(t), t is the tet holds f.</span>
<a name="l21925"></a>21925     pd = oppo(misfront);
<a name="l21926"></a>21926 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l21927"></a>21927 <span class="preprocessor"></span>    <span class="comment">// t must not be fake.</span>
<a name="l21928"></a>21928     assert(pd != (point) NULL);
<a name="l21929"></a>21929 <span class="preprocessor">#endif</span>
<a name="l21930"></a>21930 <span class="preprocessor"></span>    <span class="comment">// Insert p in D. p may not be inserted if it is one of the two cases:</span>
<a name="l21931"></a>21931     <span class="comment">//   (1) p is already a vertex of D;</span>
<a name="l21932"></a>21932     <span class="comment">//   (2) p lies outside the CH of D;</span>
<a name="l21933"></a>21933     searchtet = recenttet;
<a name="l21934"></a>21934     <span class="comment">// Make sure the tet is valid (it may be killed by flips).</span>
<a name="l21935"></a>21935     <span class="keywordflow">if</span> (isdead(&amp;searchtet)) {
<a name="l21936"></a>21936       <span class="comment">// The tet is dead. Get a live tet in D. !!!</span>
<a name="l21937"></a>21937       <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist-&gt;len(); j++) {
<a name="l21938"></a>21938         recenttet = * (triface *)(* newtetlist)[j];
<a name="l21939"></a>21939         <span class="keywordflow">if</span> (!isdead(&amp;recenttet)) <span class="keywordflow">break</span>;
<a name="l21940"></a>21940       }
<a name="l21941"></a>21941       assert(j &lt; newtetlist-&gt;len());
<a name="l21942"></a>21942       searchtet = recenttet;
<a name="l21943"></a>21943     }
<a name="l21944"></a>21944     success = insertsite(pd, &amp;searchtet, <span class="keyword">false</span>, flipque);
<a name="l21945"></a>21945     <span class="keywordflow">if</span> (success == OUTSIDEPOINT) {
<a name="l21946"></a>21946       <span class="comment">// case (2). Insert p onto CH of D.</span>
<a name="l21947"></a>21947       inserthullsite(pd, &amp;searchtet, flipque);
<a name="l21948"></a>21948     }
<a name="l21949"></a>21949     <span class="keywordflow">if</span> (success != DUPLICATEPOINT) {
<a name="l21950"></a>21950       <span class="comment">// p is inserted. Recover Delaunness of D by flips.</span>
<a name="l21951"></a>21951       flip(flipque, NULL);
<a name="l21952"></a>21952     }
<a name="l21953"></a>21953     <span class="comment">// Expand C by adding new fronts. The three faces of t which have p as a</span>
<a name="l21954"></a>21954     <span class="comment">//   vertex become new fronts. However, if a new front is coincident with</span>
<a name="l21955"></a>21955     <span class="comment">//   an old front of C, it is not added and the old front is removed.</span>
<a name="l21956"></a>21956     adjustedgering(misfront, CCW);
<a name="l21957"></a>21957     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l21958"></a>21958       <span class="comment">// Notice: Below I mis-used the names. &#39;newfront&#39; is not exactly a new</span>
<a name="l21959"></a>21959       <span class="comment">//   front, instead the &#39;casingtet&#39; should be called new front.</span>
<a name="l21960"></a>21960       <span class="comment">// Get a new front f_n.</span>
<a name="l21961"></a>21961       fnext(misfront, newfront);
<a name="l21962"></a>21962       <span class="comment">// Get the neighbor tet n at f_n.</span>
<a name="l21963"></a>21963       sym(newfront, casingtet);
<a name="l21964"></a>21964       <span class="comment">// Is n a cross tet?</span>
<a name="l21965"></a>21965       <span class="keywordflow">if</span> (!infected(casingtet)) {
<a name="l21966"></a>21966         <span class="comment">// f_n becomes a new front of C.</span>
<a name="l21967"></a>21967         <span class="comment">// Does n exist?</span>
<a name="l21968"></a>21968         <span class="keywordflow">if</span> (casingtet.tet == dummytet) {
<a name="l21969"></a>21969           <span class="comment">// Create a fake tet n&#39; to hold f_n temporarily.</span>
<a name="l21970"></a>21970           maketetrahedron(&amp;faketet);
<a name="l21971"></a>21971           <span class="comment">// Be sure that the vertices of fake tet are CCW oriented.</span>
<a name="l21972"></a>21972           adjustedgering(newfront, CW); <span class="comment">// CW edge ring.</span>
<a name="l21973"></a>21973           setorg(faketet, org(newfront));
<a name="l21974"></a>21974           setdest(faketet, dest(newfront));
<a name="l21975"></a>21975           setapex(faketet, apex(newfront));
<a name="l21976"></a>21976           setoppo(faketet, (point) NULL); <span class="comment">// Indicates it is &#39;fake&#39;.</span>
<a name="l21977"></a>21977           <span class="comment">// Bond n&#39; to a subface if it exists.</span>
<a name="l21978"></a>21978           tspivot(newfront, checksh);
<a name="l21979"></a>21979           <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l21980"></a>21980             sesymself(checksh);
<a name="l21981"></a>21981             tsbond(faketet, checksh);
<a name="l21982"></a>21982           }
<a name="l21983"></a>21983           <span class="comment">// Bond f_n &lt;--&gt; n&#39;. So we&#39;re able to find n&#39; and remove it.</span>
<a name="l21984"></a>21984           bond(faketet, newfront);
<a name="l21985"></a>21985           frontlist-&gt;append(&amp;faketet);
<a name="l21986"></a>21986         } <span class="keywordflow">else</span> {
<a name="l21987"></a>21987           <span class="comment">// Add n to frontlist.</span>
<a name="l21988"></a>21988           frontlist-&gt;append(&amp;casingtet);
<a name="l21989"></a>21989         }
<a name="l21990"></a>21990       } <span class="keywordflow">else</span> {
<a name="l21991"></a>21991         <span class="comment">// f_n is coincident with an existing front f&#39; of C. f&#39; is no longer</span>
<a name="l21992"></a>21992         <span class="comment">//   a front, remove it from frontlist.  Use the inverse order to</span>
<a name="l21993"></a>21993         <span class="comment">//   search f&#39; (most likely, a newly added front may be f&#39;).</span>
<a name="l21994"></a>21994         <span class="keywordflow">for</span> (k = frontlist-&gt;len() - 1; k &gt;= 0; k--) {
<a name="l21995"></a>21995           searchtet = * (triface *)(* frontlist)[k];
<a name="l21996"></a>21996           <span class="keywordflow">if</span> ((newfront.tet == searchtet.tet) &amp;&amp;
<a name="l21997"></a>21997               (newfront.loc == searchtet.loc)) {
<a name="l21998"></a>21998             frontlist-&gt;del(k, 0);
<a name="l21999"></a>21999             <span class="keywordflow">break</span>;
<a name="l22000"></a>22000           }
<a name="l22001"></a>22001         }
<a name="l22002"></a>22002         <span class="comment">// Is f_n a subface?</span>
<a name="l22003"></a>22003         tspivot(newfront, checksh);
<a name="l22004"></a>22004         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l22005"></a>22005           <span class="comment">// Temporarily remove checksh. Make it missing. recover it later.</span>
<a name="l22006"></a>22006           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l22007"></a>22007             printf(<span class="stringliteral">&quot;    Queuing subface (%d, %d, %d).\n&quot;</span>,
<a name="l22008"></a>22008                    pointmark(sorg(checksh)), pointmark(sdest(checksh)),
<a name="l22009"></a>22009                    pointmark(sapex(checksh)));
<a name="l22010"></a>22010           }
<a name="l22011"></a>22011           tsdissolve(newfront);
<a name="l22012"></a>22012           tsdissolve(casingtet);
<a name="l22013"></a>22013           <span class="comment">// Detach tets at the both sides of checksh.</span>
<a name="l22014"></a>22014           stdissolve(checksh);
<a name="l22015"></a>22015           sesymself(checksh);
<a name="l22016"></a>22016           stdissolve(checksh);
<a name="l22017"></a>22017           sinfect(checksh);
<a name="l22018"></a>22018           missingshqueue-&gt;push(&amp;checksh);
<a name="l22019"></a>22019         }
<a name="l22020"></a>22020       }
<a name="l22021"></a>22021       enextself(misfront);
<a name="l22022"></a>22022     }
<a name="l22023"></a>22023     <span class="comment">// C has been expanded at f. t becomes a cross tet.</span>
<a name="l22024"></a>22024     <span class="keywordflow">if</span> (!infected(misfront)) {
<a name="l22025"></a>22025       <span class="comment">// t will be deleted, queue it.</span>
<a name="l22026"></a>22026       infect(misfront);
<a name="l22027"></a>22027       crosstetlist-&gt;append(&amp;misfront);
<a name="l22028"></a>22028     }
<a name="l22029"></a>22029   }
<a name="l22030"></a>22030 
<a name="l22031"></a>22031   <span class="comment">// Loop through misfrontlist, remove infected misfronts.</span>
<a name="l22032"></a>22032   <span class="keywordflow">for</span> (i = 0; i &lt; misfrontlist-&gt;len(); i++) {
<a name="l22033"></a>22033     misfront = * (triface *)(* misfrontlist)[i];
<a name="l22034"></a>22034     <span class="keywordflow">if</span> (infected(misfront)) {
<a name="l22035"></a>22035       <span class="comment">// Remove f, keep original list order.</span>
<a name="l22036"></a>22036       misfrontlist-&gt;del(i, 1);
<a name="l22037"></a>22037       i--;
<a name="l22038"></a>22038     }
<a name="l22039"></a>22039   }
<a name="l22040"></a>22040 
<a name="l22041"></a>22041   <span class="comment">// Are we done?</span>
<a name="l22042"></a>22042   <span class="keywordflow">if</span> (misfrontlist-&gt;len() &gt; 0) {
<a name="l22043"></a>22043     <span class="comment">// No. There are unexpandable fronts.</span>
<a name="l22044"></a>22044     <span class="comment">// expandcavity_sos(misfrontlist);</span>
<a name="l22045"></a>22045     assert(0); <span class="comment">// Not done yet.</span>
<a name="l22046"></a>22046   }
<a name="l22047"></a>22047 
<a name="l22048"></a>22048   <span class="comment">// D has been updated (by added new tets or dead tets) (due to flips).</span>
<a name="l22049"></a>22049   retrievenewtets(newtetlist);
<a name="l22050"></a>22050 
<a name="l22051"></a>22051   <span class="comment">// Restore global variables.</span>
<a name="l22052"></a>22052   dummytet[0] = encode(bakhulltet);
<a name="l22053"></a>22053   hullsize = bakhullsize;
<a name="l22054"></a>22054   checksubfaces = bakchksub;
<a name="l22055"></a>22055   b-&gt;verbose++;
<a name="l22056"></a>22056 }
<a name="l22057"></a>22057 
<a name="l22059"></a>22059 <span class="comment">//                                                                           //</span>
<a name="l22060"></a>22060 <span class="comment">// carvecavity()    Remove redundant (outside) tetrahedra from D.            //</span>
<a name="l22061"></a>22061 <span class="comment">//                                                                           //</span>
<a name="l22062"></a>22062 <span class="comment">// The fronts of C have been identified in D. Hence C can be tetrahedralized //</span>
<a name="l22063"></a>22063 <span class="comment">// by removing the tets outside C. The CDT is then updated by filling C with //</span>
<a name="l22064"></a>22064 <span class="comment">// the remaining tets (inside C) of D.                                       //</span>
<a name="l22065"></a>22065 <span class="comment">//                                                                           //</span>
<a name="l22066"></a>22066 <span class="comment">// Each front is protected by an auxilary subface s in D. s has a pointer to //</span>
<a name="l22067"></a>22067 <span class="comment">// f (s.sh[0]). f can be used to classified the in- and out- tets of C (the  //</span>
<a name="l22068"></a>22068 <span class="comment">// CW orientation of f faces to the inside of C). The classified out-tets of //</span>
<a name="l22069"></a>22069 <span class="comment">// C are marked (infected) for removing.                                     //</span>
<a name="l22070"></a>22070 <span class="comment">//                                                                           //</span>
<a name="l22071"></a>22071 <span class="comment">// Notice that the out-tets may not only the tets on the CH of C,  but also  //</span>
<a name="l22072"></a>22072 <span class="comment">// tets completely inside D, eg., there is a &quot;hole&quot; in D.  Such tets must be //</span>
<a name="l22073"></a>22073 <span class="comment">// marked during classification. The hole tets are poped up and removed too. //</span>
<a name="l22074"></a>22074 <span class="comment">//                                                                           //</span>
<a name="l22076"></a>22076 <span class="comment"></span>
<a name="l22077"></a>22077 <span class="keywordtype">void</span> tetgenmesh::carvecavity(list* newtetlist, list* outtetlist,
<a name="l22078"></a>22078   queue* flipque)
<a name="l22079"></a>22079 {
<a name="l22080"></a>22080   triface newtet, neightet, front, outtet;
<a name="l22081"></a>22081   face auxsh, consh;
<a name="l22082"></a>22082   point pointptr;
<a name="l22083"></a>22083   REAL ori;
<a name="l22084"></a>22084   <span class="keywordtype">int</span> i;
<a name="l22085"></a>22085 
<a name="l22086"></a>22086   <span class="comment">// Clear work list.</span>
<a name="l22087"></a>22087   outtetlist-&gt;clear();
<a name="l22088"></a>22088 
<a name="l22089"></a>22089   <span class="comment">// Classify in- and out- tets in D. Mark and queue classified out-tets.</span>
<a name="l22090"></a>22090   <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l22091"></a>22091     <span class="comment">// Get a new tet t.</span>
<a name="l22092"></a>22092     newtet = * (triface *)(* newtetlist)[i];
<a name="l22093"></a>22093     assert(!isdead(&amp;newtet));
<a name="l22094"></a>22094     <span class="comment">// Look for aux subfaces attached at t.</span>
<a name="l22095"></a>22095     <span class="keywordflow">for</span> (newtet.loc = 0; newtet.loc &lt; 4; newtet.loc++) {
<a name="l22096"></a>22096       tspivot(newtet, auxsh);
<a name="l22097"></a>22097       <span class="keywordflow">if</span> (auxsh.sh != dummysh) {
<a name="l22098"></a>22098         <span class="comment">// Has this side a neighbor n?</span>
<a name="l22099"></a>22099         sym(newtet, neightet);
<a name="l22100"></a>22100         <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l22101"></a>22101           <span class="comment">// Classify t and n (one is &quot;in&quot; and another is &quot;out&quot;).</span>
<a name="l22102"></a>22102           <span class="comment">// Get the front f.</span>
<a name="l22103"></a>22103           decode((tetrahedron) auxsh.sh[0], front);
<a name="l22104"></a>22104           <span class="comment">// Let f face to the inside of C.</span>
<a name="l22105"></a>22105           adjustedgering(front, CW);
<a name="l22106"></a>22106           ori = orient3d(org(front), dest(front), apex(front), oppo(newtet));
<a name="l22107"></a>22107           assert(ori != 0.0);
<a name="l22108"></a>22108           <span class="keywordflow">if</span> (ori &lt; 0.0) {
<a name="l22109"></a>22109             <span class="comment">// t is in-tet. n is out-tet.</span>
<a name="l22110"></a>22110             outtet = neightet;
<a name="l22111"></a>22111           } <span class="keywordflow">else</span> {
<a name="l22112"></a>22112             <span class="comment">// n is in-tet. t is out-tet.</span>
<a name="l22113"></a>22113             outtet = newtet;
<a name="l22114"></a>22114           }
<a name="l22115"></a>22115           <span class="comment">// Add the out-tet into list.</span>
<a name="l22116"></a>22116           <span class="keywordflow">if</span> (!infected(outtet)) {
<a name="l22117"></a>22117             infect(outtet);
<a name="l22118"></a>22118             outtetlist-&gt;append(&amp;outtet);
<a name="l22119"></a>22119           }
<a name="l22120"></a>22120         }
<a name="l22121"></a>22121       }
<a name="l22122"></a>22122     }
<a name="l22123"></a>22123   }
<a name="l22124"></a>22124 
<a name="l22125"></a>22125   <span class="comment">// Find and mark all out-tets.</span>
<a name="l22126"></a>22126   <span class="keywordflow">for</span> (i = 0; i &lt; outtetlist-&gt;len(); i++) {
<a name="l22127"></a>22127     outtet = * (triface *)(* outtetlist)[i];
<a name="l22128"></a>22128     <span class="keywordflow">for</span> (outtet.loc = 0; outtet.loc &lt; 4; outtet.loc++) {
<a name="l22129"></a>22129       sym(outtet, neightet);
<a name="l22130"></a>22130       <span class="comment">// Does the neighbor exist and unmarked?</span>
<a name="l22131"></a>22131       <span class="keywordflow">if</span> ((neightet.tet != dummytet) &amp;&amp; !infected(neightet)) {
<a name="l22132"></a>22132         <span class="comment">// Is it protected by an aux subface?</span>
<a name="l22133"></a>22133         tspivot(outtet, auxsh);
<a name="l22134"></a>22134         <span class="keywordflow">if</span> (auxsh.sh == dummysh) {
<a name="l22135"></a>22135           <span class="comment">// It&#39;s an out-tet.</span>
<a name="l22136"></a>22136           infect(neightet);
<a name="l22137"></a>22137           outtetlist-&gt;append(&amp;neightet);
<a name="l22138"></a>22138         }
<a name="l22139"></a>22139       }
<a name="l22140"></a>22140     }
<a name="l22141"></a>22141   }
<a name="l22142"></a>22142 
<a name="l22143"></a>22143   <span class="comment">// Remove the out- (and hole) tets.</span>
<a name="l22144"></a>22144   <span class="keywordflow">for</span> (i = 0; i &lt; outtetlist-&gt;len(); i++) {
<a name="l22145"></a>22145     <span class="comment">// Get an out-tet t.</span>
<a name="l22146"></a>22146     outtet = * (triface *)(* outtetlist)[i];
<a name="l22147"></a>22147     <span class="comment">// Detach t from the in-tets.</span>
<a name="l22148"></a>22148     <span class="keywordflow">for</span> (outtet.loc = 0; outtet.loc &lt; 4; outtet.loc++) {
<a name="l22149"></a>22149       <span class="comment">// Is there an aux subface s?</span>
<a name="l22150"></a>22150       tspivot(outtet, auxsh);
<a name="l22151"></a>22151       <span class="keywordflow">if</span> (auxsh.sh != dummysh) {
<a name="l22152"></a>22152         <span class="comment">// Get the neighbor n.</span>
<a name="l22153"></a>22153         sym(outtet, neightet);
<a name="l22154"></a>22154         assert(!infected(neightet)); <span class="comment">// t must be in-tet.</span>
<a name="l22155"></a>22155         <span class="comment">// Detach n -x-&gt; t.</span>
<a name="l22156"></a>22156         dissolve(neightet);
<a name="l22157"></a>22157       }
<a name="l22158"></a>22158     }
<a name="l22159"></a>22159     <span class="comment">// Dealloc the tet.</span>
<a name="l22160"></a>22160     tetrahedrondealloc(outtet.tet);
<a name="l22161"></a>22161   }
<a name="l22162"></a>22162 
<a name="l22163"></a>22163   <span class="comment">// Connect the in-tets of C to fronts. Remove aux subfaces and fake tets.</span>
<a name="l22164"></a>22164   <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l22165"></a>22165     <span class="comment">// Get a new tet t.</span>
<a name="l22166"></a>22166     newtet = * (triface *)(* newtetlist)[i];
<a name="l22167"></a>22167     <span class="comment">// t may be an out-tet and has got deleted.</span>
<a name="l22168"></a>22168     <span class="keywordflow">if</span> (isdead(&amp;newtet)) <span class="keywordflow">continue</span>;
<a name="l22169"></a>22169     <span class="comment">// t is an in-tet. Look for aux subfaces attached at t.</span>
<a name="l22170"></a>22170     <span class="keywordflow">for</span> (newtet.loc = 0; newtet.loc &lt; 4; newtet.loc++) {
<a name="l22171"></a>22171       <span class="comment">// Is there an aux subface s?</span>
<a name="l22172"></a>22172       tspivot(newtet, auxsh);
<a name="l22173"></a>22173       <span class="keywordflow">if</span> (auxsh.sh != dummysh) {
<a name="l22174"></a>22174         <span class="comment">// Get the front f.</span>
<a name="l22175"></a>22175         decode((tetrahedron) auxsh.sh[0], front);
<a name="l22176"></a>22176         assert((front.tet != dummytet) &amp;&amp; !infected(front));
<a name="l22177"></a>22177         <span class="comment">// s has fulfilled its duty. Can be deleted.</span>
<a name="l22178"></a>22178         tsdissolve(newtet); <span class="comment">// dissolve: t -x-&gt; s.</span>
<a name="l22179"></a>22179         <span class="comment">// Delete s.</span>
<a name="l22180"></a>22180         shellfacedealloc(subfaces, auxsh.sh);
<a name="l22181"></a>22181         <span class="comment">// Connect the newtet t and front f.</span>
<a name="l22182"></a>22182         <span class="comment">// Is there a concrete subface c at f.</span>
<a name="l22183"></a>22183         tspivot(front, consh);
<a name="l22184"></a>22184         <span class="keywordflow">if</span> (consh.sh != dummysh) {
<a name="l22185"></a>22185           sesymself(consh);
<a name="l22186"></a>22186           <span class="comment">// Bond: t &lt;--&gt; c.</span>
<a name="l22187"></a>22187           tsbond(newtet, consh);
<a name="l22188"></a>22188         }
<a name="l22189"></a>22189         <span class="comment">// Does f hold by a fake tet.</span>
<a name="l22190"></a>22190         <span class="keywordflow">if</span> (oppo(front) == (point) NULL) {
<a name="l22191"></a>22191           <span class="comment">// f is fake.</span>
<a name="l22192"></a>22192           <span class="keywordflow">if</span> (consh.sh != dummysh) {
<a name="l22193"></a>22193             sesymself(consh);
<a name="l22194"></a>22194             <span class="comment">// Dissolve: c -x-&gt; f.</span>
<a name="l22195"></a>22195             stdissolve(consh);
<a name="l22196"></a>22196           }
<a name="l22197"></a>22197           <span class="comment">// Dealloc f.</span>
<a name="l22198"></a>22198           tetrahedrondealloc(front.tet);
<a name="l22199"></a>22199           <span class="comment">// f becomes a hull. let &#39;dummytet&#39; bond to it.</span>
<a name="l22200"></a>22200           dummytet[0] = encode(newtet);
<a name="l22201"></a>22201         } <span class="keywordflow">else</span> {
<a name="l22202"></a>22202           <span class="comment">// Bond t &lt;--&gt; f.</span>
<a name="l22203"></a>22203           bond(newtet, front);
<a name="l22204"></a>22204         }
<a name="l22205"></a>22205         <span class="comment">// t may be non-locally Delaunay and flipable.</span>
<a name="l22206"></a>22206         <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l22207"></a>22207           enqueueflipface(newtet, flipque);
<a name="l22208"></a>22208         }
<a name="l22209"></a>22209       }
<a name="l22210"></a>22210     }
<a name="l22211"></a>22211     <span class="comment">// Let the corners of t2 point to it for fast searching.</span>
<a name="l22212"></a>22212     pointptr = org(newtet);
<a name="l22213"></a>22213     setpoint2tet(pointptr, encode(newtet));
<a name="l22214"></a>22214     pointptr = dest(newtet);
<a name="l22215"></a>22215     setpoint2tet(pointptr, encode(newtet));
<a name="l22216"></a>22216     pointptr = apex(newtet);
<a name="l22217"></a>22217     setpoint2tet(pointptr, encode(newtet));
<a name="l22218"></a>22218     pointptr = oppo(newtet);
<a name="l22219"></a>22219     setpoint2tet(pointptr, encode(newtet));
<a name="l22220"></a>22220   }
<a name="l22221"></a>22221   <span class="comment">// The cavity has been re-tetrahedralized.</span>
<a name="l22222"></a>22222 }
<a name="l22223"></a>22223 
<a name="l22225"></a>22225 <span class="comment">//                                                                           //</span>
<a name="l22226"></a>22226 <span class="comment">// delaunizecavity()    Tetrahedralize a cavity by Delaunay tetrahedra.      //</span>
<a name="l22227"></a>22227 <span class="comment">//                                                                           //</span>
<a name="l22228"></a>22228 <span class="comment">// The cavity C is bounded by a set of triangles in &#39;floorlist&#39; (a list of   //</span>
<a name="l22229"></a>22229 <span class="comment">// coplanar subfaces) and &#39;ceillist&#39; (a list of tetrahedral faces lie above  //</span>
<a name="l22230"></a>22230 <span class="comment">// the subfaces). &#39;floorptlist&#39; and &#39;ceilptlist&#39; are the vertices of C.      //</span>
<a name="l22231"></a>22231 <span class="comment">//                                                                           //</span>
<a name="l22233"></a>22233 <span class="comment"></span>
<a name="l22234"></a>22234 <span class="keywordtype">void</span> tetgenmesh::delaunizecavity(list* floorlist, list* ceillist,
<a name="l22235"></a>22235   list* ceilptlist, list* floorptlist, list* frontlist, list* misfrontlist,
<a name="l22236"></a>22236   list* newtetlist, list* crosstetlist, queue* missingshqueue, queue* flipque)
<a name="l22237"></a>22237 {
<a name="l22238"></a>22238   <span class="keywordtype">int</span> vertnum;
<a name="l22239"></a>22239 
<a name="l22240"></a>22240   vertnum = floorptlist-&gt;len();
<a name="l22241"></a>22241   vertnum += (ceilptlist != (list *) NULL ? ceilptlist-&gt;len() : 0);
<a name="l22242"></a>22242   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l22243"></a>22243     printf(<span class="stringliteral">&quot;    Delaunizing cavity (%d floors, %d ceilings, %d vertices).\n&quot;</span>,
<a name="l22244"></a>22244            floorlist-&gt;len(), ceillist-&gt;len(), vertnum);
<a name="l22245"></a>22245   }
<a name="l22246"></a>22246   <span class="comment">// Save the size of the largest cavity.</span>
<a name="l22247"></a>22247   <span class="keywordflow">if</span> ((floorlist-&gt;len() + ceillist-&gt;len()) &gt; maxcavfaces) {
<a name="l22248"></a>22248     maxcavfaces = floorlist-&gt;len() + ceillist-&gt;len();
<a name="l22249"></a>22249   }
<a name="l22250"></a>22250   <span class="keywordflow">if</span> (vertnum &gt; maxcavverts) {
<a name="l22251"></a>22251     maxcavverts = vertnum;
<a name="l22252"></a>22252   }
<a name="l22253"></a>22253 
<a name="l22254"></a>22254   <span class="comment">// Clear these lists.</span>
<a name="l22255"></a>22255   frontlist-&gt;clear();
<a name="l22256"></a>22256   misfrontlist-&gt;clear();
<a name="l22257"></a>22257   newtetlist-&gt;clear();
<a name="l22258"></a>22258 
<a name="l22259"></a>22259   <span class="comment">// Initialize the cavity C.</span>
<a name="l22260"></a>22260   initializecavity(floorlist, ceillist, frontlist);
<a name="l22261"></a>22261   <span class="comment">// Form the D of the vertices of C.</span>
<a name="l22262"></a>22262   delaunizecavvertices(NULL, floorptlist, ceilptlist, newtetlist, flipque);
<a name="l22263"></a>22263   <span class="comment">// Identify faces of C in D.</span>
<a name="l22264"></a>22264   <span class="keywordflow">while</span> (!identifyfronts(frontlist, misfrontlist, newtetlist)) {
<a name="l22265"></a>22265     <span class="comment">// Remove protecting subfaces, keep new tets.</span>
<a name="l22266"></a>22266     detachauxsubfaces(newtetlist);
<a name="l22267"></a>22267     <span class="comment">// Expand C and updateing D.</span>
<a name="l22268"></a>22268     expandcavity(frontlist, misfrontlist, newtetlist, crosstetlist,
<a name="l22269"></a>22269                  missingshqueue, flipque);
<a name="l22270"></a>22270   }
<a name="l22271"></a>22271   <span class="comment">// All fronts have identified in D. Get the shape of C by removing out</span>
<a name="l22272"></a>22272   <span class="comment">//   tets of C. &#39;misfrontlist&#39; is reused for removing out tets.</span>
<a name="l22273"></a>22273   carvecavity(newtetlist, misfrontlist, NULL);
<a name="l22274"></a>22274 }
<a name="l22275"></a>22275 
<a name="l22277"></a>22277 <span class="comment">//                                                                           //</span>
<a name="l22278"></a>22278 <span class="comment">// formmissingregion()    Form the missing region.                           //</span>
<a name="l22279"></a>22279 <span class="comment">//                                                                           //</span>
<a name="l22280"></a>22280 <span class="comment">// &#39;missingsh&#39; is a missing subface.  Start from it we can form the missing  //</span>
<a name="l22281"></a>22281 <span class="comment">// region R (a set of connected missing subfaces).  Because all missing sub- //</span>
<a name="l22282"></a>22282 <span class="comment">// faces have been marked (infected) before. R can be formed by checking the //</span>
<a name="l22283"></a>22283 <span class="comment">// neighbors of &#39;missingsh&#39;, and the neighbors of the neighbors, and so on.  //</span>
<a name="l22284"></a>22284 <span class="comment">// Stop checking further at either a segment or an unmarked subface.         //</span>
<a name="l22285"></a>22285 <span class="comment">//                                                                           //</span>
<a name="l22286"></a>22286 <span class="comment">// &#39;missingshlist&#39; returns R. The edge ring of subfaces of R are oriented in //</span>
<a name="l22287"></a>22287 <span class="comment">// the same direction. &#39;equatptlist&#39; returns the vertices of R, each vertex  //</span>
<a name="l22288"></a>22288 <span class="comment">// is marked with &#39;1&#39; (in &#39;worklist&#39;).                                       //</span>
<a name="l22289"></a>22289 <span class="comment">//                                                                           //</span>
<a name="l22291"></a>22291 <span class="comment"></span>
<a name="l22292"></a>22292 <span class="keywordtype">void</span> tetgenmesh::formmissingregion(face* missingsh, list* missingshlist,
<a name="l22293"></a>22293   list* equatptlist, <span class="keywordtype">int</span>* worklist)
<a name="l22294"></a>22294 {
<a name="l22295"></a>22295   face neighsh, worksh, workseg;
<a name="l22296"></a>22296   point workpt[3];
<a name="l22297"></a>22297   <span class="keywordtype">int</span> idx, i, j;
<a name="l22298"></a>22298 
<a name="l22299"></a>22299   <span class="comment">// Add &#39;missingsh&#39; into &#39;missingshlist&#39;.</span>
<a name="l22300"></a>22300   missingshlist-&gt;append(missingsh);
<a name="l22301"></a>22301   <span class="comment">// Save and mark its three vertices.</span>
<a name="l22302"></a>22302   workpt[0] = sorg(*missingsh);
<a name="l22303"></a>22303   workpt[1] = sdest(*missingsh);
<a name="l22304"></a>22304   workpt[2] = sapex(*missingsh);
<a name="l22305"></a>22305   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l22306"></a>22306     idx = pointmark(workpt[i]) - in-&gt;firstnumber;
<a name="l22307"></a>22307     worklist[idx] = 1;
<a name="l22308"></a>22308     equatptlist-&gt;append(&amp;workpt[i]);
<a name="l22309"></a>22309   }
<a name="l22310"></a>22310   <span class="comment">// Temporarily uninfect it (avoid to save it again).</span>
<a name="l22311"></a>22311   suninfect(*missingsh);
<a name="l22312"></a>22312 
<a name="l22313"></a>22313   <span class="comment">// Find the other missing subfaces.</span>
<a name="l22314"></a>22314   <span class="keywordflow">for</span> (i = 0; i &lt; missingshlist-&gt;len(); i++) {
<a name="l22315"></a>22315     <span class="comment">// Get a missing subface.</span>
<a name="l22316"></a>22316     worksh = * (face *)(* missingshlist)[i];
<a name="l22317"></a>22317     <span class="comment">// Check three neighbors of this face.</span>
<a name="l22318"></a>22318     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l22319"></a>22319       sspivot(worksh, workseg);
<a name="l22320"></a>22320       <span class="keywordflow">if</span> (workseg.sh == dummysh) {
<a name="l22321"></a>22321         spivot(worksh, neighsh);
<a name="l22322"></a>22322         <span class="keywordflow">if</span> (sinfected(neighsh)) {
<a name="l22323"></a>22323           <span class="comment">// Find a missing subface, adjust the face orientation.</span>
<a name="l22324"></a>22324           <span class="keywordflow">if</span> (sorg(neighsh) != sdest(worksh)) {
<a name="l22325"></a>22325             sesymself(neighsh);
<a name="l22326"></a>22326           }
<a name="l22327"></a>22327           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l22328"></a>22328             printf(<span class="stringliteral">&quot;    Add missing subface (%d, %d, %d).\n&quot;</span>,
<a name="l22329"></a>22329                    pointmark(sorg(neighsh)), pointmark(sdest(neighsh)),
<a name="l22330"></a>22330                    pointmark(sapex(neighsh)));
<a name="l22331"></a>22331           }
<a name="l22332"></a>22332           missingshlist-&gt;append(&amp;neighsh);
<a name="l22333"></a>22333           <span class="comment">// Save and mark its apex.</span>
<a name="l22334"></a>22334           workpt[0] = sapex(neighsh);
<a name="l22335"></a>22335           idx = pointmark(workpt[0]) - in-&gt;firstnumber;
<a name="l22336"></a>22336           <span class="comment">// Has workpt[0] been added?</span>
<a name="l22337"></a>22337           <span class="keywordflow">if</span> (worklist[idx] == 0) {
<a name="l22338"></a>22338             worklist[idx] = 1;
<a name="l22339"></a>22339             equatptlist-&gt;append(&amp;workpt[0]);
<a name="l22340"></a>22340           }
<a name="l22341"></a>22341           <span class="comment">// Temporarily uninfect it (avoid to save it again).</span>
<a name="l22342"></a>22342           suninfect(neighsh);
<a name="l22343"></a>22343         }
<a name="l22344"></a>22344       }
<a name="l22345"></a>22345       senextself(worksh);
<a name="l22346"></a>22346     }
<a name="l22347"></a>22347   }
<a name="l22348"></a>22348 
<a name="l22349"></a>22349   <span class="comment">// R has been formed. Infect missing subfaces again.</span>
<a name="l22350"></a>22350   <span class="keywordflow">for</span> (i = 0; i &lt; missingshlist-&gt;len(); i++) {
<a name="l22351"></a>22351     worksh = * (face *)(* missingshlist)[i];
<a name="l22352"></a>22352     sinfect(worksh);
<a name="l22353"></a>22353   }
<a name="l22354"></a>22354 }
<a name="l22355"></a>22355 
<a name="l22357"></a>22357 <span class="comment">//                                                                           //</span>
<a name="l22358"></a>22358 <span class="comment">// rearrangesubfaces()    Rearrange the set of subfaces of a missing region  //</span>
<a name="l22359"></a>22359 <span class="comment">//                        so that they conform to the faces of DT.           //</span>
<a name="l22360"></a>22360 <span class="comment">//                                                                           //</span>
<a name="l22361"></a>22361 <span class="comment">// The missing region formed by subfaces of &#39;missingshlist&#39; contains a set   //</span>
<a name="l22362"></a>22362 <span class="comment">// of degenerate vertices, hence the set of subfaces don&#39;t match the set of  //</span>
<a name="l22363"></a>22363 <span class="comment">// faces in DT.  Instead of forcing them to present in DT, we re-arrange the //</span>
<a name="l22364"></a>22364 <span class="comment">// connection of them so that the new subfaces conform to the faces of DT.   //</span>
<a name="l22365"></a>22365 <span class="comment">// &#39;boundedgelist&#39; is a set of boundary edges of the region, these edges(may //</span>
<a name="l22366"></a>22366 <span class="comment">// be subsegments) must exist in DT.                                         //</span>
<a name="l22367"></a>22367 <span class="comment">//                                                                           //</span>
<a name="l22368"></a>22368 <span class="comment">// On completion, we have created and inserted a set of new subfaces which   //</span>
<a name="l22369"></a>22369 <span class="comment">// conform to faces of DT. The set of old subfaces in &#39;missingshlist&#39; are    //</span>
<a name="l22370"></a>22370 <span class="comment">// deleted. The region vertices in &#39;equatptlist&#39; are unmarked.               //</span>
<a name="l22371"></a>22371 <span class="comment">//                                                                           //</span>
<a name="l22373"></a>22373 <span class="comment"></span>
<a name="l22374"></a>22374 <span class="keywordtype">void</span> tetgenmesh::rearrangesubfaces(list* missingshlist, list* boundedgelist,
<a name="l22375"></a>22375   list* equatptlist, <span class="keywordtype">int</span>* worklist)
<a name="l22376"></a>22376 {
<a name="l22377"></a>22377   link *boundedgelink;
<a name="l22378"></a>22378   link *newshlink;
<a name="l22379"></a>22379   triface starttet, spintet, neightet, worktet;
<a name="l22380"></a>22380   face shloop, newsh, neighsh, spinsh, worksh;
<a name="l22381"></a>22381   face workseg, casingin, casingout;
<a name="l22382"></a>22382   point torg, tdest, workpt;
<a name="l22383"></a>22383   point spt1, spt2, spt3;
<a name="l22384"></a>22384   <span class="keyword">enum</span> finddirectionresult collinear;
<a name="l22385"></a>22385   <span class="keyword">enum</span> shestype shtype;
<a name="l22386"></a>22386   REAL area;
<a name="l22387"></a>22387   <span class="keywordtype">bool</span> matchflag, finishflag;
<a name="l22388"></a>22388   <span class="keywordtype">int</span> shmark, pbcgp, idx, hitbdry;
<a name="l22389"></a>22389   <span class="keywordtype">int</span> i, j;
<a name="l22390"></a>22390 
<a name="l22391"></a>22391   <span class="comment">// Initialize the boundary edge link.</span>
<a name="l22392"></a>22392   boundedgelink = <span class="keyword">new</span> link(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l22393"></a>22393   <span class="comment">// Initialize the new subface link.</span>
<a name="l22394"></a>22394   newshlink = <span class="keyword">new</span> link(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l22395"></a>22395   <span class="comment">// Remember the type (skinny or not) of replaced subfaces.  They should</span>
<a name="l22396"></a>22396   <span class="comment">//   all have the same type since there is no segment inside the region.</span>
<a name="l22397"></a>22397   worksh = * (face *)(* missingshlist)[0];
<a name="l22398"></a>22398   shtype = shelltype(worksh);
<a name="l22399"></a>22399   <span class="comment">// The following loop is only for checking purpose.</span>
<a name="l22400"></a>22400   <span class="keywordflow">for</span> (i = 1; i &lt; missingshlist-&gt;len(); i++) {
<a name="l22401"></a>22401     worksh = * (face *)(* missingshlist)[i];
<a name="l22402"></a>22402     assert(shelltype(worksh) == shtype);
<a name="l22403"></a>22403   }
<a name="l22404"></a>22404   <span class="comment">// To avoid compilation warnings.</span>
<a name="l22405"></a>22405   shmark = pbcgp = 0;
<a name="l22406"></a>22406   area = 0.0;
<a name="l22407"></a>22407 
<a name="l22408"></a>22408   <span class="comment">// Create an initial boundary link.</span>
<a name="l22409"></a>22409   <span class="keywordflow">for</span> (i = 0; i &lt; boundedgelist-&gt;len(); i++) {
<a name="l22410"></a>22410     shloop = * (face *)(* boundedgelist)[i];
<a name="l22411"></a>22411     <span class="keywordflow">if</span> (i == 0) {
<a name="l22412"></a>22412       <span class="comment">// &#39;shmark&#39; will be set to all new created subfaces.</span>
<a name="l22413"></a>22413       shmark = shellmark(shloop);
<a name="l22414"></a>22414       <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l22415"></a>22415         <span class="comment">// area will be copied to all new created subfaces.</span>
<a name="l22416"></a>22416         area = areabound(shloop);
<a name="l22417"></a>22417       }
<a name="l22418"></a>22418       <span class="keywordflow">if</span> (checkpbcs) {
<a name="l22419"></a>22419         <span class="comment">// pbcgp will be copied to all new created subfaces.</span>
<a name="l22420"></a>22420         pbcgp = shellpbcgroup(shloop);
<a name="l22421"></a>22421       }
<a name="l22422"></a>22422       <span class="comment">// Get the abovepoint of this facet.</span>
<a name="l22423"></a>22423       abovepoint = facetabovepointarray[shellmark(shloop)];
<a name="l22424"></a>22424       <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l22425"></a>22425         getfacetabovepoint(&amp;shloop);
<a name="l22426"></a>22426       }
<a name="l22427"></a>22427     }
<a name="l22428"></a>22428     sspivot(shloop, workseg);
<a name="l22429"></a>22429     <span class="keywordflow">if</span> (workseg.sh == dummysh) {
<a name="l22430"></a>22430       <span class="comment">// This edge is an interior edge.</span>
<a name="l22431"></a>22431       spivot(shloop, neighsh);
<a name="l22432"></a>22432       boundedgelink-&gt;add(&amp;neighsh);
<a name="l22433"></a>22433     } <span class="keywordflow">else</span> {
<a name="l22434"></a>22434       <span class="comment">// This side has a segment, the edge exists.</span>
<a name="l22435"></a>22435       boundedgelink-&gt;add(&amp;shloop);
<a name="l22436"></a>22436     }
<a name="l22437"></a>22437   }
<a name="l22438"></a>22438 
<a name="l22439"></a>22439   <span class="comment">// Each edge ab of boundedgelink will be finished by finding a vertex c</span>
<a name="l22440"></a>22440   <span class="comment">//   which is a vertex of the missing region, such that:</span>
<a name="l22441"></a>22441   <span class="comment">//   (1) abc is inside the missing region, i.e., abc intersects at least</span>
<a name="l22442"></a>22442   <span class="comment">//       one of missing subfaces (saved in missingshlist);</span>
<a name="l22443"></a>22443   <span class="comment">//   (2) abc is not intersect with any previously created new subfaces</span>
<a name="l22444"></a>22444   <span class="comment">//       in the missing region (saved in newshlink).</span>
<a name="l22445"></a>22445   <span class="comment">//   After abc is created, it will be inserted into both the surface mesh</span>
<a name="l22446"></a>22446   <span class="comment">//   and the DT. The boundedgelink will be updated, ab is removed, bc and</span>
<a name="l22447"></a>22447   <span class="comment">//   ca will be added if they are open.</span>
<a name="l22448"></a>22448 
<a name="l22449"></a>22449   <span class="keywordflow">while</span> (boundedgelink-&gt;len() &gt; 0) {
<a name="l22450"></a>22450     <span class="comment">// Remove an edge (ab) from the link.</span>
<a name="l22451"></a>22451     shloop = * (face *) boundedgelink-&gt;del(1);
<a name="l22452"></a>22452     <span class="comment">// &#39;workseg&#39; indicates it is a segment or not.</span>
<a name="l22453"></a>22453     sspivot(shloop, workseg);
<a name="l22454"></a>22454     torg = sorg(shloop);  <span class="comment">// torg = a;</span>
<a name="l22455"></a>22455     tdest = sdest(shloop);  <span class="comment">// tdest = b;</span>
<a name="l22456"></a>22456     <span class="comment">// Find a tetrahedron containing ab.</span>
<a name="l22457"></a>22457     getsearchtet(torg, tdest, &amp;starttet, &amp;workpt);
<a name="l22458"></a>22458     collinear = finddirection(&amp;starttet, workpt, tetrahedrons-&gt;items);
<a name="l22459"></a>22459     <span class="keywordflow">if</span> (collinear == LEFTCOLLINEAR) {
<a name="l22460"></a>22460       enext2self(starttet);
<a name="l22461"></a>22461       esymself(starttet);
<a name="l22462"></a>22462     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == TOPCOLLINEAR) {
<a name="l22463"></a>22463       fnextself(starttet);
<a name="l22464"></a>22464       enext2self(starttet);
<a name="l22465"></a>22465       esymself(starttet);
<a name="l22466"></a>22466     }
<a name="l22467"></a>22467     assert(dest(starttet) == workpt);
<a name="l22468"></a>22468     <span class="comment">// Checking faces around ab until a valid face is found.</span>
<a name="l22469"></a>22469     matchflag = <span class="keyword">false</span>;
<a name="l22470"></a>22470     spintet = starttet;
<a name="l22471"></a>22471     hitbdry = 0;
<a name="l22472"></a>22472     <span class="keywordflow">do</span> {
<a name="l22473"></a>22473       workpt = apex(spintet);
<a name="l22474"></a>22474       idx = pointmark(workpt) - in-&gt;firstnumber;
<a name="l22475"></a>22475       <span class="keywordflow">if</span> (worklist[idx] == 1) {
<a name="l22476"></a>22476         <span class="comment">// (trog, tdest, workpt) is on the facet. Check if it satisfies (1).</span>
<a name="l22477"></a>22477         finishflag = <span class="keyword">false</span>;
<a name="l22478"></a>22478         <span class="keywordflow">for</span> (i = 0; i &lt; missingshlist-&gt;len(); i++) {
<a name="l22479"></a>22479           worksh = * (face *)(* missingshlist)[i];
<a name="l22480"></a>22480           spt1 = sorg(worksh);
<a name="l22481"></a>22481           spt2 = sdest(worksh);
<a name="l22482"></a>22482           spt3 = sapex(worksh);
<a name="l22483"></a>22483           <span class="comment">// Does bc intersect the face?</span>
<a name="l22484"></a>22484           <span class="keywordflow">if</span> (tri_edge_cop_inter(spt1, spt2, spt3, tdest, workpt, abovepoint)
<a name="l22485"></a>22485               == INTERSECT) {
<a name="l22486"></a>22486             finishflag = <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l22487"></a>22487           }
<a name="l22488"></a>22488           <span class="comment">// Does ca intersect the face?</span>
<a name="l22489"></a>22489           <span class="keywordflow">if</span> (tri_edge_cop_inter(spt1, spt2, spt3, workpt, torg, abovepoint)
<a name="l22490"></a>22490               == INTERSECT) {
<a name="l22491"></a>22491             finishflag = <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l22492"></a>22492           }
<a name="l22493"></a>22493           <span class="comment">// Does c inside the face?</span>
<a name="l22494"></a>22494           <span class="keywordflow">if</span> (tri_vert_cop_inter(spt1, spt2, spt3, workpt, abovepoint)
<a name="l22495"></a>22495               == INTERSECT) {
<a name="l22496"></a>22496             finishflag = <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l22497"></a>22497           }
<a name="l22498"></a>22498         }
<a name="l22499"></a>22499         <span class="keywordflow">if</span> (finishflag) {
<a name="l22500"></a>22500           <span class="comment">// Satisfying (1). Check if it satisfies (2).</span>
<a name="l22501"></a>22501           matchflag = <span class="keyword">true</span>;
<a name="l22502"></a>22502           <span class="keywordflow">for</span> (i = 0; i &lt; newshlink-&gt;len() &amp;&amp; matchflag; i++) {
<a name="l22503"></a>22503             worksh = * (face *) newshlink-&gt;getnitem(i + 1);
<a name="l22504"></a>22504             spt1 = sorg(worksh);
<a name="l22505"></a>22505             spt2 = sdest(worksh);
<a name="l22506"></a>22506             spt3 = sapex(worksh);
<a name="l22507"></a>22507             <span class="comment">// Does bc intersect the face?</span>
<a name="l22508"></a>22508             <span class="keywordflow">if</span> (tri_edge_cop_inter(spt1, spt2, spt3, tdest, workpt, abovepoint)
<a name="l22509"></a>22509                 == INTERSECT) {
<a name="l22510"></a>22510               matchflag = <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l22511"></a>22511             }
<a name="l22512"></a>22512             <span class="comment">// Does ca intersect the face?</span>
<a name="l22513"></a>22513             <span class="keywordflow">if</span> (tri_edge_cop_inter(spt1, spt2, spt3, workpt, torg, abovepoint)
<a name="l22514"></a>22514                 == INTERSECT) {
<a name="l22515"></a>22515               matchflag = <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l22516"></a>22516             }
<a name="l22517"></a>22517             <span class="comment">// Does c inside the face?</span>
<a name="l22518"></a>22518             <span class="keywordflow">if</span> (tri_vert_cop_inter(spt1, spt2, spt3, workpt, abovepoint)
<a name="l22519"></a>22519                 == INTERSECT) {
<a name="l22520"></a>22520               matchflag = <span class="keyword">false</span>; <span class="keywordflow">break</span>;
<a name="l22521"></a>22521             }
<a name="l22522"></a>22522           }
<a name="l22523"></a>22523         }
<a name="l22524"></a>22524         <span class="keywordflow">if</span> (matchflag == <span class="keyword">true</span>) {
<a name="l22525"></a>22525           <span class="comment">// Satisfying both (1) and (2). Find abc.</span>
<a name="l22526"></a>22526           <span class="keywordflow">break</span>;
<a name="l22527"></a>22527         }
<a name="l22528"></a>22528       }
<a name="l22529"></a>22529       <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l22530"></a>22530         hitbdry ++;
<a name="l22531"></a>22531         <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l22532"></a>22532           esym(starttet, spintet);
<a name="l22533"></a>22533           <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l22534"></a>22534             hitbdry ++;
<a name="l22535"></a>22535           }
<a name="l22536"></a>22536         }
<a name="l22537"></a>22537       }
<a name="l22538"></a>22538     } <span class="keywordflow">while</span> (hitbdry &lt; 2 &amp;&amp; apex(spintet) != apex(starttet));
<a name="l22539"></a>22539     assert(matchflag == <span class="keyword">true</span>);
<a name="l22540"></a>22540     tspivot(spintet, neighsh);
<a name="l22541"></a>22541     <span class="keywordflow">if</span> (neighsh.sh != dummysh) {
<a name="l22542"></a>22542       printf(<span class="stringliteral">&quot;Error:  Invalid PLC.\n&quot;</span>);
<a name="l22543"></a>22543       printf(<span class="stringliteral">&quot;  Facet #%d and facet #%d overlap each other.\n&quot;</span>,
<a name="l22544"></a>22544              shellmark(neighsh), shellmark(shloop));
<a name="l22545"></a>22545       printf(<span class="stringliteral">&quot;  It might be caused by a facet is defined more than once.\n&quot;</span>);
<a name="l22546"></a>22546       printf(<span class="stringliteral">&quot;  Hint:  Use -d switch to find all overlapping facets.\n&quot;</span>);
<a name="l22547"></a>22547       exit(1);
<a name="l22548"></a>22548     }
<a name="l22549"></a>22549     <span class="comment">// The side of &#39;spintet&#39; is at which a new subface will be attached.</span>
<a name="l22550"></a>22550     adjustedgering(spintet, CCW);
<a name="l22551"></a>22551     <span class="comment">// Create the new subface.</span>
<a name="l22552"></a>22552     makeshellface(subfaces, &amp;newsh);
<a name="l22553"></a>22553     setsorg(newsh, org(spintet));
<a name="l22554"></a>22554     setsdest(newsh, dest(spintet));
<a name="l22555"></a>22555     setsapex(newsh, apex(spintet));
<a name="l22556"></a>22556     <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l22557"></a>22557       setareabound(newsh, area);
<a name="l22558"></a>22558     }
<a name="l22559"></a>22559     <span class="keywordflow">if</span> (checkpbcs) {
<a name="l22560"></a>22560       setshellpbcgroup(newsh, pbcgp);
<a name="l22561"></a>22561     }
<a name="l22562"></a>22562     setshellmark(newsh, shmark);
<a name="l22563"></a>22563     setshelltype(newsh, shtype);  <span class="comment">// It may be a skinny subface.</span>
<a name="l22564"></a>22564     <span class="comment">// Add newsh into newshlink for intersecting checking.</span>
<a name="l22565"></a>22565     newshlink-&gt;add(&amp;newsh);
<a name="l22566"></a>22566     <span class="comment">// Insert it into the current mesh.</span>
<a name="l22567"></a>22567     tsbond(spintet, newsh);
<a name="l22568"></a>22568     sym(spintet, neightet);
<a name="l22569"></a>22569     <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l22570"></a>22570       sesym(newsh, neighsh);
<a name="l22571"></a>22571       tsbond(neightet, neighsh);
<a name="l22572"></a>22572     }
<a name="l22573"></a>22573     <span class="comment">// Insert it into the surface mesh.</span>
<a name="l22574"></a>22574     sspivot(shloop, workseg);
<a name="l22575"></a>22575     <span class="keywordflow">if</span> (workseg.sh == dummysh) {
<a name="l22576"></a>22576       sbond(shloop, newsh);
<a name="l22577"></a>22577     } <span class="keywordflow">else</span> {
<a name="l22578"></a>22578       <span class="comment">// There is a subsegment, &#39;shloop&#39; is the subface which is going to</span>
<a name="l22579"></a>22579       <span class="comment">//   die. Insert the &#39;newsh&#39; at the place of &#39;shloop&#39; into its face</span>
<a name="l22580"></a>22580       <span class="comment">//   link, so as to dettach &#39;shloop&#39;.   The original connection is:</span>
<a name="l22581"></a>22581       <span class="comment">//   -&gt; casingin -&gt; shloop -&gt; casingout -&gt;, it will be changed with:</span>
<a name="l22582"></a>22582       <span class="comment">//   -&gt; casingin -&gt;  newsh -&gt; casingout -&gt;.  Pay attention to the</span>
<a name="l22583"></a>22583       <span class="comment">//   case when this subsegment is dangling in the mesh, i.e., &#39;shloop&#39;</span>
<a name="l22584"></a>22584       <span class="comment">//   is bonded to itself.</span>
<a name="l22585"></a>22585       spivot(shloop, casingout);
<a name="l22586"></a>22586       <span class="keywordflow">if</span> (shloop.sh != casingout.sh) {
<a name="l22587"></a>22587         <span class="comment">// &#39;shloop&#39; is not bonded to itself.</span>
<a name="l22588"></a>22588         spinsh = casingout;
<a name="l22589"></a>22589         <span class="keywordflow">do</span> {
<a name="l22590"></a>22590           casingin = spinsh;
<a name="l22591"></a>22591           spivotself(spinsh);
<a name="l22592"></a>22592         } <span class="keywordflow">while</span> (sapex(spinsh) != sapex(shloop));
<a name="l22593"></a>22593         assert(casingin.sh != shloop.sh);
<a name="l22594"></a>22594         <span class="comment">// Bond casingin -&gt; newsh -&gt; casingout.</span>
<a name="l22595"></a>22595         sbond1(casingin, newsh);
<a name="l22596"></a>22596         sbond1(newsh, casingout);
<a name="l22597"></a>22597       } <span class="keywordflow">else</span> {
<a name="l22598"></a>22598         <span class="comment">// Bond newsh -&gt; newsh.</span>
<a name="l22599"></a>22599         sbond(newsh, newsh);
<a name="l22600"></a>22600       }
<a name="l22601"></a>22601       <span class="comment">// Bond the segment.</span>
<a name="l22602"></a>22602       ssbond(newsh, workseg);
<a name="l22603"></a>22603     }
<a name="l22604"></a>22604     <span class="comment">// Check other two sides of this new subface.  If a side is not bonded</span>
<a name="l22605"></a>22605     <span class="comment">//   to any edge in the link, it will be added to the link.</span>
<a name="l22606"></a>22606     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l22607"></a>22607       <span class="keywordflow">if</span> (i == 0) {
<a name="l22608"></a>22608         senext(newsh, worksh);
<a name="l22609"></a>22609       } <span class="keywordflow">else</span> {
<a name="l22610"></a>22610         senext2(newsh, worksh);
<a name="l22611"></a>22611       }
<a name="l22612"></a>22612       torg = sorg(worksh);
<a name="l22613"></a>22613       tdest = sdest(worksh);
<a name="l22614"></a>22614       finishflag = <span class="keyword">false</span>;
<a name="l22615"></a>22615       <span class="keywordflow">for</span> (j = 0; j &lt; boundedgelink-&gt;len() &amp;&amp; !finishflag; j++) {
<a name="l22616"></a>22616         neighsh = * (face *) boundedgelink-&gt;getnitem(j + 1);
<a name="l22617"></a>22617         <span class="keywordflow">if</span> ((sorg(neighsh) == torg &amp;&amp; sdest(neighsh) == tdest) ||
<a name="l22618"></a>22618             (sorg(neighsh) == tdest &amp;&amp; sdest(neighsh) == torg)) {
<a name="l22619"></a>22619           <span class="comment">// Find a boundary edge.  Bond them and exit the loop.</span>
<a name="l22620"></a>22620           sspivot(neighsh, workseg);
<a name="l22621"></a>22621           <span class="keywordflow">if</span> (workseg.sh == dummysh) {
<a name="l22622"></a>22622             sbond(neighsh, worksh);
<a name="l22623"></a>22623           } <span class="keywordflow">else</span> {
<a name="l22624"></a>22624             <span class="comment">// There is a subsegment, &#39;neighsh&#39; is the subface which is</span>
<a name="l22625"></a>22625             <span class="comment">//   going to die. Do the same as above for &#39;worksh&#39;.</span>
<a name="l22626"></a>22626             spivot(neighsh, casingout);
<a name="l22627"></a>22627             <span class="keywordflow">if</span> (neighsh.sh != casingout.sh) {
<a name="l22628"></a>22628               <span class="comment">// &#39;neighsh&#39; is not bonded to itself.</span>
<a name="l22629"></a>22629               spinsh = casingout;
<a name="l22630"></a>22630               <span class="keywordflow">do</span> {
<a name="l22631"></a>22631                 casingin = spinsh;
<a name="l22632"></a>22632                 spivotself(spinsh);
<a name="l22633"></a>22633               } <span class="keywordflow">while</span> (sapex(spinsh) != sapex(neighsh));
<a name="l22634"></a>22634               assert(casingin.sh != neighsh.sh);
<a name="l22635"></a>22635               <span class="comment">// Bond casingin -&gt; worksh -&gt; casingout.</span>
<a name="l22636"></a>22636               sbond1(casingin, worksh);
<a name="l22637"></a>22637               sbond1(worksh, casingout);
<a name="l22638"></a>22638             } <span class="keywordflow">else</span> {
<a name="l22639"></a>22639               <span class="comment">// Bond worksh -&gt; worksh.</span>
<a name="l22640"></a>22640               sbond(worksh, worksh);
<a name="l22641"></a>22641             }
<a name="l22642"></a>22642             <span class="comment">// Bond the segment.</span>
<a name="l22643"></a>22643             ssbond(worksh, workseg);
<a name="l22644"></a>22644           }
<a name="l22645"></a>22645           <span class="comment">// Remove this boundary edge from the link.</span>
<a name="l22646"></a>22646           boundedgelink-&gt;del(j + 1);
<a name="l22647"></a>22647           finishflag = <span class="keyword">true</span>;
<a name="l22648"></a>22648         }
<a name="l22649"></a>22649       }
<a name="l22650"></a>22650       <span class="keywordflow">if</span> (!finishflag) {
<a name="l22651"></a>22651         <span class="comment">// It&#39;s a new boundary edge, add it to link.</span>
<a name="l22652"></a>22652         boundedgelink-&gt;add(&amp;worksh);
<a name="l22653"></a>22653       }
<a name="l22654"></a>22654     }
<a name="l22655"></a>22655   }
<a name="l22656"></a>22656 
<a name="l22657"></a>22657   <span class="comment">// Deallocate the set of old missing subfaces.</span>
<a name="l22658"></a>22658   <span class="keywordflow">for</span> (i = 0; i &lt; missingshlist-&gt;len(); i++) {
<a name="l22659"></a>22659     worksh = * (face *)(* missingshlist)[i];
<a name="l22660"></a>22660     shellfacedealloc(subfaces, worksh.sh);
<a name="l22661"></a>22661   }
<a name="l22662"></a>22662   <span class="comment">// Unmark region vertices in &#39;worklist&#39;.</span>
<a name="l22663"></a>22663   <span class="keywordflow">for</span> (i = 0; i &lt; equatptlist-&gt;len(); i++) {
<a name="l22664"></a>22664     workpt = * (point *)(* equatptlist)[i];
<a name="l22665"></a>22665     idx = pointmark(workpt) - in-&gt;firstnumber;
<a name="l22666"></a>22666     worklist[idx] = 0;
<a name="l22667"></a>22667   }
<a name="l22668"></a>22668 
<a name="l22669"></a>22669   <span class="keyword">delete</span> boundedgelink;
<a name="l22670"></a>22670   <span class="keyword">delete</span> newshlink;
<a name="l22671"></a>22671 }
<a name="l22672"></a>22672 
<a name="l22674"></a>22674 <span class="comment">//                                                                           //</span>
<a name="l22675"></a>22675 <span class="comment">// scoutcrossingedge()    Search an edge crossing the missing region.        //</span>
<a name="l22676"></a>22676 <span class="comment">//                                                                           //</span>
<a name="l22677"></a>22677 <span class="comment">// &#39;missingshlist&#39; forms the missing region R. This routine searches for an  //</span>
<a name="l22678"></a>22678 <span class="comment">// edge crossing R.  It first forms a &#39;boundedgelist&#39; consisting of the      //</span>
<a name="l22679"></a>22679 <span class="comment">// boundary edges of R. Such edges are existing in CDT.  A crossing edge is  //</span>
<a name="l22680"></a>22680 <span class="comment">// found by rotating faces around one of the boundary edges. It is possible  //</span>
<a name="l22681"></a>22681 <span class="comment">// there is no edge crosses R (e.g. R has a degenerate point set).           //</span>
<a name="l22682"></a>22682 <span class="comment">//                                                                           //</span>
<a name="l22683"></a>22683 <span class="comment">// If find a croosing edge, return TRUE, &#39;crossedgelist&#39; contains this edge. //</span>
<a name="l22684"></a>22684 <span class="comment">// Otherwise, return FALSE.                                                  //</span>
<a name="l22685"></a>22685 <span class="comment">//                                                                           //</span>
<a name="l22687"></a>22687 <span class="comment"></span>
<a name="l22688"></a>22688 <span class="keywordtype">bool</span> tetgenmesh::scoutcrossingedge(list* missingshlist, list* boundedgelist,
<a name="l22689"></a>22689   list* crossedgelist, <span class="keywordtype">int</span>* worklist)
<a name="l22690"></a>22690 {
<a name="l22691"></a>22691   triface starttet, spintet, worktet;
<a name="l22692"></a>22692   face startsh, neighsh, worksh, workseg;
<a name="l22693"></a>22693   point torg, tdest, tapex;
<a name="l22694"></a>22694   point workpt[3], pa, pb, pc;
<a name="l22695"></a>22695   <span class="keyword">enum</span> finddirectionresult collinear;
<a name="l22696"></a>22696   REAL ori1, ori2;
<a name="l22697"></a>22697   <span class="keywordtype">bool</span> crossflag;
<a name="l22698"></a>22698   <span class="keywordtype">int</span> hitbdry;
<a name="l22699"></a>22699   <span class="keywordtype">int</span> i, j, k;
<a name="l22700"></a>22700 
<a name="l22701"></a>22701   <span class="comment">// Form the &#39;boundedgelist&#39;. Loop through &#39;missingshlist&#39;, check each</span>
<a name="l22702"></a>22702   <span class="comment">//   edge of these subfaces. If an edge is a segment or the neighbor</span>
<a name="l22703"></a>22703   <span class="comment">//   subface is uninfected, add it to &#39;boundedgelist&#39;.</span>
<a name="l22704"></a>22704   <span class="keywordflow">for</span> (i = 0; i &lt; missingshlist-&gt;len(); i++) {
<a name="l22705"></a>22705     worksh = * (face *)(* missingshlist)[i];
<a name="l22706"></a>22706     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l22707"></a>22707       sspivot(worksh, workseg);
<a name="l22708"></a>22708       <span class="keywordflow">if</span> (workseg.sh == dummysh) {
<a name="l22709"></a>22709         spivot(worksh, neighsh);
<a name="l22710"></a>22710         <span class="keywordflow">if</span> (!sinfected(neighsh)) {
<a name="l22711"></a>22711           boundedgelist-&gt;append(&amp;worksh);
<a name="l22712"></a>22712         }
<a name="l22713"></a>22713       } <span class="keywordflow">else</span> {
<a name="l22714"></a>22714         boundedgelist-&gt;append(&amp;worksh);
<a name="l22715"></a>22715       }
<a name="l22716"></a>22716       senextself(worksh);
<a name="l22717"></a>22717     }
<a name="l22718"></a>22718   }
<a name="l22719"></a>22719 
<a name="l22720"></a>22720   crossflag = <span class="keyword">false</span>;
<a name="l22721"></a>22721   <span class="comment">// Find a crossing edge. It is possible there is no such edge. We need to</span>
<a name="l22722"></a>22722   <span class="comment">//   loop through all edges of &#39;boundedgelist&#39; for sure we don&#39;t miss any.</span>
<a name="l22723"></a>22723   <span class="keywordflow">for</span> (i = 0; i &lt; boundedgelist-&gt;len() &amp;&amp; !crossflag; i++) {
<a name="l22724"></a>22724     startsh = * (face *)(* boundedgelist)[i];
<a name="l22725"></a>22725     <span class="comment">// &#39;startsh&#39; (abc) holds an existing edge of the DT, find it.</span>
<a name="l22726"></a>22726     torg = sorg(startsh);
<a name="l22727"></a>22727     tdest = sdest(startsh);
<a name="l22728"></a>22728     tapex = sapex(startsh);
<a name="l22729"></a>22729     getsearchtet(torg, tdest, &amp;starttet, &amp;workpt[0]);
<a name="l22730"></a>22730     collinear = finddirection(&amp;starttet, workpt[0], tetrahedrons-&gt;items);
<a name="l22731"></a>22731     <span class="keywordflow">if</span> (collinear == LEFTCOLLINEAR) {
<a name="l22732"></a>22732       enext2self(starttet);
<a name="l22733"></a>22733       esymself(starttet);
<a name="l22734"></a>22734     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (collinear == TOPCOLLINEAR) {
<a name="l22735"></a>22735       fnextself(starttet);
<a name="l22736"></a>22736       enext2self(starttet);
<a name="l22737"></a>22737       esymself(starttet);
<a name="l22738"></a>22738     }
<a name="l22739"></a>22739 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l22740"></a>22740 <span class="preprocessor"></span>    assert(dest(starttet) == workpt[0]);
<a name="l22741"></a>22741 <span class="preprocessor">#endif</span>
<a name="l22742"></a>22742 <span class="preprocessor"></span>    <span class="comment">// Now starttet holds edge ab. Find is edge de crossing R.</span>
<a name="l22743"></a>22743     spintet = starttet;
<a name="l22744"></a>22744     hitbdry = 0;
<a name="l22745"></a>22745     <span class="keywordflow">do</span> {
<a name="l22746"></a>22746       <span class="keywordflow">if</span> (fnextself(spintet)) {
<a name="l22747"></a>22747         <span class="comment">// splittet = abde. Check if de crosses abc.</span>
<a name="l22748"></a>22748         workpt[1] = apex(spintet);  <span class="comment">// workpt[1] = d.</span>
<a name="l22749"></a>22749         workpt[2] = oppo(spintet);  <span class="comment">// workpt[2] = e.</span>
<a name="l22750"></a>22750         j = pointmark(workpt[1]) - in-&gt;firstnumber;
<a name="l22751"></a>22751         k = pointmark(workpt[2]) - in-&gt;firstnumber;
<a name="l22752"></a>22752         <span class="keywordflow">if</span> (worklist[j] == 1) {
<a name="l22753"></a>22753           ori1 = 0.0; <span class="comment">// d is a vertex of the missing region.</span>
<a name="l22754"></a>22754         } <span class="keywordflow">else</span> {
<a name="l22755"></a>22755           <span class="comment">// Get the orientation of d wrt. abc.</span>
<a name="l22756"></a>22756           ori1 = orient3d(torg, tdest, tapex, workpt[1]);
<a name="l22757"></a>22757         }
<a name="l22758"></a>22758         <span class="keywordflow">if</span> (worklist[k] == 1) {
<a name="l22759"></a>22759           ori2 = 0.0; <span class="comment">// e is a vertex of the missing region.</span>
<a name="l22760"></a>22760         } <span class="keywordflow">else</span> {
<a name="l22761"></a>22761           <span class="comment">// Get the orientation of e wrt. abc.</span>
<a name="l22762"></a>22762           ori2 = orient3d(torg, tdest, tapex, workpt[2]);
<a name="l22763"></a>22763         }
<a name="l22764"></a>22764         <span class="comment">// Only do check if d and e locate on different sides of abc.</span>
<a name="l22765"></a>22765         <span class="keywordflow">if</span> (ori1 * ori2 &lt; 0.0) {
<a name="l22766"></a>22766           <span class="comment">// Check if de crosses any subface of R.</span>
<a name="l22767"></a>22767           <span class="keywordflow">for</span> (j = 0; j &lt; missingshlist-&gt;len(); j++) {
<a name="l22768"></a>22768             worksh = * (face *)(* missingshlist)[j];
<a name="l22769"></a>22769             pa = sorg(worksh);
<a name="l22770"></a>22770             pb = sdest(worksh);
<a name="l22771"></a>22771             pc = sapex(worksh);
<a name="l22772"></a>22772             crossflag = (tri_tri_inter(pa, pb, pc, workpt[0], workpt[1],
<a name="l22773"></a>22773                                        workpt[2]) == INTERSECT);
<a name="l22774"></a>22774             <span class="keywordflow">if</span> (crossflag) {
<a name="l22775"></a>22775               <span class="comment">// Find a crossing edge. We&#39;re done.</span>
<a name="l22776"></a>22776               worktet = spintet;
<a name="l22777"></a>22777               adjustedgering(worktet, CCW);
<a name="l22778"></a>22778               enextfnextself(worktet);
<a name="l22779"></a>22779               enextself(worktet);
<a name="l22780"></a>22780               <span class="comment">// Add this edge (worktet) into &#39;crossedgelist&#39;.</span>
<a name="l22781"></a>22781               crossedgelist-&gt;append(&amp;worktet);
<a name="l22782"></a>22782               <span class="keywordflow">break</span>;
<a name="l22783"></a>22783             }
<a name="l22784"></a>22784           }
<a name="l22785"></a>22785           <span class="keywordflow">if</span> (crossflag) <span class="keywordflow">break</span>;
<a name="l22786"></a>22786         }
<a name="l22787"></a>22787         <span class="keywordflow">if</span> (apex(spintet) == apex(starttet)) <span class="keywordflow">break</span>;
<a name="l22788"></a>22788       } <span class="keywordflow">else</span> {
<a name="l22789"></a>22789         hitbdry++;
<a name="l22790"></a>22790         <span class="comment">// It is only possible to hit boundary once.</span>
<a name="l22791"></a>22791         <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l22792"></a>22792           esym(starttet, spintet);
<a name="l22793"></a>22793         }
<a name="l22794"></a>22794       }
<a name="l22795"></a>22795     } <span class="keywordflow">while</span> (hitbdry &lt; 2);
<a name="l22796"></a>22796   }
<a name="l22797"></a>22797 
<a name="l22798"></a>22798   <span class="keywordflow">return</span> crossflag;
<a name="l22799"></a>22799 }
<a name="l22800"></a>22800 
<a name="l22802"></a>22802 <span class="comment">//                                                                           //</span>
<a name="l22803"></a>22803 <span class="comment">// formcavity()    Form the cavity for recovering the missing region.        //</span>
<a name="l22804"></a>22804 <span class="comment">//                                                                           //</span>
<a name="l22805"></a>22805 <span class="comment">// The cavity C is bounded by faces of current CDT.  All tetrahedra inside C //</span>
<a name="l22806"></a>22806 <span class="comment">// will be removed, intead a set of constrained Delaunay tetrahedra will be  //</span>
<a name="l22807"></a>22807 <span class="comment">// filled in and the missing region are recovered.                           //</span>
<a name="l22808"></a>22808 <span class="comment">//                                                                           //</span>
<a name="l22809"></a>22809 <span class="comment">// &#39;missingshlist&#39; contains a set of subfaces forming the missing region R.  //</span>
<a name="l22810"></a>22810 <span class="comment">// C is formed by first finding all the tetrahedra in CDT that intersect the //</span>
<a name="l22811"></a>22811 <span class="comment">// relative interior of R; then deleting them from the CDT, this will form C //</span>
<a name="l22812"></a>22812 <span class="comment">// inside the CDT. At the beginning, &#39;crossedgelist&#39; contains an edge which  //</span>
<a name="l22813"></a>22813 <span class="comment">// is crossing R. All tets containing this edge must cross R. Start from it, //</span>
<a name="l22814"></a>22814 <span class="comment">// other crossing edges can be found incrementally.  The discovered crossing //</span>
<a name="l22815"></a>22815 <span class="comment">// tets are saved in &#39;crosstetlist&#39;.                                         //</span>
<a name="l22816"></a>22816 <span class="comment">//                                                                           //</span>
<a name="l22817"></a>22817 <span class="comment">// Notice that not all tets in &#39;crosstetlist&#39; are crossing R. The discovered //</span>
<a name="l22818"></a>22818 <span class="comment">// tets are connected each other. However, there may be other tets crossing  //</span>
<a name="l22819"></a>22819 <span class="comment">// R but disjoint with the found tets. Due to this fact we need to check the //</span>
<a name="l22820"></a>22820 <span class="comment">// &#39;missingshlist&#39; once more. Only recover those subfaces which are crossed  //</span>
<a name="l22821"></a>22821 <span class="comment">// by the set of discovered tets, i.e., R may be shrinked to conform the set //</span>
<a name="l22822"></a>22822 <span class="comment">// of discovered tets. The extra subfaces of R will be recovered later.      //</span>
<a name="l22823"></a>22823 <span class="comment">//                                                                           //</span>
<a name="l22824"></a>22824 <span class="comment">// Notice that some previous recovered subfaces may completely included in C.//</span>
<a name="l22825"></a>22825 <span class="comment">// This can happen when R is very big and these subfaces lie above R and so  //</span>
<a name="l22826"></a>22826 <span class="comment">// close to it. Such subfaces have to be queued (and sinfected()) to recover //</span>
<a name="l22827"></a>22827 <span class="comment">// them later. Otherwise, we lost the connection to these subfaces forever.  //</span>
<a name="l22828"></a>22828 <span class="comment">//                                                                           //</span>
<a name="l22830"></a>22830 <span class="comment"></span>
<a name="l22831"></a>22831 <span class="keywordtype">void</span> tetgenmesh::formcavity(list* missingshlist, list* crossedgelist,
<a name="l22832"></a>22832   list* equatptlist, list* crossshlist, list* crosstetlist,
<a name="l22833"></a>22833   list* belowfacelist, list* abovefacelist, list* horizptlist,
<a name="l22834"></a>22834   list* belowptlist, list* aboveptlist, queue* missingshqueue, <span class="keywordtype">int</span>* worklist)
<a name="l22835"></a>22835 {
<a name="l22836"></a>22836   triface starttet, spintet, neightet, worktet;
<a name="l22837"></a>22837   face startsh, neighsh, worksh, workseg;
<a name="l22838"></a>22838   point torg, tdest, tapex, workpt[3];
<a name="l22839"></a>22839   REAL checksign, orgori, destori;
<a name="l22840"></a>22840   <span class="keywordtype">bool</span> crossflag, inlistflag;
<a name="l22841"></a>22841   <span class="keywordtype">bool</span> belowflag, aboveflag;
<a name="l22842"></a>22842   <span class="keywordtype">int</span> idx, share;
<a name="l22843"></a>22843   <span class="keywordtype">int</span> i, j, k;
<a name="l22844"></a>22844 
<a name="l22845"></a>22845   <span class="comment">// Get a face at horizon.</span>
<a name="l22846"></a>22846   startsh = * (face *)(* missingshlist)[0];
<a name="l22847"></a>22847   torg = sorg(startsh);
<a name="l22848"></a>22848   tdest = sdest(startsh);
<a name="l22849"></a>22849   tapex = sapex(startsh);
<a name="l22850"></a>22850 
<a name="l22851"></a>22851   <span class="comment">// Collect the set of crossing tetrahedra by rotating crossing edges.</span>
<a name="l22852"></a>22852   <span class="keywordflow">for</span> (i = 0; i &lt; crossedgelist-&gt;len(); i++) {
<a name="l22853"></a>22853     <span class="comment">// Get a tet abcd, ab is a crossing edge.</span>
<a name="l22854"></a>22854     starttet = * (triface *)(* crossedgelist)[i];
<a name="l22855"></a>22855     adjustedgering(starttet, CCW);
<a name="l22856"></a>22856     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l22857"></a>22857       printf(<span class="stringliteral">&quot;    Collect tets containing edge (%d, %d).\n&quot;</span>,
<a name="l22858"></a>22858              pointmark(org(starttet)), pointmark(dest(starttet)));
<a name="l22859"></a>22859     }
<a name="l22860"></a>22860     orgori = orient3d(torg, tdest, tapex, org(starttet));
<a name="l22861"></a>22861     destori = orient3d(torg, tdest, tapex, dest(starttet));
<a name="l22862"></a>22862 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l22863"></a>22863 <span class="preprocessor"></span>    assert(orgori * destori &lt; 0.0);
<a name="l22864"></a>22864 <span class="preprocessor">#endif</span>
<a name="l22865"></a>22865 <span class="preprocessor"></span>    spintet = starttet;
<a name="l22866"></a>22866     <span class="keywordflow">do</span> {
<a name="l22867"></a>22867       <span class="comment">// The face rotation should not meet boundary.</span>
<a name="l22868"></a>22868       fnextself(spintet);
<a name="l22869"></a>22869       <span class="comment">// Check the validity of the PLC.</span>
<a name="l22870"></a>22870       tspivot(spintet, worksh);
<a name="l22871"></a>22871       <span class="keywordflow">if</span> (worksh.sh != dummysh) {
<a name="l22872"></a>22872         printf(<span class="stringliteral">&quot;Error:  Invalid PLC.\n&quot;</span>);
<a name="l22873"></a>22873         printf(<span class="stringliteral">&quot;  Two subfaces (%d, %d, %d) and (%d, %d, %d)\n&quot;</span>,
<a name="l22874"></a>22874                pointmark(torg), pointmark(tdest), pointmark(tapex),
<a name="l22875"></a>22875                pointmark(sorg(worksh)), pointmark(sdest(worksh)),
<a name="l22876"></a>22876                pointmark(sapex(worksh)));
<a name="l22877"></a>22877         printf(<span class="stringliteral">&quot;  are found intersecting each other.\n&quot;</span>);
<a name="l22878"></a>22878         printf(<span class="stringliteral">&quot;  Hint:  Use -d switch to find all intersecting facets.\n&quot;</span>);
<a name="l22879"></a>22879         terminatetetgen(1);
<a name="l22880"></a>22880       }
<a name="l22881"></a>22881       <span class="keywordflow">if</span> (!infected(spintet)) {
<a name="l22882"></a>22882         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l22883"></a>22883           printf(<span class="stringliteral">&quot;      Add crossing tet (%d, %d, %d, %d).\n&quot;</span>,
<a name="l22884"></a>22884                  pointmark(org(spintet)), pointmark(dest(spintet)),
<a name="l22885"></a>22885                  pointmark(apex(spintet)), pointmark(oppo(spintet)));
<a name="l22886"></a>22886         }
<a name="l22887"></a>22887         infect(spintet);
<a name="l22888"></a>22888         crosstetlist-&gt;append(&amp;spintet);
<a name="l22889"></a>22889       }
<a name="l22890"></a>22890       <span class="comment">// Check whether other two edges of &#39;spintet&#39; is a crossing edge.</span>
<a name="l22891"></a>22891       <span class="comment">//   It can be quickly checked from the apex of &#39;spintet&#39;, if it is</span>
<a name="l22892"></a>22892       <span class="comment">//   not on the facet, then there exists a crossing edge.</span>
<a name="l22893"></a>22893       workpt[0] = apex(spintet);
<a name="l22894"></a>22894       idx = pointmark(workpt[0]) - in-&gt;firstnumber;
<a name="l22895"></a>22895       <span class="keywordflow">if</span> (worklist[idx] != 1) {
<a name="l22896"></a>22896         <span class="comment">// Either edge (dest, apex) or edge (apex, org) crosses.</span>
<a name="l22897"></a>22897         checksign = orient3d(torg, tdest, tapex, workpt[0]);
<a name="l22898"></a>22898 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l22899"></a>22899 <span class="preprocessor"></span>        assert(checksign != 0.0);
<a name="l22900"></a>22900 <span class="preprocessor">#endif</span>
<a name="l22901"></a>22901 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (checksign * orgori &lt; 0.0) {
<a name="l22902"></a>22902           enext2(spintet, worktet); <span class="comment">// edge (apex, org).</span>
<a name="l22903"></a>22903           workpt[1] = org(spintet);
<a name="l22904"></a>22904         } <span class="keywordflow">else</span> {
<a name="l22905"></a>22905 <span class="comment">//#ifdef SELF_CHECK // commented out to get gcc 4.6 working</span>
<a name="l22906"></a>22906           assert(checksign * destori &lt; 0.0);
<a name="l22907"></a>22907 <span class="comment">//#endif</span>
<a name="l22908"></a>22908           enext(spintet, worktet);  <span class="comment">// edge (dest, apex).</span>
<a name="l22909"></a>22909           workpt[1] = dest(spintet);
<a name="l22910"></a>22910         }
<a name="l22911"></a>22911         <span class="comment">// &#39;worktet&#39; represents the crossing edge. Add it into list only</span>
<a name="l22912"></a>22912         <span class="comment">//   it doesn&#39;t exist in &#39;crossedgelist&#39;.</span>
<a name="l22913"></a>22913         inlistflag = <span class="keyword">false</span>;
<a name="l22914"></a>22914         <span class="keywordflow">for</span> (j = 0; j &lt; crossedgelist-&gt;len() &amp;&amp; !inlistflag; j++) {
<a name="l22915"></a>22915           neightet = * (triface *)(* crossedgelist)[j];
<a name="l22916"></a>22916           <span class="keywordflow">if</span> (org(neightet) == workpt[0]) {
<a name="l22917"></a>22917             <span class="keywordflow">if</span> (dest(neightet) == workpt[1]) inlistflag = <span class="keyword">true</span>;
<a name="l22918"></a>22918           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (org(neightet) == workpt[1]) {
<a name="l22919"></a>22919             <span class="keywordflow">if</span> (dest(neightet) == workpt[0]) inlistflag = <span class="keyword">true</span>;
<a name="l22920"></a>22920           }
<a name="l22921"></a>22921         }
<a name="l22922"></a>22922         <span class="keywordflow">if</span> (!inlistflag) {
<a name="l22923"></a>22923           crossedgelist-&gt;append(&amp;worktet);
<a name="l22924"></a>22924         }
<a name="l22925"></a>22925       }
<a name="l22926"></a>22926     } <span class="keywordflow">while</span> (apex(spintet) != apex(starttet));
<a name="l22927"></a>22927   }
<a name="l22928"></a>22928 
<a name="l22929"></a>22929   <span class="comment">// Identifying the boundary faces and vertices of C. Sort them into</span>
<a name="l22930"></a>22930   <span class="comment">//   &#39;abovefacelist&#39;, &#39;aboveptlist, &#39;belowfacelist&#39;, and &#39;belowptlist&#39;,</span>
<a name="l22931"></a>22931   <span class="comment">//    respectively. &quot;above&quot; and &quot;below&quot; are wrt.(torg, tdest, tapex).</span>
<a name="l22932"></a>22932   <span class="keywordflow">for</span> (i = 0; i &lt; crosstetlist-&gt;len(); i++) {
<a name="l22933"></a>22933     <span class="comment">// Get a tet abcd, ab is the crossing edge.</span>
<a name="l22934"></a>22934     starttet = * (triface *)(* crosstetlist)[i];
<a name="l22935"></a>22935 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l22936"></a>22936 <span class="preprocessor"></span>    assert(infected(starttet));
<a name="l22937"></a>22937 <span class="preprocessor">#endif</span>
<a name="l22938"></a>22938 <span class="preprocessor"></span>    adjustedgering(starttet, CCW);
<a name="l22939"></a>22939     <span class="comment">// abc and abd are sharing the crossing edge, the two neighbors must</span>
<a name="l22940"></a>22940     <span class="comment">//   be crossing tetrahedra too. They can&#39;t be boundaries of C.</span>
<a name="l22941"></a>22941     <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l22942"></a>22942       <span class="keywordflow">if</span> (j == 0) {
<a name="l22943"></a>22943         enextfnext(starttet, worktet); <span class="comment">// Check bcd.</span>
<a name="l22944"></a>22944       } <span class="keywordflow">else</span> {
<a name="l22945"></a>22945         enext2fnext(starttet, worktet); <span class="comment">// Check acd.</span>
<a name="l22946"></a>22946       }
<a name="l22947"></a>22947       sym(worktet, neightet);
<a name="l22948"></a>22948       <span class="comment">// If the neighbor doesn&#39;t exist or exists but doesn&#39;t be infected,</span>
<a name="l22949"></a>22949       <span class="comment">//   it&#39;s a boundary face of C, save it.</span>
<a name="l22950"></a>22950       <span class="keywordflow">if</span> ((neightet.tet == dummytet) || !infected(neightet)) {
<a name="l22951"></a>22951         workpt[0] = org(worktet);
<a name="l22952"></a>22952         workpt[1] = dest(worktet);
<a name="l22953"></a>22953         workpt[2] = apex(worktet);
<a name="l22954"></a>22954         belowflag = aboveflag = <span class="keyword">false</span>;
<a name="l22955"></a>22955         share = 0;
<a name="l22956"></a>22956         <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) {
<a name="l22957"></a>22957           idx = pointmark(workpt[k]) - in-&gt;firstnumber;
<a name="l22958"></a>22958           <span class="keywordflow">if</span> (worklist[idx] == 0) {
<a name="l22959"></a>22959             <span class="comment">// It&#39;s not a vertices of facet, find which side it lies.</span>
<a name="l22960"></a>22960             checksign = orient3d(torg, tdest, tapex, workpt[k]);
<a name="l22961"></a>22961 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l22962"></a>22962 <span class="preprocessor"></span>            assert(checksign != 0.0);
<a name="l22963"></a>22963 <span class="preprocessor">#endif</span>
<a name="l22964"></a>22964 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (checksign &gt; 0.0) {
<a name="l22965"></a>22965               <span class="comment">// It lies &quot;below&quot; the facet wrt. &#39;startsh&#39;.</span>
<a name="l22966"></a>22966               worklist[idx] = 2;
<a name="l22967"></a>22967               belowptlist-&gt;append(&amp;workpt[k]);
<a name="l22968"></a>22968             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (checksign &lt; 0.0) {
<a name="l22969"></a>22969               <span class="comment">// It lies &quot;above&quot; the facet wrt. &#39;startsh&#39;.</span>
<a name="l22970"></a>22970               worklist[idx] = 3;
<a name="l22971"></a>22971               aboveptlist-&gt;append(&amp;workpt[k]);
<a name="l22972"></a>22972             }
<a name="l22973"></a>22973           }
<a name="l22974"></a>22974           <span class="keywordflow">if</span> (worklist[idx] == 2) {
<a name="l22975"></a>22975             <span class="comment">// This face lies &quot;below&quot; the facet wrt. &#39;startsh&#39;.</span>
<a name="l22976"></a>22976             belowflag = <span class="keyword">true</span>;
<a name="l22977"></a>22977           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (worklist[idx] == 3) {
<a name="l22978"></a>22978             <span class="comment">// This face lies &quot;above&quot; the facet wrt. &#39;startsh&#39;.</span>
<a name="l22979"></a>22979             aboveflag = <span class="keyword">true</span>;
<a name="l22980"></a>22980           } <span class="keywordflow">else</span> {
<a name="l22981"></a>22981 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l22982"></a>22982 <span class="preprocessor"></span>            <span class="comment">// In degenerate case, this face may just be the equator.</span>
<a name="l22983"></a>22983             assert(worklist[idx] == 1);
<a name="l22984"></a>22984 <span class="preprocessor">#endif</span>
<a name="l22985"></a>22985 <span class="preprocessor"></span>            share++;
<a name="l22986"></a>22986           }
<a name="l22987"></a>22987         }
<a name="l22988"></a>22988 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l22989"></a>22989 <span class="preprocessor"></span>        <span class="comment">// The degenerate case has been ruled out.</span>
<a name="l22990"></a>22990         assert(share &lt; 3);
<a name="l22991"></a>22991         <span class="comment">// Only one flag is possible for a cavity face.</span>
<a name="l22992"></a>22992         assert(belowflag ^ aboveflag);
<a name="l22993"></a>22993 <span class="preprocessor">#endif</span>
<a name="l22994"></a>22994 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (belowflag) {
<a name="l22995"></a>22995           belowfacelist-&gt;append(&amp;worktet);
<a name="l22996"></a>22996         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (aboveflag) {
<a name="l22997"></a>22997           abovefacelist-&gt;append(&amp;worktet);
<a name="l22998"></a>22998         }
<a name="l22999"></a>22999       }
<a name="l23000"></a>23000     }
<a name="l23001"></a>23001   }
<a name="l23002"></a>23002 
<a name="l23003"></a>23003   <span class="comment">// Shrink R if not all its subfaces are crossing by the discovered tets.</span>
<a name="l23004"></a>23004   <span class="comment">//   &#39;crossshlist&#39; and &#39;horizptlist&#39; represent the set of subfaces and</span>
<a name="l23005"></a>23005   <span class="comment">//   vertices of the shrinked missing region, respectively.</span>
<a name="l23006"></a>23006   <span class="keywordflow">for</span> (i = 0; i &lt; missingshlist-&gt;len(); i++) {
<a name="l23007"></a>23007     worksh = * (face *)(* missingshlist)[i];
<a name="l23008"></a>23008 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l23009"></a>23009 <span class="preprocessor"></span>    assert(sinfected(worksh));
<a name="l23010"></a>23010 <span class="preprocessor">#endif</span>
<a name="l23011"></a>23011 <span class="preprocessor"></span>    workpt[0] = sorg(worksh);
<a name="l23012"></a>23012     workpt[1] = sdest(worksh);
<a name="l23013"></a>23013     workpt[2] = sapex(worksh);
<a name="l23014"></a>23014     crossflag = <span class="keyword">false</span>;
<a name="l23015"></a>23015     <span class="keywordflow">for</span> (j = 0; j &lt; crosstetlist-&gt;len() &amp;&amp; !crossflag; j++) {
<a name="l23016"></a>23016       <span class="comment">// Get a tet abcd, ab is a crossing edge.</span>
<a name="l23017"></a>23017       starttet = * (triface *)(* crosstetlist)[j];
<a name="l23018"></a>23018       adjustedgering(starttet, CCW);
<a name="l23019"></a>23019       <span class="comment">// Only need to check two sides of worktet.</span>
<a name="l23020"></a>23020       <span class="keywordflow">for</span> (k = 0; k &lt; 2 &amp;&amp; !crossflag; k++) {
<a name="l23021"></a>23021         <span class="keywordflow">if</span> (k == 0) {
<a name="l23022"></a>23022           worktet = starttet; <span class="comment">// Check abc.</span>
<a name="l23023"></a>23023         } <span class="keywordflow">else</span> {
<a name="l23024"></a>23024           fnext(starttet, worktet); <span class="comment">// Check abd.</span>
<a name="l23025"></a>23025         }
<a name="l23026"></a>23026         crossflag = tritritest(&amp;worktet, workpt[0], workpt[1], workpt[2]);
<a name="l23027"></a>23027       }
<a name="l23028"></a>23028     }
<a name="l23029"></a>23029     <span class="keywordflow">if</span> (crossflag) {
<a name="l23030"></a>23030       <span class="comment">// &#39;worksh&#39; is crossed by &#39;worktet&#39;, uninfect it.</span>
<a name="l23031"></a>23031       suninfect(worksh);
<a name="l23032"></a>23032       crossshlist-&gt;append(&amp;worksh);
<a name="l23033"></a>23033       <span class="comment">// Add its corners into &#39;horizptlist&#39;.</span>
<a name="l23034"></a>23034       <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) {
<a name="l23035"></a>23035         idx = pointmark(workpt[k]) - in-&gt;firstnumber;
<a name="l23036"></a>23036         <span class="keywordflow">if</span> (worklist[idx] != 4) {
<a name="l23037"></a>23037           worklist[idx] = 4;
<a name="l23038"></a>23038           horizptlist-&gt;append(&amp;workpt[k]);
<a name="l23039"></a>23039         }
<a name="l23040"></a>23040       }
<a name="l23041"></a>23041     }
<a name="l23042"></a>23042   }
<a name="l23043"></a>23043 
<a name="l23044"></a>23044   <span class="comment">// Check &#39;crossingtetlist&#39;. Queue subfaces inside them.</span>
<a name="l23045"></a>23045   <span class="keywordflow">for</span> (i = 0; i &lt; crosstetlist-&gt;len(); i++) {
<a name="l23046"></a>23046     starttet = * (triface *)(* crosstetlist)[i];
<a name="l23047"></a>23047     <span class="keywordflow">for</span> (starttet.loc = 0; starttet.loc &lt; 4; starttet.loc++) {
<a name="l23048"></a>23048       sym(starttet, neightet);
<a name="l23049"></a>23049       <span class="comment">// If the neighbor exist and is infected, check it.</span>
<a name="l23050"></a>23050       <span class="keywordflow">if</span> ((neightet.tet != dummytet) &amp;&amp; infected(neightet)) {
<a name="l23051"></a>23051         tspivot(starttet, worksh);
<a name="l23052"></a>23052         <span class="keywordflow">if</span> (worksh.sh != dummysh) {
<a name="l23053"></a>23053           <span class="comment">// Temporarily remove worksh. Make it missing. recover it later.</span>
<a name="l23054"></a>23054           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l23055"></a>23055             printf(<span class="stringliteral">&quot;    Queuing subface (%d, %d, %d).\n&quot;</span>,
<a name="l23056"></a>23056                    pointmark(sorg(worksh)), pointmark(sdest(worksh)),
<a name="l23057"></a>23057                    pointmark(sapex(worksh)));
<a name="l23058"></a>23058           }
<a name="l23059"></a>23059           tsdissolve(neightet);
<a name="l23060"></a>23060           tsdissolve(starttet);
<a name="l23061"></a>23061           <span class="comment">// Detach tets at the both sides of this subface.</span>
<a name="l23062"></a>23062           stdissolve(worksh);
<a name="l23063"></a>23063           sesymself(worksh);
<a name="l23064"></a>23064           stdissolve(worksh);
<a name="l23065"></a>23065           sinfect(worksh);
<a name="l23066"></a>23066           missingshqueue-&gt;push(&amp;worksh);
<a name="l23067"></a>23067         }
<a name="l23068"></a>23068       }
<a name="l23069"></a>23069     }
<a name="l23070"></a>23070   }
<a name="l23071"></a>23071 
<a name="l23072"></a>23072   <span class="comment">// Clear flags set in &#39;worklist&#39;.</span>
<a name="l23073"></a>23073   <span class="keywordflow">for</span> (i = 0; i &lt; equatptlist-&gt;len(); i++) {
<a name="l23074"></a>23074     workpt[0] = * (point *)(* equatptlist)[i];
<a name="l23075"></a>23075     idx = pointmark(workpt[0]) - in-&gt;firstnumber;
<a name="l23076"></a>23076 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l23077"></a>23077 <span class="preprocessor"></span>    assert((worklist[idx] == 1) || (worklist[idx] == 4));
<a name="l23078"></a>23078 <span class="preprocessor">#endif</span>
<a name="l23079"></a>23079 <span class="preprocessor"></span>    worklist[idx] = 0;
<a name="l23080"></a>23080   }
<a name="l23081"></a>23081   <span class="keywordflow">for</span> (i = 0; i &lt; belowptlist-&gt;len(); i++) {
<a name="l23082"></a>23082     workpt[0] = * (point *)(* belowptlist)[i];
<a name="l23083"></a>23083     idx = pointmark(workpt[0]) - in-&gt;firstnumber;
<a name="l23084"></a>23084 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l23085"></a>23085 <span class="preprocessor"></span>    assert(worklist[idx] == 2);
<a name="l23086"></a>23086 <span class="preprocessor">#endif</span>
<a name="l23087"></a>23087 <span class="preprocessor"></span>    worklist[idx] = 0;
<a name="l23088"></a>23088   }
<a name="l23089"></a>23089   <span class="keywordflow">for</span> (i = 0; i &lt; aboveptlist-&gt;len(); i++) {
<a name="l23090"></a>23090     workpt[0] = * (point *)(* aboveptlist)[i];
<a name="l23091"></a>23091     idx = pointmark(workpt[0]) - in-&gt;firstnumber;
<a name="l23092"></a>23092 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l23093"></a>23093 <span class="preprocessor"></span>    assert(worklist[idx] == 3);
<a name="l23094"></a>23094 <span class="preprocessor">#endif</span>
<a name="l23095"></a>23095 <span class="preprocessor"></span>    worklist[idx] = 0;
<a name="l23096"></a>23096   }
<a name="l23097"></a>23097 }
<a name="l23098"></a>23098 
<a name="l23100"></a>23100 <span class="comment">//                                                                           //</span>
<a name="l23101"></a>23101 <span class="comment">// insertallsubfaces()    Insert all subfaces, queue missing subfaces.       //</span>
<a name="l23102"></a>23102 <span class="comment">//                                                                           //</span>
<a name="l23103"></a>23103 <span class="comment">// Loop through all subfaces, insert each into the DT. If one already exists,//</span>
<a name="l23104"></a>23104 <span class="comment">// bond it to the tetrahedra having it. Otherwise, it is missing, infect it  //</span>
<a name="l23105"></a>23105 <span class="comment">// and save it in &#39;missingshqueue&#39;.                                          //</span>
<a name="l23106"></a>23106 <span class="comment">//                                                                           //</span>
<a name="l23108"></a>23108 <span class="comment"></span>
<a name="l23109"></a>23109 <span class="keywordtype">void</span> tetgenmesh::insertallsubfaces(queue* missingshqueue)
<a name="l23110"></a>23110 {
<a name="l23111"></a>23111   triface searchtet;
<a name="l23112"></a>23112   face subloop;
<a name="l23113"></a>23113 
<a name="l23114"></a>23114   searchtet.tet = (tetrahedron *) NULL;
<a name="l23115"></a>23115   subfaces-&gt;traversalinit();
<a name="l23116"></a>23116   subloop.sh = shellfacetraverse(subfaces);
<a name="l23117"></a>23117   <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l23118"></a>23118     <span class="keywordflow">if</span> (!insertsubface(&amp;subloop, &amp;searchtet)) {
<a name="l23119"></a>23119       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l23120"></a>23120         printf(<span class="stringliteral">&quot;    Queuing subface (%d, %d, %d).\n&quot;</span>, pointmark(sorg(subloop)),
<a name="l23121"></a>23121                pointmark(sdest(subloop)), pointmark(sapex(subloop)));
<a name="l23122"></a>23122       }
<a name="l23123"></a>23123       sinfect(subloop);
<a name="l23124"></a>23124       missingshqueue-&gt;push(&amp;subloop);
<a name="l23125"></a>23125     }
<a name="l23126"></a>23126     subloop.sh = shellfacetraverse(subfaces);
<a name="l23127"></a>23127   }
<a name="l23128"></a>23128 }
<a name="l23129"></a>23129 
<a name="l23131"></a>23131 <span class="comment">//                                                                           //</span>
<a name="l23132"></a>23132 <span class="comment">// constrainedfacets()    Recover subfaces in a Delaunay tetrahedralization. //</span>
<a name="l23133"></a>23133 <span class="comment">//                                                                           //</span>
<a name="l23134"></a>23134 <span class="comment">// This routine creates a CDT by incrementally updating a DT D into a CDT T. //</span>
<a name="l23135"></a>23135 <span class="comment">// The process of recovering facets can be imagined by &quot;merging&quot; the surface //</span>
<a name="l23136"></a>23136 <span class="comment">// mesh F into D. At the beginning, F and D are completely seperated.  Some  //</span>
<a name="l23137"></a>23137 <span class="comment">// faces of them are matching some are not because they are crossed by some  //</span>
<a name="l23138"></a>23138 <span class="comment">// tetrahedra of D. The non-matching subfaces will be forced to appear in T  //</span>
<a name="l23139"></a>23139 <span class="comment">// by locally retetrahedralizing the regions where F and D are intersecting. //</span>
<a name="l23140"></a>23140 <span class="comment">//                                                                           //</span>
<a name="l23141"></a>23141 <span class="comment">// When a subface s of F is found missing in D, probably some other subfaces //</span>
<a name="l23142"></a>23142 <span class="comment">// near to s are missing too.  The set of adjoining coplanar missing faces   //</span>
<a name="l23143"></a>23143 <span class="comment">// forms a missing region R (R may not simply connected).                    //</span>
<a name="l23144"></a>23144 <span class="comment">//                                                                           //</span>
<a name="l23145"></a>23145 <span class="comment">// There are two possibilities can result a mssing region R: (1) Some edges  //</span>
<a name="l23146"></a>23146 <span class="comment">// of D cross R; (2) No edge of D crosses R, but some faces of D spans R, ie,//</span>
<a name="l23147"></a>23147 <span class="comment">// D is locally degenerate at R. In case (1), D is modified so that it resp- //</span>
<a name="l23148"></a>23148 <span class="comment">// ects R (done by a cavity retetrahedralization algorithm).  In case (2), F //</span>
<a name="l23149"></a>23149 <span class="comment">// is modified so that the set of subfaces of R matches faces in D (done by  //</span>
<a name="l23150"></a>23150 <span class="comment">// a face rearrangment algorithm).                                           //</span>
<a name="l23151"></a>23151 <span class="comment">//                                                                           //</span>
<a name="l23153"></a>23153 <span class="comment"></span>
<a name="l23154"></a>23154 <span class="keywordtype">void</span> tetgenmesh::constrainedfacets()
<a name="l23155"></a>23155 {
<a name="l23156"></a>23156   queue *missingshqueue, *flipque;
<a name="l23157"></a>23157   list *missingshlist, *equatptlist;
<a name="l23158"></a>23158   list *boundedgelist, *crossedgelist, *crosstetlist;
<a name="l23159"></a>23159   list *crossshlist, *belowfacelist, *abovefacelist;
<a name="l23160"></a>23160   list *horizptlist, *belowptlist, *aboveptlist;
<a name="l23161"></a>23161   list *frontlist, *misfrontlist, *newtetlist;
<a name="l23162"></a>23162   triface searchtet, worktet;
<a name="l23163"></a>23163   face subloop, worksh;
<a name="l23164"></a>23164   <span class="keywordtype">int</span> *worklist;
<a name="l23165"></a>23165   <span class="keywordtype">int</span> i;
<a name="l23166"></a>23166 
<a name="l23167"></a>23167   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l23168"></a>23168     printf(<span class="stringliteral">&quot;Constraining facets.\n&quot;</span>);
<a name="l23169"></a>23169   }
<a name="l23170"></a>23170 
<a name="l23171"></a>23171   <span class="comment">// Initialize queues.</span>
<a name="l23172"></a>23172   missingshqueue = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(face));
<a name="l23173"></a>23173   flipque = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l23174"></a>23174   <span class="comment">// Initialize the working lists.</span>
<a name="l23175"></a>23175   missingshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL);
<a name="l23176"></a>23176   boundedgelist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL);
<a name="l23177"></a>23177   crossedgelist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l23178"></a>23178   equatptlist = <span class="keyword">new</span> list((<span class="keywordtype">char</span>*) <span class="stringliteral">&quot;point *&quot;</span>);
<a name="l23179"></a>23179   crossshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL);
<a name="l23180"></a>23180   crosstetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l23181"></a>23181   belowfacelist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l23182"></a>23182   abovefacelist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l23183"></a>23183   horizptlist = <span class="keyword">new</span> list((<span class="keywordtype">char</span>*)<span class="stringliteral">&quot;point *&quot;</span>);
<a name="l23184"></a>23184   belowptlist = <span class="keyword">new</span> list((<span class="keywordtype">char</span>*)<span class="stringliteral">&quot;point *&quot;</span>);
<a name="l23185"></a>23185   aboveptlist = <span class="keyword">new</span> list((<span class="keywordtype">char</span>*)<span class="stringliteral">&quot;point *&quot;</span>);
<a name="l23186"></a>23186   frontlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l23187"></a>23187   misfrontlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l23188"></a>23188   newtetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l23189"></a>23189   <span class="comment">// Initialize the array for marking vertices.</span>
<a name="l23190"></a>23190   worklist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l23191"></a>23191   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) worklist[i] = 0;
<a name="l23192"></a>23192 
<a name="l23193"></a>23193   <span class="comment">// Compute a mapping from points to tetrahedra for fast searching.</span>
<a name="l23194"></a>23194   makepoint2tetmap();
<a name="l23195"></a>23195 
<a name="l23196"></a>23196   <span class="comment">// Match subfaces in D, queue all missing subfaces.</span>
<a name="l23197"></a>23197   insertallsubfaces(missingshqueue);
<a name="l23198"></a>23198 
<a name="l23199"></a>23199   <span class="comment">// Recover all missing subfaces.</span>
<a name="l23200"></a>23200   <span class="keywordflow">while</span> (!missingshqueue-&gt;empty()) {
<a name="l23201"></a>23201     <span class="comment">// Get a queued face s.</span>
<a name="l23202"></a>23202     subloop = * (face *) missingshqueue-&gt;pop();
<a name="l23203"></a>23203     <span class="comment">// s may have been deleted in a face rearrangment operation.</span>
<a name="l23204"></a>23204     <span class="keywordflow">if</span> (isdead(&amp;subloop)) <span class="keywordflow">continue</span>;
<a name="l23205"></a>23205     <span class="comment">// s may have been recovered in a previous missing region.</span>
<a name="l23206"></a>23206     <span class="keywordflow">if</span> (!sinfected(subloop)) <span class="keywordflow">continue</span>;
<a name="l23207"></a>23207     <span class="comment">// s may match a face in D now due to previous transformations.</span>
<a name="l23208"></a>23208     <span class="keywordflow">if</span> (insertsubface(&amp;subloop, &amp;searchtet)) {
<a name="l23209"></a>23209       suninfect(subloop);
<a name="l23210"></a>23210       <span class="keywordflow">continue</span>;
<a name="l23211"></a>23211     }
<a name="l23212"></a>23212     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l23213"></a>23213       printf(<span class="stringliteral">&quot;    Recover subface (%d, %d, %d).\n&quot;</span>, pointmark(sorg(subloop)),
<a name="l23214"></a>23214              pointmark(sdest(subloop)), pointmark(sapex(subloop)));
<a name="l23215"></a>23215     }
<a name="l23216"></a>23216     <span class="comment">// Form the missing region R containing s.</span>
<a name="l23217"></a>23217     formmissingregion(&amp;subloop, missingshlist, equatptlist, worklist);
<a name="l23218"></a>23218     <span class="comment">// Is R crossing by any tetrahedron?</span>
<a name="l23219"></a>23219     <span class="keywordflow">if</span> (scoutcrossingedge(missingshlist, boundedgelist, crossedgelist,
<a name="l23220"></a>23220                           worklist)) {
<a name="l23221"></a>23221       <span class="comment">// Form the cavity C containing R.</span>
<a name="l23222"></a>23222       formcavity(missingshlist, crossedgelist, equatptlist, crossshlist,
<a name="l23223"></a>23223                  crosstetlist, belowfacelist, abovefacelist, horizptlist,
<a name="l23224"></a>23224                  belowptlist, aboveptlist, missingshqueue, worklist);
<a name="l23225"></a>23225       <span class="comment">// Recover the above part of C.</span>
<a name="l23226"></a>23226       delaunizecavity(crossshlist, abovefacelist, aboveptlist, horizptlist,
<a name="l23227"></a>23227                       frontlist, misfrontlist, newtetlist, crosstetlist,
<a name="l23228"></a>23228                       missingshqueue, flipque);
<a name="l23229"></a>23229       <span class="comment">// Inverse the direction of subfaces in R.</span>
<a name="l23230"></a>23230       <span class="keywordflow">for</span> (i = 0; i &lt; crossshlist-&gt;len(); i++) {
<a name="l23231"></a>23231         worksh = * (face *)(* crossshlist)[i];
<a name="l23232"></a>23232         sesymself(worksh);
<a name="l23233"></a>23233         * (face *)(* crossshlist)[i] = worksh;
<a name="l23234"></a>23234       }
<a name="l23235"></a>23235       <span class="comment">// Recover the below part of C.</span>
<a name="l23236"></a>23236       delaunizecavity(crossshlist, belowfacelist, belowptlist, horizptlist,
<a name="l23237"></a>23237                       frontlist, misfrontlist, newtetlist, crosstetlist,
<a name="l23238"></a>23238                       missingshqueue, flipque);
<a name="l23239"></a>23239       <span class="comment">// Delete tetrahedra in C.</span>
<a name="l23240"></a>23240       <span class="keywordflow">for</span> (i = 0; i &lt; crosstetlist-&gt;len(); i++) {
<a name="l23241"></a>23241         worktet = * (triface *)(* crosstetlist)[i];
<a name="l23242"></a>23242         tetrahedrondealloc(worktet.tet);
<a name="l23243"></a>23243       }
<a name="l23244"></a>23244       <span class="comment">// There may have some un-recovered subfaces of R. Put them back into</span>
<a name="l23245"></a>23245       <span class="comment">//   queue. Otherwise, they will be missing on the boundary.</span>
<a name="l23246"></a>23246       <span class="keywordflow">for</span> (i = 0; i &lt; missingshlist-&gt;len(); i++) {
<a name="l23247"></a>23247         worksh = * (face *)(* missingshlist)[i];
<a name="l23248"></a>23248         <span class="keywordflow">if</span> (sinfected(worksh)) {
<a name="l23249"></a>23249           <span class="comment">// An unrecovered subface, put it back into queue.</span>
<a name="l23250"></a>23250           missingshqueue-&gt;push(&amp;worksh);
<a name="l23251"></a>23251         }
<a name="l23252"></a>23252       }
<a name="l23253"></a>23253       crossshlist-&gt;clear();
<a name="l23254"></a>23254       belowfacelist-&gt;clear();
<a name="l23255"></a>23255       abovefacelist-&gt;clear();
<a name="l23256"></a>23256       horizptlist-&gt;clear();
<a name="l23257"></a>23257       belowptlist-&gt;clear();
<a name="l23258"></a>23258       aboveptlist-&gt;clear();
<a name="l23259"></a>23259       crosstetlist-&gt;clear();
<a name="l23260"></a>23260     } <span class="keywordflow">else</span> {
<a name="l23261"></a>23261       <span class="comment">// No. Rearrange subfaces of F conforming to that of D in R. It can</span>
<a name="l23262"></a>23262       <span class="comment">//   happen when the facet has non-coplanar vertices.</span>
<a name="l23263"></a>23263       rearrangesubfaces(missingshlist, boundedgelist, equatptlist, worklist);
<a name="l23264"></a>23264     }
<a name="l23265"></a>23265     <span class="comment">// Clear all working lists.</span>
<a name="l23266"></a>23266     missingshlist-&gt;clear();
<a name="l23267"></a>23267     boundedgelist-&gt;clear();
<a name="l23268"></a>23268     crossedgelist-&gt;clear();
<a name="l23269"></a>23269     equatptlist-&gt;clear();
<a name="l23270"></a>23270   }
<a name="l23271"></a>23271 
<a name="l23272"></a>23272   <span class="comment">// Subfaces have been merged into D.</span>
<a name="l23273"></a>23273   checksubfaces = 1;
<a name="l23274"></a>23274 
<a name="l23275"></a>23275   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l23276"></a>23276     printf(<span class="stringliteral">&quot;  The biggest cavity: %d faces, %d vertices\n&quot;</span>, maxcavfaces,
<a name="l23277"></a>23277            maxcavverts);
<a name="l23278"></a>23278     printf(<span class="stringliteral">&quot;  Enlarged %d times\n&quot;</span>, expcavcount);
<a name="l23279"></a>23279   }
<a name="l23280"></a>23280 
<a name="l23281"></a>23281   <span class="keyword">delete</span> missingshqueue;
<a name="l23282"></a>23282   <span class="keyword">delete</span> flipque;
<a name="l23283"></a>23283   <span class="keyword">delete</span> missingshlist;
<a name="l23284"></a>23284   <span class="keyword">delete</span> boundedgelist;
<a name="l23285"></a>23285   <span class="keyword">delete</span> crossedgelist;
<a name="l23286"></a>23286   <span class="keyword">delete</span> equatptlist;
<a name="l23287"></a>23287   <span class="keyword">delete</span> crossshlist;
<a name="l23288"></a>23288   <span class="keyword">delete</span> crosstetlist;
<a name="l23289"></a>23289   <span class="keyword">delete</span> belowfacelist;
<a name="l23290"></a>23290   <span class="keyword">delete</span> abovefacelist;
<a name="l23291"></a>23291   <span class="keyword">delete</span> horizptlist;
<a name="l23292"></a>23292   <span class="keyword">delete</span> belowptlist;
<a name="l23293"></a>23293   <span class="keyword">delete</span> aboveptlist;
<a name="l23294"></a>23294   <span class="keyword">delete</span> frontlist;
<a name="l23295"></a>23295   <span class="keyword">delete</span> misfrontlist;
<a name="l23296"></a>23296   <span class="keyword">delete</span> newtetlist;
<a name="l23297"></a>23297   <span class="keyword">delete</span> [] worklist;
<a name="l23298"></a>23298 }
<a name="l23299"></a>23299 
<a name="l23300"></a>23300 <span class="comment">//</span>
<a name="l23301"></a>23301 <span class="comment">// End of facet recovery routines</span>
<a name="l23302"></a>23302 <span class="comment">//</span>
<a name="l23303"></a>23303 
<a name="l23304"></a>23304 <span class="comment">//</span>
<a name="l23305"></a>23305 <span class="comment">// Begin of carving out holes and concavities routines</span>
<a name="l23306"></a>23306 <span class="comment">//</span>
<a name="l23307"></a>23307 
<a name="l23309"></a>23309 <span class="comment">//                                                                           //</span>
<a name="l23310"></a>23310 <span class="comment">// infecthull()    Virally infect all of the tetrahedra of the convex hull   //</span>
<a name="l23311"></a>23311 <span class="comment">//                 that are not protected by subfaces.  Where there are      //</span>
<a name="l23312"></a>23312 <span class="comment">//                 subfaces, set boundary markers as appropriate.            //</span>
<a name="l23313"></a>23313 <span class="comment">//                                                                           //</span>
<a name="l23314"></a>23314 <span class="comment">// Memorypool &#39;viri&#39; is used to return all the infected tetrahedra.          //</span>
<a name="l23315"></a>23315 <span class="comment">//                                                                           //</span>
<a name="l23317"></a>23317 <span class="comment"></span>
<a name="l23318"></a>23318 <span class="keywordtype">void</span> tetgenmesh::infecthull(<a class="code" href="structmemorypool.html">memorypool</a> *viri)
<a name="l23319"></a>23319 {
<a name="l23320"></a>23320   triface tetloop, tsymtet;
<a name="l23321"></a>23321   tetrahedron **deadtet;
<a name="l23322"></a>23322   face hullface;
<a name="l23323"></a>23323   <span class="comment">// point horg, hdest, hapex;</span>
<a name="l23324"></a>23324 
<a name="l23325"></a>23325   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l23326"></a>23326     printf(<span class="stringliteral">&quot;  Marking concavities for elimination.\n&quot;</span>);
<a name="l23327"></a>23327   }
<a name="l23328"></a>23328   tetrahedrons-&gt;traversalinit();
<a name="l23329"></a>23329   tetloop.tet = tetrahedrontraverse();
<a name="l23330"></a>23330   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l23331"></a>23331     <span class="comment">// Is this tetrahedron on the hull?</span>
<a name="l23332"></a>23332     <span class="keywordflow">for</span> (tetloop.loc = 0; tetloop.loc &lt; 4; tetloop.loc++) {
<a name="l23333"></a>23333       sym(tetloop, tsymtet);
<a name="l23334"></a>23334       <span class="keywordflow">if</span> (tsymtet.tet == dummytet) {
<a name="l23335"></a>23335         <span class="comment">// Is the tetrahedron protected by a subface?</span>
<a name="l23336"></a>23336         tspivot(tetloop, hullface);
<a name="l23337"></a>23337         <span class="keywordflow">if</span> (hullface.sh == dummysh) {
<a name="l23338"></a>23338           <span class="comment">// The tetrahedron is not protected; infect it.</span>
<a name="l23339"></a>23339           <span class="keywordflow">if</span> (!infected(tetloop)) {
<a name="l23340"></a>23340             infect(tetloop);
<a name="l23341"></a>23341             deadtet = (tetrahedron **) viri-&gt;alloc();
<a name="l23342"></a>23342             *deadtet = tetloop.tet;
<a name="l23343"></a>23343             <span class="keywordflow">break</span>;  <span class="comment">// Go and get next tet.</span>
<a name="l23344"></a>23344           }
<a name="l23345"></a>23345         } <span class="keywordflow">else</span> {
<a name="l23346"></a>23346           <span class="comment">// The tetrahedron is protected; set boundary markers if appropriate.</span>
<a name="l23347"></a>23347           <span class="keywordflow">if</span> (shellmark(hullface) == 0) {
<a name="l23348"></a>23348             setshellmark(hullface, 1);
<a name="l23349"></a>23349             <span class="comment">/*</span>
<a name="l23350"></a>23350 <span class="comment">            horg = sorg(hullface);</span>
<a name="l23351"></a>23351 <span class="comment">            hdest = sdest(hullface);</span>
<a name="l23352"></a>23352 <span class="comment">            hapex = sapex(hullface);</span>
<a name="l23353"></a>23353 <span class="comment">            if (pointmark(horg) == 0) {</span>
<a name="l23354"></a>23354 <span class="comment">              setpointmark(horg, 1);</span>
<a name="l23355"></a>23355 <span class="comment">            }</span>
<a name="l23356"></a>23356 <span class="comment">            if (pointmark(hdest) == 0) {</span>
<a name="l23357"></a>23357 <span class="comment">              setpointmark(hdest, 1);</span>
<a name="l23358"></a>23358 <span class="comment">            }</span>
<a name="l23359"></a>23359 <span class="comment">            if (pointmark(hapex) == 0) {</span>
<a name="l23360"></a>23360 <span class="comment">              setpointmark(hapex, 1);</span>
<a name="l23361"></a>23361 <span class="comment">            }</span>
<a name="l23362"></a>23362 <span class="comment">            */</span>
<a name="l23363"></a>23363           }
<a name="l23364"></a>23364         }
<a name="l23365"></a>23365       }
<a name="l23366"></a>23366     }
<a name="l23367"></a>23367     tetloop.tet = tetrahedrontraverse();
<a name="l23368"></a>23368   }
<a name="l23369"></a>23369 }
<a name="l23370"></a>23370 
<a name="l23372"></a>23372 <span class="comment">//                                                                           //</span>
<a name="l23373"></a>23373 <span class="comment">// plague()    Spread the virus from all infected tets to any neighbors not  //</span>
<a name="l23374"></a>23374 <span class="comment">//             protected by subfaces.                                        //</span>
<a name="l23375"></a>23375 <span class="comment">//                                                                           //</span>
<a name="l23376"></a>23376 <span class="comment">// This routine identifies all the tetrahedra that will die, and marks them  //</span>
<a name="l23377"></a>23377 <span class="comment">// as infected.  They are marked to ensure that each tetrahedron is added to //</span>
<a name="l23378"></a>23378 <span class="comment">// the virus pool only once, so the procedure will terminate. &#39;viri&#39; returns //</span>
<a name="l23379"></a>23379 <span class="comment">// all infected tetrahedra which are outside the domian.                     //</span>
<a name="l23380"></a>23380 <span class="comment">//                                                                           //</span>
<a name="l23382"></a>23382 <span class="comment"></span>
<a name="l23383"></a>23383 <span class="keywordtype">void</span> tetgenmesh::plague(<a class="code" href="structmemorypool.html">memorypool</a> *viri)
<a name="l23384"></a>23384 {
<a name="l23385"></a>23385   tetrahedron **virusloop;
<a name="l23386"></a>23386   tetrahedron **deadtet;
<a name="l23387"></a>23387   triface testtet, neighbor;
<a name="l23388"></a>23388   face neighsh, testseg;
<a name="l23389"></a>23389   face spinsh, casingin, casingout;
<a name="l23390"></a>23390   <span class="keywordtype">int</span> firstdadsub;
<a name="l23391"></a>23391   <span class="keywordtype">int</span> i;
<a name="l23392"></a>23392 
<a name="l23393"></a>23393   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l23394"></a>23394     printf(<span class="stringliteral">&quot;  Marking neighbors of marked tetrahedra.\n&quot;</span>);
<a name="l23395"></a>23395   }
<a name="l23396"></a>23396   firstdadsub = 0;
<a name="l23397"></a>23397   <span class="comment">// Loop through all the infected tetrahedra, spreading the virus to</span>
<a name="l23398"></a>23398   <span class="comment">//   their neighbors, then to their neighbors&#39; neighbors.</span>
<a name="l23399"></a>23399   viri-&gt;traversalinit();
<a name="l23400"></a>23400   virusloop = (tetrahedron **) viri-&gt;traverse();
<a name="l23401"></a>23401   <span class="keywordflow">while</span> (virusloop != (tetrahedron **) NULL) {
<a name="l23402"></a>23402     testtet.tet = *virusloop;
<a name="l23403"></a>23403     <span class="comment">// Temporarily uninfect this tetrahedron, not necessary.</span>
<a name="l23404"></a>23404     uninfect(testtet);
<a name="l23405"></a>23405     <span class="comment">// Check each of the tetrahedron&#39;s four neighbors.</span>
<a name="l23406"></a>23406     <span class="keywordflow">for</span> (testtet.loc = 0; testtet.loc &lt; 4; testtet.loc++) {
<a name="l23407"></a>23407       <span class="comment">// Find the neighbor.</span>
<a name="l23408"></a>23408       sym(testtet, neighbor);
<a name="l23409"></a>23409       <span class="comment">// Check for a shell between the tetrahedron and its neighbor.</span>
<a name="l23410"></a>23410       tspivot(testtet, neighsh);
<a name="l23411"></a>23411       <span class="comment">// Check if the neighbor is nonexistent or already infected.</span>
<a name="l23412"></a>23412       <span class="keywordflow">if</span> ((neighbor.tet == dummytet) || infected(neighbor)) {
<a name="l23413"></a>23413         <span class="keywordflow">if</span> (neighsh.sh != dummysh) {
<a name="l23414"></a>23414           <span class="comment">// There is a subface separating the tetrahedron from its neighbor,</span>
<a name="l23415"></a>23415           <span class="comment">//   but both tetrahedra are dying, so the subface dies too.</span>
<a name="l23416"></a>23416           <span class="comment">// Before deallocte this subface, dissolve the connections between</span>
<a name="l23417"></a>23417           <span class="comment">//   other subfaces, subsegments and tetrahedra.</span>
<a name="l23418"></a>23418           neighsh.shver = 0;
<a name="l23419"></a>23419           <span class="keywordflow">if</span> (!firstdadsub) {
<a name="l23420"></a>23420             firstdadsub = 1; <span class="comment">// Report the problem once.</span>
<a name="l23421"></a>23421             <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l23422"></a>23422               printf(<span class="stringliteral">&quot;Warning:  Detecting an open face (%d, %d, %d).\n&quot;</span>,
<a name="l23423"></a>23423                      pointmark(sorg(neighsh)), pointmark(sdest(neighsh)),
<a name="l23424"></a>23424                      pointmark(sapex(neighsh)));
<a name="l23425"></a>23425             }
<a name="l23426"></a>23426           }
<a name="l23427"></a>23427           <span class="comment">// For keep the same enext() direction.</span>
<a name="l23428"></a>23428           findedge(&amp;testtet, sorg(neighsh), sdest(neighsh));
<a name="l23429"></a>23429           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l23430"></a>23430             sspivot(neighsh, testseg);
<a name="l23431"></a>23431             <span class="keywordflow">if</span> (testseg.sh != dummysh) {
<a name="l23432"></a>23432               <span class="comment">// A subsegment is found at this side, dissolve this subface</span>
<a name="l23433"></a>23433               <span class="comment">//   from the face link of this subsegment.</span>
<a name="l23434"></a>23434               testseg.shver = 0;
<a name="l23435"></a>23435               spinsh = neighsh;
<a name="l23436"></a>23436               <span class="keywordflow">if</span> (sorg(spinsh) != sorg(testseg)) {
<a name="l23437"></a>23437                 sesymself(spinsh);
<a name="l23438"></a>23438               }
<a name="l23439"></a>23439               spivot(spinsh, casingout);
<a name="l23440"></a>23440               <span class="keywordflow">if</span> (casingout.sh == spinsh.sh) {
<a name="l23441"></a>23441                 <span class="comment">// This is a trivial face link, only &#39;neighsh&#39; itself,</span>
<a name="l23442"></a>23442                 <span class="comment">//   the subsegment at this side is also died.</span>
<a name="l23443"></a>23443                 shellfacedealloc(subsegs, testseg.sh);
<a name="l23444"></a>23444               } <span class="keywordflow">else</span> {
<a name="l23445"></a>23445                 spinsh = casingout;
<a name="l23446"></a>23446                 <span class="keywordflow">do</span> {
<a name="l23447"></a>23447                   casingin = spinsh;
<a name="l23448"></a>23448                   spivotself(spinsh);
<a name="l23449"></a>23449                 } <span class="keywordflow">while</span> (spinsh.sh != neighsh.sh);
<a name="l23450"></a>23450                 <span class="comment">// Set the link casingin-&gt;casingout.</span>
<a name="l23451"></a>23451                 sbond1(casingin, casingout);
<a name="l23452"></a>23452                 <span class="comment">// Bond the subsegment anyway.</span>
<a name="l23453"></a>23453                 ssbond(casingin, testseg);
<a name="l23454"></a>23454               }
<a name="l23455"></a>23455             }
<a name="l23456"></a>23456             senextself(neighsh);
<a name="l23457"></a>23457             enextself(testtet);
<a name="l23458"></a>23458           }
<a name="l23459"></a>23459           <span class="keywordflow">if</span> (neighbor.tet != dummytet) {
<a name="l23460"></a>23460             <span class="comment">// Make sure the subface doesn&#39;t get deallocated again later</span>
<a name="l23461"></a>23461             <span class="comment">//   when the infected neighbor is visited.</span>
<a name="l23462"></a>23462             tsdissolve(neighbor);
<a name="l23463"></a>23463           }
<a name="l23464"></a>23464           <span class="comment">// This subface has been separated.</span>
<a name="l23465"></a>23465           <span class="keywordflow">if</span> (in-&gt;mesh_dim &gt; 2) {
<a name="l23466"></a>23466             shellfacedealloc(subfaces, neighsh.sh);
<a name="l23467"></a>23467           } <span class="keywordflow">else</span> {
<a name="l23468"></a>23468             <span class="comment">// Dimension is 2. keep it for output.</span>
<a name="l23469"></a>23469             <span class="comment">// Dissolve tets at both sides of this subface.</span>
<a name="l23470"></a>23470             stdissolve(neighsh);
<a name="l23471"></a>23471             sesymself(neighsh);
<a name="l23472"></a>23472             stdissolve(neighsh);
<a name="l23473"></a>23473           }
<a name="l23474"></a>23474         }
<a name="l23475"></a>23475       } <span class="keywordflow">else</span> {                   <span class="comment">// The neighbor exists and is not infected.</span>
<a name="l23476"></a>23476         <span class="keywordflow">if</span> (neighsh.sh == dummysh) {
<a name="l23477"></a>23477           <span class="comment">// There is no subface protecting the neighbor, infect it.</span>
<a name="l23478"></a>23478           infect(neighbor);
<a name="l23479"></a>23479           <span class="comment">// Ensure that the neighbor&#39;s neighbors will be infected.</span>
<a name="l23480"></a>23480           deadtet = (tetrahedron **) viri-&gt;alloc();
<a name="l23481"></a>23481           *deadtet = neighbor.tet;
<a name="l23482"></a>23482         } <span class="keywordflow">else</span> {               <span class="comment">// The neighbor is protected by a subface.</span>
<a name="l23483"></a>23483           <span class="comment">// Remove this tetrahedron from the subface.</span>
<a name="l23484"></a>23484           stdissolve(neighsh);
<a name="l23485"></a>23485           <span class="comment">// The subface becomes a boundary.  Set markers accordingly.</span>
<a name="l23486"></a>23486           <span class="keywordflow">if</span> (shellmark(neighsh) == 0) {
<a name="l23487"></a>23487             setshellmark(neighsh, 1);
<a name="l23488"></a>23488           }
<a name="l23489"></a>23489           <span class="comment">// This side becomes hull. Update the handle in dummytet.</span>
<a name="l23490"></a>23490           dummytet[0] = encode(neighbor);
<a name="l23491"></a>23491         }
<a name="l23492"></a>23492       }
<a name="l23493"></a>23493     }
<a name="l23494"></a>23494     <span class="comment">// Remark the tetrahedron as infected, so it doesn&#39;t get added to the</span>
<a name="l23495"></a>23495     <span class="comment">//   virus pool again.</span>
<a name="l23496"></a>23496     infect(testtet);
<a name="l23497"></a>23497     virusloop = (tetrahedron **) viri-&gt;traverse();
<a name="l23498"></a>23498   }
<a name="l23499"></a>23499 }
<a name="l23500"></a>23500 
<a name="l23502"></a>23502 <span class="comment">//                                                                           //</span>
<a name="l23503"></a>23503 <span class="comment">// regionplague()    Spread regional attributes and/or volume constraints    //</span>
<a name="l23504"></a>23504 <span class="comment">//                   (from a .poly file) throughout the mesh.                //</span>
<a name="l23505"></a>23505 <span class="comment">//                                                                           //</span>
<a name="l23506"></a>23506 <span class="comment">// This procedure operates in two phases.  The first phase spreads an attri- //</span>
<a name="l23507"></a>23507 <span class="comment">// bute and/or a volume constraint through a (facet-bounded) region.  The    //</span>
<a name="l23508"></a>23508 <span class="comment">// second phase uninfects all infected tetrahedra, returning them to normal. //</span>
<a name="l23509"></a>23509 <span class="comment">//                                                                           //</span>
<a name="l23511"></a>23511 <span class="comment"></span>
<a name="l23512"></a>23512 <span class="keywordtype">void</span> tetgenmesh::
<a name="l23513"></a>23513 regionplague(<a class="code" href="structmemorypool.html">memorypool</a> *regionviri, REAL attribute, REAL volume)
<a name="l23514"></a>23514 {
<a name="l23515"></a>23515   tetrahedron **virusloop;
<a name="l23516"></a>23516   tetrahedron **regiontet;
<a name="l23517"></a>23517   triface testtet, neighbor;
<a name="l23518"></a>23518   face neighsh;
<a name="l23519"></a>23519 
<a name="l23520"></a>23520   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l23521"></a>23521     printf(<span class="stringliteral">&quot;  Marking neighbors of marked tetrahedra.\n&quot;</span>);
<a name="l23522"></a>23522   }
<a name="l23523"></a>23523   <span class="comment">// Loop through all the infected tetrahedra, spreading the attribute</span>
<a name="l23524"></a>23524   <span class="comment">//   and/or volume constraint to their neighbors, then to their neighbors&#39;</span>
<a name="l23525"></a>23525   <span class="comment">//   neighbors.</span>
<a name="l23526"></a>23526   regionviri-&gt;traversalinit();
<a name="l23527"></a>23527   virusloop = (tetrahedron **) regionviri-&gt;traverse();
<a name="l23528"></a>23528   <span class="keywordflow">while</span> (virusloop != (tetrahedron **) NULL) {
<a name="l23529"></a>23529     testtet.tet = *virusloop;
<a name="l23530"></a>23530     <span class="comment">// Temporarily uninfect this tetrahedron, not necessary.</span>
<a name="l23531"></a>23531     uninfect(testtet);
<a name="l23532"></a>23532     <span class="keywordflow">if</span> (b-&gt;regionattrib) {
<a name="l23533"></a>23533       <span class="comment">// Set an attribute.</span>
<a name="l23534"></a>23534       setelemattribute(testtet.tet, in-&gt;numberoftetrahedronattributes,
<a name="l23535"></a>23535                        attribute);
<a name="l23536"></a>23536     }
<a name="l23537"></a>23537     <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l23538"></a>23538       <span class="comment">// Set a volume constraint.</span>
<a name="l23539"></a>23539       setvolumebound(testtet.tet, volume);
<a name="l23540"></a>23540     }
<a name="l23541"></a>23541     <span class="comment">// Check each of the tetrahedron&#39;s four neighbors.</span>
<a name="l23542"></a>23542     <span class="keywordflow">for</span> (testtet.loc = 0; testtet.loc &lt; 4; testtet.loc++) {
<a name="l23543"></a>23543       <span class="comment">// Find the neighbor.</span>
<a name="l23544"></a>23544       sym(testtet, neighbor);
<a name="l23545"></a>23545       <span class="comment">// Check for a subface between the tetrahedron and its neighbor.</span>
<a name="l23546"></a>23546       tspivot(testtet, neighsh);
<a name="l23547"></a>23547       <span class="comment">// Make sure the neighbor exists, is not already infected, and</span>
<a name="l23548"></a>23548       <span class="comment">//   isn&#39;t protected by a subface, or is protected by a nonsolid</span>
<a name="l23549"></a>23549       <span class="comment">//   subface.</span>
<a name="l23550"></a>23550       <span class="keywordflow">if</span> ((neighbor.tet != dummytet) &amp;&amp; !infected(neighbor)
<a name="l23551"></a>23551           &amp;&amp; (neighsh.sh == dummysh)) {
<a name="l23552"></a>23552         <span class="comment">// Infect the neighbor.</span>
<a name="l23553"></a>23553         infect(neighbor);
<a name="l23554"></a>23554         <span class="comment">// Ensure that the neighbor&#39;s neighbors will be infected.</span>
<a name="l23555"></a>23555         regiontet = (tetrahedron **) regionviri-&gt;alloc();
<a name="l23556"></a>23556         *regiontet = neighbor.tet;
<a name="l23557"></a>23557       }
<a name="l23558"></a>23558     }
<a name="l23559"></a>23559     <span class="comment">// Remark the tetrahedron as infected, so it doesn&#39;t get added to the</span>
<a name="l23560"></a>23560     <span class="comment">//   virus pool again.</span>
<a name="l23561"></a>23561     infect(testtet);
<a name="l23562"></a>23562     virusloop = (tetrahedron **) regionviri-&gt;traverse();
<a name="l23563"></a>23563   }
<a name="l23564"></a>23564 
<a name="l23565"></a>23565   <span class="comment">// Uninfect all tetrahedra.</span>
<a name="l23566"></a>23566   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l23567"></a>23567     printf(<span class="stringliteral">&quot;  Unmarking marked tetrahedra.\n&quot;</span>);
<a name="l23568"></a>23568   }
<a name="l23569"></a>23569   regionviri-&gt;traversalinit();
<a name="l23570"></a>23570   virusloop = (tetrahedron **) regionviri-&gt;traverse();
<a name="l23571"></a>23571   <span class="keywordflow">while</span> (virusloop != (tetrahedron **) NULL) {
<a name="l23572"></a>23572     testtet.tet = *virusloop;
<a name="l23573"></a>23573     uninfect(testtet);
<a name="l23574"></a>23574     virusloop = (tetrahedron **) regionviri-&gt;traverse();
<a name="l23575"></a>23575   }
<a name="l23576"></a>23576   <span class="comment">// Empty the virus pool.</span>
<a name="l23577"></a>23577   regionviri-&gt;restart();
<a name="l23578"></a>23578 }
<a name="l23579"></a>23579 
<a name="l23581"></a>23581 <span class="comment">//                                                                           //</span>
<a name="l23582"></a>23582 <span class="comment">// removeholetets()    Remove tetrahedra which are outside the domain.       //</span>
<a name="l23583"></a>23583 <span class="comment">//                                                                           //</span>
<a name="l23585"></a>23585 <span class="comment"></span>
<a name="l23586"></a>23586 <span class="keywordtype">void</span> tetgenmesh::removeholetets(<a class="code" href="structmemorypool.html">memorypool</a>* viri)
<a name="l23587"></a>23587 {
<a name="l23588"></a>23588   tetrahedron **virusloop;
<a name="l23589"></a>23589   triface testtet, neighbor;
<a name="l23590"></a>23590   point checkpt;
<a name="l23591"></a>23591   <span class="keywordtype">int</span> *tetspernodelist;
<a name="l23592"></a>23592   <span class="keywordtype">int</span> i, j;
<a name="l23593"></a>23593 
<a name="l23594"></a>23594   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l23595"></a>23595     printf(<span class="stringliteral">&quot;  Deleting marked tetrahedra.\n&quot;</span>);
<a name="l23596"></a>23596   }
<a name="l23597"></a>23597 
<a name="l23598"></a>23598   <span class="comment">// Create and initialize &#39;tetspernodelist&#39;.</span>
<a name="l23599"></a>23599   tetspernodelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l23600"></a>23600   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) tetspernodelist[i] = 0;
<a name="l23601"></a>23601 
<a name="l23602"></a>23602   <span class="comment">// Loop the tetrahedra list, counter the number of tets sharing each node.</span>
<a name="l23603"></a>23603   tetrahedrons-&gt;traversalinit();
<a name="l23604"></a>23604   testtet.tet = tetrahedrontraverse();
<a name="l23605"></a>23605   <span class="keywordflow">while</span> (testtet.tet != (tetrahedron *) NULL) {
<a name="l23606"></a>23606     <span class="comment">// Increment the number of sharing tets for each endpoint.</span>
<a name="l23607"></a>23607     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l23608"></a>23608       j = pointmark((point) testtet.tet[4 + i]);
<a name="l23609"></a>23609       tetspernodelist[j]++;
<a name="l23610"></a>23610     }
<a name="l23611"></a>23611     testtet.tet = tetrahedrontraverse();
<a name="l23612"></a>23612   }
<a name="l23613"></a>23613 
<a name="l23614"></a>23614   viri-&gt;traversalinit();
<a name="l23615"></a>23615   virusloop = (tetrahedron **) viri-&gt;traverse();
<a name="l23616"></a>23616   <span class="keywordflow">while</span> (virusloop != (tetrahedron **) NULL) {
<a name="l23617"></a>23617     testtet.tet = *virusloop;
<a name="l23618"></a>23618     <span class="comment">// Record changes in the number of boundary faces, and disconnect</span>
<a name="l23619"></a>23619     <span class="comment">//   dead tetrahedra from their neighbors.</span>
<a name="l23620"></a>23620     <span class="keywordflow">for</span> (testtet.loc = 0; testtet.loc &lt; 4; testtet.loc++) {
<a name="l23621"></a>23621       sym(testtet, neighbor);
<a name="l23622"></a>23622       <span class="keywordflow">if</span> (neighbor.tet == dummytet) {
<a name="l23623"></a>23623         <span class="comment">// There is no neighboring tetrahedron on this face, so this face</span>
<a name="l23624"></a>23624         <span class="comment">//   is a boundary face.  This tetrahedron is being deleted, so this</span>
<a name="l23625"></a>23625         <span class="comment">//   boundary face is deleted.</span>
<a name="l23626"></a>23626         hullsize--;
<a name="l23627"></a>23627       } <span class="keywordflow">else</span> {
<a name="l23628"></a>23628         <span class="comment">// Disconnect the tetrahedron from its neighbor.</span>
<a name="l23629"></a>23629         dissolve(neighbor);
<a name="l23630"></a>23630         <span class="comment">// There is a neighboring tetrahedron on this face, so this face</span>
<a name="l23631"></a>23631         <span class="comment">//   becomes a boundary face when this tetrahedron is deleted.</span>
<a name="l23632"></a>23632         hullsize++;
<a name="l23633"></a>23633       }
<a name="l23634"></a>23634     }
<a name="l23635"></a>23635     <span class="comment">// Check the four corners of this tet if they&#39;re isolated.</span>
<a name="l23636"></a>23636     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l23637"></a>23637       checkpt = (point) testtet.tet[4 + i];
<a name="l23638"></a>23638       j = pointmark(checkpt);
<a name="l23639"></a>23639       tetspernodelist[j]--;
<a name="l23640"></a>23640       <span class="keywordflow">if</span> (tetspernodelist[j] == 0) {
<a name="l23641"></a>23641         <span class="comment">// If it is added volume vertex or &#39;-j&#39; is not used, delete it.</span>
<a name="l23642"></a>23642         <span class="keywordflow">if</span> ((pointtype(checkpt) == FREEVOLVERTEX) || !b-&gt;nojettison) {
<a name="l23643"></a>23643           setpointtype(checkpt, UNUSEDVERTEX);
<a name="l23644"></a>23644           unuverts++;
<a name="l23645"></a>23645         }
<a name="l23646"></a>23646       }
<a name="l23647"></a>23647     }
<a name="l23648"></a>23648     <span class="comment">// Return the dead tetrahedron to the pool of tetrahedra.</span>
<a name="l23649"></a>23649     tetrahedrondealloc(testtet.tet);
<a name="l23650"></a>23650     virusloop = (tetrahedron **) viri-&gt;traverse();
<a name="l23651"></a>23651   }
<a name="l23652"></a>23652 
<a name="l23653"></a>23653   <span class="keyword">delete</span> [] tetspernodelist;
<a name="l23654"></a>23654 }
<a name="l23655"></a>23655 
<a name="l23657"></a>23657 <span class="comment">//                                                                           //</span>
<a name="l23658"></a>23658 <span class="comment">// assignregionattribs()    Assign each tetrahedron a region number.         //</span>
<a name="l23659"></a>23659 <span class="comment">//                                                                           //</span>
<a name="l23660"></a>23660 <span class="comment">// This routine is called when &#39;-AA&#39; switch is specified.  Every tetrahedron //</span>
<a name="l23661"></a>23661 <span class="comment">// of a (bounded) region will get a integer number to that region.  Default, //</span>
<a name="l23662"></a>23662 <span class="comment">// regions are numbered as 1, 2, 3, etc. However, if a number has already    //</span>
<a name="l23663"></a>23663 <span class="comment">// been used (set by user in the region section in .poly or .smesh), it is   //</span>
<a name="l23664"></a>23664 <span class="comment">// skipped and the next available number will be used.                       //</span>
<a name="l23665"></a>23665 <span class="comment">//                                                                           //</span>
<a name="l23667"></a>23667 <span class="comment"></span>
<a name="l23668"></a>23668 <span class="keywordtype">void</span> tetgenmesh::assignregionattribs()
<a name="l23669"></a>23669 {
<a name="l23670"></a>23670   list *regionnumlist;
<a name="l23671"></a>23671   list *regiontetlist;
<a name="l23672"></a>23672   triface tetloop, regiontet, neightet;
<a name="l23673"></a>23673   face checksh;
<a name="l23674"></a>23674   <span class="keywordtype">bool</span> flag;
<a name="l23675"></a>23675   <span class="keywordtype">int</span> regionnum, num;
<a name="l23676"></a>23676   <span class="keywordtype">int</span> attridx, count;
<a name="l23677"></a>23677   <span class="keywordtype">int</span> i;
<a name="l23678"></a>23678 
<a name="l23679"></a>23679   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l23680"></a>23680     printf(<span class="stringliteral">&quot;  Assign region numbers.\n&quot;</span>);
<a name="l23681"></a>23681   }
<a name="l23682"></a>23682 
<a name="l23683"></a>23683   regionnumlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>), NULL, 256);
<a name="l23684"></a>23684   regiontetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 1024);
<a name="l23685"></a>23685   attridx = in-&gt;numberoftetrahedronattributes;
<a name="l23686"></a>23686 
<a name="l23687"></a>23687   <span class="comment">// Loop through all tets. Infect tets which already have a region number,</span>
<a name="l23688"></a>23688   <span class="comment">//   and save the used numbers in &#39;regionnumlist&#39;.</span>
<a name="l23689"></a>23689   tetrahedrons-&gt;traversalinit();
<a name="l23690"></a>23690   tetloop.tet = tetrahedrontraverse();
<a name="l23691"></a>23691   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l23692"></a>23692     <span class="keywordflow">if</span> (!infected(tetloop)) {
<a name="l23693"></a>23693       regionnum = (int) elemattribute(tetloop.tet, attridx);
<a name="l23694"></a>23694       <span class="keywordflow">if</span> (regionnum != 0.0) {
<a name="l23695"></a>23695         <span class="comment">// Found a numbered region tet.</span>
<a name="l23696"></a>23696         infect(tetloop);
<a name="l23697"></a>23697         regiontetlist-&gt;append(&amp;tetloop);
<a name="l23698"></a>23698         <span class="comment">// Found and infect all tets in this region.</span>
<a name="l23699"></a>23699         <span class="keywordflow">for</span> (i = 0; i &lt; regiontetlist-&gt;len(); i++) {
<a name="l23700"></a>23700           regiontet = * (triface *)(* regiontetlist)[i];
<a name="l23701"></a>23701           <span class="keywordflow">for</span> (regiontet.loc = 0; regiontet.loc &lt; 4; regiontet.loc++) {
<a name="l23702"></a>23702             <span class="comment">// Is there a boundary face?</span>
<a name="l23703"></a>23703             tspivot(regiontet, checksh);
<a name="l23704"></a>23704             <span class="keywordflow">if</span> (checksh.sh == dummysh) {
<a name="l23705"></a>23705               sym(regiontet, neightet);
<a name="l23706"></a>23706               <span class="keywordflow">if</span> ((neightet.tet != dummytet) &amp;&amp; !infected(neightet)) {
<a name="l23707"></a>23707 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l23708"></a>23708 <span class="preprocessor"></span>                <span class="comment">// neightet should have the same region number. Check it.</span>
<a name="l23709"></a>23709                 num = (int) elemattribute(neightet.tet, attridx);
<a name="l23710"></a>23710                 assert(num == regionnum);
<a name="l23711"></a>23711 <span class="preprocessor">#endif</span>
<a name="l23712"></a>23712 <span class="preprocessor"></span>                infect(neightet);
<a name="l23713"></a>23713                 regiontetlist-&gt;append(&amp;neightet);
<a name="l23714"></a>23714               }
<a name="l23715"></a>23715             }
<a name="l23716"></a>23716           }
<a name="l23717"></a>23717         }
<a name="l23718"></a>23718         <span class="comment">// Add regionnum to list if it is not exist.</span>
<a name="l23719"></a>23719         flag = <span class="keyword">false</span>;
<a name="l23720"></a>23720         <span class="keywordflow">for</span> (i = 0; i &lt; regionnumlist-&gt;len() &amp;&amp; !flag; i++) {
<a name="l23721"></a>23721           num = * (<span class="keywordtype">int</span> *)(* regionnumlist)[i];
<a name="l23722"></a>23722           flag = (num == regionnum);
<a name="l23723"></a>23723         }
<a name="l23724"></a>23724         <span class="keywordflow">if</span> (!flag) regionnumlist-&gt;append(&amp;regionnum);
<a name="l23725"></a>23725         <span class="comment">// Clear list for the next region.</span>
<a name="l23726"></a>23726         regiontetlist-&gt;clear();
<a name="l23727"></a>23727       }
<a name="l23728"></a>23728     }
<a name="l23729"></a>23729     tetloop.tet = tetrahedrontraverse();
<a name="l23730"></a>23730   }
<a name="l23731"></a>23731 
<a name="l23732"></a>23732   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l23733"></a>23733     printf(<span class="stringliteral">&quot;  %d user-specified regions.\n&quot;</span>, regionnumlist-&gt;len());
<a name="l23734"></a>23734   }
<a name="l23735"></a>23735 
<a name="l23736"></a>23736   <span class="comment">// Now loop the tets again. Assign region numbers to uninfected tets.</span>
<a name="l23737"></a>23737   tetrahedrons-&gt;traversalinit();
<a name="l23738"></a>23738   tetloop.tet = tetrahedrontraverse();
<a name="l23739"></a>23739   regionnum = 1;  <span class="comment">// Start region number.</span>
<a name="l23740"></a>23740   count = 0;
<a name="l23741"></a>23741   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l23742"></a>23742     <span class="keywordflow">if</span> (!infected(tetloop)) {
<a name="l23743"></a>23743       <span class="comment">// An unassigned region tet.</span>
<a name="l23744"></a>23744       count++;
<a name="l23745"></a>23745       <span class="keywordflow">do</span> {
<a name="l23746"></a>23746         flag = <span class="keyword">false</span>;
<a name="l23747"></a>23747         <span class="comment">// Check if the region number has been used.</span>
<a name="l23748"></a>23748         <span class="keywordflow">for</span> (i = 0; i &lt; regionnumlist-&gt;len() &amp;&amp; !flag; i++) {
<a name="l23749"></a>23749           num = * (<span class="keywordtype">int</span> *)(* regionnumlist)[i];
<a name="l23750"></a>23750           flag = (num == regionnum);
<a name="l23751"></a>23751         }
<a name="l23752"></a>23752         <span class="keywordflow">if</span> (flag) regionnum++;
<a name="l23753"></a>23753       } <span class="keywordflow">while</span> (flag);
<a name="l23754"></a>23754       setelemattribute(tetloop.tet, attridx, (REAL) regionnum);
<a name="l23755"></a>23755       infect(tetloop);
<a name="l23756"></a>23756       regiontetlist-&gt;append(&amp;tetloop);
<a name="l23757"></a>23757       <span class="comment">// Found and infect all tets in this region.</span>
<a name="l23758"></a>23758       <span class="keywordflow">for</span> (i = 0; i &lt; regiontetlist-&gt;len(); i++) {
<a name="l23759"></a>23759         regiontet = * (triface *)(* regiontetlist)[i];
<a name="l23760"></a>23760         <span class="keywordflow">for</span> (regiontet.loc = 0; regiontet.loc &lt; 4; regiontet.loc++) {
<a name="l23761"></a>23761           <span class="comment">// Is there a boundary face?</span>
<a name="l23762"></a>23762           tspivot(regiontet, checksh);
<a name="l23763"></a>23763           <span class="keywordflow">if</span> (checksh.sh == dummysh) {
<a name="l23764"></a>23764             sym(regiontet, neightet);
<a name="l23765"></a>23765             <span class="keywordflow">if</span> ((neightet.tet != dummytet) &amp;&amp; !infected(neightet)) {
<a name="l23766"></a>23766 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l23767"></a>23767 <span class="preprocessor"></span>              <span class="comment">// neightet should have not been assigned yet. Check it.</span>
<a name="l23768"></a>23768               num = (int) elemattribute(neightet.tet, attridx);
<a name="l23769"></a>23769               assert(num == 0);
<a name="l23770"></a>23770 <span class="preprocessor">#endif</span>
<a name="l23771"></a>23771 <span class="preprocessor"></span>              setelemattribute(neightet.tet, attridx, (REAL) regionnum);
<a name="l23772"></a>23772               infect(neightet);
<a name="l23773"></a>23773               regiontetlist-&gt;append(&amp;neightet);
<a name="l23774"></a>23774             }
<a name="l23775"></a>23775           }
<a name="l23776"></a>23776         }
<a name="l23777"></a>23777       }
<a name="l23778"></a>23778       regiontetlist-&gt;clear();
<a name="l23779"></a>23779       regionnum++; <span class="comment">// The next region number.</span>
<a name="l23780"></a>23780     }
<a name="l23781"></a>23781     tetloop.tet = tetrahedrontraverse();
<a name="l23782"></a>23782   }
<a name="l23783"></a>23783 
<a name="l23784"></a>23784   <span class="comment">// Uninfect all tets.</span>
<a name="l23785"></a>23785   tetrahedrons-&gt;traversalinit();
<a name="l23786"></a>23786   tetloop.tet = tetrahedrontraverse();
<a name="l23787"></a>23787   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l23788"></a>23788 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l23789"></a>23789 <span class="preprocessor"></span>    assert(infected(tetloop));
<a name="l23790"></a>23790 <span class="preprocessor">#endif</span>
<a name="l23791"></a>23791 <span class="preprocessor"></span>    uninfect(tetloop);
<a name="l23792"></a>23792     tetloop.tet = tetrahedrontraverse();
<a name="l23793"></a>23793   }
<a name="l23794"></a>23794 
<a name="l23795"></a>23795   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l23796"></a>23796     printf(<span class="stringliteral">&quot;  %d regions are numbered.\n&quot;</span>, count);
<a name="l23797"></a>23797   }
<a name="l23798"></a>23798 
<a name="l23799"></a>23799   <span class="keyword">delete</span> regionnumlist;
<a name="l23800"></a>23800   <span class="keyword">delete</span> regiontetlist;
<a name="l23801"></a>23801 }
<a name="l23802"></a>23802 
<a name="l23804"></a>23804 <span class="comment">//                                                                           //</span>
<a name="l23805"></a>23805 <span class="comment">// carveholes()    Find the holes and infect them.  Find the volume          //</span>
<a name="l23806"></a>23806 <span class="comment">//                 constraints and infect them.  Infect the convex hull.     //</span>
<a name="l23807"></a>23807 <span class="comment">//                 Spread the infection and kill tetrahedra.  Spread the     //</span>
<a name="l23808"></a>23808 <span class="comment">//                 volume constraints.                                       //</span>
<a name="l23809"></a>23809 <span class="comment">//                                                                           //</span>
<a name="l23810"></a>23810 <span class="comment">// This routine mainly calls other routines to carry out all these functions.//</span>
<a name="l23811"></a>23811 <span class="comment">//                                                                           //</span>
<a name="l23813"></a>23813 <span class="comment"></span>
<a name="l23814"></a>23814 <span class="keywordtype">void</span> tetgenmesh::carveholes()
<a name="l23815"></a>23815 {
<a name="l23816"></a>23816   <a class="code" href="structmemorypool.html">memorypool</a> *holeviri, *regionviri;
<a name="l23817"></a>23817   tetrahedron *tptr, **holetet, **regiontet;
<a name="l23818"></a>23818   triface searchtet, *holetets, *regiontets;
<a name="l23819"></a>23819   <span class="keyword">enum</span> locateresult intersect;
<a name="l23820"></a>23820   <span class="keywordtype">int</span> i;
<a name="l23821"></a>23821 
<a name="l23822"></a>23822   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l23823"></a>23823     printf(<span class="stringliteral">&quot;Removing unwanted tetrahedra.\n&quot;</span>);
<a name="l23824"></a>23824     <span class="keywordflow">if</span> (b-&gt;verbose &amp;&amp; (in-&gt;numberofholes &gt; 0)) {
<a name="l23825"></a>23825       printf(<span class="stringliteral">&quot;  Marking holes for elimination.\n&quot;</span>);
<a name="l23826"></a>23826     }
<a name="l23827"></a>23827   }
<a name="l23828"></a>23828 
<a name="l23829"></a>23829   <span class="comment">// Initialize a pool of viri to be used for holes, concavities.</span>
<a name="l23830"></a>23830   holeviri = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(tetrahedron *), 1024, POINTER, 0);
<a name="l23831"></a>23831   <span class="comment">// Mark as infected any unprotected tetrahedra on the boundary.</span>
<a name="l23832"></a>23832   infecthull(holeviri);
<a name="l23833"></a>23833 
<a name="l23834"></a>23834   <span class="keywordflow">if</span> (in-&gt;numberofholes &gt; 0) {
<a name="l23835"></a>23835     <span class="comment">// Allocate storage for the tetrahedra in which hole points fall.</span>
<a name="l23836"></a>23836     holetets = (triface *) <span class="keyword">new</span> triface[in-&gt;numberofholes];
<a name="l23837"></a>23837     <span class="comment">// Infect each tetrahedron in which a hole lies.</span>
<a name="l23838"></a>23838     for (i = 0; i &lt; 3 * in-&gt;numberofholes; i += 3) {
<a name="l23839"></a>23839       <span class="comment">// Ignore holes that aren&#39;t within the bounds of the mesh.</span>
<a name="l23840"></a>23840       <span class="keywordflow">if</span> ((in-&gt;holelist[i] &gt;= xmin) &amp;&amp; (in-&gt;holelist[i] &lt;= xmax)
<a name="l23841"></a>23841           &amp;&amp; (in-&gt;holelist[i + 1] &gt;= ymin)
<a name="l23842"></a>23842           &amp;&amp; (in-&gt;holelist[i + 1] &lt;= ymax)
<a name="l23843"></a>23843           &amp;&amp; (in-&gt;holelist[i + 2] &gt;= zmin)
<a name="l23844"></a>23844           &amp;&amp; (in-&gt;holelist[i + 2] &lt;= zmax)) {
<a name="l23845"></a>23845         searchtet.tet = dummytet;
<a name="l23846"></a>23846         <span class="comment">// Find a tetrahedron that contains the hole.</span>
<a name="l23847"></a>23847         intersect = locate(&amp;in-&gt;holelist[i], &amp;searchtet);
<a name="l23848"></a>23848         <span class="keywordflow">if</span> ((intersect != OUTSIDE) &amp;&amp; (!infected(searchtet))) {
<a name="l23849"></a>23849           <span class="comment">// Record the tetrahedron for processing carve hole.</span>
<a name="l23850"></a>23850           holetets[i / 3] = searchtet;
<a name="l23851"></a>23851         }
<a name="l23852"></a>23852       }
<a name="l23853"></a>23853     }
<a name="l23854"></a>23854     <span class="comment">// Infect the hole tetrahedron.  This is done by marking the tet as</span>
<a name="l23855"></a>23855     <span class="comment">//   infected and including the tetrahedron in the virus pool.</span>
<a name="l23856"></a>23856     <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofholes; i++) {
<a name="l23857"></a>23857       infect(holetets[i]);
<a name="l23858"></a>23858       holetet = (tetrahedron **) holeviri-&gt;alloc();
<a name="l23859"></a>23859       *holetet = holetets[i].tet;
<a name="l23860"></a>23860     }
<a name="l23861"></a>23861     <span class="comment">// Free up memory.</span>
<a name="l23862"></a>23862     <span class="keyword">delete</span> [] holetets;
<a name="l23863"></a>23863   }
<a name="l23864"></a>23864 
<a name="l23865"></a>23865   <span class="comment">// Mark as infected all tets of the holes and concavities.</span>
<a name="l23866"></a>23866   plague(holeviri);
<a name="l23867"></a>23867   <span class="comment">// The virus pool contains all outside tets now.</span>
<a name="l23868"></a>23868 
<a name="l23869"></a>23869   <span class="comment">// Is -A switch in use.</span>
<a name="l23870"></a>23870   <span class="keywordflow">if</span> (b-&gt;regionattrib) {
<a name="l23871"></a>23871     <span class="comment">// Assign every tetrahedron a regional attribute of zero.</span>
<a name="l23872"></a>23872     tetrahedrons-&gt;traversalinit();
<a name="l23873"></a>23873     tptr = tetrahedrontraverse();
<a name="l23874"></a>23874     <span class="keywordflow">while</span> (tptr != (tetrahedron *) NULL) {
<a name="l23875"></a>23875       setelemattribute(tptr, in-&gt;numberoftetrahedronattributes, 0.0);
<a name="l23876"></a>23876       tptr = tetrahedrontraverse();
<a name="l23877"></a>23877     }
<a name="l23878"></a>23878   }
<a name="l23879"></a>23879 
<a name="l23880"></a>23880   <span class="keywordflow">if</span> (in-&gt;numberofregions &gt; 0) {
<a name="l23881"></a>23881     <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l23882"></a>23882       <span class="keywordflow">if</span> (b-&gt;regionattrib) {
<a name="l23883"></a>23883         <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l23884"></a>23884           printf(<span class="stringliteral">&quot;Spreading regional attributes and volume constraints.\n&quot;</span>);
<a name="l23885"></a>23885         } <span class="keywordflow">else</span> {
<a name="l23886"></a>23886           printf(<span class="stringliteral">&quot;Spreading regional attributes.\n&quot;</span>);
<a name="l23887"></a>23887         }
<a name="l23888"></a>23888       } <span class="keywordflow">else</span> {
<a name="l23889"></a>23889         printf(<span class="stringliteral">&quot;Spreading regional volume constraints.\n&quot;</span>);
<a name="l23890"></a>23890       }
<a name="l23891"></a>23891     }
<a name="l23892"></a>23892     <span class="comment">// Allocate storage for the tetrahedra in which region points fall.</span>
<a name="l23893"></a>23893     regiontets = (triface *) <span class="keyword">new</span> triface[in-&gt;numberofregions];
<a name="l23894"></a>23894     <span class="comment">// Find the starting tetrahedron for each region.</span>
<a name="l23895"></a>23895     for (i = 0; i &lt; in-&gt;numberofregions; i++) {
<a name="l23896"></a>23896       regiontets[i].tet = dummytet;
<a name="l23897"></a>23897       <span class="comment">// Ignore region points that aren&#39;t within the bounds of the mesh.</span>
<a name="l23898"></a>23898       <span class="keywordflow">if</span> ((in-&gt;regionlist[5 * i] &gt;= xmin)
<a name="l23899"></a>23899            &amp;&amp; (in-&gt;regionlist[5 * i] &lt;= xmax)
<a name="l23900"></a>23900            &amp;&amp; (in-&gt;regionlist[5 * i + 1] &gt;= ymin)
<a name="l23901"></a>23901            &amp;&amp; (in-&gt;regionlist[5 * i + 1] &lt;= ymax)
<a name="l23902"></a>23902            &amp;&amp; (in-&gt;regionlist[5 * i + 2] &gt;= zmin)
<a name="l23903"></a>23903            &amp;&amp; (in-&gt;regionlist[5 * i + 2] &lt;= zmax)) {
<a name="l23904"></a>23904         searchtet.tet = dummytet;
<a name="l23905"></a>23905         <span class="comment">// Find a tetrahedron that contains the region point.</span>
<a name="l23906"></a>23906         intersect = locate(&amp;in-&gt;regionlist[5 * i], &amp;searchtet);
<a name="l23907"></a>23907         <span class="keywordflow">if</span> ((intersect != OUTSIDE) &amp;&amp; (!infected(searchtet))) {
<a name="l23908"></a>23908           <span class="comment">// Record the tetrahedron for processing after the</span>
<a name="l23909"></a>23909           <span class="comment">//   holes have been carved.</span>
<a name="l23910"></a>23910           regiontets[i] = searchtet;
<a name="l23911"></a>23911         }
<a name="l23912"></a>23912       }
<a name="l23913"></a>23913     }
<a name="l23914"></a>23914     <span class="comment">// Initialize a pool to be used for regional attrs, and/or regional</span>
<a name="l23915"></a>23915     <span class="comment">//   volume constraints.</span>
<a name="l23916"></a>23916     regionviri = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(tetrahedron *), 1024, POINTER, 0);
<a name="l23917"></a>23917     <span class="comment">// Find and set all regions.</span>
<a name="l23918"></a>23918     <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofregions; i++) {
<a name="l23919"></a>23919       <span class="keywordflow">if</span> (regiontets[i].tet != dummytet) {
<a name="l23920"></a>23920         <span class="comment">// Make sure the tetrahedron under consideration still exists.</span>
<a name="l23921"></a>23921         <span class="comment">//   It may have been eaten by the virus.</span>
<a name="l23922"></a>23922         <span class="keywordflow">if</span> (!isdead(&amp;(regiontets[i]))) {
<a name="l23923"></a>23923           <span class="comment">// Put one tetrahedron in the virus pool.</span>
<a name="l23924"></a>23924           infect(regiontets[i]);
<a name="l23925"></a>23925           regiontet = (tetrahedron **) regionviri-&gt;alloc();
<a name="l23926"></a>23926           *regiontet = regiontets[i].tet;
<a name="l23927"></a>23927           <span class="comment">// Apply one region&#39;s attribute and/or volume constraint.</span>
<a name="l23928"></a>23928           regionplague(regionviri, in-&gt;regionlist[5 * i + 3],
<a name="l23929"></a>23929                        in-&gt;regionlist[5 * i + 4]);
<a name="l23930"></a>23930           <span class="comment">// The virus pool should be empty now.</span>
<a name="l23931"></a>23931         }
<a name="l23932"></a>23932       }
<a name="l23933"></a>23933     }
<a name="l23934"></a>23934     <span class="comment">// Free up memory.</span>
<a name="l23935"></a>23935     <span class="keyword">delete</span> [] regiontets;
<a name="l23936"></a>23936     <span class="keyword">delete</span> regionviri;
<a name="l23937"></a>23937   }
<a name="l23938"></a>23938 
<a name="l23939"></a>23939   <span class="comment">// Now acutually remove the outside and hole tets.</span>
<a name="l23940"></a>23940   removeholetets(holeviri);
<a name="l23941"></a>23941   <span class="comment">// The mesh is nonconvex now.</span>
<a name="l23942"></a>23942   nonconvex = 1;
<a name="l23943"></a>23943 
<a name="l23944"></a>23944   <span class="keywordflow">if</span> (b-&gt;regionattrib) {
<a name="l23945"></a>23945     <span class="keywordflow">if</span> (b-&gt;regionattrib &gt; 1) {
<a name="l23946"></a>23946       <span class="comment">// -AA switch. Assign each tet a region number (&gt; 0).</span>
<a name="l23947"></a>23947       assignregionattribs();
<a name="l23948"></a>23948     }
<a name="l23949"></a>23949     <span class="comment">// Note the fact that each tetrahedron has an additional attribute.</span>
<a name="l23950"></a>23950     in-&gt;numberoftetrahedronattributes++;
<a name="l23951"></a>23951   }
<a name="l23952"></a>23952 
<a name="l23953"></a>23953   <span class="comment">// Free up memory.</span>
<a name="l23954"></a>23954   <span class="keyword">delete</span> holeviri;
<a name="l23955"></a>23955 }
<a name="l23956"></a>23956 
<a name="l23957"></a>23957 <span class="comment">//</span>
<a name="l23958"></a>23958 <span class="comment">// End of carving out holes and concavities routines</span>
<a name="l23959"></a>23959 <span class="comment">//</span>
<a name="l23960"></a>23960 
<a name="l23961"></a>23961 <span class="comment">//</span>
<a name="l23962"></a>23962 <span class="comment">// Begin of boundary Steiner points removing routines</span>
<a name="l23963"></a>23963 <span class="comment">//</span>
<a name="l23964"></a>23964 
<a name="l23966"></a>23966 <span class="comment">//                                                                           //</span>
<a name="l23967"></a>23967 <span class="comment">// replacepolygonsubs()    Substitute the subfaces of a polygon.             //</span>
<a name="l23968"></a>23968 <span class="comment">//                                                                           //</span>
<a name="l23969"></a>23969 <span class="comment">// &#39;oldshlist&#39; (T_old) contains the old subfaces of P.  It will be replaced  //</span>
<a name="l23970"></a>23970 <span class="comment">// by &#39;newshlist&#39; (T_new) of new subfaces. Each boundary edge of P is bonded //</span>
<a name="l23971"></a>23971 <span class="comment">// to &#39;dummysh&#39; in T_new.                                                    //</span>
<a name="l23972"></a>23972 <span class="comment">//                                                                           //</span>
<a name="l23973"></a>23973 <span class="comment">// Notice that Not every boundary edge of T_new is able to bond to a subface,//</span>
<a name="l23974"></a>23974 <span class="comment">// e.g., when it is a segment recovered by removing a Steiner point in it.   //</span>
<a name="l23975"></a>23975 <span class="comment">//                                                                           //</span>
<a name="l23977"></a>23977 <span class="comment"></span>
<a name="l23978"></a>23978 <span class="keywordtype">void</span> tetgenmesh::replacepolygonsubs(list* oldshlist, list* newshlist)
<a name="l23979"></a>23979 {
<a name="l23980"></a>23980   face newsh, oldsh, spinsh;
<a name="l23981"></a>23981   face casingout, casingin;
<a name="l23982"></a>23982   face checkseg;
<a name="l23983"></a>23983   point pa, pb;
<a name="l23984"></a>23984   <span class="keywordtype">int</span> i, j, k, l;
<a name="l23985"></a>23985 
<a name="l23986"></a>23986   <span class="keywordflow">for</span> (i = 0; i &lt; newshlist-&gt;len(); i++) {
<a name="l23987"></a>23987     <span class="comment">// Get a new subface s.</span>
<a name="l23988"></a>23988     newsh = * (face *)(* newshlist)[i];
<a name="l23989"></a>23989     <span class="comment">// Check the three edges of s.</span>
<a name="l23990"></a>23990     <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) {
<a name="l23991"></a>23991       spivot(newsh, casingout);
<a name="l23992"></a>23992       <span class="comment">// Is it a boundary edge?</span>
<a name="l23993"></a>23993       <span class="keywordflow">if</span> (casingout.sh == dummysh) {
<a name="l23994"></a>23994         <span class="comment">// Find the old subface s_o having the same edge as s.</span>
<a name="l23995"></a>23995         pa = sorg(newsh);
<a name="l23996"></a>23996         pb = sdest(newsh);
<a name="l23997"></a>23997         <span class="keywordflow">for</span> (j = 0; j &lt; oldshlist-&gt;len(); j++) {
<a name="l23998"></a>23998           oldsh = * (face *)(* oldshlist)[j];
<a name="l23999"></a>23999       <span class="keywordflow">for</span> (l = 0; l &lt; 3; l++) {
<a name="l24000"></a>24000             <span class="keywordflow">if</span> (((sorg(oldsh) == pa) &amp;&amp; (sdest(oldsh) == pb)) ||
<a name="l24001"></a>24001                 ((sorg(oldsh) == pb) &amp;&amp; (sdest(oldsh) == pa))) <span class="keywordflow">break</span>;
<a name="l24002"></a>24002             senextself(oldsh);
<a name="l24003"></a>24003           }
<a name="l24004"></a>24004           <span class="keywordflow">if</span> (l &lt; 3) <span class="keywordflow">break</span>;
<a name="l24005"></a>24005         }
<a name="l24006"></a>24006         <span class="comment">// Is there a matched edge?</span>
<a name="l24007"></a>24007         <span class="keywordflow">if</span> (j &lt; oldshlist-&gt;len()) {
<a name="l24008"></a>24008           <span class="comment">// Get the neighbor subface s_out.</span>
<a name="l24009"></a>24009           spivot(oldsh, casingout);
<a name="l24010"></a>24010           sspivot(oldsh, checkseg);
<a name="l24011"></a>24011           <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l24012"></a>24012             <span class="comment">// A segment. Insert s into the face ring, ie, s_in -&gt; s -&gt; s_out.</span>
<a name="l24013"></a>24013             <span class="keywordflow">if</span> (oldsh.sh != casingout.sh) {
<a name="l24014"></a>24014               <span class="comment">// s is not bonded to itself.</span>
<a name="l24015"></a>24015               spinsh = casingout;
<a name="l24016"></a>24016               <span class="keywordflow">do</span> {
<a name="l24017"></a>24017                 casingin = spinsh;
<a name="l24018"></a>24018                 spivotself(spinsh);
<a name="l24019"></a>24019               } <span class="keywordflow">while</span> (sapex(spinsh) != sapex(oldsh));
<a name="l24020"></a>24020               assert(casingin.sh != oldsh.sh);
<a name="l24021"></a>24021               <span class="comment">// Bond s_in -&gt; s -&gt; s_out (and dissolve s_in -&gt; s_old -&gt; s_out).</span>
<a name="l24022"></a>24022               sbond1(casingin, newsh);
<a name="l24023"></a>24023               sbond1(newsh, casingout);
<a name="l24024"></a>24024             } <span class="keywordflow">else</span> {
<a name="l24025"></a>24025               <span class="comment">// Bond newsh -&gt; newsh.</span>
<a name="l24026"></a>24026               sbond(newsh, newsh);
<a name="l24027"></a>24027             }
<a name="l24028"></a>24028             <span class="comment">// Bond the segment.</span>
<a name="l24029"></a>24029             ssbond(newsh, checkseg);
<a name="l24030"></a>24030           } <span class="keywordflow">else</span> {
<a name="l24031"></a>24031             <span class="comment">// Bond s &lt;-&gt; s_out (and dissolve s_out -&gt; s_old).</span>
<a name="l24032"></a>24032             sbond(newsh, casingout);
<a name="l24033"></a>24033           }
<a name="l24034"></a>24034           <span class="comment">// Unbound oldsh to indicate it&#39;s neighbor has been replaced.</span>
<a name="l24035"></a>24035           <span class="comment">//   It will be used to indentfy the edge in the inverse.</span>
<a name="l24036"></a>24036           sdissolve(oldsh);
<a name="l24037"></a>24037           ssdissolve(oldsh);
<a name="l24038"></a>24038         }
<a name="l24039"></a>24039       }
<a name="l24040"></a>24040       <span class="comment">// Go to the next edge of s.</span>
<a name="l24041"></a>24041       senextself(newsh);
<a name="l24042"></a>24042     }
<a name="l24043"></a>24043   }
<a name="l24044"></a>24044 }
<a name="l24045"></a>24045 
<a name="l24047"></a>24047 <span class="comment">//                                                                           //</span>
<a name="l24048"></a>24048 <span class="comment">// orientnewsubs()    Orient new subfaces facing to the inside of cavity.    //</span>
<a name="l24049"></a>24049 <span class="comment">//                                                                           //</span>
<a name="l24050"></a>24050 <span class="comment">// &#39;newshlist&#39; contains new subfaces of the cavity C (created by re-triangu- //</span>
<a name="l24051"></a>24051 <span class="comment">// lation the polygon P). They&#39;re not necessary facing to the inside of C.   //</span>
<a name="l24052"></a>24052 <span class="comment">// &#39;orientsh&#39;, faces to the inside of C, is used to adjust new subfaces. The //</span>
<a name="l24053"></a>24053 <span class="comment">// normal of the new subfaces is returned in &#39;norm&#39;.                         //</span>
<a name="l24054"></a>24054 <span class="comment">//                                                                           //</span>
<a name="l24056"></a>24056 <span class="comment"></span>
<a name="l24057"></a>24057 <span class="keywordtype">void</span> tetgenmesh::orientnewsubs(list* newshlist, face* orientsh, REAL* norm)
<a name="l24058"></a>24058 {
<a name="l24059"></a>24059   face *newsh;
<a name="l24060"></a>24060   point pa, pb, pc;
<a name="l24061"></a>24061   REAL ref[3], ori, len;
<a name="l24062"></a>24062   <span class="keywordtype">int</span> i;
<a name="l24063"></a>24063 
<a name="l24064"></a>24064   <span class="comment">// Calculate the normal of &#39;orientsh&#39;.</span>
<a name="l24065"></a>24065   pa = sorg(*orientsh);
<a name="l24066"></a>24066   pb = sdest(*orientsh);
<a name="l24067"></a>24067   pc = sapex(*orientsh);
<a name="l24068"></a>24068   facenormal(pa, pb, pc, norm, &amp;len);
<a name="l24069"></a>24069   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) ref[i] = pa[i] + norm[i];
<a name="l24070"></a>24070   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) norm[i] /= len;
<a name="l24071"></a>24071 
<a name="l24072"></a>24072   <span class="comment">// Orient new subfaces. Let the normal above each one.</span>
<a name="l24073"></a>24073   <span class="keywordflow">for</span> (i = 0; i &lt; newshlist-&gt;len(); i++) {
<a name="l24074"></a>24074     newsh = (face *)(* newshlist)[i];
<a name="l24075"></a>24075     pa = sorg(*newsh);
<a name="l24076"></a>24076     pb = sdest(*newsh);
<a name="l24077"></a>24077     pc = sapex(*newsh);
<a name="l24078"></a>24078     ori = orient3d(pa, pb, pc, ref);
<a name="l24079"></a>24079     assert(ori != 0.0);
<a name="l24080"></a>24080     <span class="keywordflow">if</span> (ori &gt; 0.0) {
<a name="l24081"></a>24081       sesymself(*newsh);
<a name="l24082"></a>24082     }
<a name="l24083"></a>24083   }
<a name="l24084"></a>24084 }
<a name="l24085"></a>24085 
<a name="l24087"></a>24087 <span class="comment">//                                                                           //</span>
<a name="l24088"></a>24088 <span class="comment">// constrainedflip()    Flip a non-constrained face.                         //</span>
<a name="l24089"></a>24089 <span class="comment">//                                                                           //</span>
<a name="l24090"></a>24090 <span class="comment">// &#39;flipface&#39; f (abc) is a face we want to flip. In addition, if &#39;front&#39; is  //</span>
<a name="l24091"></a>24091 <span class="comment">// given (not a NULL), f is a crossface. f may not be flippable if it is one //</span>
<a name="l24092"></a>24092 <span class="comment">// of the following cases:                                                   //</span>
<a name="l24093"></a>24093 <span class="comment">//   (1) f has an aux subface attached;                                      //</span>
<a name="l24094"></a>24094 <span class="comment">//   (2) f is on the convex hull;                                            //</span>
<a name="l24095"></a>24095 <span class="comment">//   (3) f is not locally Delaunay (f must be recovered by a previous flip,  //</span>
<a name="l24096"></a>24096 <span class="comment">//       we should keep it, otherwise, we may fall into a flip loop);        //</span>
<a name="l24097"></a>24097 <span class="comment">//   (4) f is T32 at ab, but abd or abe has an aux subface attached;         //</span>
<a name="l24098"></a>24098 <span class="comment">//   (5) f is T22 or T44 at ab, but abd, or abe, or abf has an aux subface   //</span>
<a name="l24099"></a>24099 <span class="comment">//       attached;                                                           //</span>
<a name="l24100"></a>24100 <span class="comment">//   (6) f is unflipable at ab, and abd, abe, ... are all unflippable due to //</span>
<a name="l24101"></a>24101 <span class="comment">//       the cases (1) - (5).                                                //</span>
<a name="l24102"></a>24102 <span class="comment">// If f is a crssface (&#39;front&#39; != NULL) and it is unflipable due to case (3),//</span>
<a name="l24103"></a>24103 <span class="comment">// (4), (5) and (6). Try to flip the next crossing face of front first.      //</span>
<a name="l24104"></a>24104 <span class="comment">//                                                                           //</span>
<a name="l24106"></a>24106 <span class="comment"></span>
<a name="l24107"></a>24107 <span class="keywordtype">bool</span> tetgenmesh::constrainedflip(triface* flipface, triface* front,
<a name="l24108"></a>24108   queue* flipque)
<a name="l24109"></a>24109 {
<a name="l24110"></a>24110   triface symface, spintet;
<a name="l24111"></a>24111   face checksh;
<a name="l24112"></a>24112   point pa, pb, pc, pd, pe;
<a name="l24113"></a>24113   <span class="keyword">enum</span> fliptype fc;
<a name="l24114"></a>24114   REAL sign;
<a name="l24115"></a>24115   <span class="keywordtype">bool</span> doflip;
<a name="l24116"></a>24116   <span class="keywordtype">int</span> ia, ib, ic, id, ie;
<a name="l24117"></a>24117   <span class="keywordtype">int</span> i;
<a name="l24118"></a>24118 
<a name="l24119"></a>24119   <span class="comment">// (1) Is f protected by an (auxilary) subface?</span>
<a name="l24120"></a>24120   tspivot(*flipface, checksh);
<a name="l24121"></a>24121   <span class="keywordflow">if</span> (checksh.sh != dummysh) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l24122"></a>24122   <span class="comment">// (2) Is f on the convex hull?</span>
<a name="l24123"></a>24123   sym(*flipface, symface);
<a name="l24124"></a>24124   <span class="keywordflow">if</span> (symface.tet == dummytet) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l24125"></a>24125   <span class="comment">// (3) Is f not locally Delaunay?</span>
<a name="l24126"></a>24126   adjustedgering(*flipface, CCW);
<a name="l24127"></a>24127   pa = dest(*flipface);
<a name="l24128"></a>24128   pb = org(*flipface);
<a name="l24129"></a>24129   pc = apex(*flipface);
<a name="l24130"></a>24130   pd = oppo(*flipface);
<a name="l24131"></a>24131   pe = oppo(symface);
<a name="l24132"></a>24132   <span class="comment">// if (symbolic) {</span>
<a name="l24133"></a>24133     ia = pointmark(pa);
<a name="l24134"></a>24134     ib = pointmark(pb);
<a name="l24135"></a>24135     ic = pointmark(pc);
<a name="l24136"></a>24136     <span class="keywordtype">id</span> = pointmark(pd);
<a name="l24137"></a>24137     ie = pointmark(pe);
<a name="l24138"></a>24138     sign = insphere_sos(pa, pb, pc, pd, pe, ia, ib, ic, <span class="keywordtype">id</span>, ie);
<a name="l24139"></a>24139     assert(sign != 0.0);
<a name="l24140"></a>24140   <span class="comment">// } else {</span>
<a name="l24141"></a>24141   <span class="comment">//   sign = insphere(pa, pb, pc, pd, pe);</span>
<a name="l24142"></a>24142   <span class="comment">// }</span>
<a name="l24143"></a>24143   <span class="keywordflow">if</span> (sign &lt;= 0.0) {
<a name="l24144"></a>24144     <span class="comment">// Get the fliptype of f.</span>
<a name="l24145"></a>24145     checksubfaces = 0; <span class="comment">// switch off subface test.</span>
<a name="l24146"></a>24146     fc = categorizeface(*flipface);
<a name="l24147"></a>24147     checksubfaces = 1; <span class="comment">// switch on subface test.</span>
<a name="l24148"></a>24148     <span class="keywordflow">if</span> (fc == T23) {
<a name="l24149"></a>24149       doflip = <span class="keyword">true</span>;
<a name="l24150"></a>24150       <span class="comment">// Avoid one tet created by the 2-3 flip is nearly degenerate.</span>
<a name="l24151"></a>24151       <span class="comment">/* pc = oppo(*flipface);</span>
<a name="l24152"></a>24152 <span class="comment">      pd = oppo(symface);</span>
<a name="l24153"></a>24153 <span class="comment">      adjustedgering(*flipface, CCW);</span>
<a name="l24154"></a>24154 <span class="comment">      for (i = 0; i &lt; 3; i++) {</span>
<a name="l24155"></a>24155 <span class="comment">        pa = org(*flipface);</span>
<a name="l24156"></a>24156 <span class="comment">        pb = dest(*flipface);</span>
<a name="l24157"></a>24157 <span class="comment">        ori = orient3d(pa, pb, pc, pd);</span>
<a name="l24158"></a>24158 <span class="comment">        if (iscoplanar(pa, pb, pc, pd, ori, b-&gt;epsilon)) {</span>
<a name="l24159"></a>24159 <span class="comment">          doflip = false; break;</span>
<a name="l24160"></a>24160 <span class="comment">        }</span>
<a name="l24161"></a>24161 <span class="comment">        enextself(*flipface);</span>
<a name="l24162"></a>24162 <span class="comment">      } */</span>
<a name="l24163"></a>24163       <span class="keywordflow">if</span> (doflip) {
<a name="l24164"></a>24164         flip23(flipface, flipque);
<a name="l24165"></a>24165         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l24166"></a>24166       }
<a name="l24167"></a>24167     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fc == T32) {
<a name="l24168"></a>24168       <span class="comment">// (4) Is abd, or abe protected?</span>
<a name="l24169"></a>24169       doflip = <span class="keyword">true</span>;
<a name="l24170"></a>24170       spintet = *flipface;
<a name="l24171"></a>24171       <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l24172"></a>24172         fnextself(spintet);
<a name="l24173"></a>24173         tspivot(spintet, checksh);
<a name="l24174"></a>24174         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l24175"></a>24175           doflip = <span class="keyword">false</span>; <span class="keywordflow">break</span>; <span class="comment">// f is protected. Unflipable.</span>
<a name="l24176"></a>24176         }
<a name="l24177"></a>24177       }
<a name="l24178"></a>24178       <span class="keywordflow">if</span> (doflip) {
<a name="l24179"></a>24179         flip32(flipface, flipque);
<a name="l24180"></a>24180         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l24181"></a>24181       }
<a name="l24182"></a>24182     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fc == T22 || fc == T44) {
<a name="l24183"></a>24183       <span class="comment">// (5) Is abd, abe, or abf protected?</span>
<a name="l24184"></a>24184       doflip = <span class="keyword">true</span>;
<a name="l24185"></a>24185       <span class="keywordflow">if</span> (fc == T22) {
<a name="l24186"></a>24186         <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l24187"></a>24187           spintet = *flipface;
<a name="l24188"></a>24188           <span class="keywordflow">if</span> (i == 1) {
<a name="l24189"></a>24189             esymself(spintet);
<a name="l24190"></a>24190           }
<a name="l24191"></a>24191           fnextself(spintet);
<a name="l24192"></a>24192           tspivot(spintet, checksh);
<a name="l24193"></a>24193           <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l24194"></a>24194             doflip = <span class="keyword">false</span>; <span class="keywordflow">break</span>; <span class="comment">// f is protected. Unflipable.</span>
<a name="l24195"></a>24195           }
<a name="l24196"></a>24196         }
<a name="l24197"></a>24197       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fc == T44) {
<a name="l24198"></a>24198         spintet = *flipface;
<a name="l24199"></a>24199         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l24200"></a>24200           fnextself(spintet);
<a name="l24201"></a>24201           tspivot(spintet, checksh);
<a name="l24202"></a>24202           <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l24203"></a>24203             doflip = <span class="keyword">false</span>; <span class="keywordflow">break</span>; <span class="comment">// f is protected. Unflipable.</span>
<a name="l24204"></a>24204           }
<a name="l24205"></a>24205         }
<a name="l24206"></a>24206       }
<a name="l24207"></a>24207       <span class="keywordflow">if</span> (doflip) {
<a name="l24208"></a>24208         flip22(flipface, flipque);
<a name="l24209"></a>24209         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l24210"></a>24210       }
<a name="l24211"></a>24211     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fc == N32) {
<a name="l24212"></a>24212       <span class="comment">// Is f a crossface?</span>
<a name="l24213"></a>24213       <span class="keywordflow">if</span> (front != (triface *) NULL) {
<a name="l24214"></a>24214         <span class="comment">// (6) Is any obstacle face (abd, or abe, ...) flipable?</span>
<a name="l24215"></a>24215         spintet = *flipface;
<a name="l24216"></a>24216         <span class="keywordflow">while</span> (fnextself(spintet)) {
<a name="l24217"></a>24217           <span class="keywordflow">if</span> (apex(spintet) == apex(*flipface)) <span class="keywordflow">break</span>;
<a name="l24218"></a>24218           <span class="comment">// Check if spintet is flipable, no recursive.</span>
<a name="l24219"></a>24219           <span class="keywordflow">if</span> (constrainedflip(&amp;spintet, NULL, flipque)) {
<a name="l24220"></a>24220             <span class="comment">// One obstacle face has been flipped.</span>
<a name="l24221"></a>24221             <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l24222"></a>24222           }
<a name="l24223"></a>24223           <span class="comment">// Unflipable. Go to the next obstacle face.</span>
<a name="l24224"></a>24224           findedge(&amp;spintet, org(*flipface), dest(*flipface));
<a name="l24225"></a>24225         }
<a name="l24226"></a>24226       }
<a name="l24227"></a>24227     }
<a name="l24228"></a>24228   }
<a name="l24229"></a>24229 
<a name="l24230"></a>24230   <span class="comment">// f is unflipable. Is f a crossface?</span>
<a name="l24231"></a>24231   <span class="keywordflow">if</span> (front != (triface *) NULL) {
<a name="l24232"></a>24232     <span class="comment">// Look if there is another crossface.</span>
<a name="l24233"></a>24233     pa = org(*front);
<a name="l24234"></a>24234     pb = dest(*front);
<a name="l24235"></a>24235     pc = apex(*front);
<a name="l24236"></a>24236     <span class="comment">// sym(*flipface, symface);</span>
<a name="l24237"></a>24237     <span class="comment">// Have we reach the end of abc (We&#39;ve started from edge ab).</span>
<a name="l24238"></a>24238     <span class="keywordflow">if</span> (oppo(symface) != pc) {
<a name="l24239"></a>24239       adjustedgering(symface, CCW);
<a name="l24240"></a>24240       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l24241"></a>24241         fnext(symface, spintet);
<a name="l24242"></a>24242         <span class="comment">// Is c ahead of this face?</span>
<a name="l24243"></a>24243         sign = orient3d(org(spintet), dest(spintet), apex(spintet), pc);
<a name="l24244"></a>24244         <span class="keywordflow">if</span> (sign &lt; 0.0) {
<a name="l24245"></a>24245           <span class="keywordflow">if</span> (tritritest(&amp;spintet, pa, pb, pc)) {
<a name="l24246"></a>24246             <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l24247"></a>24247               printf(<span class="stringliteral">&quot;    Next crossface (%d, %d, %d).\n&quot;</span>,
<a name="l24248"></a>24248                      pointmark(org(spintet)), pointmark(dest(spintet)),
<a name="l24249"></a>24249                      pointmark(apex(spintet)));
<a name="l24250"></a>24250             }
<a name="l24251"></a>24251             <span class="keywordflow">return</span> constrainedflip(&amp;spintet, front, flipque);
<a name="l24252"></a>24252             <span class="comment">// return constrainedflip(&amp;spintet, NULL, flipque);</span>
<a name="l24253"></a>24253           }
<a name="l24254"></a>24254         }
<a name="l24255"></a>24255         enextself(symface);
<a name="l24256"></a>24256       }
<a name="l24257"></a>24257     }
<a name="l24258"></a>24258   }
<a name="l24259"></a>24259   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l24260"></a>24260 }
<a name="l24261"></a>24261 
<a name="l24263"></a>24263 <span class="comment">//                                                                           //</span>
<a name="l24264"></a>24264 <span class="comment">// recoverfront()    Recover a missing front by flips.                       //</span>
<a name="l24265"></a>24265 <span class="comment">//                                                                           //</span>
<a name="l24266"></a>24266 <span class="comment">// &#39;front&#39; f is missing in D - it was crossed by faces of D. The cross faces //</span>
<a name="l24267"></a>24267 <span class="comment">// may be flippable, so f can be recovered by flipping them away.            //</span>
<a name="l24268"></a>24268 <span class="comment">//                                                                           //</span>
<a name="l24270"></a>24270 <span class="comment"></span>
<a name="l24271"></a>24271 <span class="keywordtype">bool</span> tetgenmesh::recoverfront(triface* front, list* newtetlist, queue* flipque)
<a name="l24272"></a>24272 {
<a name="l24273"></a>24273   triface idfront, starttet, spintet;
<a name="l24274"></a>24274   point pa, pb, pc, pd, ref;
<a name="l24275"></a>24275   <span class="keyword">enum</span> locateresult loc;
<a name="l24276"></a>24276   <span class="keyword">enum</span> finddirectionresult col;
<a name="l24277"></a>24277   REAL ori, ori1, ori2, sign;
<a name="l24278"></a>24278   <span class="keywordtype">int</span> hitbdry;
<a name="l24279"></a>24279   <span class="keywordtype">int</span> i, j;
<a name="l24280"></a>24280 
<a name="l24281"></a>24281   <span class="comment">// Find an existing edge of f in D to start with.</span>
<a name="l24282"></a>24282   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l24283"></a>24283     pa = org(*front);
<a name="l24284"></a>24284     pb = dest(*front);
<a name="l24285"></a>24285     <span class="comment">// Get a tet for searching.</span>
<a name="l24286"></a>24286     idfront = recenttet;
<a name="l24287"></a>24287     <span class="comment">// Make sure the tet is valid (flip32() may kill a tet).</span>
<a name="l24288"></a>24288     <span class="keywordflow">if</span> (isdead(&amp;idfront)) {
<a name="l24289"></a>24289       <span class="comment">// The tet is dead. Get a live tet in D. !!!</span>
<a name="l24290"></a>24290       <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist-&gt;len(); j++) {
<a name="l24291"></a>24291         recenttet = * (triface *)(* newtetlist)[j];
<a name="l24292"></a>24292         <span class="keywordflow">if</span> (!isdead(&amp;recenttet)) <span class="keywordflow">break</span>;
<a name="l24293"></a>24293       }
<a name="l24294"></a>24294       assert(j &lt; newtetlist-&gt;len());
<a name="l24295"></a>24295     }
<a name="l24296"></a>24296     loc = preciselocate(pa, &amp;idfront, (<span class="keywordtype">long</span>) newtetlist-&gt;len());
<a name="l24297"></a>24297     <span class="keywordflow">if</span> (loc != ONVERTEX) {
<a name="l24298"></a>24298       <span class="comment">// Do a brute-force search in D.</span>
<a name="l24299"></a>24299       <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist-&gt;len(); j++) {
<a name="l24300"></a>24300         idfront = * (triface *)(* newtetlist)[j];
<a name="l24301"></a>24301         <span class="keywordflow">if</span> (isdead(&amp;idfront)) <span class="keywordflow">continue</span>;
<a name="l24302"></a>24302         <span class="keywordflow">if</span> (findorg(&amp;idfront, pa)) <span class="keywordflow">break</span>;
<a name="l24303"></a>24303       }
<a name="l24304"></a>24304       assert(j &lt; newtetlist-&gt;len()); <span class="comment">// a must belong to one tet.</span>
<a name="l24305"></a>24305     }
<a name="l24306"></a>24306     recenttet = idfront;
<a name="l24307"></a>24307     <span class="comment">// Search for a tet having edge ab.</span>
<a name="l24308"></a>24308     col = finddirection(&amp;idfront, pb, (<span class="keywordtype">long</span>) newtetlist-&gt;len());
<a name="l24309"></a>24309     <span class="keywordflow">if</span> (col == BELOWHULL) {
<a name="l24310"></a>24310       <span class="comment">// Do a brute-force search in D.</span>
<a name="l24311"></a>24311       <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist-&gt;len(); j++) {
<a name="l24312"></a>24312         idfront = * (triface *)(* newtetlist)[j];
<a name="l24313"></a>24313         <span class="keywordflow">if</span> (isdead(&amp;idfront)) <span class="keywordflow">continue</span>;
<a name="l24314"></a>24314         <span class="keywordflow">if</span> (findorg(&amp;idfront, pa)) {
<a name="l24315"></a>24315           assert(org(idfront) == pa);
<a name="l24316"></a>24316           <span class="keywordflow">if</span> (dest(idfront) == pb) {
<a name="l24317"></a>24317             col = RIGHTCOLLINEAR; <span class="keywordflow">break</span>;
<a name="l24318"></a>24318           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (apex(idfront) == pb) {
<a name="l24319"></a>24319             col = LEFTCOLLINEAR; <span class="keywordflow">break</span>;
<a name="l24320"></a>24320           } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oppo(idfront) == pb) {
<a name="l24321"></a>24321             col = TOPCOLLINEAR; <span class="keywordflow">break</span>;
<a name="l24322"></a>24322           }
<a name="l24323"></a>24323         }
<a name="l24324"></a>24324       }
<a name="l24325"></a>24325     }
<a name="l24326"></a>24326     <span class="keywordflow">if</span> (col == RIGHTCOLLINEAR) {
<a name="l24327"></a>24327       <span class="comment">// b is just the destination.</span>
<a name="l24328"></a>24328     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (col == LEFTCOLLINEAR) {
<a name="l24329"></a>24329       enext2self(idfront);
<a name="l24330"></a>24330       esymself(idfront);
<a name="l24331"></a>24331     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (col == TOPCOLLINEAR) {
<a name="l24332"></a>24332       fnextself(idfront);
<a name="l24333"></a>24333       enext2self(idfront);
<a name="l24334"></a>24334       esymself(idfront);
<a name="l24335"></a>24335     }
<a name="l24336"></a>24336     <span class="keywordflow">if</span> (dest(idfront) == pb) <span class="keywordflow">break</span>; <span class="comment">// Found.</span>
<a name="l24337"></a>24337     <span class="comment">// Missing. Go to the next edge of f.</span>
<a name="l24338"></a>24338     enextself(*front);
<a name="l24339"></a>24339   }
<a name="l24340"></a>24340   <span class="keywordflow">if</span> (i == 3) {
<a name="l24341"></a>24341     <span class="comment">// All three edges of f are missing - unrecoverable.</span>
<a name="l24342"></a>24342     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l24343"></a>24343   }
<a name="l24344"></a>24344 
<a name="l24345"></a>24345   <span class="comment">// Search for a tet having f (abc).</span>
<a name="l24346"></a>24346   pc = apex(*front);
<a name="l24347"></a>24347   spintet = idfront;
<a name="l24348"></a>24348   hitbdry = 0;
<a name="l24349"></a>24349   <span class="keywordflow">do</span> {
<a name="l24350"></a>24350     <span class="keywordflow">if</span> (apex(spintet) == pc) {
<a name="l24351"></a>24351       <span class="comment">// Found abc. Insert an auxilary subface s at idfront.</span>
<a name="l24352"></a>24352       insertauxsubface(front, &amp;spintet);
<a name="l24353"></a>24353       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l24354"></a>24354     }
<a name="l24355"></a>24355     <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l24356"></a>24356       hitbdry ++;
<a name="l24357"></a>24357       <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l24358"></a>24358         esym(idfront, spintet);
<a name="l24359"></a>24359         <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l24360"></a>24360           hitbdry ++;
<a name="l24361"></a>24361         }
<a name="l24362"></a>24362       }
<a name="l24363"></a>24363     }
<a name="l24364"></a>24364     <span class="keywordflow">if</span> (apex(spintet) == apex(idfront)) <span class="keywordflow">break</span>;
<a name="l24365"></a>24365   } <span class="keywordflow">while</span> (hitbdry &lt; 2);
<a name="l24366"></a>24366 
<a name="l24367"></a>24367   <span class="comment">// Search for a crossing face to flip.</span>
<a name="l24368"></a>24368   pd = apex(idfront);
<a name="l24369"></a>24369   assert(pd != pc);
<a name="l24370"></a>24370   <span class="comment">// Decide the orientation of d with abc.</span>
<a name="l24371"></a>24371   ori = orient3d(pa, pb, pc, pd);
<a name="l24372"></a>24372   <span class="keywordflow">if</span> (ori &lt; 0.0) {
<a name="l24373"></a>24373     <span class="comment">// d is above abc. Rotate downwards.</span>
<a name="l24374"></a>24374     esym(idfront, starttet);
<a name="l24375"></a>24375     sign = -1.0;
<a name="l24376"></a>24376   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori &gt; 0.0) {
<a name="l24377"></a>24377     <span class="comment">// d is below abc. Rotate upwards.</span>
<a name="l24378"></a>24378     starttet = idfront;
<a name="l24379"></a>24379     sign = 1.0;
<a name="l24380"></a>24380   } <span class="keywordflow">else</span> {
<a name="l24381"></a>24381     assert(ori == 0.0);
<a name="l24382"></a>24382     <span class="comment">// d is coplanar with abc. Do abc and abd intersect?</span>
<a name="l24383"></a>24383     ref = oppo(idfront);
<a name="l24384"></a>24384     ori1 = orient3d(pa, pb, ref, pc);
<a name="l24385"></a>24385     ori2 = orient3d(pa, pb, ref, pd);
<a name="l24386"></a>24386     assert(ori1 * ori2 != 0.0);
<a name="l24387"></a>24387     <span class="keywordflow">if</span> (ori1 * ori2 &gt; 0) {
<a name="l24388"></a>24388       <span class="comment">// abc and abd intersect.  There&#39;re two possible intersections:</span>
<a name="l24389"></a>24389       <span class="comment">//   ad and bc, or ac and bd.  Find it out.</span>
<a name="l24390"></a>24390       ori1 = orient3d(pb, pc, ref, pd);
<a name="l24391"></a>24391       ori2 = orient3d(pb, pc, ref, pa);
<a name="l24392"></a>24392       assert(ori1 * ori2 != 0.0);
<a name="l24393"></a>24393       <span class="keywordflow">if</span> (ori1 * ori2 &gt; 0) {
<a name="l24394"></a>24394         <span class="comment">// ac intersects bd.</span>
<a name="l24395"></a>24395         enextself(idfront); <span class="comment">// go to edge bd.</span>
<a name="l24396"></a>24396       } <span class="keywordflow">else</span> {
<a name="l24397"></a>24397         <span class="comment">// ad intersects bc.</span>
<a name="l24398"></a>24398         enext2self(idfront); <span class="comment">// go to edge ad.</span>
<a name="l24399"></a>24399       }
<a name="l24400"></a>24400       adjustedgering(idfront, CCW);
<a name="l24401"></a>24401       fnextself(idfront); <span class="comment">// face ade or bce need a 4-to-4 flip.</span>
<a name="l24402"></a>24402       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l24403"></a>24403         printf(<span class="stringliteral">&quot;    Get crossface (%d, %d, %d).\n&quot;</span>, pointmark(org(idfront)),
<a name="l24404"></a>24404                pointmark(dest(idfront)), pointmark(apex(idfront)));
<a name="l24405"></a>24405       }
<a name="l24406"></a>24406       <span class="keywordflow">if</span> (constrainedflip(&amp;idfront, front, flipque)) {
<a name="l24407"></a>24407         <span class="comment">// A crossface has been flipped. Continue to recover f.</span>
<a name="l24408"></a>24408         <span class="keywordflow">return</span> recoverfront(front, newtetlist, flipque);
<a name="l24409"></a>24409       }
<a name="l24410"></a>24410       <span class="comment">// Unable to recover f.</span>
<a name="l24411"></a>24411       <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// sign = 0.0;</span>
<a name="l24412"></a>24412     } <span class="keywordflow">else</span> {
<a name="l24413"></a>24413       <span class="comment">// Not intersect. We can go either direction.</span>
<a name="l24414"></a>24414       starttet = idfront;
<a name="l24415"></a>24415       <span class="keywordflow">if</span> (fnextself(starttet)) {
<a name="l24416"></a>24416         <span class="comment">// Choose to rotate upwards.</span>
<a name="l24417"></a>24417         sign = 1.0;
<a name="l24418"></a>24418       } <span class="keywordflow">else</span> {
<a name="l24419"></a>24419         <span class="comment">// Hit convex hull. Choose to rotate downwrads.</span>
<a name="l24420"></a>24420         esym(idfront, starttet);
<a name="l24421"></a>24421         sign = -1.0;
<a name="l24422"></a>24422       }
<a name="l24423"></a>24423     }
<a name="l24424"></a>24424   }
<a name="l24425"></a>24425 
<a name="l24426"></a>24426   assert(sign != 0.0);
<a name="l24427"></a>24427   <span class="keywordflow">if</span> (sign == -1) {
<a name="l24428"></a>24428     <span class="comment">// The edge ab has be changed. Reverse it.</span>
<a name="l24429"></a>24429     pa = org(starttet);
<a name="l24430"></a>24430     pb = dest(starttet);
<a name="l24431"></a>24431     <span class="comment">// The sign has been reversed as well.</span>
<a name="l24432"></a>24432     sign = -sign;
<a name="l24433"></a>24433   }
<a name="l24434"></a>24434   <span class="comment">// Rotate face abd around edge ab. Moreover, we&#39;ve chosen the rotate</span>
<a name="l24435"></a>24435   <span class="comment">//   direction such that no convex hull face will be reach.</span>
<a name="l24436"></a>24436   spintet = starttet;
<a name="l24437"></a>24437   <span class="keywordflow">while</span> (fnextself(spintet)) {
<a name="l24438"></a>24438     pd = apex(spintet);
<a name="l24439"></a>24439     assert(pd != pc);
<a name="l24440"></a>24440     <span class="comment">// Check if the orientation of d (with abc) has changed.</span>
<a name="l24441"></a>24441     ori = orient3d(pa, pb, pc, pd);
<a name="l24442"></a>24442     <span class="keywordflow">if</span> (ori == 0.0) {
<a name="l24443"></a>24443       <span class="comment">// abc and abd must coplanar intersect (4-to-4 flip is needed).</span>
<a name="l24444"></a>24444       ref = oppo(spintet);
<a name="l24445"></a>24445       ori1 = orient3d(pb, pc, ref, pd);
<a name="l24446"></a>24446       ori2 = orient3d(pb, pc, ref, pa);
<a name="l24447"></a>24447       assert(ori1 * ori2 != 0.0);
<a name="l24448"></a>24448       <span class="keywordflow">if</span> (ori1 * ori2 &gt; 0) {
<a name="l24449"></a>24449         <span class="comment">// ac intersects bd.</span>
<a name="l24450"></a>24450         enextself(spintet); <span class="comment">// go to edge bd.</span>
<a name="l24451"></a>24451       } <span class="keywordflow">else</span> {
<a name="l24452"></a>24452         <span class="comment">// ad intersects bc.</span>
<a name="l24453"></a>24453         enext2self(spintet); <span class="comment">// go to edge ad.</span>
<a name="l24454"></a>24454       }
<a name="l24455"></a>24455       adjustedgering(spintet, CCW);
<a name="l24456"></a>24456       fnextself(spintet); <span class="comment">// face ade or bce need a 4-to-4 flip.</span>
<a name="l24457"></a>24457       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l24458"></a>24458         printf(<span class="stringliteral">&quot;    Get crossface (%d, %d, %d).\n&quot;</span>, pointmark(org(spintet)),
<a name="l24459"></a>24459                pointmark(dest(spintet)), pointmark(apex(spintet)));
<a name="l24460"></a>24460       }
<a name="l24461"></a>24461       <span class="keywordflow">if</span> (constrainedflip(&amp;spintet, front, flipque)) {
<a name="l24462"></a>24462         <span class="comment">// A crossface has been flipped. Continue to recover f.</span>
<a name="l24463"></a>24463         <span class="keywordflow">return</span> recoverfront(front, newtetlist, flipque);
<a name="l24464"></a>24464       }
<a name="l24465"></a>24465       <span class="comment">// Unable to recover f.</span>
<a name="l24466"></a>24466       <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// sign = 0.0;</span>
<a name="l24467"></a>24467     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ori * sign &lt; 0.0) {
<a name="l24468"></a>24468       <span class="comment">// Sign has changed. The face dea or deb must cross abc.</span>
<a name="l24469"></a>24469       adjustedgering(spintet, CCW);
<a name="l24470"></a>24470       enextself(spintet);
<a name="l24471"></a>24471       <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l24472"></a>24472         <span class="comment">// Get the face dea or deb.</span>
<a name="l24473"></a>24473         fnext(spintet, starttet);
<a name="l24474"></a>24474         <span class="keywordflow">if</span> (tritritest(&amp;starttet, pa, pb, pc)) {
<a name="l24475"></a>24475           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l24476"></a>24476             printf(<span class="stringliteral">&quot;    Get crossface (%d, %d, %d).\n&quot;</span>,
<a name="l24477"></a>24477                    pointmark(org(starttet)), pointmark(dest(starttet)),
<a name="l24478"></a>24478                    pointmark(apex(starttet)));
<a name="l24479"></a>24479           }
<a name="l24480"></a>24480           <span class="keywordflow">if</span> (constrainedflip(&amp;starttet, front, flipque)) {
<a name="l24481"></a>24481             <span class="comment">// A crossface has been flipped. Continue to recover f.</span>
<a name="l24482"></a>24482             <span class="keywordflow">return</span> recoverfront(front, newtetlist, flipque);
<a name="l24483"></a>24483           }
<a name="l24484"></a>24484         }
<a name="l24485"></a>24485         enextself(spintet);
<a name="l24486"></a>24486       }
<a name="l24487"></a>24487       <span class="comment">// Unable to recover f.</span>
<a name="l24488"></a>24488       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l24489"></a>24489     }
<a name="l24490"></a>24490   }
<a name="l24491"></a>24491   <span class="comment">// Impossible to be here.</span>
<a name="l24492"></a>24492   assert(0);
<a name="l24493"></a>24493   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l24494"></a>24494 }
<a name="l24495"></a>24495 
<a name="l24497"></a>24497 <span class="comment">//                                                                           //</span>
<a name="l24498"></a>24498 <span class="comment">// repairflips()    Flip non-Delaunay and non-constrained faces.             //</span>
<a name="l24499"></a>24499 <span class="comment">//                                                                           //</span>
<a name="l24501"></a>24501 <span class="comment"></span>
<a name="l24502"></a>24502 <span class="keywordtype">void</span> tetgenmesh::repairflips(queue* flipque)
<a name="l24503"></a>24503 {
<a name="l24504"></a>24504   badface *qface;
<a name="l24505"></a>24505   triface flipface, symface, spintet;
<a name="l24506"></a>24506   face checksh;
<a name="l24507"></a>24507   point pa, pb, pc, pd, pe;
<a name="l24508"></a>24508   <span class="keyword">enum</span> fliptype fc;
<a name="l24509"></a>24509   REAL sign;
<a name="l24510"></a>24510   <span class="keywordtype">long</span> flipcount;
<a name="l24511"></a>24511   <span class="keywordtype">bool</span> doflip;
<a name="l24512"></a>24512   <span class="keywordtype">int</span> ia, ib, ic, id, ie;
<a name="l24513"></a>24513   <span class="keywordtype">int</span> i;
<a name="l24514"></a>24514 
<a name="l24515"></a>24515   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l24516"></a>24516     printf(<span class="stringliteral">&quot;    Repair flip %ld faces.\n&quot;</span>, flipque-&gt;len());
<a name="l24517"></a>24517   }
<a name="l24518"></a>24518   flipcount = flip23s + flip32s + flip22s + flip44s;
<a name="l24519"></a>24519   <span class="comment">// Loop until the queue is empty.</span>
<a name="l24520"></a>24520   <span class="keywordflow">while</span> (!flipque-&gt;empty()) {
<a name="l24521"></a>24521     qface = (badface *) flipque-&gt;pop();
<a name="l24522"></a>24522     flipface = qface-&gt;tt;
<a name="l24523"></a>24523     <span class="comment">// Check the validity of this face.</span>
<a name="l24524"></a>24524     <span class="keywordflow">if</span> (isdead(&amp;flipface) || flipface.tet == dummytet ||
<a name="l24525"></a>24525         (org(flipface) != qface-&gt;forg) ||
<a name="l24526"></a>24526         (dest(flipface) != qface-&gt;fdest) ||
<a name="l24527"></a>24527         (apex(flipface) != qface-&gt;fapex) ||
<a name="l24528"></a>24528         (oppo(flipface) == (point) NULL)) <span class="keywordflow">continue</span>;
<a name="l24529"></a>24529     <span class="comment">// (1) Is f protected by an (auxilary) subface?</span>
<a name="l24530"></a>24530     tspivot(flipface, checksh);
<a name="l24531"></a>24531     <span class="keywordflow">if</span> (checksh.sh != dummysh) <span class="keywordflow">continue</span>;
<a name="l24532"></a>24532     <span class="comment">// (2) Is f on the convex hull?</span>
<a name="l24533"></a>24533     sym(flipface, symface);
<a name="l24534"></a>24534     <span class="keywordflow">if</span> (symface.tet == dummytet) <span class="keywordflow">continue</span>;
<a name="l24535"></a>24535     <span class="comment">// For positive orientation that insphere() test requires.</span>
<a name="l24536"></a>24536     adjustedgering(flipface, CW);
<a name="l24537"></a>24537     pa = org(flipface);
<a name="l24538"></a>24538     pb = dest(flipface);
<a name="l24539"></a>24539     pc = apex(flipface);
<a name="l24540"></a>24540     pd = oppo(flipface);
<a name="l24541"></a>24541     pe = oppo(symface);
<a name="l24542"></a>24542     <span class="comment">// if (symbolic) {</span>
<a name="l24543"></a>24543       ia = pointmark(pa);
<a name="l24544"></a>24544       ib = pointmark(pb);
<a name="l24545"></a>24545       ic = pointmark(pc);
<a name="l24546"></a>24546       <span class="keywordtype">id</span> = pointmark(pd);
<a name="l24547"></a>24547       ie = pointmark(pe);
<a name="l24548"></a>24548       sign = insphere_sos(pa, pb, pc, pd, pe, ia, ib, ic, <span class="keywordtype">id</span>, ie);
<a name="l24549"></a>24549       assert(sign != 0.0);
<a name="l24550"></a>24550     <span class="comment">// } else {</span>
<a name="l24551"></a>24551     <span class="comment">//   sign = insphere(pa, pb, pc, pd, pe);</span>
<a name="l24552"></a>24552     <span class="comment">// }</span>
<a name="l24553"></a>24553     <span class="keywordflow">if</span> (sign &gt; 0.0) {
<a name="l24554"></a>24554       <span class="comment">// f is non-lcally Delaunay. Get the fliptype of f.</span>
<a name="l24555"></a>24555       checksubfaces = 0; <span class="comment">// switch off subface test.</span>
<a name="l24556"></a>24556       fc = categorizeface(flipface);
<a name="l24557"></a>24557       checksubfaces = 1; <span class="comment">// switch on subface test.</span>
<a name="l24558"></a>24558       <span class="keywordflow">if</span> (fc == T23) {
<a name="l24559"></a>24559         doflip = <span class="keyword">true</span>;
<a name="l24560"></a>24560         <span class="comment">// Avoid to create a nearly degenerate tet.</span>
<a name="l24561"></a>24561         <span class="comment">/* pc = oppo(flipface);</span>
<a name="l24562"></a>24562 <span class="comment">        pd = oppo(symface);</span>
<a name="l24563"></a>24563 <span class="comment">        adjustedgering(flipface, CCW);</span>
<a name="l24564"></a>24564 <span class="comment">        for (i = 0; i &lt; 3; i++) {</span>
<a name="l24565"></a>24565 <span class="comment">          pa = org(flipface);</span>
<a name="l24566"></a>24566 <span class="comment">          pb = dest(flipface);</span>
<a name="l24567"></a>24567 <span class="comment">          ori = orient3d(pa, pb, pc, pd);</span>
<a name="l24568"></a>24568 <span class="comment">          if (iscoplanar(pa, pb, pc, pd, ori, b-&gt;epsilon)) {</span>
<a name="l24569"></a>24569 <span class="comment">            doflip = false; break;</span>
<a name="l24570"></a>24570 <span class="comment">          }</span>
<a name="l24571"></a>24571 <span class="comment">          enextself(flipface);</span>
<a name="l24572"></a>24572 <span class="comment">        } */</span>
<a name="l24573"></a>24573         <span class="keywordflow">if</span> (doflip) {
<a name="l24574"></a>24574           flip23(&amp;flipface, flipque);
<a name="l24575"></a>24575         }
<a name="l24576"></a>24576       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fc == T32) {
<a name="l24577"></a>24577         <span class="comment">// (4) Is abd, or abe protected?</span>
<a name="l24578"></a>24578         doflip = <span class="keyword">true</span>;
<a name="l24579"></a>24579         spintet = flipface;
<a name="l24580"></a>24580         <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l24581"></a>24581           fnextself(spintet);
<a name="l24582"></a>24582           tspivot(spintet, checksh);
<a name="l24583"></a>24583           <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l24584"></a>24584             doflip = <span class="keyword">false</span>; <span class="keywordflow">break</span>; <span class="comment">// f is protected. Unflipable.</span>
<a name="l24585"></a>24585           }
<a name="l24586"></a>24586         }
<a name="l24587"></a>24587         <span class="keywordflow">if</span> (doflip) {
<a name="l24588"></a>24588           flip32(&amp;flipface, flipque);
<a name="l24589"></a>24589         }
<a name="l24590"></a>24590       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fc == T22 || fc == T44) {
<a name="l24591"></a>24591         <span class="comment">// (5) Is abd, abe, or abf protected?</span>
<a name="l24592"></a>24592         doflip = <span class="keyword">true</span>;
<a name="l24593"></a>24593         <span class="keywordflow">if</span> (fc == T22) {
<a name="l24594"></a>24594           <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l24595"></a>24595             spintet = flipface;
<a name="l24596"></a>24596             <span class="keywordflow">if</span> (i == 1) {
<a name="l24597"></a>24597               esymself(spintet);
<a name="l24598"></a>24598             }
<a name="l24599"></a>24599             fnextself(spintet);
<a name="l24600"></a>24600             tspivot(spintet, checksh);
<a name="l24601"></a>24601             <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l24602"></a>24602               doflip = <span class="keyword">false</span>; <span class="keywordflow">break</span>; <span class="comment">// f is protected. Unflipable.</span>
<a name="l24603"></a>24603             }
<a name="l24604"></a>24604           }
<a name="l24605"></a>24605         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fc == T44) {
<a name="l24606"></a>24606           spintet = flipface;
<a name="l24607"></a>24607           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l24608"></a>24608             fnextself(spintet);
<a name="l24609"></a>24609             tspivot(spintet, checksh);
<a name="l24610"></a>24610             <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l24611"></a>24611               doflip = <span class="keyword">false</span>; <span class="keywordflow">break</span>; <span class="comment">// f is protected. Unflipable.</span>
<a name="l24612"></a>24612             }
<a name="l24613"></a>24613           }
<a name="l24614"></a>24614         }
<a name="l24615"></a>24615         <span class="keywordflow">if</span> (doflip) {
<a name="l24616"></a>24616           flip22(&amp;flipface, flipque);
<a name="l24617"></a>24617         }
<a name="l24618"></a>24618       }
<a name="l24619"></a>24619     }
<a name="l24620"></a>24620   }
<a name="l24621"></a>24621   flipcount = flip23s + flip32s + flip22s + flip44s - flipcount;
<a name="l24622"></a>24622   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l24623"></a>24623     printf(<span class="stringliteral">&quot;    %ld flips.\n&quot;</span>, flipcount);
<a name="l24624"></a>24624   }
<a name="l24625"></a>24625 }
<a name="l24626"></a>24626 
<a name="l24628"></a>24628 <span class="comment">//                                                                           //</span>
<a name="l24629"></a>24629 <span class="comment">// constrainedcavity()    Tetrahedralize a cavity by constrained tetrahedra. //</span>
<a name="l24630"></a>24630 <span class="comment">//                                                                           //</span>
<a name="l24631"></a>24631 <span class="comment">// The cavity C is bounded by faces F in &#39;floorlist&#39; and &#39;ceillist&#39;. &#39;ptlist&#39;//</span>
<a name="l24632"></a>24632 <span class="comment">// V is the set of vertices of C.                                            //</span>
<a name="l24633"></a>24633 <span class="comment">//                                                                           //</span>
<a name="l24635"></a>24635 <span class="comment"></span>
<a name="l24636"></a>24636 <span class="keywordtype">bool</span> tetgenmesh::constrainedcavity(triface* oldtet, list* floorlist,
<a name="l24637"></a>24637   list* ceillist, list* ptlist, list* frontlist, list* misfrontlist,
<a name="l24638"></a>24638   list* newtetlist, queue* flipque)
<a name="l24639"></a>24639 {
<a name="l24640"></a>24640   triface misfront, newtet;
<a name="l24641"></a>24641   <span class="keywordtype">long</span> facenum;
<a name="l24642"></a>24642   <span class="keywordtype">int</span> i;
<a name="l24643"></a>24643 
<a name="l24644"></a>24644   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l24645"></a>24645     printf(<span class="stringliteral">&quot;    Constrained cavity (%d floors, %d ceilings, %d vertices).\n&quot;</span>,
<a name="l24646"></a>24646            floorlist-&gt;len(), ceillist-&gt;len(), ptlist-&gt;len());
<a name="l24647"></a>24647   }
<a name="l24648"></a>24648 
<a name="l24649"></a>24649   <span class="comment">// symbolic = 1;</span>
<a name="l24650"></a>24650 
<a name="l24651"></a>24651   <span class="comment">// Initialize the cavity C.</span>
<a name="l24652"></a>24652   initializecavity(floorlist, ceillist, frontlist);
<a name="l24653"></a>24653   <span class="comment">// Form the D of the vertices of C.</span>
<a name="l24654"></a>24654   delaunizecavvertices(oldtet, ptlist, NULL, newtetlist, flipque);
<a name="l24655"></a>24655 
<a name="l24656"></a>24656   <span class="comment">// Identify faces of C in D.</span>
<a name="l24657"></a>24657   <span class="keywordflow">if</span> (!identifyfronts(frontlist, misfrontlist, newtetlist)) {
<a name="l24658"></a>24658     <span class="comment">// Some faces are missing.</span>
<a name="l24659"></a>24659     recenttet = * (triface *)(* newtetlist)[0];
<a name="l24660"></a>24660     assert((recenttet.tet != dummytet) &amp;&amp; !isdead(&amp;recenttet));
<a name="l24661"></a>24661     <span class="comment">// Try to recover missing faces by flips.</span>
<a name="l24662"></a>24662     <span class="keywordflow">do</span> {
<a name="l24663"></a>24663       facenum = misfrontlist-&gt;len();
<a name="l24664"></a>24664       <span class="keywordflow">for</span> (i = 0; i &lt; misfrontlist-&gt;len(); i++) {
<a name="l24665"></a>24665         <span class="comment">// Get a missing front f.</span>
<a name="l24666"></a>24666         misfront = * (triface *)(* misfrontlist)[i];
<a name="l24667"></a>24667         <span class="comment">// Let f face toward the inside of C.</span>
<a name="l24668"></a>24668         adjustedgering(misfront, CW);
<a name="l24669"></a>24669         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l24670"></a>24670           printf(<span class="stringliteral">&quot;    Recover face (%d, %d, %d).\n&quot;</span>, pointmark(org(misfront)),
<a name="l24671"></a>24671                  pointmark(dest(misfront)), pointmark(apex(misfront)));
<a name="l24672"></a>24672         }
<a name="l24673"></a>24673         <span class="keywordflow">if</span> (recoverfront(&amp;misfront, newtetlist, flipque)) {
<a name="l24674"></a>24674           <span class="comment">// f has been recovered.</span>
<a name="l24675"></a>24675           frontlist-&gt;append(&amp;misfront);
<a name="l24676"></a>24676           misfrontlist-&gt;del(i, 0); i--;
<a name="l24677"></a>24677         }
<a name="l24678"></a>24678         <span class="comment">// Flip non-locally non-constrained Delaunay faces.</span>
<a name="l24679"></a>24679         repairflips(flipque);
<a name="l24680"></a>24680       }
<a name="l24681"></a>24681       <span class="comment">// Have all faces been recovered?</span>
<a name="l24682"></a>24682       <span class="keywordflow">if</span> (misfrontlist-&gt;len() == 0) <span class="keywordflow">break</span>;
<a name="l24683"></a>24683       <span class="comment">// No! There are still un-recovered faces. Continue the loop if any</span>
<a name="l24684"></a>24684       <span class="comment">//   face has been recovered.</span>
<a name="l24685"></a>24685     } <span class="keywordflow">while</span> (misfrontlist-&gt;len() &lt; facenum);
<a name="l24686"></a>24686     <span class="comment">// Retrieve new tets and purge dead tets in D.</span>
<a name="l24687"></a>24687     retrievenewtets(newtetlist);
<a name="l24688"></a>24688   }
<a name="l24689"></a>24689 
<a name="l24690"></a>24690   <span class="comment">// symbolic = 0;</span>
<a name="l24691"></a>24691 
<a name="l24692"></a>24692   <span class="keywordflow">if</span> (misfrontlist-&gt;len() == 0) {
<a name="l24693"></a>24693     <span class="comment">// All fronts have identified in D. Get the shape of C by removing out</span>
<a name="l24694"></a>24694     <span class="comment">//   tets of C. &#39;misfrontlist&#39; is reused for removing out tets.</span>
<a name="l24695"></a>24695     <span class="comment">//   Don&#39;t do flip since the new tets may get deleted later.</span>
<a name="l24696"></a>24696     carvecavity(newtetlist, misfrontlist, NULL);
<a name="l24697"></a>24697     <span class="comment">// Recover locally Delaunay faces.</span>
<a name="l24698"></a>24698     <span class="comment">// flip(flipque, NULL);</span>
<a name="l24699"></a>24699     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l24700"></a>24700   } <span class="keywordflow">else</span> {
<a name="l24701"></a>24701     <span class="comment">// Fail to tetrahedralize C.</span>
<a name="l24702"></a>24702     <span class="comment">// Remove aux subfaces.</span>
<a name="l24703"></a>24703     detachauxsubfaces(newtetlist);
<a name="l24704"></a>24704     <span class="comment">// Remove new tets.</span>
<a name="l24705"></a>24705     <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l24706"></a>24706       newtet = * (triface *)(* newtetlist)[i];
<a name="l24707"></a>24707       assert(!isdead(&amp;newtet));
<a name="l24708"></a>24708       tetrahedrondealloc(newtet.tet);
<a name="l24709"></a>24709     }
<a name="l24710"></a>24710     newtetlist-&gt;clear();
<a name="l24711"></a>24711     <span class="comment">// Restore faces of C in frontlist.</span>
<a name="l24712"></a>24712     <span class="keywordflow">for</span> (i = 0; i &lt; misfrontlist-&gt;len(); i++) {
<a name="l24713"></a>24713       misfront = * (triface *)(* misfrontlist)[i];
<a name="l24714"></a>24714       frontlist-&gt;append(&amp;misfront);
<a name="l24715"></a>24715     }
<a name="l24716"></a>24716     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l24717"></a>24717   }
<a name="l24718"></a>24718 }
<a name="l24719"></a>24719 
<a name="l24721"></a>24721 <span class="comment">//                                                                           //</span>
<a name="l24722"></a>24722 <span class="comment">// expandsteinercavity()    Expand the cavity of a Steiner point.            //</span>
<a name="l24723"></a>24723 <span class="comment">//                                                                           //</span>
<a name="l24724"></a>24724 <span class="comment">// Expand the cavity C if there fronts (except fronts having subfaces) which //</span>
<a name="l24725"></a>24725 <span class="comment">// are either (nearly) coplanar or invisible by the Steiner point.           //</span>
<a name="l24726"></a>24726 <span class="comment">//                                                                           //</span>
<a name="l24728"></a>24728 <span class="comment"></span>
<a name="l24729"></a>24729 <span class="keywordtype">void</span> tetgenmesh::expandsteinercavity(point steinpt, REAL eps, list* frontlist,
<a name="l24730"></a>24730   list* oldtetlist)
<a name="l24731"></a>24731 {
<a name="l24732"></a>24732   triface front, symfront, newfront, oldfront;
<a name="l24733"></a>24733   face frontsh;
<a name="l24734"></a>24734   point pa, pb, pc;
<a name="l24735"></a>24735   REAL ori;
<a name="l24736"></a>24736   <span class="keywordtype">bool</span> expflag, newflag;
<a name="l24737"></a>24737   <span class="keywordtype">int</span> i, j;
<a name="l24738"></a>24738 
<a name="l24739"></a>24739   <span class="keywordflow">do</span> {
<a name="l24740"></a>24740     expflag = <span class="keyword">false</span>;
<a name="l24741"></a>24741     <span class="keywordflow">for</span> (i = 0; i &lt; frontlist-&gt;len(); i++) {
<a name="l24742"></a>24742       <span class="comment">// Get a front f.</span>
<a name="l24743"></a>24743       front =  * (triface *)(* frontlist)[i];
<a name="l24744"></a>24744       <span class="comment">// f can be expanded if it is not a subface.</span>
<a name="l24745"></a>24745       tspivot(front, frontsh);
<a name="l24746"></a>24746       <span class="keywordflow">if</span> (frontsh.sh == dummysh) {
<a name="l24747"></a>24747         <span class="comment">// Let f face to the inside of C.</span>
<a name="l24748"></a>24748         adjustedgering(front, CW);
<a name="l24749"></a>24749         pa = org(front);
<a name="l24750"></a>24750         pb = dest(front);
<a name="l24751"></a>24751         pc = apex(front);
<a name="l24752"></a>24752         ori = orient3d(pa, pb, pc, steinpt);
<a name="l24753"></a>24753         <span class="keywordflow">if</span> (ori != 0.0) {
<a name="l24754"></a>24754           <span class="keywordflow">if</span> (iscoplanar(pa, pb, pc, steinpt, ori, eps)) {
<a name="l24755"></a>24755             ori = 0.0; <span class="comment">// f is nearly coplanar with p.</span>
<a name="l24756"></a>24756           }
<a name="l24757"></a>24757         }
<a name="l24758"></a>24758         <span class="keywordflow">if</span> (ori &gt;= 0.0) {
<a name="l24759"></a>24759           <span class="comment">// f is either invisible or coplanar with p.</span>
<a name="l24760"></a>24760           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l24761"></a>24761             printf(<span class="stringliteral">&quot;    Remove front (%d, %d, %d).\n&quot;</span>, pointmark(pa),
<a name="l24762"></a>24762                    pointmark(pb), pointmark(pc));
<a name="l24763"></a>24763           }
<a name="l24764"></a>24764           frontlist-&gt;del(i, 1);
<a name="l24765"></a>24765           expflag = <span class="keyword">true</span>;
<a name="l24766"></a>24766           <span class="keywordflow">break</span>;
<a name="l24767"></a>24767         }
<a name="l24768"></a>24768       }
<a name="l24769"></a>24769     }
<a name="l24770"></a>24770     <span class="keywordflow">if</span> (expflag) {
<a name="l24771"></a>24771       assert(!infected(front) &amp;&amp; (oppo(front) != NULL));
<a name="l24772"></a>24772       <span class="comment">// Expand C at f by including new fronts.</span>
<a name="l24773"></a>24773       adjustedgering(front, CCW);
<a name="l24774"></a>24774       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l24775"></a>24775         newflag = <span class="keyword">true</span>;
<a name="l24776"></a>24776         <span class="comment">// Get a new boundary n of the cavity.</span>
<a name="l24777"></a>24777         fnext(front, symfront);
<a name="l24778"></a>24778         tspivot(symfront, frontsh);
<a name="l24779"></a>24779         sym(symfront, newfront);
<a name="l24780"></a>24780         <span class="keywordflow">if</span> (frontsh.sh == dummysh) {
<a name="l24781"></a>24781           assert(newfront.tet != dummytet);
<a name="l24782"></a>24782           <span class="comment">// Is n a front of the unexp. cavity?</span>
<a name="l24783"></a>24783           <span class="keywordflow">if</span> (infected(newfront)) {
<a name="l24784"></a>24784             <span class="keywordflow">for</span> (j = 0; j &lt; frontlist-&gt;len(); j++) {
<a name="l24785"></a>24785               oldfront = * (triface *)(* frontlist)[j];
<a name="l24786"></a>24786               <span class="keywordflow">if</span> ((oldfront.tet == symfront.tet) &amp;&amp;
<a name="l24787"></a>24787                   (oldfront.loc == symfront.loc)) {
<a name="l24788"></a>24788                 <span class="comment">// n is not a front anymore.</span>
<a name="l24789"></a>24789                 <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l24790"></a>24790                   printf(<span class="stringliteral">&quot;    Remove front (%d, %d, %d).\n&quot;</span>,
<a name="l24791"></a>24791                          pointmark(org(oldfront)), pointmark(dest(oldfront)),
<a name="l24792"></a>24792                          pointmark(apex(oldfront)));
<a name="l24793"></a>24793                 }
<a name="l24794"></a>24794                 frontlist-&gt;del(j, 1);
<a name="l24795"></a>24795                 newflag = <span class="keyword">false</span>;
<a name="l24796"></a>24796                 <span class="keywordflow">break</span>;
<a name="l24797"></a>24797               }
<a name="l24798"></a>24798             }
<a name="l24799"></a>24799           }
<a name="l24800"></a>24800         } <span class="keywordflow">else</span> {
<a name="l24801"></a>24801           <span class="comment">// n is a subface.</span>
<a name="l24802"></a>24802           <span class="keywordflow">if</span> (newfront.tet == dummytet) {
<a name="l24803"></a>24803             sesymself(frontsh);
<a name="l24804"></a>24804             <span class="comment">// Create a fake tet to hold n.</span>
<a name="l24805"></a>24805             maketetrahedron(&amp;newfront);
<a name="l24806"></a>24806             setorg(newfront, sorg(frontsh));
<a name="l24807"></a>24807             setdest(newfront, sdest(frontsh));
<a name="l24808"></a>24808             setapex(newfront, sapex(frontsh));
<a name="l24809"></a>24809             setoppo(newfront, (point) NULL);
<a name="l24810"></a>24810             tsbond(newfront, frontsh);
<a name="l24811"></a>24811           } <span class="keywordflow">else</span> {
<a name="l24812"></a>24812             <span class="comment">// n should not be a front of cavity yet.</span>
<a name="l24813"></a>24813             assert(!infected(newfront));
<a name="l24814"></a>24814           }
<a name="l24815"></a>24815         }
<a name="l24816"></a>24816         <span class="keywordflow">if</span> (newflag) {
<a name="l24817"></a>24817           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l24818"></a>24818             printf(<span class="stringliteral">&quot;    Add front (%d, %d, %d).\n&quot;</span>, pointmark(org(newfront)),
<a name="l24819"></a>24819                    pointmark(dest(newfront)), pointmark(apex(newfront)));
<a name="l24820"></a>24820           }
<a name="l24821"></a>24821           frontlist-&gt;append(&amp;newfront);
<a name="l24822"></a>24822         }
<a name="l24823"></a>24823         enextself(front);
<a name="l24824"></a>24824       }
<a name="l24825"></a>24825       <span class="comment">// Add f into oldtetlist (to be deleted).</span>
<a name="l24826"></a>24826       infect(front);
<a name="l24827"></a>24827       oldtetlist-&gt;append(&amp;front);
<a name="l24828"></a>24828       expcavcount++;
<a name="l24829"></a>24829     }
<a name="l24830"></a>24830   } <span class="keywordflow">while</span> (expflag);
<a name="l24831"></a>24831 }
<a name="l24832"></a>24832 
<a name="l24834"></a>24834 <span class="comment">//                                                                           //</span>
<a name="l24835"></a>24835 <span class="comment">// findrelocatepoint()    Find new location for relocating a point.          //</span>
<a name="l24836"></a>24836 <span class="comment">//                                                                           //</span>
<a name="l24837"></a>24837 <span class="comment">// &#39;frontlist&#39; contains the boundary faces of the cavity C.  Some fronts are //</span>
<a name="l24838"></a>24838 <span class="comment">// visible by &#39;stpt&#39; p, some are coplanar with p.                            //</span>
<a name="l24839"></a>24839 <span class="comment">//                                                                           //</span>
<a name="l24841"></a>24841 <span class="comment"></span>
<a name="l24842"></a>24842 <span class="keywordtype">bool</span> tetgenmesh::findrelocatepoint(point sp, point np, REAL* n,
<a name="l24843"></a>24843   list* frontlist, list* oldtetlist)
<a name="l24844"></a>24844 {
<a name="l24845"></a>24845   triface front;
<a name="l24846"></a>24846   point pa, pb, pc;
<a name="l24847"></a>24847   REAL tp[3], tvol, mvol;
<a name="l24848"></a>24848   REAL ori, eps;
<a name="l24849"></a>24849   <span class="keywordtype">bool</span> visible;
<a name="l24850"></a>24850   <span class="keywordtype">int</span> i, j, k;
<a name="l24851"></a>24851 
<a name="l24852"></a>24852   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l24853"></a>24853     printf(<span class="stringliteral">&quot;    Find new location for point %d.\n&quot;</span>, pointmark(sp));
<a name="l24854"></a>24854   }
<a name="l24855"></a>24855 
<a name="l24856"></a>24856   <span class="comment">// Avoid compilation warnings.</span>
<a name="l24857"></a>24857   tvol = mvol = 0.0;
<a name="l24858"></a>24858   visible = <span class="keyword">false</span>;
<a name="l24859"></a>24859 
<a name="l24860"></a>24860   eps = b-&gt;epsilon;
<a name="l24861"></a>24861   <span class="comment">// Initialize np far enough from p (outside C).</span>
<a name="l24862"></a>24862   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) np[i] = sp[i] + longest * n[i];
<a name="l24863"></a>24863   <span class="comment">// Let tp = np;</span>
<a name="l24864"></a>24864   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) tp[i] = np[i];
<a name="l24865"></a>24865   <span class="comment">// Interation to adjust np until it is visible by all fronts.</span>
<a name="l24866"></a>24866   j = 0;
<a name="l24867"></a>24867   <span class="keywordflow">do</span> {
<a name="l24868"></a>24868     <span class="keywordflow">for</span> (i = 0; i &lt; frontlist-&gt;len(); i++) {
<a name="l24869"></a>24869       <span class="comment">// Get a front face f.</span>
<a name="l24870"></a>24870       front = * (triface *)(* frontlist)[i];
<a name="l24871"></a>24871       <span class="comment">// Let f face to the interior of C.</span>
<a name="l24872"></a>24872       adjustedgering(front, CW);
<a name="l24873"></a>24873       pa = org(front);
<a name="l24874"></a>24874       pb = dest(front);
<a name="l24875"></a>24875       pc = apex(front);
<a name="l24876"></a>24876       ori = orient3d(pa, pb, pc, np);
<a name="l24877"></a>24877       visible = (ori &lt; 0.0);
<a name="l24878"></a>24878       <span class="keywordflow">if</span> (!visible) {
<a name="l24879"></a>24879         <span class="comment">// A front is invisible by np. Move it towards p along the normal.</span>
<a name="l24880"></a>24880         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) np[i] = sp[i] + 0.5 * (sp[i] - np[i]);
<a name="l24881"></a>24881         <span class="comment">// Failed if tp = np.</span>
<a name="l24882"></a>24882         <span class="keywordflow">if</span> ((tp[0] == np[0]) &amp;&amp; (tp[1] == np[1]) &amp;&amp; (tp[2] == np[2])) {
<a name="l24883"></a>24883           <span class="comment">// Try to expand the cavity.</span>
<a name="l24884"></a>24884           expandsteinercavity(sp, eps, frontlist, oldtetlist);
<a name="l24885"></a>24885           eps *= 10.0;
<a name="l24886"></a>24886           <span class="keywordflow">if</span> (eps &gt; b-&gt;epsilon * 1000.0) {
<a name="l24887"></a>24887           <span class="comment">// printf(&quot;Internal error: Fail to relocate pt %d.\n&quot;,pointmark(sp));</span>
<a name="l24888"></a>24888             <span class="comment">// internalerror();</span>
<a name="l24889"></a>24889             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l24890"></a>24890           }
<a name="l24891"></a>24891           <span class="comment">// Restart the point relocation.</span>
<a name="l24892"></a>24892           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) np[i] = sp[i] + longest * n[i];
<a name="l24893"></a>24893         }
<a name="l24894"></a>24894         <span class="keywordflow">if</span> (j % 2) {
<a name="l24895"></a>24895           <span class="comment">// Set tp = np (at every 2 steps) to catch the stop state.</span>
<a name="l24896"></a>24896           <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) tp[i] = np[i];
<a name="l24897"></a>24897         }
<a name="l24898"></a>24898         <span class="keywordflow">break</span>;
<a name="l24899"></a>24899       } <span class="keywordflow">else</span> {
<a name="l24900"></a>24900         <span class="comment">// Save the smallest volume.</span>
<a name="l24901"></a>24901         <span class="keywordflow">if</span> (i == 0) {
<a name="l24902"></a>24902           mvol = fabs(ori);
<a name="l24903"></a>24903         } <span class="keywordflow">else</span> {
<a name="l24904"></a>24904           mvol = fabs(ori) &lt; mvol ? fabs(ori) : mvol;
<a name="l24905"></a>24905         }
<a name="l24906"></a>24906       }
<a name="l24907"></a>24907     }
<a name="l24908"></a>24908     j++;
<a name="l24909"></a>24909   } <span class="keywordflow">while</span> (!visible);
<a name="l24910"></a>24910 
<a name="l24911"></a>24911   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l24912"></a>24912     printf(<span class="stringliteral">&quot;    %d iterations. minvol = %.12g.\n&quot;</span>, j, mvol);
<a name="l24913"></a>24913   }
<a name="l24914"></a>24914 
<a name="l24915"></a>24915   <span class="comment">// Continue to adjust np until the minimal volume of tets formed by</span>
<a name="l24916"></a>24916   <span class="comment">//   fronts and np doesn&#39;t increase (all fronts are visible by np).</span>
<a name="l24917"></a>24917   k = 0;
<a name="l24918"></a>24918   <span class="keywordflow">do</span> {
<a name="l24919"></a>24919     j = 0;
<a name="l24920"></a>24920     <span class="keywordflow">do</span> {
<a name="l24921"></a>24921       <span class="keywordflow">if</span> (k == 0) {
<a name="l24922"></a>24922         <span class="comment">// Initial tp := np + 0.9 * (p - np). Move toward p.</span>
<a name="l24923"></a>24923         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) tp[i] = sp[i] + 0.9 * (np[i] - sp[i]);
<a name="l24924"></a>24924       } <span class="keywordflow">else</span> {
<a name="l24925"></a>24925         <span class="comment">// Initial tp := np + 1.1 * (p - np). Move away from p.</span>
<a name="l24926"></a>24926         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) tp[i] = sp[i] + 1.1 * (np[i] - sp[i]);
<a name="l24927"></a>24927       }
<a name="l24928"></a>24928       <span class="comment">// Get the minial volume formed by tp with one of the fronts.</span>
<a name="l24929"></a>24929       <span class="keywordflow">for</span> (i = 0; i &lt; frontlist-&gt;len(); i++) {
<a name="l24930"></a>24930         <span class="comment">// Get a front face f.</span>
<a name="l24931"></a>24931         front = * (triface *)(* frontlist)[i];
<a name="l24932"></a>24932         <span class="comment">// Let f face to the interior of C.</span>
<a name="l24933"></a>24933         adjustedgering(front, CW);
<a name="l24934"></a>24934         pa = org(front);
<a name="l24935"></a>24935         pb = dest(front);
<a name="l24936"></a>24936         pc = apex(front);
<a name="l24937"></a>24937         ori = orient3d(pa, pb, pc, tp);
<a name="l24938"></a>24938         visible = (ori &lt; 0.0);
<a name="l24939"></a>24939         <span class="keywordflow">if</span> (visible) {
<a name="l24940"></a>24940           <span class="comment">// Save the smallest volume.</span>
<a name="l24941"></a>24941           <span class="keywordflow">if</span> (i == 0) {
<a name="l24942"></a>24942             tvol = fabs(ori);
<a name="l24943"></a>24943           } <span class="keywordflow">else</span> {
<a name="l24944"></a>24944             tvol = fabs(ori) &lt; tvol ? fabs(ori) : tvol;
<a name="l24945"></a>24945           }
<a name="l24946"></a>24946         } <span class="keywordflow">else</span> {
<a name="l24947"></a>24947           <span class="comment">// A front is invisible by tp. Stop.</span>
<a name="l24948"></a>24948           tvol = 0.0;
<a name="l24949"></a>24949           <span class="keywordflow">break</span>;
<a name="l24950"></a>24950         }
<a name="l24951"></a>24951       }
<a name="l24952"></a>24952       <span class="keywordflow">if</span> (tvol &gt; mvol) {
<a name="l24953"></a>24953         <span class="comment">// Get a larger minimal volume.</span>
<a name="l24954"></a>24954         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) np[i] = tp[i];
<a name="l24955"></a>24955         mvol = tvol;
<a name="l24956"></a>24956       } <span class="keywordflow">else</span> {
<a name="l24957"></a>24957         <span class="comment">// Minimal volume decreases. Stop.</span>
<a name="l24958"></a>24958         <span class="keywordflow">break</span>;
<a name="l24959"></a>24959       }
<a name="l24960"></a>24960       <span class="comment">// Continue to adjust np.</span>
<a name="l24961"></a>24961       j++;
<a name="l24962"></a>24962     } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l24963"></a>24963     <span class="comment">// Has np been adjusted?</span>
<a name="l24964"></a>24964     <span class="keywordflow">if</span> (j &gt; 0) <span class="keywordflow">break</span>;
<a name="l24965"></a>24965     <span class="comment">// Try to move np to anoter direction.</span>
<a name="l24966"></a>24966     k++;
<a name="l24967"></a>24967   } <span class="keywordflow">while</span> (k &lt; 2);
<a name="l24968"></a>24968 
<a name="l24969"></a>24969   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l24970"></a>24970     printf(<span class="stringliteral">&quot;    %d adjust iterations. minvol = %.12g.\n&quot;</span>, j, mvol);
<a name="l24971"></a>24971   }
<a name="l24972"></a>24972   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l24973"></a>24973 }
<a name="l24974"></a>24974 
<a name="l24976"></a>24976 <span class="comment">//                                                                           //</span>
<a name="l24977"></a>24977 <span class="comment">// relocatepoint()    Relocate a point into the cavity.                      //</span>
<a name="l24978"></a>24978 <span class="comment">//                                                                           //</span>
<a name="l24979"></a>24979 <span class="comment">// &#39;frontlist&#39; contains the boundary faces of the cavity C. All fronts must  //</span>
<a name="l24980"></a>24980 <span class="comment">// be visible by &#39;steinpt&#39;.  Some fronts may hold by &#39;fake&#39; tets (they are   //</span>
<a name="l24981"></a>24981 <span class="comment">// hull faces).  Fake tets will be removed when they&#39;re finished.            //</span>
<a name="l24982"></a>24982 <span class="comment">//                                                                           //</span>
<a name="l24984"></a>24984 <span class="comment"></span>
<a name="l24985"></a>24985 <span class="keywordtype">void</span> tetgenmesh::relocatepoint(point steinpt, triface* oldtet, list* frontlist,
<a name="l24986"></a>24986   list* newtetlist, queue* flipque)
<a name="l24987"></a>24987 {
<a name="l24988"></a>24988   triface front, newtet, newface, neightet;
<a name="l24989"></a>24989   face checksh;
<a name="l24990"></a>24990   point pa, pb;
<a name="l24991"></a>24991   REAL attrib, volume;
<a name="l24992"></a>24992   <span class="keywordtype">bool</span> bdflag;
<a name="l24993"></a>24993   <span class="keywordtype">int</span> i, j, k, l;
<a name="l24994"></a>24994 
<a name="l24995"></a>24995   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l24996"></a>24996     printf(<span class="stringliteral">&quot;    Insert Steiner point (%.12g, %.12g, %.12g) %d.\n&quot;</span>,
<a name="l24997"></a>24997            steinpt[0], steinpt[1], steinpt[2], pointmark(steinpt));
<a name="l24998"></a>24998   }
<a name="l24999"></a>24999   <span class="comment">// Clear the list first.</span>
<a name="l25000"></a>25000   newtetlist-&gt;clear();
<a name="l25001"></a>25001 
<a name="l25002"></a>25002   <span class="comment">// Create the tets formed by fronts and &#39;steinpt&#39;.</span>
<a name="l25003"></a>25003   <span class="keywordflow">for</span> (i = 0; i &lt; frontlist-&gt;len(); i++) {
<a name="l25004"></a>25004     <span class="comment">// Get a front f.</span>
<a name="l25005"></a>25005     front = * (triface *)(* frontlist)[i];
<a name="l25006"></a>25006     <span class="comment">// Let f face inside C. (f is a face of tet adjacent to C).</span>
<a name="l25007"></a>25007     adjustedgering(front, CW);
<a name="l25008"></a>25008     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l25009"></a>25009       printf(<span class="stringliteral">&quot;    Get front (%d, %d, %d).\n&quot;</span>, pointmark(org(front)),
<a name="l25010"></a>25010              pointmark(dest(front)), pointmark(apex(front)));
<a name="l25011"></a>25011     }
<a name="l25012"></a>25012     maketetrahedron(&amp;newtet);
<a name="l25013"></a>25013     newtetlist-&gt;append(&amp;newtet);
<a name="l25014"></a>25014     setorg(newtet, org(front));
<a name="l25015"></a>25015     setdest(newtet, dest(front));
<a name="l25016"></a>25016     setapex(newtet, apex(front));
<a name="l25017"></a>25017     setoppo(newtet, steinpt);
<a name="l25018"></a>25018     <span class="keywordflow">if</span> (oldtet != (triface *) NULL) {
<a name="l25019"></a>25019       <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberoftetrahedronattributes; j++) {
<a name="l25020"></a>25020         attrib = elemattribute(oldtet-&gt;tet, j);
<a name="l25021"></a>25021         setelemattribute(newtet.tet, j, attrib);
<a name="l25022"></a>25022       }
<a name="l25023"></a>25023       <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l25024"></a>25024         volume = volumebound(oldtet-&gt;tet);
<a name="l25025"></a>25025         setvolumebound(newtet.tet, volume);
<a name="l25026"></a>25026       }
<a name="l25027"></a>25027     }
<a name="l25028"></a>25028     <span class="comment">// &#39;front&#39; may be a &#39;fake&#39; tet.</span>
<a name="l25029"></a>25029     tspivot(front, checksh);
<a name="l25030"></a>25030     <span class="keywordflow">if</span> (oppo(front) == (point) NULL) {
<a name="l25031"></a>25031       <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l25032"></a>25032         stdissolve(checksh);
<a name="l25033"></a>25033       }
<a name="l25034"></a>25034       <span class="comment">// Dealloc the &#39;fake&#39; tet.</span>
<a name="l25035"></a>25035       tetrahedrondealloc(front.tet);
<a name="l25036"></a>25036       <span class="comment">// This side (newtet) is a boundary face, let &#39;dummytet&#39; bond to it.</span>
<a name="l25037"></a>25037       <span class="comment">//   Otherwise, &#39;dummytet&#39; may point to a dead tetrahedron after the</span>
<a name="l25038"></a>25038       <span class="comment">//   old cavity tets are removed.</span>
<a name="l25039"></a>25039       dummytet[0] = encode(newtet);
<a name="l25040"></a>25040     } <span class="keywordflow">else</span> {
<a name="l25041"></a>25041       <span class="comment">// Bond two tetrahedra, also dissolve the old bond at &#39;front&#39;.</span>
<a name="l25042"></a>25042       bond(newtet, front);
<a name="l25043"></a>25043     }
<a name="l25044"></a>25044     <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l25045"></a>25045       sesymself(checksh);
<a name="l25046"></a>25046       tsbond(newtet, checksh);
<a name="l25047"></a>25047     }
<a name="l25048"></a>25048     <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l25049"></a>25049       <span class="comment">// f may be non-locally Delaunay and flipable.</span>
<a name="l25050"></a>25050       enqueueflipface(newtet, flipque);
<a name="l25051"></a>25051     }
<a name="l25052"></a>25052     <span class="comment">// The three neighbors are open. Will be finished later.</span>
<a name="l25053"></a>25053   }
<a name="l25054"></a>25054 
<a name="l25055"></a>25055   <span class="comment">// Connect new tets in C. All connecting faces must contain &#39;steinpt&#39;.</span>
<a name="l25056"></a>25056   <span class="keywordflow">for</span> (i = 0; i &lt; newtetlist-&gt;len(); i++) {
<a name="l25057"></a>25057     newtet = * (triface *)(* newtetlist)[i];
<a name="l25058"></a>25058     newtet.ver = 0;
<a name="l25059"></a>25059     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l25060"></a>25060       fnext(newtet, newface);
<a name="l25061"></a>25061       sym(newface, neightet);
<a name="l25062"></a>25062       <span class="keywordflow">if</span> (neightet.tet == dummytet) {
<a name="l25063"></a>25063         <span class="comment">// Find a neightet to connect it.</span>
<a name="l25064"></a>25064         bdflag = <span class="keyword">false</span>;
<a name="l25065"></a>25065         pa = org(newface);
<a name="l25066"></a>25066         pb = dest(newface);
<a name="l25067"></a>25067         assert(apex(newface) == steinpt);
<a name="l25068"></a>25068         <span class="keywordflow">for</span> (k = i + 1; k &lt; newtetlist-&gt;len() &amp;&amp; !bdflag; k++) {
<a name="l25069"></a>25069           neightet = * (triface *)(* newtetlist)[k];
<a name="l25070"></a>25070           neightet.ver = 0;
<a name="l25071"></a>25071           <span class="keywordflow">for</span> (l = 0; l &lt; 3; l++) {
<a name="l25072"></a>25072             <span class="keywordflow">if</span> ((org(neightet) == pa &amp;&amp; dest(neightet) == pb) ||
<a name="l25073"></a>25073                 (org(neightet) == pb &amp;&amp; dest(neightet) == pa)) {
<a name="l25074"></a>25074               <span class="comment">// Find the neighbor.</span>
<a name="l25075"></a>25075               fnextself(neightet);
<a name="l25076"></a>25076               assert(apex(neightet) == steinpt);
<a name="l25077"></a>25077               <span class="comment">// Now neightet is a face same as newface, bond them.</span>
<a name="l25078"></a>25078               bond(newface, neightet);
<a name="l25079"></a>25079               bdflag = <span class="keyword">true</span>;
<a name="l25080"></a>25080               <span class="keywordflow">break</span>;
<a name="l25081"></a>25081             }
<a name="l25082"></a>25082             enextself(neightet);
<a name="l25083"></a>25083           }
<a name="l25084"></a>25084         }
<a name="l25085"></a>25085         assert(bdflag);
<a name="l25086"></a>25086       }
<a name="l25087"></a>25087       enextself(newtet);
<a name="l25088"></a>25088     }
<a name="l25089"></a>25089     <span class="comment">// Let the corners of newtet point to it for fast searching.</span>
<a name="l25090"></a>25090     pa = org(newtet);
<a name="l25091"></a>25091     setpoint2tet(pa, encode(newtet));
<a name="l25092"></a>25092     pa = dest(newtet);
<a name="l25093"></a>25093     setpoint2tet(pa, encode(newtet));
<a name="l25094"></a>25094     pa = apex(newtet);
<a name="l25095"></a>25095     setpoint2tet(pa, encode(newtet));
<a name="l25096"></a>25096     pa = oppo(newtet);
<a name="l25097"></a>25097     setpoint2tet(pa, encode(newtet));
<a name="l25098"></a>25098   }
<a name="l25099"></a>25099 
<a name="l25100"></a>25100   <span class="keywordflow">if</span> (flipque != (queue *) NULL) {
<a name="l25101"></a>25101     <span class="comment">// Recover locally Delaunay faces.</span>
<a name="l25102"></a>25102     flip(flipque, NULL);
<a name="l25103"></a>25103   }
<a name="l25104"></a>25104 }
<a name="l25105"></a>25105 
<a name="l25107"></a>25107 <span class="comment">//                                                                           //</span>
<a name="l25108"></a>25108 <span class="comment">// findcollapseedge()    Find collapseable edge to suppress an endpoint.     //</span>
<a name="l25109"></a>25109 <span class="comment">//                                                                           //</span>
<a name="l25111"></a>25111 <span class="comment"></span>
<a name="l25112"></a>25112 <span class="keywordtype">bool</span> tetgenmesh::findcollapseedge(point suppt, point *conpt, list* oldtetlist,
<a name="l25113"></a>25113   list* ptlist)
<a name="l25114"></a>25114 {
<a name="l25115"></a>25115   triface front;
<a name="l25116"></a>25116   point pt, pa, pb, pc;
<a name="l25117"></a>25117   REAL *lenarray, ltmp, ori;
<a name="l25118"></a>25118   <span class="keywordtype">bool</span> visflag;
<a name="l25119"></a>25119   <span class="keywordtype">int</span> *idxarray, itmp;
<a name="l25120"></a>25120   <span class="keywordtype">int</span> n, i, j;
<a name="l25121"></a>25121 
<a name="l25122"></a>25122   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l25123"></a>25123     printf(<span class="stringliteral">&quot;    Search an edge (in %d edges) for collapse %d.\n&quot;</span>,
<a name="l25124"></a>25124            ptlist-&gt;len(), pointmark(suppt));
<a name="l25125"></a>25125   }
<a name="l25126"></a>25126 
<a name="l25127"></a>25127   <span class="comment">// Candidate edges are p to the points of B(p) (in &#39;ptlist&#39;).</span>
<a name="l25128"></a>25128   n = ptlist-&gt;len();
<a name="l25129"></a>25129   lenarray = <span class="keyword">new</span> REAL[n];
<a name="l25130"></a>25130   idxarray = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l25131"></a>25131   <span class="comment">// Sort the points of B(p) by distance to p.</span>
<a name="l25132"></a>25132   <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l25133"></a>25133     pt = * (point *)(* ptlist)[i];
<a name="l25134"></a>25134     lenarray[i] = distance(suppt, pt);
<a name="l25135"></a>25135     idxarray[i] = i;
<a name="l25136"></a>25136   }
<a name="l25137"></a>25137   <span class="comment">// Bubble sort.</span>
<a name="l25138"></a>25138   <span class="keywordflow">for</span> (i = 0; i &lt; n - 1; i++) {
<a name="l25139"></a>25139     <span class="keywordflow">for</span> (j = 0; j &lt; n - 1 - i; j++) {
<a name="l25140"></a>25140       <span class="keywordflow">if</span> (lenarray[j + 1] &lt; lenarray[j]) {  <span class="comment">// compare the two neighbors</span>
<a name="l25141"></a>25141         ltmp = lenarray[j];           <span class="comment">// swap a[j] and a[j + 1]</span>
<a name="l25142"></a>25142         lenarray[j] = lenarray[j + 1];
<a name="l25143"></a>25143         lenarray[j + 1] = ltmp;
<a name="l25144"></a>25144         itmp = idxarray[j];           <span class="comment">// swap a[j] and a[j + 1]</span>
<a name="l25145"></a>25145         idxarray[j] = idxarray[j + 1];
<a name="l25146"></a>25146         idxarray[j + 1] = itmp;
<a name="l25147"></a>25147       }
<a name="l25148"></a>25148     }
<a name="l25149"></a>25149   }
<a name="l25150"></a>25150   <span class="comment">// For each point q of B(p), test if the edge (p, q) can be collapseed.</span>
<a name="l25151"></a>25151   <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l25152"></a>25152     pt = * (point *)(* ptlist)[idxarray[i]];
<a name="l25153"></a>25153     <span class="comment">// Is q visible by faces of B(p) not with q as a vertex.</span>
<a name="l25154"></a>25154     lenarray[i] = 0.0; <span class="comment">// zero volume.</span>
<a name="l25155"></a>25155     visflag = <span class="keyword">true</span>;
<a name="l25156"></a>25156     <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist-&gt;len() &amp;&amp; visflag; j++) {
<a name="l25157"></a>25157       front = * (triface *)(* oldtetlist)[j];
<a name="l25158"></a>25158       <span class="comment">// Let f face to inside of B(p).</span>
<a name="l25159"></a>25159       adjustedgering(front, CCW);
<a name="l25160"></a>25160       pa = org(front);
<a name="l25161"></a>25161       pb = dest(front);
<a name="l25162"></a>25162       pc = apex(front);
<a name="l25163"></a>25163       <span class="comment">// Is f contains q?</span>
<a name="l25164"></a>25164       <span class="keywordflow">if</span> ((pa != pt) &amp;&amp; (pb != pt) &amp;&amp; (pc != pt)) {
<a name="l25165"></a>25165         ori = orient3d(pa, pb, pc, pt);
<a name="l25166"></a>25166         <span class="keywordflow">if</span> (ori != 0.0) {
<a name="l25167"></a>25167           <span class="keywordflow">if</span> (iscoplanar(pa, pb, pc, pt, ori, b-&gt;epsilon * 1e+2)) ori = 0.0;
<a name="l25168"></a>25168         }
<a name="l25169"></a>25169         visflag = ori &lt; 0.0;
<a name="l25170"></a>25170         <span class="keywordflow">if</span> (visflag) {
<a name="l25171"></a>25171           <span class="comment">// Visible, set the smallest volume.</span>
<a name="l25172"></a>25172           <span class="keywordflow">if</span> (j == 0) {
<a name="l25173"></a>25173             lenarray[i] = fabs(ori);
<a name="l25174"></a>25174           } <span class="keywordflow">else</span> {
<a name="l25175"></a>25175             lenarray[i] = fabs(ori) &lt; lenarray[i] ? fabs(ori) : lenarray[i];
<a name="l25176"></a>25176           }
<a name="l25177"></a>25177         } <span class="keywordflow">else</span> {
<a name="l25178"></a>25178           <span class="comment">// Invisible. Do not collapse (p, q).</span>
<a name="l25179"></a>25179           lenarray[i] = 0.0;
<a name="l25180"></a>25180         }
<a name="l25181"></a>25181       }
<a name="l25182"></a>25182     }
<a name="l25183"></a>25183     <span class="keywordflow">if</span> ((b-&gt;verbose &gt; 2) &amp;&amp; visflag) {
<a name="l25184"></a>25184       printf(<span class="stringliteral">&quot;    Got candidate %d vol(%g).\n&quot;</span>, pointmark(pt), lenarray[i]);
<a name="l25185"></a>25185     }
<a name="l25186"></a>25186   }
<a name="l25187"></a>25187 
<a name="l25188"></a>25188   <span class="comment">// Select the largest non-zero volume (result in ltmp).</span>
<a name="l25189"></a>25189   ltmp = lenarray[0];
<a name="l25190"></a>25190   itmp = idxarray[0];
<a name="l25191"></a>25191   <span class="keywordflow">for</span> (i = 1; i &lt; n; i++) {
<a name="l25192"></a>25192     <span class="keywordflow">if</span> (lenarray[i] != 0.0) {
<a name="l25193"></a>25193       <span class="keywordflow">if</span> (lenarray[i] &gt; ltmp) {
<a name="l25194"></a>25194         ltmp = lenarray[i];
<a name="l25195"></a>25195         itmp = idxarray[i]; <span class="comment">// The index to find the point.</span>
<a name="l25196"></a>25196       }
<a name="l25197"></a>25197     }
<a name="l25198"></a>25198   }
<a name="l25199"></a>25199 
<a name="l25200"></a>25200   <span class="keyword">delete</span> [] lenarray;
<a name="l25201"></a>25201   <span class="keyword">delete</span> [] idxarray;
<a name="l25202"></a>25202 
<a name="l25203"></a>25203   <span class="keywordflow">if</span> (ltmp == 0.0) {
<a name="l25204"></a>25204     <span class="comment">// No edge can be collapseed.</span>
<a name="l25205"></a>25205     *conpt = (point) NULL;
<a name="l25206"></a>25206     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l25207"></a>25207   } <span class="keywordflow">else</span> {
<a name="l25208"></a>25208     pt = * (point *)(* ptlist)[itmp];
<a name="l25209"></a>25209     *conpt = pt;
<a name="l25210"></a>25210     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l25211"></a>25211   }
<a name="l25212"></a>25212 }
<a name="l25213"></a>25213 
<a name="l25215"></a>25215 <span class="comment">//                                                                           //</span>
<a name="l25216"></a>25216 <span class="comment">// collapseedge()    Remove a point by edge collapse.                        //</span>
<a name="l25217"></a>25217 <span class="comment">//                                                                           //</span>
<a name="l25219"></a>25219 <span class="comment"></span>
<a name="l25220"></a>25220 <span class="keywordtype">void</span> tetgenmesh::collapseedge(point suppt, point conpt, list* oldtetlist,
<a name="l25221"></a>25221   list* deadtetlist)
<a name="l25222"></a>25222 {
<a name="l25223"></a>25223   triface oldtet, deadtet;
<a name="l25224"></a>25224   triface adjtet1, adjtet2;
<a name="l25225"></a>25225   face adjsh;
<a name="l25226"></a>25226   point pa, pb, pc;
<a name="l25227"></a>25227   <span class="keywordtype">int</span> i, j;
<a name="l25228"></a>25228 
<a name="l25229"></a>25229   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l25230"></a>25230     printf(<span class="stringliteral">&quot;    Collapse edge (%d,%d).\n&quot;</span>, pointmark(suppt), pointmark(conpt));
<a name="l25231"></a>25231   }
<a name="l25232"></a>25232 
<a name="l25233"></a>25233   <span class="comment">// Loop in B(p), replace p with np, queue dead tets, uninfect old tets.</span>
<a name="l25234"></a>25234   <span class="keywordflow">for</span> (i = 0; i &lt; oldtetlist-&gt;len(); i++) {
<a name="l25235"></a>25235     oldtet = * (triface *)(* oldtetlist)[i]; <span class="comment">// assert(infected(oldtet));</span>
<a name="l25236"></a>25236     uninfect(oldtet);
<a name="l25237"></a>25237     pa = org(oldtet);
<a name="l25238"></a>25238     pb = dest(oldtet);
<a name="l25239"></a>25239     pc = apex(oldtet);
<a name="l25240"></a>25240     assert(oppo(oldtet) == suppt);
<a name="l25241"></a>25241     setoppo(oldtet, conpt);
<a name="l25242"></a>25242     <span class="keywordflow">if</span> ((pa == conpt) || (pb == conpt) || (pc == conpt)) {
<a name="l25243"></a>25243       deadtetlist-&gt;append(&amp;oldtet); <span class="comment">// a collpased tet.</span>
<a name="l25244"></a>25244     }
<a name="l25245"></a>25245   }
<a name="l25246"></a>25246   <span class="comment">// Loop in deadtetlist, glue adjacent tets of dead tets.</span>
<a name="l25247"></a>25247   <span class="keywordflow">for</span> (i = 0; i &lt; deadtetlist-&gt;len(); i++) {
<a name="l25248"></a>25248     deadtet = * (triface *)(* deadtetlist)[i];
<a name="l25249"></a>25249     <span class="comment">// Get the adjacent tet n1 (outside B(p)).</span>
<a name="l25250"></a>25250     sym(deadtet, adjtet1);
<a name="l25251"></a>25251     tspivot(deadtet, adjsh);
<a name="l25252"></a>25252     <span class="comment">// Find the edge in deadtet opposite to conpt.</span>
<a name="l25253"></a>25253     adjustedgering(deadtet, CCW);
<a name="l25254"></a>25254     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l25255"></a>25255       <span class="keywordflow">if</span> (apex(deadtet) == conpt) <span class="keywordflow">break</span>;
<a name="l25256"></a>25256       enextself(deadtet);
<a name="l25257"></a>25257     }
<a name="l25258"></a>25258     assert(j &lt; 3);
<a name="l25259"></a>25259     <span class="comment">// Get another adjacent tet n2.</span>
<a name="l25260"></a>25260     fnext(deadtet, adjtet2);
<a name="l25261"></a>25261     symself(adjtet2);
<a name="l25262"></a>25262     assert(adjtet2.tet != dummytet); <span class="comment">// n2 is inside B(p).</span>
<a name="l25263"></a>25263     <span class="keywordflow">if</span> (adjtet1.tet != dummytet) {
<a name="l25264"></a>25264       bond(adjtet1, adjtet2); <span class="comment">// Bond n1 &lt;--&gt; n2.</span>
<a name="l25265"></a>25265     } <span class="keywordflow">else</span> {
<a name="l25266"></a>25266       dissolve(adjtet2); <span class="comment">// Dissolve at n2.</span>
<a name="l25267"></a>25267       dummytet[0] = encode(adjtet2); <span class="comment">// Let dummytet holds n2.</span>
<a name="l25268"></a>25268     }
<a name="l25269"></a>25269     <span class="keywordflow">if</span> (adjsh.sh != dummysh) {
<a name="l25270"></a>25270       tsbond(adjtet2, adjsh); <span class="comment">// Bond s &lt;--&gt; n2.</span>
<a name="l25271"></a>25271     }
<a name="l25272"></a>25272     <span class="comment">// Collapse deadtet.</span>
<a name="l25273"></a>25273     tetrahedrondealloc(deadtet.tet);
<a name="l25274"></a>25274   }
<a name="l25275"></a>25275   deadtetlist-&gt;clear();
<a name="l25276"></a>25276 }
<a name="l25277"></a>25277 
<a name="l25279"></a>25279 <span class="comment">//                                                                           //</span>
<a name="l25280"></a>25280 <span class="comment">// deallocfaketets()    Deleted fake tets at fronts.                         //</span>
<a name="l25281"></a>25281 <span class="comment">//                                                                           //</span>
<a name="l25282"></a>25282 <span class="comment">// This routine is only called when the findrelocatepoint() routine fails.   //</span>
<a name="l25283"></a>25283 <span class="comment">// In other cases, the fake tets are removed automatically in carvecavity()  //</span>
<a name="l25284"></a>25284 <span class="comment">// or relocatepoint().                                                       //</span>
<a name="l25285"></a>25285 <span class="comment">//                                                                           //</span>
<a name="l25287"></a>25287 <span class="comment"></span>
<a name="l25288"></a>25288 <span class="keywordtype">void</span> tetgenmesh::deallocfaketets(list* frontlist)
<a name="l25289"></a>25289 {
<a name="l25290"></a>25290   triface front, neightet;
<a name="l25291"></a>25291   face checksh;
<a name="l25292"></a>25292   <span class="keywordtype">bool</span> infectflag;
<a name="l25293"></a>25293   <span class="keywordtype">int</span> i;
<a name="l25294"></a>25294 
<a name="l25295"></a>25295   <span class="keywordflow">for</span> (i = 0; i &lt; frontlist-&gt;len(); i++) {
<a name="l25296"></a>25296     <span class="comment">// Get a front f.</span>
<a name="l25297"></a>25297     front = * (triface *)(* frontlist)[i];
<a name="l25298"></a>25298     <span class="comment">// Let f face inside C. (f is a face of tet adjacent to C).</span>
<a name="l25299"></a>25299     adjustedgering(front, CW);
<a name="l25300"></a>25300     sym(front, neightet);
<a name="l25301"></a>25301     tspivot(front, checksh);
<a name="l25302"></a>25302     <span class="keywordflow">if</span> (oppo(front) == (point) NULL) {
<a name="l25303"></a>25303       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l25304"></a>25304         printf(<span class="stringliteral">&quot;    Get fake tet (%d, %d, %d).\n&quot;</span>, pointmark(org(front)),
<a name="l25305"></a>25305                pointmark(dest(front)), pointmark(apex(front)));
<a name="l25306"></a>25306       }
<a name="l25307"></a>25307       <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l25308"></a>25308         <span class="comment">// The neightet may be infected. After dissolve it, the infect flag</span>
<a name="l25309"></a>25309         <span class="comment">//   will be lost. Save the flag and restore it later.</span>
<a name="l25310"></a>25310         infectflag = infected(neightet);
<a name="l25311"></a>25311         dissolve(neightet);
<a name="l25312"></a>25312         <span class="keywordflow">if</span> (infectflag) {
<a name="l25313"></a>25313           infect(neightet);
<a name="l25314"></a>25314         }
<a name="l25315"></a>25315       }
<a name="l25316"></a>25316       <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l25317"></a>25317         infectflag = sinfected(checksh);
<a name="l25318"></a>25318         stdissolve(checksh);
<a name="l25319"></a>25319         <span class="keywordflow">if</span> (infectflag) {
<a name="l25320"></a>25320           sinfect(checksh);
<a name="l25321"></a>25321         }
<a name="l25322"></a>25322       }
<a name="l25323"></a>25323       <span class="comment">// Dealloc the &#39;fake&#39; tet.</span>
<a name="l25324"></a>25324       tetrahedrondealloc(front.tet);
<a name="l25325"></a>25325       <span class="comment">// If &#39;neightet&#39; is a hull face, let &#39;dummytet&#39; bond to it. It is</span>
<a name="l25326"></a>25326       <span class="comment">//   a &#39;dummytet&#39; when this front was created from a new subface.</span>
<a name="l25327"></a>25327       <span class="comment">//   In such case, it should not be bounded.</span>
<a name="l25328"></a>25328       <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l25329"></a>25329         dummytet[0] = encode(neightet);
<a name="l25330"></a>25330       }
<a name="l25331"></a>25331     }
<a name="l25332"></a>25332   }
<a name="l25333"></a>25333 }
<a name="l25334"></a>25334 
<a name="l25336"></a>25336 <span class="comment">//                                                                           //</span>
<a name="l25337"></a>25337 <span class="comment">// restorepolyhedron()    Restore the tetrahedralization in a polyhedron.    //</span>
<a name="l25338"></a>25338 <span class="comment">//                                                                           //</span>
<a name="l25339"></a>25339 <span class="comment">// This routine is only called when the operation of suppressing a point is  //</span>
<a name="l25340"></a>25340 <span class="comment">// aborted (eg., findrelocatepoint() routine fails). The polyhedron has been //</span>
<a name="l25341"></a>25341 <span class="comment">// remeshed by new tets. This routine restore the old tets in it.            //</span>
<a name="l25342"></a>25342 <span class="comment">//                                                                           //</span>
<a name="l25343"></a>25343 <span class="comment">// &#39;oldtetlist&#39; contains the list of old tets. Each old tet t_o assumes that //</span>
<a name="l25344"></a>25344 <span class="comment">// it still connects to a tet t_b of the mesh, however, t_b does not connect //</span>
<a name="l25345"></a>25345 <span class="comment">// to t_o, this routine resets the connection such that t_b &lt;--&gt; t_o.        //</span>
<a name="l25346"></a>25346 <span class="comment">//                                                                           //</span>
<a name="l25348"></a>25348 <span class="comment"></span>
<a name="l25349"></a>25349 <span class="keywordtype">void</span> tetgenmesh::restorepolyhedron(list* oldtetlist)
<a name="l25350"></a>25350 {
<a name="l25351"></a>25351   triface oldtet, neightet, neineitet;
<a name="l25352"></a>25352   face checksh;
<a name="l25353"></a>25353   <span class="keywordtype">int</span> i;
<a name="l25354"></a>25354 
<a name="l25355"></a>25355   <span class="keywordflow">for</span> (i = 0; i &lt; oldtetlist-&gt;len(); i++) {
<a name="l25356"></a>25356     <span class="comment">// Get an old tet t_o.</span>
<a name="l25357"></a>25357     oldtet = * (triface *)(* oldtetlist)[i];
<a name="l25358"></a>25358     <span class="comment">// Check the four sides of t_o.</span>
<a name="l25359"></a>25359     <span class="keywordflow">for</span> (oldtet.loc = 0; oldtet.loc &lt; 4; oldtet.loc++) {
<a name="l25360"></a>25360       sym(oldtet, neightet);
<a name="l25361"></a>25361       tspivot(oldtet, checksh);
<a name="l25362"></a>25362       <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l25363"></a>25363         sym(neightet, neineitet);
<a name="l25364"></a>25364         <span class="keywordflow">if</span> (neineitet.tet != oldtet.tet) {
<a name="l25365"></a>25365           <span class="comment">// This face of t_o is a boundary of P.</span>
<a name="l25366"></a>25366           bond(neightet, oldtet);
<a name="l25367"></a>25367           <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l25368"></a>25368             tsbond(oldtet, checksh);
<a name="l25369"></a>25369           }
<a name="l25370"></a>25370         }
<a name="l25371"></a>25371       } <span class="keywordflow">else</span> {
<a name="l25372"></a>25372         <span class="comment">// t_o has a hull face. It should be the boundary of P.</span>
<a name="l25373"></a>25373 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l25374"></a>25374 <span class="preprocessor"></span>        assert(checksh.sh != dummysh);
<a name="l25375"></a>25375         stpivot(checksh, neineitet);
<a name="l25376"></a>25376         assert(neineitet.tet != oldtet.tet);
<a name="l25377"></a>25377 <span class="preprocessor">#endif</span>
<a name="l25378"></a>25378 <span class="preprocessor"></span>        tsbond(oldtet, checksh);
<a name="l25379"></a>25379         <span class="comment">// Let dummytet[0] points to it.</span>
<a name="l25380"></a>25380         dummytet[0] = encode(oldtet);
<a name="l25381"></a>25381       }
<a name="l25382"></a>25382     }
<a name="l25383"></a>25383   }
<a name="l25384"></a>25384 }
<a name="l25385"></a>25385 
<a name="l25387"></a>25387 <span class="comment">//                                                                           //</span>
<a name="l25388"></a>25388 <span class="comment">// suppressfacetpoint()    Suppress a point inside a facet.                  //</span>
<a name="l25389"></a>25389 <span class="comment">//                                                                           //</span>
<a name="l25390"></a>25390 <span class="comment">// The point p inside a facet F will be suppressed from F by either being    //</span>
<a name="l25391"></a>25391 <span class="comment">// deleted from the mesh or being relocated into the volume.                 //</span>
<a name="l25392"></a>25392 <span class="comment">//                                                                           //</span>
<a name="l25393"></a>25393 <span class="comment">// &#39;supsh&#39; is a subface f of F, and p = sapex(f); the other parameters are   //</span>
<a name="l25394"></a>25394 <span class="comment">// working lists which are empty at the beginning and the end.               //</span>
<a name="l25395"></a>25395 <span class="comment">//                                                                           //</span>
<a name="l25396"></a>25396 <span class="comment">// &#39;optflag&#39; is used for mesh optimization. If it is set, after removing p,  //</span>
<a name="l25397"></a>25397 <span class="comment">// test the object function on each new tet, queue bad tets.                 //</span>
<a name="l25398"></a>25398 <span class="comment">//                                                                           //</span>
<a name="l25400"></a>25400 <span class="comment"></span>
<a name="l25401"></a>25401 <span class="keywordtype">bool</span> tetgenmesh::suppressfacetpoint(face* supsh, list* frontlist,
<a name="l25402"></a>25402   list* misfrontlist, list* ptlist, list* conlist, <a class="code" href="structmemorypool.html">memorypool</a>* viri,
<a name="l25403"></a>25403   queue* flipque, <span class="keywordtype">bool</span> noreloc, <span class="keywordtype">bool</span> optflag)
<a name="l25404"></a>25404 {
<a name="l25405"></a>25405   list *oldtetlist[2], *newtetlist[2];
<a name="l25406"></a>25406   list *oldshlist, *newshlist;
<a name="l25407"></a>25407   triface oldtet, newtet;
<a name="l25408"></a>25408   face oldsh, newsh;
<a name="l25409"></a>25409   point suppt, newpt[2];
<a name="l25410"></a>25410   point *cons;
<a name="l25411"></a>25411   REAL norm[3];
<a name="l25412"></a>25412   <span class="keywordtype">bool</span> success;
<a name="l25413"></a>25413   <span class="keywordtype">int</span> shmark;
<a name="l25414"></a>25414   <span class="keywordtype">int</span> i, j;
<a name="l25415"></a>25415 
<a name="l25416"></a>25416   suppt = sapex(*supsh);
<a name="l25417"></a>25417   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l25418"></a>25418     printf(<span class="stringliteral">&quot;    Suppress point %d in facet.\n&quot;</span>, pointmark(suppt));
<a name="l25419"></a>25419   }
<a name="l25420"></a>25420 
<a name="l25421"></a>25421   <span class="comment">// Initialize working lists, variables.</span>
<a name="l25422"></a>25422   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l25423"></a>25423     oldtetlist[i] = (list *) NULL;
<a name="l25424"></a>25424     newtetlist[i] = (list *) NULL;
<a name="l25425"></a>25425     newpt[i] = (point) NULL;
<a name="l25426"></a>25426   }
<a name="l25427"></a>25427   oldshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l25428"></a>25428   newshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l25429"></a>25429   success = <span class="keyword">true</span>; <span class="comment">// Assume p can be suppressed.</span>
<a name="l25430"></a>25430 
<a name="l25431"></a>25431   <span class="comment">// Find subs of C(p).</span>
<a name="l25432"></a>25432   oldshlist-&gt;append(supsh);
<a name="l25433"></a>25433   formstarpolygon(suppt, oldshlist, ptlist);
<a name="l25434"></a>25434   <span class="comment">// Get the edges of C(p). They form a closed polygon.</span>
<a name="l25435"></a>25435   <span class="keywordflow">for</span> (i = 0; i &lt; oldshlist-&gt;len(); i++) {
<a name="l25436"></a>25436     oldsh = * (face *)(* oldshlist)[i];
<a name="l25437"></a>25437     cons = (point *) conlist-&gt;append(NULL);
<a name="l25438"></a>25438     cons[0] = sorg(oldsh);
<a name="l25439"></a>25439     cons[1] = sdest(oldsh);
<a name="l25440"></a>25440   }
<a name="l25441"></a>25441   <span class="comment">// Re-triangulate the old C(p).</span>
<a name="l25442"></a>25442   shmark = shellmark(*supsh);
<a name="l25443"></a>25443   triangulate(shmark, b-&gt;epsilon, ptlist, conlist, 0, NULL, viri, flipque);
<a name="l25444"></a>25444   <span class="comment">// Get new subs of C(p), remove protected segments.</span>
<a name="l25445"></a>25445   retrievenewsubs(newshlist, <span class="keyword">true</span>);
<a name="l25446"></a>25446   <span class="comment">// Substitute the old C(p) with the new C(p)</span>
<a name="l25447"></a>25447   replacepolygonsubs(oldshlist, newshlist);
<a name="l25448"></a>25448   <span class="comment">// Clear work lists.</span>
<a name="l25449"></a>25449   ptlist-&gt;clear();
<a name="l25450"></a>25450   conlist-&gt;clear();
<a name="l25451"></a>25451   flipque-&gt;clear();
<a name="l25452"></a>25452   viri-&gt;restart();
<a name="l25453"></a>25453 
<a name="l25454"></a>25454   <span class="comment">// B(p) (tets with p as a vertex) has been separated into two parts</span>
<a name="l25455"></a>25455   <span class="comment">//   (B_0(p) and B_1(p)) by F. Process them individually.</span>
<a name="l25456"></a>25456   <span class="keywordflow">for</span> (i = 0; i &lt; 2 &amp;&amp; success; i++) {
<a name="l25457"></a>25457     <span class="keywordflow">if</span> (i == 1) sesymself(*supsh);
<a name="l25458"></a>25458     <span class="comment">// Get a tet containing p.</span>
<a name="l25459"></a>25459     stpivot(*supsh, oldtet);
<a name="l25460"></a>25460     <span class="comment">// Is this part empty?</span>
<a name="l25461"></a>25461     <span class="keywordflow">if</span> (oldtet.tet == dummytet) <span class="keywordflow">continue</span>;
<a name="l25462"></a>25462     <span class="comment">// Allocate spaces for storing (old and new) B_i(p).</span>
<a name="l25463"></a>25463     oldtetlist[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l25464"></a>25464     newtetlist[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l25465"></a>25465     <span class="comment">// Form old B_i(p) in oldtetlist[i].</span>
<a name="l25466"></a>25466     assert(!isdead(&amp;oldtet));
<a name="l25467"></a>25467     oldtetlist[i]-&gt;append(&amp;oldtet);
<a name="l25468"></a>25468     formstarpolyhedron(suppt, oldtetlist[i], ptlist, <span class="keyword">false</span>);
<a name="l25469"></a>25469     <span class="comment">// Infect the tets in old B_i(p) (they&#39;re going to be delete).</span>
<a name="l25470"></a>25470     <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist[i]-&gt;len(); j++) {
<a name="l25471"></a>25471       oldtet = * (triface *)(* (oldtetlist[i]))[j];
<a name="l25472"></a>25472       infect(oldtet);
<a name="l25473"></a>25473     }
<a name="l25474"></a>25474     <span class="comment">// Preparation for re-tetrahedralzing old B_i(p).</span>
<a name="l25475"></a>25475     orientnewsubs(newshlist, supsh, norm);
<a name="l25476"></a>25476     <span class="comment">// Tetrahedralize old B_i(p).</span>
<a name="l25477"></a>25477     success = constrainedcavity(&amp;oldtet, newshlist, oldtetlist[i], ptlist,
<a name="l25478"></a>25478                 frontlist, misfrontlist, newtetlist[i], flipque);
<a name="l25479"></a>25479     <span class="comment">// If p is not suppressed, do relocation if &#39;noreloc&#39; is not set.</span>
<a name="l25480"></a>25480     <span class="keywordflow">if</span> (!success &amp;&amp; !noreloc) {
<a name="l25481"></a>25481       <span class="comment">// Try to relocate p into the old B_i(p).</span>
<a name="l25482"></a>25482       makepoint(&amp;(newpt[i]));
<a name="l25483"></a>25483       success = findrelocatepoint(suppt, newpt[i], norm, frontlist,
<a name="l25484"></a>25484                                   oldtetlist[i]);
<a name="l25485"></a>25485       <span class="comment">// Initialize newpt = suppt.</span>
<a name="l25486"></a>25486       <span class="comment">// for (j = 0; j &lt; 3; j++) newpt[i][j] = suppt[j];</span>
<a name="l25487"></a>25487       <span class="comment">// success = smoothvolpoint(newpt[i], frontlist, true);</span>
<a name="l25488"></a>25488       <span class="keywordflow">if</span> (success) {
<a name="l25489"></a>25489         <span class="comment">// p is relocated by newpt[i]. Now insert it. Don&#39;t do flip since</span>
<a name="l25490"></a>25490         <span class="comment">//   the new tets may get deleted again.</span>
<a name="l25491"></a>25491         relocatepoint(newpt[i], &amp;oldtet, frontlist, newtetlist[i], NULL);
<a name="l25492"></a>25492         setpointtype(newpt[i], FREEVOLVERTEX);
<a name="l25493"></a>25493         relverts++;
<a name="l25494"></a>25494       } <span class="keywordflow">else</span> {
<a name="l25495"></a>25495         <span class="comment">// Fail to relocate p. Clean fake tets and quit this option.</span>
<a name="l25496"></a>25496         deallocfaketets(frontlist);
<a name="l25497"></a>25497         pointdealloc(newpt[i]);
<a name="l25498"></a>25498         newpt[i] = (point) NULL;
<a name="l25499"></a>25499         assert(newtetlist[i]-&gt;len() == 0);
<a name="l25500"></a>25500       }
<a name="l25501"></a>25501     }
<a name="l25502"></a>25502     <span class="keywordflow">if</span> (!success &amp;&amp; noreloc) {
<a name="l25503"></a>25503       <span class="comment">// Failed and no point relocation. Clean fake tets.</span>
<a name="l25504"></a>25504       deallocfaketets(frontlist);
<a name="l25505"></a>25505     }
<a name="l25506"></a>25506     <span class="comment">// Clear work lists.</span>
<a name="l25507"></a>25507     ptlist-&gt;clear();
<a name="l25508"></a>25508     frontlist-&gt;clear();
<a name="l25509"></a>25509     misfrontlist-&gt;clear();
<a name="l25510"></a>25510     flipque-&gt;clear();
<a name="l25511"></a>25511   }
<a name="l25512"></a>25512 
<a name="l25513"></a>25513   <span class="keywordflow">if</span> (success) {
<a name="l25514"></a>25514     <span class="comment">// p has been removed! (Still in the pool).</span>
<a name="l25515"></a>25515     setpointtype(suppt, UNUSEDVERTEX);
<a name="l25516"></a>25516     unuverts++;
<a name="l25517"></a>25517     <span class="comment">// Delete old C(p).</span>
<a name="l25518"></a>25518     <span class="keywordflow">for</span> (i = 0; i &lt; oldshlist-&gt;len(); i++) {
<a name="l25519"></a>25519       oldsh = * (face *)(* oldshlist)[i];
<a name="l25520"></a>25520       <span class="keywordflow">if</span> (i == 0) {
<a name="l25521"></a>25521         <span class="comment">// Update the &#39;hullsize&#39; if C(p) is on the hull.</span>
<a name="l25522"></a>25522         stpivot(oldsh, oldtet);
<a name="l25523"></a>25523         <span class="keywordflow">if</span> (oldtet.tet != dummytet) {
<a name="l25524"></a>25524           sesymself(oldsh);
<a name="l25525"></a>25525           stpivot(oldsh, oldtet);
<a name="l25526"></a>25526         }
<a name="l25527"></a>25527         <span class="keywordflow">if</span> (oldtet.tet == dummytet) {
<a name="l25528"></a>25528           <span class="comment">// A boundary face. Update the &#39;hullsize&#39;.</span>
<a name="l25529"></a>25529           j = oldshlist-&gt;len() - newshlist-&gt;len();
<a name="l25530"></a>25530           assert(j &gt; 0);
<a name="l25531"></a>25531           hullsize -= j;
<a name="l25532"></a>25532         }
<a name="l25533"></a>25533       }
<a name="l25534"></a>25534       shellfacedealloc(subfaces, oldsh.sh);
<a name="l25535"></a>25535     }
<a name="l25536"></a>25536     <span class="comment">// Delete old B_i(p).</span>
<a name="l25537"></a>25537     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l25538"></a>25538       <span class="keywordflow">if</span> (oldtetlist[i] != (list *) NULL) {
<a name="l25539"></a>25539         <span class="comment">// Delete tets of the old B_i(p).</span>
<a name="l25540"></a>25540         <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist[i]-&gt;len(); j++) {
<a name="l25541"></a>25541           oldtet = * (triface *)(* (oldtetlist[i]))[j];
<a name="l25542"></a>25542           assert(!isdead(&amp;oldtet));
<a name="l25543"></a>25543           tetrahedrondealloc(oldtet.tet);
<a name="l25544"></a>25544         }
<a name="l25545"></a>25545       }
<a name="l25546"></a>25546     }
<a name="l25547"></a>25547     <span class="keywordflow">if</span> (optflag) {
<a name="l25548"></a>25548       <span class="comment">// Check for new bad-quality tets.</span>
<a name="l25549"></a>25549       <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l25550"></a>25550         <span class="keywordflow">if</span> (newtetlist[i] != (list *) NULL) {
<a name="l25551"></a>25551           <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist[i]-&gt;len(); j++) {
<a name="l25552"></a>25552             newtet = * (triface *)(* (newtetlist[i]))[j];
<a name="l25553"></a>25553             <span class="keywordflow">if</span> (!isdead(&amp;newtet)) checktet4opt(&amp;newtet, <span class="keyword">true</span>);
<a name="l25554"></a>25554           }
<a name="l25555"></a>25555         }
<a name="l25556"></a>25556       }
<a name="l25557"></a>25557     }
<a name="l25558"></a>25558   } <span class="keywordflow">else</span> {
<a name="l25559"></a>25559     <span class="comment">// p is not suppressed. Recover the original state.</span>
<a name="l25560"></a>25560     unsupverts++;
<a name="l25561"></a>25561     <span class="comment">// Restore the old C(p).</span>
<a name="l25562"></a>25562     replacepolygonsubs(newshlist, oldshlist);
<a name="l25563"></a>25563     <span class="comment">// Delete subs of the new C(p)</span>
<a name="l25564"></a>25564     <span class="keywordflow">for</span> (i = 0; i &lt; newshlist-&gt;len(); i++) {
<a name="l25565"></a>25565       newsh = * (face *)(* newshlist)[i];
<a name="l25566"></a>25566       shellfacedealloc(subfaces, newsh.sh);
<a name="l25567"></a>25567     }
<a name="l25568"></a>25568     <span class="comment">// Restore old B_i(p).</span>
<a name="l25569"></a>25569     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l25570"></a>25570       <span class="keywordflow">if</span> (oldtetlist[i] != (list *) NULL) {
<a name="l25571"></a>25571         <span class="comment">// Uninfect tets of old B_i(p).</span>
<a name="l25572"></a>25572         <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist[i]-&gt;len(); j++) {
<a name="l25573"></a>25573           oldtet = * (triface *)(* (oldtetlist[i]))[j];
<a name="l25574"></a>25574           assert(infected(oldtet));
<a name="l25575"></a>25575           uninfect(oldtet);
<a name="l25576"></a>25576         }
<a name="l25577"></a>25577         <span class="comment">// Has it been re-meshed?</span>
<a name="l25578"></a>25578         <span class="keywordflow">if</span> (newtetlist[i]-&gt;len() &gt; 0) {
<a name="l25579"></a>25579           <span class="comment">// Restore the old B_i(p).</span>
<a name="l25580"></a>25580           restorepolyhedron(oldtetlist[i]);
<a name="l25581"></a>25581           <span class="comment">// Delete tets of the new B_i(p);</span>
<a name="l25582"></a>25582           <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist[i]-&gt;len(); j++) {
<a name="l25583"></a>25583             newtet = * (triface *)(* (newtetlist[i]))[j];
<a name="l25584"></a>25584             <span class="comment">// Some new tets may already be deleted (by carvecavity()).</span>
<a name="l25585"></a>25585             <span class="keywordflow">if</span> (!isdead(&amp;newtet)) {
<a name="l25586"></a>25586               tetrahedrondealloc(newtet.tet);
<a name="l25587"></a>25587             }
<a name="l25588"></a>25588           }
<a name="l25589"></a>25589         }
<a name="l25590"></a>25590         <span class="comment">// Dealloc newpt[i] if it exists.</span>
<a name="l25591"></a>25591         <span class="keywordflow">if</span> (newpt[i] != (point) NULL) {
<a name="l25592"></a>25592           pointdealloc(newpt[i]);
<a name="l25593"></a>25593           relverts--;
<a name="l25594"></a>25594         }
<a name="l25595"></a>25595       }
<a name="l25596"></a>25596     }
<a name="l25597"></a>25597   }
<a name="l25598"></a>25598 
<a name="l25599"></a>25599   <span class="comment">// Delete work lists.</span>
<a name="l25600"></a>25600   <span class="keyword">delete</span> oldshlist;
<a name="l25601"></a>25601   <span class="keyword">delete</span> newshlist;
<a name="l25602"></a>25602   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l25603"></a>25603     <span class="keywordflow">if</span> (oldtetlist[i] != (list *) NULL) {
<a name="l25604"></a>25604       <span class="keyword">delete</span> oldtetlist[i];
<a name="l25605"></a>25605       <span class="keyword">delete</span> newtetlist[i];
<a name="l25606"></a>25606     }
<a name="l25607"></a>25607   }
<a name="l25608"></a>25608 
<a name="l25609"></a>25609   <span class="keywordflow">return</span> success;
<a name="l25610"></a>25610 }
<a name="l25611"></a>25611 
<a name="l25613"></a>25613 <span class="comment">//                                                                           //</span>
<a name="l25614"></a>25614 <span class="comment">// suppresssegpoint()    Suppress a point on a segment.                      //</span>
<a name="l25615"></a>25615 <span class="comment">//                                                                           //</span>
<a name="l25616"></a>25616 <span class="comment">// The point p on a segment S will be suppressed from S by either being      //</span>
<a name="l25617"></a>25617 <span class="comment">// deleted from the mesh or being relocated into the volume.                 //</span>
<a name="l25618"></a>25618 <span class="comment">//                                                                           //</span>
<a name="l25619"></a>25619 <span class="comment">// &#39;supseg&#39; is the segment S, and p = sdest(S); the other parameters are     //</span>
<a name="l25620"></a>25620 <span class="comment">// working lists which are empty at the beginning and the end.               //</span>
<a name="l25621"></a>25621 <span class="comment">//                                                                           //</span>
<a name="l25623"></a>25623 <span class="comment"></span>
<a name="l25624"></a>25624 <span class="keywordtype">bool</span> tetgenmesh::suppresssegpoint(face* supseg, list* spinshlist,
<a name="l25625"></a>25625   list* newsegshlist, list* frontlist, list* misfrontlist, list* ptlist,
<a name="l25626"></a>25626   list* conlist, <a class="code" href="structmemorypool.html">memorypool</a>* viri, queue* flipque, <span class="keywordtype">bool</span> noreloc, <span class="keywordtype">bool</span> optflag)
<a name="l25627"></a>25627 {
<a name="l25628"></a>25628   list **oldtetlist, **newtetlist;
<a name="l25629"></a>25629   list **oldshlist, **newshlist;
<a name="l25630"></a>25630   list *pnewshlist, *dnewshlist;
<a name="l25631"></a>25631   triface oldtet, newtet;
<a name="l25632"></a>25632   face oldsh, newsh;
<a name="l25633"></a>25633   face startsh, spinsh, segsh1, segsh2;
<a name="l25634"></a>25634   face nsupseg, newseg, prevseg, nextseg;
<a name="l25635"></a>25635   point suppt, *newpt;
<a name="l25636"></a>25636   point pa, pb, *cons;
<a name="l25637"></a>25637   REAL pnorm[2][3], norm[3];
<a name="l25638"></a>25638   <span class="keywordtype">bool</span> success;
<a name="l25639"></a>25639   <span class="keywordtype">int</span> shmark;
<a name="l25640"></a>25640   <span class="keywordtype">int</span> n, i, j, k;
<a name="l25641"></a>25641 
<a name="l25642"></a>25642   <span class="comment">// Get the Steiner point p.</span>
<a name="l25643"></a>25643   assert(supseg-&gt;shver &lt; 2);
<a name="l25644"></a>25644   suppt = sdest(*supseg);
<a name="l25645"></a>25645   <span class="comment">// Find the segment ab split by p.</span>
<a name="l25646"></a>25646   senext(*supseg, nsupseg);
<a name="l25647"></a>25647   spivotself(nsupseg);
<a name="l25648"></a>25648   assert(nsupseg.sh != dummysh);
<a name="l25649"></a>25649   nsupseg.shver = 0;
<a name="l25650"></a>25650   <span class="keywordflow">if</span> (sorg(nsupseg) != suppt) sesymself(nsupseg);
<a name="l25651"></a>25651   assert(sorg(nsupseg) == suppt);
<a name="l25652"></a>25652   pa = sorg(*supseg);
<a name="l25653"></a>25653   pb = sdest(nsupseg);
<a name="l25654"></a>25654   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l25655"></a>25655     printf(<span class="stringliteral">&quot;    Remove point %d on segment (%d, %d).\n&quot;</span>,
<a name="l25656"></a>25656            pointmark(suppt), pointmark(pa), pointmark(pb));
<a name="l25657"></a>25657   }
<a name="l25658"></a>25658 
<a name="l25659"></a>25659   <span class="comment">// Let startsh s containing p.</span>
<a name="l25660"></a>25660   spivot(*supseg, startsh);
<a name="l25661"></a>25661   spinsh = startsh;
<a name="l25662"></a>25662   <span class="keywordflow">do</span> {
<a name="l25663"></a>25663     <span class="comment">// Save it in list.</span>
<a name="l25664"></a>25664     spinshlist-&gt;append(&amp;spinsh);
<a name="l25665"></a>25665     <span class="comment">// Go to the next facet.</span>
<a name="l25666"></a>25666     spivotself(spinsh);
<a name="l25667"></a>25667   } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l25668"></a>25668   <span class="keywordflow">if</span> (spinshlist-&gt;len() == 1) {
<a name="l25669"></a>25669     <span class="comment">// This case has not handled yet.</span>
<a name="l25670"></a>25670     <span class="comment">// printf(&quot;Unhandled case: segment only belongs to one facet.\n&quot;);</span>
<a name="l25671"></a>25671     spinshlist-&gt;clear();
<a name="l25672"></a>25672     unsupverts++;
<a name="l25673"></a>25673     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l25674"></a>25674   }
<a name="l25675"></a>25675 
<a name="l25676"></a>25676   <span class="comment">// Suppose ab is shared by n facets (n &gt; 1), then there are n B(p) (tets</span>
<a name="l25677"></a>25677   <span class="comment">//   with p as a vertex). Some B(p) may be empty, eg, outside.</span>
<a name="l25678"></a>25678   n = spinshlist-&gt;len();
<a name="l25679"></a>25679   oldtetlist = <span class="keyword">new</span> list*[n];
<a name="l25680"></a>25680   newtetlist = <span class="keyword">new</span> list*[n];
<a name="l25681"></a>25681   oldshlist = <span class="keyword">new</span> list*[n];
<a name="l25682"></a>25682   newshlist = <span class="keyword">new</span> list*[n];
<a name="l25683"></a>25683   newpt = <span class="keyword">new</span> point[n];
<a name="l25684"></a>25684   <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l25685"></a>25685     oldtetlist[i] = (list *) NULL;
<a name="l25686"></a>25686     newtetlist[i] = (list *) NULL;
<a name="l25687"></a>25687     oldshlist[i] = (list *) NULL;
<a name="l25688"></a>25688     newshlist[i] = (list *) NULL;
<a name="l25689"></a>25689     newpt[i] = (point) NULL;
<a name="l25690"></a>25690   }
<a name="l25691"></a>25691 
<a name="l25692"></a>25692   <span class="comment">// Create a new segment ab (result in newseg).</span>
<a name="l25693"></a>25693   makeshellface(subsegs, &amp;newseg);
<a name="l25694"></a>25694   setsorg(newseg, pa);
<a name="l25695"></a>25695   setsdest(newseg, pb);
<a name="l25696"></a>25696   <span class="comment">// ab gets the same mark and segment type as ap.</span>
<a name="l25697"></a>25697   setshellmark(newseg, shellmark(*supseg));
<a name="l25698"></a>25698   setshelltype(newseg, shelltype(*supseg));
<a name="l25699"></a>25699   <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; varconstraint) {
<a name="l25700"></a>25700     <span class="comment">// Copy the areabound into the new subsegment.</span>
<a name="l25701"></a>25701     setareabound(newseg, areabound(*supseg));
<a name="l25702"></a>25702   }
<a name="l25703"></a>25703   <span class="comment">// Save the old connection at a.</span>
<a name="l25704"></a>25704   senext2(*supseg, prevseg);
<a name="l25705"></a>25705   spivotself(prevseg);
<a name="l25706"></a>25706   <span class="keywordflow">if</span> (prevseg.sh != dummysh) {
<a name="l25707"></a>25707     prevseg.shver = 0;
<a name="l25708"></a>25708     <span class="keywordflow">if</span> (sdest(prevseg) != pa) sesymself(prevseg);
<a name="l25709"></a>25709     assert(sdest(prevseg) == pa);
<a name="l25710"></a>25710     senextself(prevseg);
<a name="l25711"></a>25711     senext2self(newseg);
<a name="l25712"></a>25712     sbond(newseg, prevseg);
<a name="l25713"></a>25713     newseg.shver = 0;
<a name="l25714"></a>25714   }
<a name="l25715"></a>25715   <span class="comment">// Save the old connection at b.</span>
<a name="l25716"></a>25716   senext(nsupseg, nextseg);
<a name="l25717"></a>25717   spivotself(nextseg);
<a name="l25718"></a>25718   <span class="keywordflow">if</span> (nextseg.sh != dummysh) {
<a name="l25719"></a>25719     nextseg.shver = 0;
<a name="l25720"></a>25720     <span class="keywordflow">if</span> (sorg(nextseg) != pb) sesymself(nextseg);
<a name="l25721"></a>25721     assert(sorg(nextseg) == pb);
<a name="l25722"></a>25722     senext2self(nextseg);
<a name="l25723"></a>25723     senextself(newseg);
<a name="l25724"></a>25724     sbond(newseg, nextseg);
<a name="l25725"></a>25725     newseg.shver = 0;
<a name="l25726"></a>25726   }
<a name="l25727"></a>25727 
<a name="l25728"></a>25728   <span class="comment">// Re-triangulate C(p) (subs with p as a vertex) to remove p.</span>
<a name="l25729"></a>25729   <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len(); i++) {
<a name="l25730"></a>25730     spinsh = * (face *)(* spinshlist)[i];
<a name="l25731"></a>25731     <span class="comment">// Allocate spaces for C_i(p).</span>
<a name="l25732"></a>25732     oldshlist[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l25733"></a>25733     newshlist[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l25734"></a>25734     <span class="comment">// Get the subs of C_i(p).</span>
<a name="l25735"></a>25735     oldshlist[i]-&gt;append(&amp;spinsh);
<a name="l25736"></a>25736     formstarpolygon(suppt, oldshlist[i], ptlist);
<a name="l25737"></a>25737     <span class="comment">// Find the edges of C_i(p). It DOES NOT form a closed polygon.</span>
<a name="l25738"></a>25738     <span class="keywordflow">for</span> (j = 0; j &lt; oldshlist[i]-&gt;len(); j++) {
<a name="l25739"></a>25739       oldsh = * (face *)(* (oldshlist[i]))[j];
<a name="l25740"></a>25740       cons = (point *) conlist-&gt;append(NULL);
<a name="l25741"></a>25741       cons[0] = sorg(oldsh);
<a name="l25742"></a>25742       cons[1] = sdest(oldsh);
<a name="l25743"></a>25743     }
<a name="l25744"></a>25744     <span class="comment">// The C_i(p) isn&#39;t closed without ab. Add it to it.</span>
<a name="l25745"></a>25745     cons = (point *) conlist-&gt;append(NULL);
<a name="l25746"></a>25746     cons[0] = pa;
<a name="l25747"></a>25747     cons[1] = pb;
<a name="l25748"></a>25748     <span class="comment">// Re-triangulate C_i(p).</span>
<a name="l25749"></a>25749     shmark = shellmark(spinsh);
<a name="l25750"></a>25750     triangulate(shmark, b-&gt;epsilon, ptlist, conlist, 0, NULL, viri, flipque);
<a name="l25751"></a>25751     <span class="comment">// Get new subs of C_i(p), remove protected segments.</span>
<a name="l25752"></a>25752     retrievenewsubs(newshlist[i], <span class="keyword">true</span>);
<a name="l25753"></a>25753     <span class="comment">// Substitute old C_i(p) with the new C_i(p). !IT IS NOT COMPLETE!</span>
<a name="l25754"></a>25754     replacepolygonsubs(oldshlist[i], newshlist[i]);
<a name="l25755"></a>25755     <span class="comment">// Find the new subface s having edge ab.</span>
<a name="l25756"></a>25756     <span class="keywordflow">for</span> (j = 0; j &lt; newshlist[i]-&gt;len(); j++) {
<a name="l25757"></a>25757       segsh1 = * (face *)(* (newshlist[i]))[j];
<a name="l25758"></a>25758       <span class="keywordflow">for</span> (k = 0; k &lt; 3; k++) {
<a name="l25759"></a>25759         <span class="keywordflow">if</span> (((sorg(segsh1) == pa) &amp;&amp; (sdest(segsh1) == pb)) ||
<a name="l25760"></a>25760             ((sorg(segsh1) == pb) &amp;&amp; (sdest(segsh1) == pa))) <span class="keywordflow">break</span>;
<a name="l25761"></a>25761         senextself(segsh1);
<a name="l25762"></a>25762       }
<a name="l25763"></a>25763       <span class="keywordflow">if</span> (k &lt; 3) <span class="keywordflow">break</span>; <span class="comment">// Found.</span>
<a name="l25764"></a>25764     }
<a name="l25765"></a>25765     assert(j &lt; newshlist[i]-&gt;len()); <span class="comment">// ab must exist.</span>
<a name="l25766"></a>25766     <span class="comment">// Bond s and ab together. The C_i(p) is completedly substituted.</span>
<a name="l25767"></a>25767     ssbond(segsh1, newseg);
<a name="l25768"></a>25768     <span class="comment">// Save s for forming the face ring of ab.</span>
<a name="l25769"></a>25769     newsegshlist-&gt;append(&amp;segsh1);
<a name="l25770"></a>25770     <span class="comment">// Clear work lists.</span>
<a name="l25771"></a>25771     ptlist-&gt;clear();
<a name="l25772"></a>25772     conlist-&gt;clear();
<a name="l25773"></a>25773     flipque-&gt;clear();
<a name="l25774"></a>25774     viri-&gt;restart();
<a name="l25775"></a>25775   }
<a name="l25776"></a>25776   <span class="comment">// Form the face ring of ab.</span>
<a name="l25777"></a>25777   <span class="keywordflow">for</span> (i = 0; i &lt; newsegshlist-&gt;len(); i++) {
<a name="l25778"></a>25778     segsh1 = * (face *)(* newsegshlist)[i];
<a name="l25779"></a>25779     <span class="keywordflow">if</span> ((i + 1) == newsegshlist-&gt;len()) {
<a name="l25780"></a>25780       segsh2 = * (face *)(* newsegshlist)[0];
<a name="l25781"></a>25781     } <span class="keywordflow">else</span> {
<a name="l25782"></a>25782       segsh2 = * (face *)(* newsegshlist)[i + 1];
<a name="l25783"></a>25783     }
<a name="l25784"></a>25784     sbond1(segsh1, segsh2);
<a name="l25785"></a>25785   }
<a name="l25786"></a>25786 
<a name="l25787"></a>25787   <span class="comment">// A work list for keeping subfaces from two facets.</span>
<a name="l25788"></a>25788   dnewshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l25789"></a>25789   success = <span class="keyword">true</span>; <span class="comment">// Assume p is suppressable.</span>
<a name="l25790"></a>25790 
<a name="l25791"></a>25791   <span class="comment">// Suppress p in all B(p). B_i(p) is looped wrt the right-hand rule of ab.</span>
<a name="l25792"></a>25792   <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len() &amp;&amp; success; i++) {
<a name="l25793"></a>25793     <span class="comment">// Get an old  subface s (ap) of a facet.</span>
<a name="l25794"></a>25794     spinsh = * (face *)(* spinshlist)[i];
<a name="l25795"></a>25795     <span class="comment">// Let the edge direction of s be a-&gt;b. Hence all subfaces follow</span>
<a name="l25796"></a>25796     <span class="comment">//   the right-hand rule of ab.</span>
<a name="l25797"></a>25797     <span class="keywordflow">if</span> (sorg(spinsh) != pa) sesymself(spinsh);
<a name="l25798"></a>25798     <span class="comment">// Get a tet t of B_i(p).</span>
<a name="l25799"></a>25799     stpivot(spinsh, oldtet);
<a name="l25800"></a>25800     <span class="comment">// Is B_i(p) empty?</span>
<a name="l25801"></a>25801     <span class="keywordflow">if</span> (oldtet.tet == dummytet) <span class="keywordflow">continue</span>;
<a name="l25802"></a>25802     <span class="comment">// Allocate spaces for B_i(p).</span>
<a name="l25803"></a>25803     oldtetlist[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l25804"></a>25804     newtetlist[i] = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l25805"></a>25805     <span class="comment">// Find all tets of old B_i(p).</span>
<a name="l25806"></a>25806     oldtetlist[i]-&gt;append(&amp;oldtet);
<a name="l25807"></a>25807     formstarpolyhedron(suppt, oldtetlist[i], ptlist, <span class="keyword">false</span>);
<a name="l25808"></a>25808     <span class="comment">// Infect tets of old B_i(p) (they&#39;re going to be deleted).</span>
<a name="l25809"></a>25809     <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist[i]-&gt;len(); j++) {
<a name="l25810"></a>25810       oldtet = * (triface *)(* (oldtetlist[i]))[j];
<a name="l25811"></a>25811       infect(oldtet);
<a name="l25812"></a>25812     }
<a name="l25813"></a>25813     <span class="comment">// Collect new subfaces (of two facets) bounded B_i(p).</span>
<a name="l25814"></a>25814     <span class="keywordflow">for</span> (k = 0; k &lt; 2; k++) {
<a name="l25815"></a>25815       <span class="keywordflow">if</span> ((i + k) &lt; spinshlist-&gt;len()) {
<a name="l25816"></a>25816         pnewshlist = newshlist[i + k];
<a name="l25817"></a>25817         segsh1 = * (face *)(* spinshlist)[i + k];
<a name="l25818"></a>25818       } <span class="keywordflow">else</span> {
<a name="l25819"></a>25819         pnewshlist = newshlist[0];
<a name="l25820"></a>25820         segsh1 = * (face *)(* spinshlist)[0];
<a name="l25821"></a>25821       }
<a name="l25822"></a>25822       <span class="comment">// Adjust the orientation of segsh1 to face to the inside of C.</span>
<a name="l25823"></a>25823       <span class="keywordflow">if</span> (k == 0) {
<a name="l25824"></a>25824         <span class="keywordflow">if</span> (sorg(segsh1) != pa) sesymself(segsh1);
<a name="l25825"></a>25825         assert(sorg(segsh1) == pa);
<a name="l25826"></a>25826       } <span class="keywordflow">else</span> {
<a name="l25827"></a>25827         <span class="keywordflow">if</span> (sdest(segsh1) != pa) sesymself(segsh1);
<a name="l25828"></a>25828         assert(sdest(segsh1) == pa);
<a name="l25829"></a>25829       }
<a name="l25830"></a>25830       <span class="comment">// Preparation for re-tetrahedralzing old B_i(p).</span>
<a name="l25831"></a>25831       orientnewsubs(pnewshlist, &amp;segsh1, pnorm[k]);
<a name="l25832"></a>25832       <span class="keywordflow">for</span> (j = 0; j &lt; pnewshlist-&gt;len(); j++) {
<a name="l25833"></a>25833         dnewshlist-&gt;append((face *)(* pnewshlist)[j]);
<a name="l25834"></a>25834       }
<a name="l25835"></a>25835     }
<a name="l25836"></a>25836     <span class="comment">// Tetrahedralize B_i(p).</span>
<a name="l25837"></a>25837     success = constrainedcavity(&amp;oldtet, dnewshlist, oldtetlist[i], ptlist,
<a name="l25838"></a>25838                 frontlist, misfrontlist, newtetlist[i], flipque);
<a name="l25839"></a>25839     <span class="keywordflow">if</span> (!success &amp;&amp; !noreloc) {
<a name="l25840"></a>25840       <span class="comment">// C must be finished by re-locating the steiner point.</span>
<a name="l25841"></a>25841       makepoint(&amp;(newpt[i]));
<a name="l25842"></a>25842       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) norm[j] = 0.5 * (pnorm[0][j] + pnorm[1][j]);
<a name="l25843"></a>25843       success = findrelocatepoint(suppt, newpt[i], norm, frontlist,
<a name="l25844"></a>25844                                   oldtetlist[i]);
<a name="l25845"></a>25845       <span class="comment">// for (j = 0; j &lt; 3; j++) newpt[i][j] = suppt[j];</span>
<a name="l25846"></a>25846       <span class="comment">// success = smoothvolpoint(newpt[i], frontlist, true);</span>
<a name="l25847"></a>25847       <span class="keywordflow">if</span> (success) {
<a name="l25848"></a>25848         <span class="comment">// p is relocated by newpt[i]. Now insert it. Don&#39;t do flip since</span>
<a name="l25849"></a>25849         <span class="comment">//   the new tets may get deleted again.</span>
<a name="l25850"></a>25850         relocatepoint(newpt[i], &amp;oldtet, frontlist, newtetlist[i], NULL);
<a name="l25851"></a>25851         setpointtype(newpt[i], FREEVOLVERTEX);
<a name="l25852"></a>25852         relverts++;
<a name="l25853"></a>25853       } <span class="keywordflow">else</span> {
<a name="l25854"></a>25854         <span class="comment">// Fail to relocate p. Clean fake tets and quit this option.</span>
<a name="l25855"></a>25855         deallocfaketets(frontlist);
<a name="l25856"></a>25856         pointdealloc(newpt[i]);
<a name="l25857"></a>25857         newpt[i] = (point) NULL;
<a name="l25858"></a>25858         assert(newtetlist[i]-&gt;len() == 0);
<a name="l25859"></a>25859       }
<a name="l25860"></a>25860     }
<a name="l25861"></a>25861     <span class="keywordflow">if</span> (!success &amp;&amp; noreloc) {
<a name="l25862"></a>25862       <span class="comment">// Failed and no point relocation. Clean fake tets.</span>
<a name="l25863"></a>25863       deallocfaketets(frontlist);
<a name="l25864"></a>25864     }
<a name="l25865"></a>25865     <span class="comment">// Clear work lists.</span>
<a name="l25866"></a>25866     dnewshlist-&gt;clear();
<a name="l25867"></a>25867     ptlist-&gt;clear();
<a name="l25868"></a>25868     frontlist-&gt;clear();
<a name="l25869"></a>25869     misfrontlist-&gt;clear();
<a name="l25870"></a>25870     flipque-&gt;clear();
<a name="l25871"></a>25871   }
<a name="l25872"></a>25872 
<a name="l25873"></a>25873   <span class="keywordflow">if</span> (success) {
<a name="l25874"></a>25874     <span class="comment">// p has been suppressed. (Still in the pool).</span>
<a name="l25875"></a>25875     setpointtype(suppt, UNUSEDVERTEX);
<a name="l25876"></a>25876     unuverts++;
<a name="l25877"></a>25877     <span class="comment">// Update the segmnet pointers saved in a and b.</span>
<a name="l25878"></a>25878     setpoint2sh(pa, sencode(newseg));
<a name="l25879"></a>25879     setpoint2sh(pb, sencode(newseg));
<a name="l25880"></a>25880     <span class="comment">// Delete old segments ap, pb.</span>
<a name="l25881"></a>25881     shellfacedealloc(subsegs, supseg-&gt;sh);
<a name="l25882"></a>25882     shellfacedealloc(subsegs, nsupseg.sh);
<a name="l25883"></a>25883     <span class="comment">// Delete subs of old C_i(p).</span>
<a name="l25884"></a>25884     <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len(); i++) {
<a name="l25885"></a>25885       <span class="keywordflow">for</span> (j = 0; j &lt; oldshlist[i]-&gt;len(); j++) {
<a name="l25886"></a>25886         oldsh = * (face *)(* (oldshlist[i]))[j];
<a name="l25887"></a>25887         <span class="keywordflow">if</span> (j == 0) {
<a name="l25888"></a>25888           <span class="comment">// Update &#39;hullsize&#39; if C_i(p) is on the hull.</span>
<a name="l25889"></a>25889           stpivot(oldsh, oldtet);
<a name="l25890"></a>25890           <span class="keywordflow">if</span> (oldtet.tet != dummytet) {
<a name="l25891"></a>25891             sesymself(oldsh);
<a name="l25892"></a>25892             stpivot(oldsh, oldtet);
<a name="l25893"></a>25893           }
<a name="l25894"></a>25894           <span class="keywordflow">if</span> (oldtet.tet == dummytet) {
<a name="l25895"></a>25895             <span class="comment">// Update &#39;hullsize&#39;.</span>
<a name="l25896"></a>25896             k = oldshlist[i]-&gt;len() - newshlist[i]-&gt;len();
<a name="l25897"></a>25897             assert(k &gt; 0);
<a name="l25898"></a>25898             hullsize -= k;
<a name="l25899"></a>25899           }
<a name="l25900"></a>25900         }
<a name="l25901"></a>25901         shellfacedealloc(subfaces, oldsh.sh);
<a name="l25902"></a>25902       }
<a name="l25903"></a>25903     }
<a name="l25904"></a>25904     <span class="comment">// Delete tets old B_i(p).</span>
<a name="l25905"></a>25905     <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len(); i++) {
<a name="l25906"></a>25906       <span class="comment">// Delete them if it is not empty.</span>
<a name="l25907"></a>25907       <span class="keywordflow">if</span> (oldtetlist[i] != (list *) NULL) {
<a name="l25908"></a>25908         <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist[i]-&gt;len(); j++) {
<a name="l25909"></a>25909           oldtet = * (triface *)(* (oldtetlist[i]))[j];
<a name="l25910"></a>25910           assert(!isdead(&amp;oldtet));
<a name="l25911"></a>25911           tetrahedrondealloc(oldtet.tet);
<a name="l25912"></a>25912         }
<a name="l25913"></a>25913       }
<a name="l25914"></a>25914     }
<a name="l25915"></a>25915     <span class="keywordflow">if</span> (optflag) {
<a name="l25916"></a>25916       <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len(); i++) {
<a name="l25917"></a>25917         <span class="comment">// Check for new bad-quality tets.</span>
<a name="l25918"></a>25918         <span class="keywordflow">if</span> (newtetlist[i] != (list *) NULL) {
<a name="l25919"></a>25919           <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist[i]-&gt;len(); j++) {
<a name="l25920"></a>25920             newtet = * (triface *)(* (newtetlist[i]))[j];
<a name="l25921"></a>25921             <span class="keywordflow">if</span> (!isdead(&amp;newtet)) checktet4opt(&amp;newtet, <span class="keyword">true</span>);
<a name="l25922"></a>25922           }
<a name="l25923"></a>25923         }
<a name="l25924"></a>25924       }
<a name="l25925"></a>25925     }
<a name="l25926"></a>25926   } <span class="keywordflow">else</span> {
<a name="l25927"></a>25927     <span class="comment">// p is not suppressed. Recover the original state.</span>
<a name="l25928"></a>25928     unsupverts++;
<a name="l25929"></a>25929     <span class="comment">// Restore old connection at a.</span>
<a name="l25930"></a>25930     senext2(*supseg, prevseg);
<a name="l25931"></a>25931     spivotself(prevseg);
<a name="l25932"></a>25932     <span class="keywordflow">if</span> (prevseg.sh != dummysh) {
<a name="l25933"></a>25933       prevseg.shver = 0;
<a name="l25934"></a>25934       <span class="keywordflow">if</span> (sdest(prevseg) != pa) sesymself(prevseg);
<a name="l25935"></a>25935       assert(sdest(prevseg) == pa);
<a name="l25936"></a>25936       senextself(prevseg);
<a name="l25937"></a>25937       senext2self(*supseg);
<a name="l25938"></a>25938       sbond(*supseg, prevseg);
<a name="l25939"></a>25939       senextself(*supseg); <span class="comment">// Restore original state.</span>
<a name="l25940"></a>25940       assert(supseg-&gt;shver &lt; 2);
<a name="l25941"></a>25941     }
<a name="l25942"></a>25942     <span class="comment">// Restore old connection at b.</span>
<a name="l25943"></a>25943     senext(nsupseg, nextseg);
<a name="l25944"></a>25944     spivotself(nextseg);
<a name="l25945"></a>25945     <span class="keywordflow">if</span> (nextseg.sh != dummysh) {
<a name="l25946"></a>25946       nextseg.shver = 0;
<a name="l25947"></a>25947       <span class="keywordflow">if</span> (sorg(nextseg) != pb) sesymself(nextseg);
<a name="l25948"></a>25948       assert(sorg(nextseg) == pb);
<a name="l25949"></a>25949       senext2self(nextseg);
<a name="l25950"></a>25950       senextself(nsupseg);
<a name="l25951"></a>25951       sbond(nsupseg, nextseg);
<a name="l25952"></a>25952       <span class="comment">// nsupseg.shver = 0;</span>
<a name="l25953"></a>25953       senext2self(nsupseg); <span class="comment">// Restore original state</span>
<a name="l25954"></a>25954       assert(nsupseg.shver &lt; 2);
<a name="l25955"></a>25955     }
<a name="l25956"></a>25956     <span class="comment">// Delete the new segment ab.</span>
<a name="l25957"></a>25957     shellfacedealloc(subsegs, newseg.sh);
<a name="l25958"></a>25958     <span class="comment">// Restore old C_i(p).</span>
<a name="l25959"></a>25959     <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len(); i++) {
<a name="l25960"></a>25960       replacepolygonsubs(newshlist[i], oldshlist[i]);
<a name="l25961"></a>25961       <span class="comment">// Delete subs of the new C_i(p)</span>
<a name="l25962"></a>25962       <span class="keywordflow">for</span> (j = 0; j &lt; newshlist[i]-&gt;len(); j++) {
<a name="l25963"></a>25963         newsh = * (face *)(* (newshlist[i]))[j];
<a name="l25964"></a>25964         shellfacedealloc(subfaces, newsh.sh);
<a name="l25965"></a>25965       }
<a name="l25966"></a>25966     }
<a name="l25967"></a>25967     <span class="comment">// Restore old B_i(p).</span>
<a name="l25968"></a>25968     <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len(); i++) {
<a name="l25969"></a>25969       <span class="keywordflow">if</span> (oldtetlist[i] != (list *) NULL) {
<a name="l25970"></a>25970         <span class="comment">// Uninfect tets of old B_i(p).</span>
<a name="l25971"></a>25971         <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist[i]-&gt;len(); j++) {
<a name="l25972"></a>25972           oldtet = * (triface *)(* (oldtetlist[i]))[j];
<a name="l25973"></a>25973           assert(infected(oldtet));
<a name="l25974"></a>25974           uninfect(oldtet);
<a name="l25975"></a>25975         }
<a name="l25976"></a>25976         <span class="comment">// Has it been re-meshed?</span>
<a name="l25977"></a>25977         <span class="keywordflow">if</span> (newtetlist[i]-&gt;len() &gt; 0) {
<a name="l25978"></a>25978           <span class="comment">// Restore the old B_i(p).</span>
<a name="l25979"></a>25979           restorepolyhedron(oldtetlist[i]);
<a name="l25980"></a>25980           <span class="comment">// Delete tets of the new B_i(p);</span>
<a name="l25981"></a>25981           <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist[i]-&gt;len(); j++) {
<a name="l25982"></a>25982             newtet = * (triface *)(* (newtetlist[i]))[j];
<a name="l25983"></a>25983             <span class="comment">// Some new tets may already be deleted (by carvecavity()).</span>
<a name="l25984"></a>25984             <span class="keywordflow">if</span> (!isdead(&amp;newtet)) {
<a name="l25985"></a>25985               tetrahedrondealloc(newtet.tet);
<a name="l25986"></a>25986             }
<a name="l25987"></a>25987           }
<a name="l25988"></a>25988         }
<a name="l25989"></a>25989         <span class="comment">// Dealloc newpt[i] if it exists.</span>
<a name="l25990"></a>25990         <span class="keywordflow">if</span> (newpt[i] != (point) NULL) {
<a name="l25991"></a>25991           pointdealloc(newpt[i]);
<a name="l25992"></a>25992           relverts--;
<a name="l25993"></a>25993         }
<a name="l25994"></a>25994       }
<a name="l25995"></a>25995     }
<a name="l25996"></a>25996   }
<a name="l25997"></a>25997 
<a name="l25998"></a>25998   <span class="comment">// Delete work lists.</span>
<a name="l25999"></a>25999   <span class="keyword">delete</span> dnewshlist;
<a name="l26000"></a>26000   <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len(); i++) {
<a name="l26001"></a>26001     <span class="keyword">delete</span> oldshlist[i];
<a name="l26002"></a>26002     <span class="keyword">delete</span> newshlist[i];
<a name="l26003"></a>26003   }
<a name="l26004"></a>26004   <span class="keyword">delete</span> [] oldshlist;
<a name="l26005"></a>26005   <span class="keyword">delete</span> [] newshlist;
<a name="l26006"></a>26006   <span class="keywordflow">for</span> (i = 0; i &lt; spinshlist-&gt;len(); i++) {
<a name="l26007"></a>26007     <span class="keywordflow">if</span> (oldtetlist[i] != (list *) NULL) {
<a name="l26008"></a>26008       <span class="keyword">delete</span> oldtetlist[i];
<a name="l26009"></a>26009       <span class="keyword">delete</span> newtetlist[i];
<a name="l26010"></a>26010     }
<a name="l26011"></a>26011   }
<a name="l26012"></a>26012   <span class="keyword">delete</span> [] oldtetlist;
<a name="l26013"></a>26013   <span class="keyword">delete</span> [] newtetlist;
<a name="l26014"></a>26014   <span class="comment">// Clear work lists.</span>
<a name="l26015"></a>26015   newsegshlist-&gt;clear();
<a name="l26016"></a>26016   spinshlist-&gt;clear();
<a name="l26017"></a>26017 
<a name="l26018"></a>26018   <span class="keywordflow">return</span> success;
<a name="l26019"></a>26019 }
<a name="l26020"></a>26020 
<a name="l26022"></a>26022 <span class="comment">//                                                                           //</span>
<a name="l26023"></a>26023 <span class="comment">// suppressvolpoint()    Suppress a point inside mesh.                       //</span>
<a name="l26024"></a>26024 <span class="comment">//                                                                           //</span>
<a name="l26025"></a>26025 <span class="comment">// The point p = org(suptet) is inside the mesh and will be suppressed from  //</span>
<a name="l26026"></a>26026 <span class="comment">// the mesh. Note that p may not be suppressed.                              //</span>
<a name="l26027"></a>26027 <span class="comment">//                                                                           //</span>
<a name="l26028"></a>26028 <span class="comment">// &#39;optflag&#39; is used for mesh optimization. If it is set, after removing p,  //</span>
<a name="l26029"></a>26029 <span class="comment">// test the object function on each new tet, queue bad tets.                 //</span>
<a name="l26030"></a>26030 <span class="comment">//                                                                           //</span>
<a name="l26032"></a>26032 <span class="comment"></span>
<a name="l26033"></a>26033 <span class="keywordtype">bool</span> tetgenmesh::suppressvolpoint(triface* suptet, list* frontlist,
<a name="l26034"></a>26034   list* misfrontlist, list* ptlist, queue* flipque, <span class="keywordtype">bool</span> optflag)
<a name="l26035"></a>26035 {
<a name="l26036"></a>26036   list *myfrontlist, *mymisfrontlist, *myptlist;
<a name="l26037"></a>26037   list *oldtetlist, *newtetlist;
<a name="l26038"></a>26038   list *newshlist; <span class="comment">// a dummy list.</span>
<a name="l26039"></a>26039   queue *myflipque;
<a name="l26040"></a>26040   triface oldtet, newtet;
<a name="l26041"></a>26041   point suppt, conpt;
<a name="l26042"></a>26042   <span class="keywordtype">bool</span> success;
<a name="l26043"></a>26043   <span class="keywordtype">int</span> j;
<a name="l26044"></a>26044 
<a name="l26045"></a>26045   <span class="comment">// Allocate spaces for storing (old and new) B(p).</span>
<a name="l26046"></a>26046   oldtetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l26047"></a>26047   newtetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l26048"></a>26048   newshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l26049"></a>26049   <span class="comment">// Allocate work lists if user doesn&#39;t supply them.</span>
<a name="l26050"></a>26050   myfrontlist = mymisfrontlist = myptlist = (list *) NULL;
<a name="l26051"></a>26051   myflipque = (queue *) NULL;
<a name="l26052"></a>26052   <span class="keywordflow">if</span> (frontlist == (list *) NULL) {
<a name="l26053"></a>26053     myfrontlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l26054"></a>26054     frontlist = myfrontlist;
<a name="l26055"></a>26055     mymisfrontlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l26056"></a>26056     misfrontlist = mymisfrontlist;
<a name="l26057"></a>26057     myptlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL, 256);
<a name="l26058"></a>26058     ptlist = myptlist;
<a name="l26059"></a>26059     myflipque = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l26060"></a>26060     flipque = myflipque;
<a name="l26061"></a>26061   }
<a name="l26062"></a>26062 
<a name="l26063"></a>26063   suppt = org(*suptet);
<a name="l26064"></a>26064   oldtet = *suptet;
<a name="l26065"></a>26065   success = <span class="keyword">true</span>; <span class="comment">// Assume p can be suppressed.</span>
<a name="l26066"></a>26066 
<a name="l26067"></a>26067   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l26068"></a>26068     printf(<span class="stringliteral">&quot;    Remove point %d in mesh.\n&quot;</span>, pointmark(suppt));
<a name="l26069"></a>26069   }
<a name="l26070"></a>26070 
<a name="l26071"></a>26071   <span class="comment">// Form old B(p) in oldtetlist.</span>
<a name="l26072"></a>26072   oldtetlist-&gt;append(&amp;oldtet);
<a name="l26073"></a>26073   formstarpolyhedron(suppt, oldtetlist, ptlist, <span class="keyword">false</span>);
<a name="l26074"></a>26074   <span class="comment">// Infect the tets in old B(p) (they&#39;re going to be delete).</span>
<a name="l26075"></a>26075   <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist-&gt;len(); j++) {
<a name="l26076"></a>26076     oldtet = * (triface *)(* oldtetlist)[j];
<a name="l26077"></a>26077     infect(oldtet);
<a name="l26078"></a>26078   }
<a name="l26079"></a>26079   <span class="comment">// Tetrahedralize old B(p).</span>
<a name="l26080"></a>26080   success = constrainedcavity(&amp;oldtet, newshlist, oldtetlist, ptlist,
<a name="l26081"></a>26081               frontlist, misfrontlist, newtetlist, flipque);
<a name="l26082"></a>26082   <span class="keywordflow">if</span> (!success) {
<a name="l26083"></a>26083     <span class="comment">// Unable to suppress p.</span>
<a name="l26084"></a>26084     deallocfaketets(frontlist);
<a name="l26085"></a>26085     <span class="comment">// Try to collapse an edge at p.</span>
<a name="l26086"></a>26086     conpt = (point) NULL;
<a name="l26087"></a>26087     assert(newtetlist-&gt;len() == 0);
<a name="l26088"></a>26088     <span class="keywordflow">if</span> (findcollapseedge(suppt, &amp;conpt, oldtetlist, ptlist)) {
<a name="l26089"></a>26089       <span class="comment">// Collapse the edge suppt-&gt;conpt. Re-use newtetlist.</span>
<a name="l26090"></a>26090       collapseedge(suppt, conpt, oldtetlist, newtetlist);
<a name="l26091"></a>26091       <span class="comment">// The oldtetlist contains newtetlist.</span>
<a name="l26092"></a>26092       <span class="keywordflow">if</span> (optflag) {
<a name="l26093"></a>26093         assert(newtetlist-&gt;len() == 0);
<a name="l26094"></a>26094         <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist-&gt;len(); j++) {
<a name="l26095"></a>26095           newtet = * (triface *)(* oldtetlist)[j];
<a name="l26096"></a>26096           newtetlist-&gt;append(&amp;newtet);
<a name="l26097"></a>26097         }
<a name="l26098"></a>26098       }
<a name="l26099"></a>26099       oldtetlist-&gt;clear(); <span class="comment">// Do not delete them.</span>
<a name="l26100"></a>26100       collapverts++;
<a name="l26101"></a>26101       success = <span class="keyword">true</span>;
<a name="l26102"></a>26102     }
<a name="l26103"></a>26103   }
<a name="l26104"></a>26104   <span class="keywordflow">if</span> (success) {
<a name="l26105"></a>26105     <span class="comment">// p has been removed! (Still in the pool).</span>
<a name="l26106"></a>26106     setpointtype(suppt, UNUSEDVERTEX);
<a name="l26107"></a>26107     unuverts++;
<a name="l26108"></a>26108     suprelverts++;
<a name="l26109"></a>26109     <span class="comment">// Delete old B(p).</span>
<a name="l26110"></a>26110     <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist-&gt;len(); j++) {
<a name="l26111"></a>26111       oldtet = * (triface *)(* oldtetlist)[j];
<a name="l26112"></a>26112       assert(!isdead(&amp;oldtet));
<a name="l26113"></a>26113       tetrahedrondealloc(oldtet.tet);
<a name="l26114"></a>26114     }
<a name="l26115"></a>26115     <span class="keywordflow">if</span> (optflag) {
<a name="l26116"></a>26116       <span class="comment">// Check for new bad tets.</span>
<a name="l26117"></a>26117       <span class="keywordflow">for</span> (j = 0; j &lt; newtetlist-&gt;len(); j++) {
<a name="l26118"></a>26118         newtet = * (triface *)(* newtetlist)[j];
<a name="l26119"></a>26119         <span class="keywordflow">if</span> (!isdead(&amp;newtet)) checktet4opt(&amp;newtet, <span class="keyword">true</span>);
<a name="l26120"></a>26120       }
<a name="l26121"></a>26121     }
<a name="l26122"></a>26122   } <span class="keywordflow">else</span> {
<a name="l26123"></a>26123     <span class="comment">// p is not suppressed. Recover the original state.</span>
<a name="l26124"></a>26124     <span class="comment">// Uninfect tets of old B(p).</span>
<a name="l26125"></a>26125     <span class="keywordflow">for</span> (j = 0; j &lt; oldtetlist-&gt;len(); j++) {
<a name="l26126"></a>26126       oldtet = * (triface *)(* oldtetlist)[j];
<a name="l26127"></a>26127       assert(infected(oldtet));
<a name="l26128"></a>26128       uninfect(oldtet);
<a name="l26129"></a>26129     }
<a name="l26130"></a>26130   }
<a name="l26131"></a>26131 
<a name="l26132"></a>26132   <span class="comment">// Clear work lists.</span>
<a name="l26133"></a>26133   ptlist-&gt;clear();
<a name="l26134"></a>26134   frontlist-&gt;clear();
<a name="l26135"></a>26135   misfrontlist-&gt;clear();
<a name="l26136"></a>26136   flipque-&gt;clear();
<a name="l26137"></a>26137   <span class="comment">// Deallocate work lists.</span>
<a name="l26138"></a>26138   <span class="keywordflow">if</span> (myfrontlist != (list *) NULL) {
<a name="l26139"></a>26139     <span class="keyword">delete</span> myfrontlist;
<a name="l26140"></a>26140     <span class="keyword">delete</span> mymisfrontlist;
<a name="l26141"></a>26141     <span class="keyword">delete</span> myptlist;
<a name="l26142"></a>26142     <span class="keyword">delete</span> myflipque;
<a name="l26143"></a>26143   }
<a name="l26144"></a>26144   <span class="keyword">delete</span> oldtetlist;
<a name="l26145"></a>26145   <span class="keyword">delete</span> newtetlist;
<a name="l26146"></a>26146   <span class="keyword">delete</span> newshlist;
<a name="l26147"></a>26147 
<a name="l26148"></a>26148   <span class="keywordflow">return</span> success;
<a name="l26149"></a>26149 }
<a name="l26150"></a>26150 
<a name="l26152"></a>26152 <span class="comment">//                                                                           //</span>
<a name="l26153"></a>26153 <span class="comment">// smoothpoint()    Smooth a volume/segment point.                           //</span>
<a name="l26154"></a>26154 <span class="comment">//                                                                           //</span>
<a name="l26155"></a>26155 <span class="comment">// &#39;smthpt&#39; (p) is inside the polyhedron (C) bounded by faces in &#39;starlist&#39;. //</span>
<a name="l26156"></a>26156 <span class="comment">// This routine moves p inside C until an object function is maximized.      //</span>
<a name="l26157"></a>26157 <span class="comment">//                                                                           //</span>
<a name="l26158"></a>26158 <span class="comment">// Default, the CCW edge ring of the faces on C points to p. If &#39;invtori&#39; is //</span>
<a name="l26159"></a>26159 <span class="comment">// TRUE, the orientation is inversed.                                        //</span>
<a name="l26160"></a>26160 <span class="comment">//                                                                           //</span>
<a name="l26161"></a>26161 <span class="comment">// If &#39;key&#39; != NULL, it contains an object value to be improved. Current it  //</span>
<a name="l26162"></a>26162 <span class="comment">// means the cosine of the largest dihedral angle. In such case, the point   //</span>
<a name="l26163"></a>26163 <span class="comment">// is smoothed only if the final configuration improves the object value, it //</span>
<a name="l26164"></a>26164 <span class="comment">// is returned by the &#39;key&#39;.                                                 //</span>
<a name="l26165"></a>26165 <span class="comment">//                                                                           //</span>
<a name="l26167"></a>26167 <span class="comment"></span>
<a name="l26168"></a>26168 <span class="keywordtype">bool</span> tetgenmesh::smoothpoint(point smthpt, point e1, point e2, list *starlist,
<a name="l26169"></a>26169   <span class="keywordtype">bool</span> invtori, REAL *key)
<a name="l26170"></a>26170 {
<a name="l26171"></a>26171   triface starttet;
<a name="l26172"></a>26172   point pa, pb, pc;
<a name="l26173"></a>26173   REAL fcent[3], startpt[3], nextpt[3], bestpt[3];
<a name="l26174"></a>26174   REAL iniTmax, oldTmax, newTmax;
<a name="l26175"></a>26175   REAL ori, aspT, aspTmax, imprate;
<a name="l26176"></a>26176   REAL cosd, maxcosd;
<a name="l26177"></a>26177   <span class="keywordtype">bool</span> segflag, randflag; <span class="comment">//, subflag;</span>
<a name="l26178"></a>26178   <span class="keywordtype">int</span> numdirs;
<a name="l26179"></a>26179   <span class="keywordtype">int</span> iter, i, j;
<a name="l26180"></a>26180 
<a name="l26181"></a>26181   <span class="comment">// Is p a segment vertex?</span>
<a name="l26182"></a>26182   segflag = (e1 != (point) NULL);
<a name="l26183"></a>26183   <span class="comment">// Decide the number of moving directions.</span>
<a name="l26184"></a>26184   numdirs = segflag ? 2 : starlist-&gt;len();
<a name="l26185"></a>26185   randflag = numdirs &gt; 10;
<a name="l26186"></a>26186   <span class="keywordflow">if</span> (randflag) {
<a name="l26187"></a>26187     numdirs = 10; <span class="comment">// Maximum 10 directions.</span>
<a name="l26188"></a>26188   }
<a name="l26189"></a>26189 
<a name="l26190"></a>26190   aspTmax = 0.0;
<a name="l26191"></a>26191   <span class="comment">// Calculate the initial object value (the largest aspect ratio).</span>
<a name="l26192"></a>26192   <span class="keywordflow">for</span> (i = 0; i &lt; starlist-&gt;len(); i++) {
<a name="l26193"></a>26193     starttet = * (triface *)(* starlist)[i];
<a name="l26194"></a>26194     adjustedgering(starttet, !invtori ? CCW : CW);
<a name="l26195"></a>26195     pa = org(starttet);
<a name="l26196"></a>26196     pb = dest(starttet);
<a name="l26197"></a>26197     pc = apex(starttet);
<a name="l26198"></a>26198     aspT = tetaspectratio(pa, pb, pc, smthpt);
<a name="l26199"></a>26199     <span class="keywordflow">if</span> (i == 0) {
<a name="l26200"></a>26200       aspTmax = aspT;
<a name="l26201"></a>26201     } <span class="keywordflow">else</span> {
<a name="l26202"></a>26202       aspTmax = aspT &gt; aspTmax ? aspT : aspTmax;
<a name="l26203"></a>26203     }
<a name="l26204"></a>26204   }
<a name="l26205"></a>26205   iniTmax = aspTmax;
<a name="l26206"></a>26206 
<a name="l26207"></a>26207   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l26208"></a>26208     printf(<span class="stringliteral">&quot;    Smooth %s point %d (%g, %g, %g).\n&quot;</span>, segflag ? <span class="stringliteral">&quot;seg&quot;</span> : <span class="stringliteral">&quot;vol&quot;</span>,
<a name="l26209"></a>26209            pointmark(smthpt), smthpt[0], smthpt[1], smthpt[2]);
<a name="l26210"></a>26210     printf(<span class="stringliteral">&quot;    Initial max L/h = %g.\n&quot;</span>, iniTmax);
<a name="l26211"></a>26211   }
<a name="l26212"></a>26212   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l26213"></a>26213     bestpt[i] = startpt[i] = smthpt[i];
<a name="l26214"></a>26214   }
<a name="l26215"></a>26215 
<a name="l26216"></a>26216   <span class="comment">// Do iteration until the new aspTmax does not decrease.</span>
<a name="l26217"></a>26217   newTmax = iniTmax;
<a name="l26218"></a>26218   iter = 0;
<a name="l26219"></a>26219   <span class="keywordflow">while</span> (<span class="keyword">true</span>) {
<a name="l26220"></a>26220     <span class="comment">// Find the best next location.</span>
<a name="l26221"></a>26221     oldTmax = newTmax;
<a name="l26222"></a>26222     <span class="keywordflow">for</span> (i = 0; i &lt; numdirs; i++) {
<a name="l26223"></a>26223       <span class="comment">// Calculate the moved point (saved in &#39;nextpt&#39;).</span>
<a name="l26224"></a>26224       <span class="keywordflow">if</span> (!segflag) {
<a name="l26225"></a>26225         <span class="keywordflow">if</span> (randflag) {
<a name="l26226"></a>26226           <span class="comment">// Randomly pick a direction.</span>
<a name="l26227"></a>26227           j = (int) randomnation(starlist-&gt;len());
<a name="l26228"></a>26228         } <span class="keywordflow">else</span> {
<a name="l26229"></a>26229           j = i;
<a name="l26230"></a>26230         }
<a name="l26231"></a>26231         starttet = * (triface *)(* starlist)[j];
<a name="l26232"></a>26232         adjustedgering(starttet, !invtori ? CCW : CW);
<a name="l26233"></a>26233         pa = org(starttet);
<a name="l26234"></a>26234         pb = dest(starttet);
<a name="l26235"></a>26235         pc = apex(starttet);
<a name="l26236"></a>26236         <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l26237"></a>26237           fcent[j] = (pa[j] + pb[j] + pc[j]) / 3.0;
<a name="l26238"></a>26238         }
<a name="l26239"></a>26239       } <span class="keywordflow">else</span> {
<a name="l26240"></a>26240         <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l26241"></a>26241           fcent[j] = (i == 0 ? e1[j] : e2[j]);
<a name="l26242"></a>26242         }
<a name="l26243"></a>26243       }
<a name="l26244"></a>26244       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l26245"></a>26245         nextpt[j] = startpt[j] + 0.01 * (fcent[j] - startpt[j]);
<a name="l26246"></a>26246       }
<a name="l26247"></a>26247       <span class="comment">// Get the largest object value for the new location.</span>
<a name="l26248"></a>26248       <span class="keywordflow">for</span> (j = 0; j &lt; starlist-&gt;len(); j++) {
<a name="l26249"></a>26249         starttet = * (triface *)(* starlist)[j];
<a name="l26250"></a>26250         adjustedgering(starttet, !invtori ? CCW : CW);
<a name="l26251"></a>26251         pa = org(starttet);
<a name="l26252"></a>26252         pb = dest(starttet);
<a name="l26253"></a>26253         pc = apex(starttet);
<a name="l26254"></a>26254         ori = orient3d(pa, pb, pc, nextpt);
<a name="l26255"></a>26255         <span class="keywordflow">if</span> (ori &lt; 0.0) {
<a name="l26256"></a>26256           aspT = tetaspectratio(pa, pb, pc, nextpt);
<a name="l26257"></a>26257           <span class="keywordflow">if</span> (j == 0) {
<a name="l26258"></a>26258             aspTmax = aspT;
<a name="l26259"></a>26259           } <span class="keywordflow">else</span> {
<a name="l26260"></a>26260             aspTmax = aspT &gt; aspTmax ? aspT : aspTmax;
<a name="l26261"></a>26261           }
<a name="l26262"></a>26262         } <span class="keywordflow">else</span> {
<a name="l26263"></a>26263           <span class="comment">// An invalid new tet. Discard this point.</span>
<a name="l26264"></a>26264           aspTmax = newTmax;
<a name="l26265"></a>26265         } <span class="comment">// if (ori &lt; 0.0)</span>
<a name="l26266"></a>26266         <span class="comment">// Stop looping when the object value is bigger than before.</span>
<a name="l26267"></a>26267         <span class="keywordflow">if</span> (aspTmax &gt;= newTmax) <span class="keywordflow">break</span>;
<a name="l26268"></a>26268       } <span class="comment">// for (j = 0; j &lt; starlist-&gt;len(); j++)</span>
<a name="l26269"></a>26269       <span class="keywordflow">if</span> (aspTmax &lt; newTmax) {
<a name="l26270"></a>26270         <span class="comment">// Save the improved object value and the location.</span>
<a name="l26271"></a>26271         newTmax = aspTmax;
<a name="l26272"></a>26272         <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) bestpt[j] = nextpt[j];
<a name="l26273"></a>26273       }
<a name="l26274"></a>26274     } <span class="comment">// for (i = 0; i &lt; starlist-&gt;len(); i++)</span>
<a name="l26275"></a>26275     <span class="comment">// Does the object value improved much?</span>
<a name="l26276"></a>26276     imprate = fabs(oldTmax - newTmax) / oldTmax;
<a name="l26277"></a>26277     <span class="keywordflow">if</span> (imprate &lt; 1e-3) <span class="keywordflow">break</span>;
<a name="l26278"></a>26278     <span class="comment">// Yes, move p to the new location and continue.</span>
<a name="l26279"></a>26279     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) startpt[j] = bestpt[j];
<a name="l26280"></a>26280     iter++;
<a name="l26281"></a>26281   } <span class="comment">// while (true)</span>
<a name="l26282"></a>26282 
<a name="l26283"></a>26283   <span class="keywordflow">if</span> (iter &gt; 0) {
<a name="l26284"></a>26284     <span class="comment">// The point is moved.</span>
<a name="l26285"></a>26285     <span class="keywordflow">if</span> (key) {
<a name="l26286"></a>26286       <span class="comment">// Check if the quality is improved by the smoothed point.</span>
<a name="l26287"></a>26287       maxcosd = 0.0; <span class="comment">// = cos(90).</span>
<a name="l26288"></a>26288       <span class="keywordflow">for</span> (j = 0; j &lt; starlist-&gt;len(); j++) {
<a name="l26289"></a>26289         starttet = * (triface *)(* starlist)[j];
<a name="l26290"></a>26290         adjustedgering(starttet, !invtori ? CCW : CW);
<a name="l26291"></a>26291         pa = org(starttet);
<a name="l26292"></a>26292         pb = dest(starttet);
<a name="l26293"></a>26293         pc = apex(starttet);
<a name="l26294"></a>26294         tetalldihedral(pa, pb, pc, startpt, NULL, &amp;cosd, NULL);
<a name="l26295"></a>26295         <span class="keywordflow">if</span> (cosd &lt; *key) {
<a name="l26296"></a>26296           <span class="comment">// This quality will not be improved. Stop.</span>
<a name="l26297"></a>26297           iter = 0; <span class="keywordflow">break</span>;
<a name="l26298"></a>26298         } <span class="keywordflow">else</span> {
<a name="l26299"></a>26299           <span class="comment">// Remeber the worst quality value (of the new configuration).</span>
<a name="l26300"></a>26300           maxcosd = maxcosd &lt; cosd ? maxcosd : cosd;
<a name="l26301"></a>26301         }
<a name="l26302"></a>26302       }
<a name="l26303"></a>26303       <span class="keywordflow">if</span> (iter &gt; 0) *key = maxcosd;
<a name="l26304"></a>26304     }
<a name="l26305"></a>26305   }
<a name="l26306"></a>26306 
<a name="l26307"></a>26307   <span class="keywordflow">if</span> (iter &gt; 0) {
<a name="l26308"></a>26308     segflag ? smoothsegverts++ : smoothvolverts++;
<a name="l26309"></a>26309     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) smthpt[i] = startpt[i];
<a name="l26310"></a>26310     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l26311"></a>26311       printf(<span class="stringliteral">&quot;    Move to new location (%g, %g, %g).\n&quot;</span>, smthpt[0], smthpt[1],
<a name="l26312"></a>26312              smthpt[2]);
<a name="l26313"></a>26313       printf(<span class="stringliteral">&quot;    Final max L/h = %g. (%d iterations)\n&quot;</span>, newTmax, iter);
<a name="l26314"></a>26314       <span class="keywordflow">if</span> (key) {
<a name="l26315"></a>26315         printf(<span class="stringliteral">&quot;    Max. dihed = %g (degree).\n&quot;</span>, acos(*key) / PI * 180.0);
<a name="l26316"></a>26316       }
<a name="l26317"></a>26317     }
<a name="l26318"></a>26318     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l26319"></a>26319   } <span class="keywordflow">else</span> {
<a name="l26320"></a>26320     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l26321"></a>26321       printf(<span class="stringliteral">&quot;    Not smoothed.\n&quot;</span>);
<a name="l26322"></a>26322     }
<a name="l26323"></a>26323     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l26324"></a>26324   }
<a name="l26325"></a>26325 }
<a name="l26326"></a>26326 
<a name="l26328"></a>26328 <span class="comment">//                                                                           //</span>
<a name="l26329"></a>26329 <span class="comment">// removesteiners()    Delete or relocate Steiner points on facets.          //</span>
<a name="l26330"></a>26330 <span class="comment">//                                                                           //</span>
<a name="l26332"></a>26332 <span class="comment"></span>
<a name="l26333"></a>26333 <span class="keywordtype">void</span> tetgenmesh::removesteiners(<span class="keywordtype">bool</span> coarseflag)
<a name="l26334"></a>26334 {
<a name="l26335"></a>26335   list *frontlist, *misfrontlist;
<a name="l26336"></a>26336   list *spinshlist, *newsegshlist;
<a name="l26337"></a>26337   list *ptlist, *conlist;
<a name="l26338"></a>26338   <a class="code" href="structmemorypool.html">memorypool</a> *viri;
<a name="l26339"></a>26339   queue *flipque;
<a name="l26340"></a>26340   triface checktet;
<a name="l26341"></a>26341   face shloop;
<a name="l26342"></a>26342   face segloop, nextseg;
<a name="l26343"></a>26343   point pa, neipt;
<a name="l26344"></a>26344   REAL len;
<a name="l26345"></a>26345   <span class="keywordtype">bool</span> remflag;
<a name="l26346"></a>26346   <span class="keywordtype">int</span> *worklist;
<a name="l26347"></a>26347   <span class="keywordtype">int</span> oldnum, rmstein;
<a name="l26348"></a>26348   <span class="keywordtype">int</span> i, j;
<a name="l26349"></a>26349 
<a name="l26350"></a>26350   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l26351"></a>26351     <span class="keywordflow">if</span> (!coarseflag) {
<a name="l26352"></a>26352       printf(<span class="stringliteral">&quot;Removing Steiner points.\n&quot;</span>);
<a name="l26353"></a>26353     } <span class="keywordflow">else</span> {
<a name="l26354"></a>26354       printf(<span class="stringliteral">&quot;Coarsening mesh.\n&quot;</span>);
<a name="l26355"></a>26355     }
<a name="l26356"></a>26356   }
<a name="l26357"></a>26357 
<a name="l26358"></a>26358   <span class="comment">// Initialize work lists.</span>
<a name="l26359"></a>26359   frontlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l26360"></a>26360   misfrontlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL);
<a name="l26361"></a>26361   spinshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL);
<a name="l26362"></a>26362   newsegshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL);
<a name="l26363"></a>26363   ptlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL);
<a name="l26364"></a>26364   conlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *) * 2, NULL);
<a name="l26365"></a>26365   flipque = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l26366"></a>26366   viri = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(shellface *), 1024, POINTER, 0);
<a name="l26367"></a>26367   oldnum = unuverts;
<a name="l26368"></a>26368   relverts = suprelverts = collapverts = unsupverts;
<a name="l26369"></a>26369   smoothvolverts = 0;
<a name="l26370"></a>26370   expcavcount = 0;
<a name="l26371"></a>26371 
<a name="l26372"></a>26372   <span class="comment">// Suppress Steiner points inside facets.</span>
<a name="l26373"></a>26373   <span class="keywordflow">do</span> {
<a name="l26374"></a>26374     rmstein = unuverts;
<a name="l26375"></a>26375     subfaces-&gt;traversalinit();
<a name="l26376"></a>26376     shloop.sh = shellfacetraverse(subfaces);
<a name="l26377"></a>26377     <span class="keywordflow">while</span> (shloop.sh != (shellface *) NULL) {
<a name="l26378"></a>26378       remflag = <span class="keyword">false</span>;
<a name="l26379"></a>26379       <span class="comment">// Is s contains a Steiner point?</span>
<a name="l26380"></a>26380       shloop.shver = 0;
<a name="l26381"></a>26381       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l26382"></a>26382         pa = sapex(shloop);
<a name="l26383"></a>26383         <span class="keywordflow">if</span> (pointtype(pa) == FREESUBVERTEX) {
<a name="l26384"></a>26384           <span class="keywordflow">if</span> (!coarseflag) {
<a name="l26385"></a>26385             <span class="comment">// Remove it if it is not an input point.</span>
<a name="l26386"></a>26386             j = pointmark(pa) - in-&gt;firstnumber;
<a name="l26387"></a>26387             <span class="keywordflow">if</span> (j &gt;= in-&gt;numberofpoints) {
<a name="l26388"></a>26388               <span class="keywordflow">if</span> (b-&gt;nobisect == 1) {
<a name="l26389"></a>26389                 <span class="comment">// &#39;-Y&#39;. Remove p if s is a hull face.</span>
<a name="l26390"></a>26390                 stpivot(shloop, checktet);
<a name="l26391"></a>26391                 <span class="keywordflow">if</span> (checktet.tet != dummytet) {
<a name="l26392"></a>26392                   sesymself(shloop);
<a name="l26393"></a>26393                   stpivot(shloop, checktet);
<a name="l26394"></a>26394                 }
<a name="l26395"></a>26395                 remflag = (checktet.tet == dummytet);
<a name="l26396"></a>26396               } <span class="keywordflow">else</span> {
<a name="l26397"></a>26397                 <span class="comment">// &#39;-YY&#39;. Remove p whatever s is a hull face or not.</span>
<a name="l26398"></a>26398                 remflag = <span class="keyword">true</span>;
<a name="l26399"></a>26399               }
<a name="l26400"></a>26400             }
<a name="l26401"></a>26401           } <span class="keywordflow">else</span> {
<a name="l26402"></a>26402             <span class="comment">// Check if this vertex can be coarsed.</span>
<a name="l26403"></a>26403             <span class="keywordflow">if</span> (b-&gt;nobisect == 0) {
<a name="l26404"></a>26404               <span class="comment">// Is a background mesh available?</span>
<a name="l26405"></a>26405               <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l26406"></a>26406                 <span class="comment">// assert(pa[pointmtrindex] &gt; 0.0);</span>
<a name="l26407"></a>26407                 <span class="comment">// Form the star of pa.</span>
<a name="l26408"></a>26408                 spinshlist-&gt;append(&amp;shloop);
<a name="l26409"></a>26409                 formstarpolygon(pa, spinshlist, ptlist);
<a name="l26410"></a>26410                 len = 0.0;
<a name="l26411"></a>26411                 <span class="keywordflow">for</span> (j = 0; j &lt; ptlist-&gt;len(); j++) {
<a name="l26412"></a>26412                   neipt = * (point *)(* ptlist)[j];
<a name="l26413"></a>26413                   len += distance(pa, neipt);
<a name="l26414"></a>26414                 }
<a name="l26415"></a>26415                 len /= ptlist-&gt;len();
<a name="l26416"></a>26416                 <span class="comment">// Carse it if the average edge length is small.</span>
<a name="l26417"></a>26417                 remflag = len &lt; pa[pointmtrindex];
<a name="l26418"></a>26418                 spinshlist-&gt;clear();
<a name="l26419"></a>26419                 ptlist-&gt;clear();
<a name="l26420"></a>26420               } <span class="keywordflow">else</span> {
<a name="l26421"></a>26421                 <span class="comment">// Coarse it if (1) it is an input point and its pointmarker</span>
<a name="l26422"></a>26422                 <span class="comment">//   is zero, or (2) it is a Steiner point.</span>
<a name="l26423"></a>26423                 remflag = <span class="keyword">true</span>;
<a name="l26424"></a>26424                 j = pointmark(pa) - in-&gt;firstnumber;
<a name="l26425"></a>26425                 <span class="keywordflow">if</span> (j &lt; in-&gt;numberofpoints) {
<a name="l26426"></a>26426                   remflag = (in-&gt;pointmarkerlist[j] == 0);
<a name="l26427"></a>26427                 }
<a name="l26428"></a>26428               } <span class="comment">// if (b-&gt;metric)</span>
<a name="l26429"></a>26429             } <span class="comment">// if (b-&gt;nobisect == 0)</span>
<a name="l26430"></a>26430           } <span class="comment">// if (!coarseflag)</span>
<a name="l26431"></a>26431           <span class="keywordflow">if</span> (remflag) <span class="keywordflow">break</span>;
<a name="l26432"></a>26432         } <span class="comment">// if (pointtype(pa) == FREESUBVERTEX)</span>
<a name="l26433"></a>26433         senextself(shloop);
<a name="l26434"></a>26434       } <span class="comment">// for (i = 0; i &lt; 3; i++)</span>
<a name="l26435"></a>26435       <span class="keywordflow">if</span> (remflag) {
<a name="l26436"></a>26436         suppressfacetpoint(&amp;shloop, frontlist, misfrontlist, ptlist, conlist,
<a name="l26437"></a>26437                            viri, flipque, coarseflag, <span class="keyword">false</span>);
<a name="l26438"></a>26438       }
<a name="l26439"></a>26439       shloop.sh = shellfacetraverse(subfaces);
<a name="l26440"></a>26440     }
<a name="l26441"></a>26441     <span class="comment">// Continue if any Steiner point has been removed.</span>
<a name="l26442"></a>26442   } <span class="keywordflow">while</span> (unuverts &gt; rmstein);
<a name="l26443"></a>26443 
<a name="l26444"></a>26444   <span class="keywordflow">if</span> (coarseflag) {
<a name="l26445"></a>26445     shellface **segsperverlist;
<a name="l26446"></a>26446     <span class="keywordtype">int</span> *idx2seglist;
<a name="l26447"></a>26447     face seg1, seg2;
<a name="l26448"></a>26448     point e1, e2;
<a name="l26449"></a>26449     <span class="comment">// Connecting collinear segments. Hence the segment vertices may be</span>
<a name="l26450"></a>26450     <span class="comment">//   removed. In fact, this should be done by reconstructmesh().</span>
<a name="l26451"></a>26451     makesegmentmap(idx2seglist, segsperverlist);
<a name="l26452"></a>26452     subsegs-&gt;traversalinit();
<a name="l26453"></a>26453     segloop.sh = shellfacetraverse(subsegs);
<a name="l26454"></a>26454     <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l26455"></a>26455       <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l26456"></a>26456         segloop.shver = i;
<a name="l26457"></a>26457         senext(segloop, nextseg);
<a name="l26458"></a>26458         spivotself(nextseg);
<a name="l26459"></a>26459         <span class="keywordflow">if</span> ((nextseg.sh == dummysh) || (nextseg.sh &gt; segloop.sh)) {
<a name="l26460"></a>26460           <span class="comment">// No neighbor segment connection or haven&#39;t been processed yet.</span>
<a name="l26461"></a>26461           pa = sdest(segloop);
<a name="l26462"></a>26462           j = pointmark(pa) - in-&gt;firstnumber;
<a name="l26463"></a>26463           <span class="keywordflow">if</span> (idx2seglist[j + 1] - idx2seglist[j] == 2) {
<a name="l26464"></a>26464             <span class="comment">// pa is shared by only two segments. Get the other one.</span>
<a name="l26465"></a>26465             nextseg.sh = segsperverlist[idx2seglist[j]];
<a name="l26466"></a>26466             <span class="keywordflow">if</span> (nextseg.sh == segloop.sh) {
<a name="l26467"></a>26467               nextseg.sh = segsperverlist[idx2seglist[j] + 1];
<a name="l26468"></a>26468             }
<a name="l26469"></a>26469             nextseg.shver = 0;
<a name="l26470"></a>26470             <span class="keywordflow">if</span> (sorg(nextseg) != pa) sesymself(nextseg);
<a name="l26471"></a>26471             <span class="comment">// Check if the two segments are collinear.</span>
<a name="l26472"></a>26472             e1 = sorg(segloop);
<a name="l26473"></a>26473             e2 = sdest(nextseg);
<a name="l26474"></a>26474             <span class="keywordflow">if</span> (iscollinear(e1, pa, e2, b-&gt;epsilon)) {
<a name="l26475"></a>26475               <span class="comment">// Connect the two segments together.</span>
<a name="l26476"></a>26476               <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l26477"></a>26477                 printf(<span class="stringliteral">&quot;  Glue two insegs (%d, %d) at %d.\n&quot;</span>, pointmark(e1),
<a name="l26478"></a>26478                        pointmark(e2), pointmark(pa));
<a name="l26479"></a>26479               }
<a name="l26480"></a>26480               senext(segloop, seg1);
<a name="l26481"></a>26481               senext2(nextseg, seg2);
<a name="l26482"></a>26482               sbond(seg1, seg2);
<a name="l26483"></a>26483             }
<a name="l26484"></a>26484           }
<a name="l26485"></a>26485         } <span class="comment">// if (nextseg.sh == dummysh)</span>
<a name="l26486"></a>26486       } <span class="comment">// for (i = 0;</span>
<a name="l26487"></a>26487       segloop.sh = shellfacetraverse(subsegs);
<a name="l26488"></a>26488     }
<a name="l26489"></a>26489     <span class="keyword">delete</span> [] segsperverlist;
<a name="l26490"></a>26490     <span class="keyword">delete</span> [] idx2seglist;
<a name="l26491"></a>26491   }
<a name="l26492"></a>26492 
<a name="l26493"></a>26493   <span class="comment">// Suppress Steiner points on segments.</span>
<a name="l26494"></a>26494   <span class="keywordflow">do</span> {
<a name="l26495"></a>26495     rmstein = unuverts;
<a name="l26496"></a>26496     subsegs-&gt;traversalinit();
<a name="l26497"></a>26497     segloop.sh = shellfacetraverse(subsegs);
<a name="l26498"></a>26498     <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l26499"></a>26499       remflag = <span class="keyword">false</span>;
<a name="l26500"></a>26500       <span class="comment">// for (i = 0; i &lt; 2; i++) {</span>
<a name="l26501"></a>26501         <span class="comment">// Don&#39;t check the poinytype of pa, it may be a Steiner point but</span>
<a name="l26502"></a>26502         <span class="comment">//   has type NACUTEVERTEX due to splitting a type-3 segment.</span>
<a name="l26503"></a>26503         segloop.shver = 0; <span class="comment">// segloop.shver = i;</span>
<a name="l26504"></a>26504         senext(segloop, nextseg);
<a name="l26505"></a>26505         spivotself(nextseg);
<a name="l26506"></a>26506         <span class="keywordflow">if</span> (nextseg.sh != dummysh) {
<a name="l26507"></a>26507           pa = sdest(segloop); <span class="comment">// p is going to be checked for removal.</span>
<a name="l26508"></a>26508           nextseg.shver = 0;
<a name="l26509"></a>26509           <span class="keywordflow">if</span> (sorg(nextseg) != pa) sesymself(nextseg);
<a name="l26510"></a>26510           assert(sorg(nextseg) == pa);
<a name="l26511"></a>26511           <span class="keywordflow">if</span> (!coarseflag) {
<a name="l26512"></a>26512             <span class="comment">// try to remove it if it is not an input point.</span>
<a name="l26513"></a>26513             j = pointmark(pa) - in-&gt;firstnumber;
<a name="l26514"></a>26514             <span class="keywordflow">if</span> (j &gt;= in-&gt;numberofpoints) {
<a name="l26515"></a>26515               <span class="keywordflow">if</span> (b-&gt;nobisect == 1) {
<a name="l26516"></a>26516                 <span class="comment">// &#39;-Y&#39;. Remove p if it is on the hull.</span>
<a name="l26517"></a>26517                 sstpivot(&amp;segloop, &amp;checktet);
<a name="l26518"></a>26518                 assert(checktet.tet != dummytet);
<a name="l26519"></a>26519                 pa = apex(checktet);
<a name="l26520"></a>26520                 <span class="keywordflow">do</span> {
<a name="l26521"></a>26521                   <span class="keywordflow">if</span> (!fnextself(checktet)) {
<a name="l26522"></a>26522                     <span class="comment">// Meet a boundary face - p is on the hull.</span>
<a name="l26523"></a>26523                     remflag = <span class="keyword">true</span>; <span class="keywordflow">break</span>;
<a name="l26524"></a>26524                   }
<a name="l26525"></a>26525                 } <span class="keywordflow">while</span> (pa != apex(checktet));
<a name="l26526"></a>26526               } <span class="keywordflow">else</span> {
<a name="l26527"></a>26527                 <span class="comment">// &#39;-YY&#39;. Remove p whatever it is on the hull or not.</span>
<a name="l26528"></a>26528                 remflag = <span class="keyword">true</span>;
<a name="l26529"></a>26529               }
<a name="l26530"></a>26530             }
<a name="l26531"></a>26531           } <span class="keywordflow">else</span> {
<a name="l26532"></a>26532             <span class="comment">// Check if this vertex can be coarsed.</span>
<a name="l26533"></a>26533             <span class="keywordflow">if</span> (b-&gt;nobisect == 0) {
<a name="l26534"></a>26534               <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l26535"></a>26535                 <span class="comment">// assert(pa[pointmtrindex] &gt; 0.0);</span>
<a name="l26536"></a>26536                 len = 0.0;
<a name="l26537"></a>26537                 neipt = sorg(segloop);
<a name="l26538"></a>26538                 <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l26539"></a>26539                   len += distance(pa, neipt);
<a name="l26540"></a>26540                   <span class="comment">/*// Is neipt inside the sparse ball of pa?</span>
<a name="l26541"></a>26541 <span class="comment">                  if (len &lt; pa[pointmtrindex]) {</span>
<a name="l26542"></a>26542 <span class="comment">                    // Yes, the local of pa is too dense, corse it.</span>
<a name="l26543"></a>26543 <span class="comment">                    remflag = true; break;</span>
<a name="l26544"></a>26544 <span class="comment">                  } */</span>
<a name="l26545"></a>26545                   neipt = sdest(nextseg);
<a name="l26546"></a>26546                 }
<a name="l26547"></a>26547                 len /= 2.0;
<a name="l26548"></a>26548                 <span class="comment">// Carse it if the average edge lengh is small.</span>
<a name="l26549"></a>26549                 remflag = len &lt; pa[pointmtrindex];
<a name="l26550"></a>26550               } <span class="keywordflow">else</span> {
<a name="l26551"></a>26551                 <span class="comment">// Coarse it if (1) it is an input point and its pointmarker</span>
<a name="l26552"></a>26552                 <span class="comment">//   is zero, or (2) it is a Steiner point.</span>
<a name="l26553"></a>26553                 remflag = <span class="keyword">true</span>;
<a name="l26554"></a>26554                 j = pointmark(pa) - in-&gt;firstnumber;
<a name="l26555"></a>26555                 <span class="keywordflow">if</span> (j &lt; in-&gt;numberofpoints) {
<a name="l26556"></a>26556                   remflag = (in-&gt;pointmarkerlist[j] == 0);
<a name="l26557"></a>26557                 }
<a name="l26558"></a>26558               } <span class="comment">// if (b-&gt;metric)</span>
<a name="l26559"></a>26559             } <span class="comment">// if (b-&gt;nobisect == 0)</span>
<a name="l26560"></a>26560           } <span class="comment">// if (!coarseflag)</span>
<a name="l26561"></a>26561         } <span class="comment">// if (nextseg.sh != dummysh)</span>
<a name="l26562"></a>26562         <span class="comment">// if (remflag) break;</span>
<a name="l26563"></a>26563       <span class="comment">// } // for (i = 0; i &lt; 2; i++)</span>
<a name="l26564"></a>26564       <span class="keywordflow">if</span> (remflag) {
<a name="l26565"></a>26565         suppresssegpoint(&amp;segloop, spinshlist, newsegshlist, frontlist,
<a name="l26566"></a>26566           misfrontlist, ptlist, conlist, viri, flipque, coarseflag, <span class="keyword">false</span>);
<a name="l26567"></a>26567       }
<a name="l26568"></a>26568       segloop.sh = shellfacetraverse(subsegs);
<a name="l26569"></a>26569     }
<a name="l26570"></a>26570     <span class="comment">// Continue if any Steiner point has been removed.</span>
<a name="l26571"></a>26571   } <span class="keywordflow">while</span> (unuverts &gt; rmstein);
<a name="l26572"></a>26572 
<a name="l26573"></a>26573   <span class="keywordflow">if</span> ((relverts &gt; 0) || coarseflag) {
<a name="l26574"></a>26574     worklist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l26575"></a>26575     <span class="comment">// Suppress relocated points &amp; coarse free mesh points.</span>
<a name="l26576"></a>26576     <span class="keywordflow">do</span> {
<a name="l26577"></a>26577       <span class="comment">// Initialize the work list. Each entry of the list counts how many</span>
<a name="l26578"></a>26578       <span class="comment">//   times the point has been processed.</span>
<a name="l26579"></a>26579       <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) worklist[i] = 0;
<a name="l26580"></a>26580       rmstein = unuverts;
<a name="l26581"></a>26581       tetrahedrons-&gt;traversalinit();
<a name="l26582"></a>26582       checktet.tet = tetrahedrontraverse();
<a name="l26583"></a>26583       <span class="keywordflow">while</span> (checktet.tet != (tetrahedron *) NULL) {
<a name="l26584"></a>26584         remflag = <span class="keyword">false</span>;
<a name="l26585"></a>26585         <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l26586"></a>26586           pa = (point) checktet.tet[4 + i];
<a name="l26587"></a>26587           if (pointtype(pa) == FREEVOLVERTEX) {
<a name="l26588"></a>26588             <span class="comment">// NOTE. Chenge the number 3 will change the number n of removed</span>
<a name="l26589"></a>26589             <span class="comment">//   Steiner points. In my test, n is larger when it is 1. 3</span>
<a name="l26590"></a>26590             <span class="comment">//   reduces n in a reasonable way (see example, mech_part,</span>
<a name="l26591"></a>26591             <span class="comment">//   thepart), 5 results a larger n than 3 does. While the best</span>
<a name="l26592"></a>26592             <span class="comment">//   result is no limit of this number, but it makes the code</span>
<a name="l26593"></a>26593             <span class="comment">//   extremely slow.</span>
<a name="l26594"></a>26594             <span class="keywordflow">if</span> (worklist[pointmark(pa)] &lt; 3) {
<a name="l26595"></a>26595               worklist[pointmark(pa)]++;
<a name="l26596"></a>26596               <span class="keywordflow">if</span> (!coarseflag) {
<a name="l26597"></a>26597                 <span class="comment">// Remove p if it is a Steiner point.</span>
<a name="l26598"></a>26598                 <span class="keywordflow">if</span> (pointmark(pa) &gt;= (in-&gt;numberofpoints + in-&gt;firstnumber)) {
<a name="l26599"></a>26599                   remflag = <span class="keyword">true</span>;
<a name="l26600"></a>26600                 }
<a name="l26601"></a>26601               } <span class="keywordflow">else</span> {
<a name="l26602"></a>26602                 <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l26603"></a>26603                   <span class="comment">// assert(pa[pointmtrindex] &gt; 0.0);</span>
<a name="l26604"></a>26604                   <span class="comment">// Form the star of pa.</span>
<a name="l26605"></a>26605                   frontlist-&gt;append(&amp;checktet);
<a name="l26606"></a>26606                   formstarpolyhedron(pa, frontlist, ptlist, <span class="keyword">true</span>);
<a name="l26607"></a>26607                   len = 0.0;
<a name="l26608"></a>26608                   <span class="keywordflow">for</span> (j = 0; j &lt; ptlist-&gt;len(); j++) {
<a name="l26609"></a>26609                     neipt = * (point *)(* ptlist)[j];
<a name="l26610"></a>26610                     len += distance(pa, neipt);
<a name="l26611"></a>26611                   }
<a name="l26612"></a>26612                   len /= ptlist-&gt;len();
<a name="l26613"></a>26613                   <span class="comment">// Carse it if the average edge length is small.</span>
<a name="l26614"></a>26614                   remflag = len &lt; pa[pointmtrindex];
<a name="l26615"></a>26615                   frontlist-&gt;clear();
<a name="l26616"></a>26616                   ptlist-&gt;clear();
<a name="l26617"></a>26617                 } <span class="keywordflow">else</span> {
<a name="l26618"></a>26618                   <span class="comment">// Coarse it if (1) it is an input point and its pointmarker</span>
<a name="l26619"></a>26619                   <span class="comment">//   is zero, or (2) it is a Steiner point.</span>
<a name="l26620"></a>26620                   remflag = <span class="keyword">true</span>;
<a name="l26621"></a>26621                   j = pointmark(pa) - in-&gt;firstnumber;
<a name="l26622"></a>26622                   <span class="keywordflow">if</span> (j &lt; in-&gt;numberofpoints) {
<a name="l26623"></a>26623                     remflag = (in-&gt;pointmarkerlist[j] == 0);
<a name="l26624"></a>26624                   }
<a name="l26625"></a>26625                 } <span class="comment">// if (b-&gt;metric)</span>
<a name="l26626"></a>26626               } <span class="comment">// if (!coarseflag)</span>
<a name="l26627"></a>26627               <span class="keywordflow">if</span> (remflag) <span class="keywordflow">break</span>;
<a name="l26628"></a>26628             } <span class="comment">// if (worklist[pointmark(pa)] == 0)</span>
<a name="l26629"></a>26629           } <span class="comment">// if (pointtype(pa) == FREEVOLVERTEX)</span>
<a name="l26630"></a>26630         } <span class="comment">// for (i = 0; i &lt; 4; i++)</span>
<a name="l26631"></a>26631         <span class="keywordflow">if</span> (remflag) {
<a name="l26632"></a>26632           findorg(&amp;checktet, pa);
<a name="l26633"></a>26633           assert(org(checktet) == pa);
<a name="l26634"></a>26634           suppressvolpoint(&amp;checktet, frontlist, misfrontlist, ptlist, flipque,
<a name="l26635"></a>26635                            <span class="keyword">false</span>);
<a name="l26636"></a>26636         }
<a name="l26637"></a>26637         checktet.tet = tetrahedrontraverse();
<a name="l26638"></a>26638       }
<a name="l26639"></a>26639       <span class="comment">// Continue if any relocated point has been suppressed.</span>
<a name="l26640"></a>26640     } <span class="keywordflow">while</span> (unuverts &gt; rmstein);
<a name="l26641"></a>26641 
<a name="l26642"></a>26642 
<a name="l26643"></a>26643     <span class="comment">// Smooth the unsuppressed points if it is not coarse mesh.</span>
<a name="l26644"></a>26644     <span class="keywordflow">if</span> (!coarseflag &amp;&amp; (relverts &gt; suprelverts)) {
<a name="l26645"></a>26645       <span class="keywordflow">if</span> (b-&gt;verbose) {
<a name="l26646"></a>26646         printf(<span class="stringliteral">&quot;  Smoothing relocated points.\n&quot;</span>);
<a name="l26647"></a>26647       }
<a name="l26648"></a>26648       <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) worklist[i] = 0;
<a name="l26649"></a>26649       tetrahedrons-&gt;traversalinit();
<a name="l26650"></a>26650       checktet.tet = tetrahedrontraverse();
<a name="l26651"></a>26651       <span class="keywordflow">while</span> (checktet.tet != (tetrahedron *) NULL) {
<a name="l26652"></a>26652         <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l26653"></a>26653           pa = (point) checktet.tet[4 + i];
<a name="l26654"></a>26654           if (pointtype(pa) == FREEVOLVERTEX) {
<a name="l26655"></a>26655             <span class="keywordflow">if</span> (worklist[pointmark(pa)] == 0) {
<a name="l26656"></a>26656               worklist[pointmark(pa)] = 1;
<a name="l26657"></a>26657               <span class="keywordflow">if</span> (pointmark(pa) &gt;= (in-&gt;numberofpoints + in-&gt;firstnumber)) {
<a name="l26658"></a>26658                 <span class="comment">// Smooth pa.</span>
<a name="l26659"></a>26659                 findorg(&amp;checktet, pa);
<a name="l26660"></a>26660                 frontlist-&gt;append(&amp;checktet);
<a name="l26661"></a>26661                 formstarpolyhedron(pa, frontlist, NULL, <span class="keyword">false</span>);
<a name="l26662"></a>26662                 smoothpoint(pa, NULL, NULL, frontlist, <span class="keyword">false</span>, NULL);
<a name="l26663"></a>26663                 frontlist-&gt;clear();
<a name="l26664"></a>26664               }
<a name="l26665"></a>26665             } <span class="comment">// if (worklist[pointmark(pa)] == 0)</span>
<a name="l26666"></a>26666           } <span class="comment">// if (pointtype(pa) == FREEVOLVERTEX)</span>
<a name="l26667"></a>26667         } <span class="comment">// for (i = 0; i &lt; 4; i++)</span>
<a name="l26668"></a>26668         checktet.tet = tetrahedrontraverse();
<a name="l26669"></a>26669       }
<a name="l26670"></a>26670     }
<a name="l26671"></a>26671     <span class="keyword">delete</span> [] worklist;
<a name="l26672"></a>26672   }
<a name="l26673"></a>26673 
<a name="l26674"></a>26674   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l26675"></a>26675     <span class="keywordflow">if</span> (!coarseflag) {
<a name="l26676"></a>26676       printf(<span class="stringliteral">&quot;  %d points removed from boundary&quot;</span>, unuverts - oldnum);
<a name="l26677"></a>26677       <span class="keywordflow">if</span> (expcavcount &gt; 0) {
<a name="l26678"></a>26678         printf(<span class="stringliteral">&quot; (%d cavity corrections)&quot;</span>, expcavcount);
<a name="l26679"></a>26679       }
<a name="l26680"></a>26680       printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l26681"></a>26681       <span class="keywordflow">if</span> (relverts &gt; 0) {
<a name="l26682"></a>26682         printf(<span class="stringliteral">&quot;  %d points relocated (%d suppressed, %d collapsed).\n&quot;</span>,
<a name="l26683"></a>26683                relverts, suprelverts - collapverts, collapverts);
<a name="l26684"></a>26684         <span class="keywordflow">if</span> (smoothvolverts &gt; 0) {
<a name="l26685"></a>26685           printf(<span class="stringliteral">&quot;  %d points are smoothed.\n&quot;</span>, smoothvolverts);
<a name="l26686"></a>26686         }
<a name="l26687"></a>26687       }
<a name="l26688"></a>26688       <span class="keywordflow">if</span> (unsupverts &gt; 0) {
<a name="l26689"></a>26689         printf(<span class="stringliteral">&quot;  !! %d points are unsuppressed.\n&quot;</span>, unsupverts);
<a name="l26690"></a>26690       }
<a name="l26691"></a>26691     } <span class="keywordflow">else</span> {
<a name="l26692"></a>26692       printf(<span class="stringliteral">&quot;  %d points are removed.\n&quot;</span>, unuverts - oldnum);
<a name="l26693"></a>26693     }
<a name="l26694"></a>26694   }
<a name="l26695"></a>26695 
<a name="l26696"></a>26696   <span class="comment">// Delete work lists.</span>
<a name="l26697"></a>26697   <span class="keyword">delete</span> frontlist;
<a name="l26698"></a>26698   <span class="keyword">delete</span> misfrontlist;
<a name="l26699"></a>26699   <span class="keyword">delete</span> spinshlist;
<a name="l26700"></a>26700   <span class="keyword">delete</span> newsegshlist;
<a name="l26701"></a>26701   <span class="keyword">delete</span> ptlist;
<a name="l26702"></a>26702   <span class="keyword">delete</span> conlist;
<a name="l26703"></a>26703   <span class="keyword">delete</span> flipque;
<a name="l26704"></a>26704   <span class="keyword">delete</span> viri;
<a name="l26705"></a>26705 }
<a name="l26706"></a>26706 
<a name="l26707"></a>26707 <span class="comment">//</span>
<a name="l26708"></a>26708 <span class="comment">// End of boundary Steiner points removing routines</span>
<a name="l26709"></a>26709 <span class="comment">//</span>
<a name="l26710"></a>26710 
<a name="l26712"></a>26712 <span class="comment">//                                                                           //</span>
<a name="l26713"></a>26713 <span class="comment">// reconstructmesh()    Reconstruct a tetrahedral mesh from a list of        //</span>
<a name="l26714"></a>26714 <span class="comment">//                      tetrahedra and possibly a list of boundary faces.    //</span>
<a name="l26715"></a>26715 <span class="comment">//                                                                           //</span>
<a name="l26716"></a>26716 <span class="comment">// The list of tetrahedra is stored in &#39;in-&gt;tetrahedronlist&#39;,  the list of   //</span>
<a name="l26717"></a>26717 <span class="comment">// boundary faces is stored in &#39;in-&gt;trifacelist&#39;.  The tetrahedral mesh is   //</span>
<a name="l26718"></a>26718 <span class="comment">// reconstructed in memorypool &#39;tetrahedrons&#39;, its boundary faces (subfaces) //</span>
<a name="l26719"></a>26719 <span class="comment">// are reconstructed in &#39;subfaces&#39;, its boundary edges (subsegments) are     //</span>
<a name="l26720"></a>26720 <span class="comment">// reconstructed in &#39;subsegs&#39;. If the -a switch is used, this procedure will //</span>
<a name="l26721"></a>26721 <span class="comment">// also read a list of REALs from &#39;in-&gt;tetrahedronvolumelist&#39; and set a      //</span>
<a name="l26722"></a>26722 <span class="comment">// maximum volume constraint on each tetrahedron.                            //</span>
<a name="l26723"></a>26723 <span class="comment">//                                                                           //</span>
<a name="l26724"></a>26724 <span class="comment">// If the user has provided the boundary faces in &#39;in-&gt;trifacelist&#39;, they    //</span>
<a name="l26725"></a>26725 <span class="comment">// will be inserted the mesh. Otherwise subfaces will be identified from the //</span>
<a name="l26726"></a>26726 <span class="comment">// mesh.  All hull faces (including faces of the internal holes) will be     //</span>
<a name="l26727"></a>26727 <span class="comment">// recognized as subfaces, internal faces between two tetrahedra which have  //</span>
<a name="l26728"></a>26728 <span class="comment">// different attributes will also be recognized as subfaces.                 //</span>
<a name="l26729"></a>26729 <span class="comment">//                                                                           //</span>
<a name="l26730"></a>26730 <span class="comment">// Subsegments will be identified after subfaces are reconstructed. Edges at //</span>
<a name="l26731"></a>26731 <span class="comment">// the intersections of non-coplanar subfaces are recognized as subsegments. //</span>
<a name="l26732"></a>26732 <span class="comment">// Edges between two coplanar subfaces with different boundary markers are   //</span>
<a name="l26733"></a>26733 <span class="comment">// also recognized as subsegments.                                           //</span>
<a name="l26734"></a>26734 <span class="comment">//                                                                           //</span>
<a name="l26735"></a>26735 <span class="comment">// The facet index of each subface will be set automatically after we have   //</span>
<a name="l26736"></a>26736 <span class="comment">// recovered subfaces and subsegments.  That is, the set of subfaces, which  //</span>
<a name="l26737"></a>26737 <span class="comment">// are coplanar and have the same boundary marker will be recognized as a    //</span>
<a name="l26738"></a>26738 <span class="comment">// facet and has a unique index, stored as the facet marker in each subface  //</span>
<a name="l26739"></a>26739 <span class="comment">// of the set, the real boundary marker of each subface will be found in     //</span>
<a name="l26740"></a>26740 <span class="comment">// &#39;in-&gt;facetmarkerlist&#39; by the index.  Facet index will be used in Delaunay //</span>
<a name="l26741"></a>26741 <span class="comment">// refinement for detecting two incident facets.                             //</span>
<a name="l26742"></a>26742 <span class="comment">//                                                                           //</span>
<a name="l26743"></a>26743 <span class="comment">// Points which are not corners of tetrahedra will be inserted into the mesh.//</span>
<a name="l26744"></a>26744 <span class="comment">// Return the number of faces on the hull after the reconstruction.          //</span>
<a name="l26745"></a>26745 <span class="comment">//                                                                           //</span>
<a name="l26747"></a>26747 <span class="comment"></span>
<a name="l26748"></a>26748 <span class="keywordtype">long</span> tetgenmesh::reconstructmesh()
<a name="l26749"></a>26749 {
<a name="l26750"></a>26750   tetrahedron **tetsperverlist;
<a name="l26751"></a>26751   shellface **facesperverlist;
<a name="l26752"></a>26752   triface tetloop, neightet, neineightet, spintet;
<a name="l26753"></a>26753   face subloop, neighsh, neineighsh, subseg;
<a name="l26754"></a>26754   face sface1, sface2;
<a name="l26755"></a>26755   point *idx2verlist;
<a name="l26756"></a>26756   point torg, tdest, tapex, toppo;
<a name="l26757"></a>26757   point norg, ndest, napex;
<a name="l26758"></a>26758   list *neighshlist, *markerlist;
<a name="l26759"></a>26759   REAL sign, attrib, volume;
<a name="l26760"></a>26760   REAL da1, da2;
<a name="l26761"></a>26761   <span class="keywordtype">bool</span> bondflag, insertsegflag;
<a name="l26762"></a>26762   <span class="keywordtype">int</span> *idx2tetlist;
<a name="l26763"></a>26763   <span class="keywordtype">int</span> *idx2facelist;
<a name="l26764"></a>26764   <span class="keywordtype">int</span> *worklist;
<a name="l26765"></a>26765   <span class="keywordtype">int</span> facetidx, marker;
<a name="l26766"></a>26766   <span class="keywordtype">int</span> iorg, idest, iapex, ioppo;
<a name="l26767"></a>26767   <span class="keywordtype">int</span> inorg, indest, inapex;
<a name="l26768"></a>26768   <span class="keywordtype">int</span> index, i, j;
<a name="l26769"></a>26769 
<a name="l26770"></a>26770   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l26771"></a>26771     printf(<span class="stringliteral">&quot;Reconstructing mesh.\n&quot;</span>);
<a name="l26772"></a>26772   }
<a name="l26773"></a>26773 
<a name="l26774"></a>26774   <span class="comment">// Create a map from index to points.</span>
<a name="l26775"></a>26775   makeindex2pointmap(idx2verlist);
<a name="l26776"></a>26776 
<a name="l26777"></a>26777   <span class="comment">// Create the tetrahedra.</span>
<a name="l26778"></a>26778   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftetrahedra; i++) {
<a name="l26779"></a>26779     <span class="comment">// Create a new tetrahedron and set its four corners, make sure that</span>
<a name="l26780"></a>26780     <span class="comment">//   four corners form a positive orientation.</span>
<a name="l26781"></a>26781     maketetrahedron(&amp;tetloop);
<a name="l26782"></a>26782     index = i * in-&gt;numberofcorners;
<a name="l26783"></a>26783     <span class="comment">// Although there may be 10 nodes, we only read the first 4.</span>
<a name="l26784"></a>26784     iorg = in-&gt;tetrahedronlist[index] - in-&gt;firstnumber;
<a name="l26785"></a>26785     idest = in-&gt;tetrahedronlist[index + 1] - in-&gt;firstnumber;
<a name="l26786"></a>26786     iapex = in-&gt;tetrahedronlist[index + 2] - in-&gt;firstnumber;
<a name="l26787"></a>26787     ioppo = in-&gt;tetrahedronlist[index + 3] - in-&gt;firstnumber;
<a name="l26788"></a>26788     torg = idx2verlist[iorg];
<a name="l26789"></a>26789     tdest = idx2verlist[idest];
<a name="l26790"></a>26790     tapex = idx2verlist[iapex];
<a name="l26791"></a>26791     toppo = idx2verlist[ioppo];
<a name="l26792"></a>26792     sign = orient3d(torg, tdest, tapex, toppo);
<a name="l26793"></a>26793     <span class="keywordflow">if</span> (sign &gt; 0.0) {
<a name="l26794"></a>26794       norg = torg; torg = tdest; tdest = norg;
<a name="l26795"></a>26795     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (sign == 0.0) {
<a name="l26796"></a>26796       <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l26797"></a>26797         printf(<span class="stringliteral">&quot;Warning:  Tet %d is degenerate.\n&quot;</span>, i + in-&gt;firstnumber);
<a name="l26798"></a>26798       }
<a name="l26799"></a>26799     }
<a name="l26800"></a>26800     setorg(tetloop, torg);
<a name="l26801"></a>26801     setdest(tetloop, tdest);
<a name="l26802"></a>26802     setapex(tetloop, tapex);
<a name="l26803"></a>26803     setoppo(tetloop, toppo);
<a name="l26804"></a>26804     <span class="comment">// Temporarily set the vertices be type FREEVOLVERTEX, to indicate that</span>
<a name="l26805"></a>26805     <span class="comment">//   they belong to the mesh.  These types may be changed later.</span>
<a name="l26806"></a>26806     setpointtype(torg, FREEVOLVERTEX);
<a name="l26807"></a>26807     setpointtype(tdest, FREEVOLVERTEX);
<a name="l26808"></a>26808     setpointtype(tapex, FREEVOLVERTEX);
<a name="l26809"></a>26809     setpointtype(toppo, FREEVOLVERTEX);
<a name="l26810"></a>26810     <span class="comment">// Set element attributes if they exist.</span>
<a name="l26811"></a>26811     <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberoftetrahedronattributes; j++) {
<a name="l26812"></a>26812       index = i * in-&gt;numberoftetrahedronattributes;
<a name="l26813"></a>26813       attrib = in-&gt;tetrahedronattributelist[index + j];
<a name="l26814"></a>26814       setelemattribute(tetloop.tet, j, attrib);
<a name="l26815"></a>26815     }
<a name="l26816"></a>26816     <span class="comment">// If -a switch is used (with no number follows) Set a volume</span>
<a name="l26817"></a>26817     <span class="comment">//   constraint if it exists.</span>
<a name="l26818"></a>26818     <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l26819"></a>26819       <span class="keywordflow">if</span> (in-&gt;tetrahedronvolumelist != (REAL *) NULL) {
<a name="l26820"></a>26820         volume = in-&gt;tetrahedronvolumelist[i];
<a name="l26821"></a>26821       } <span class="keywordflow">else</span> {
<a name="l26822"></a>26822         volume = -1.0;
<a name="l26823"></a>26823       }
<a name="l26824"></a>26824       setvolumebound(tetloop.tet, volume);
<a name="l26825"></a>26825     }
<a name="l26826"></a>26826   }
<a name="l26827"></a>26827 
<a name="l26828"></a>26828   <span class="comment">// Set the connection between tetrahedra.</span>
<a name="l26829"></a>26829   hullsize = 0l;
<a name="l26830"></a>26830   <span class="comment">// Create a map from nodes to tetrahedra.</span>
<a name="l26831"></a>26831   maketetrahedronmap(idx2tetlist, tetsperverlist);
<a name="l26832"></a>26832   <span class="comment">// Initialize the worklist.</span>
<a name="l26833"></a>26833   worklist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items];
<a name="l26834"></a>26834   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items; i++) worklist[i] = 0;
<a name="l26835"></a>26835 
<a name="l26836"></a>26836   <span class="comment">// Loop all tetrahedra, bond two tetrahedra if they share a common face.</span>
<a name="l26837"></a>26837   tetrahedrons-&gt;traversalinit();
<a name="l26838"></a>26838   tetloop.tet = tetrahedrontraverse();
<a name="l26839"></a>26839   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l26840"></a>26840     <span class="comment">// Loop the four sides of the tetrahedron.</span>
<a name="l26841"></a>26841     <span class="keywordflow">for</span> (tetloop.loc = 0; tetloop.loc &lt; 4; tetloop.loc++) {
<a name="l26842"></a>26842       sym(tetloop, neightet);
<a name="l26843"></a>26843       <span class="keywordflow">if</span> (neightet.tet != dummytet) <span class="keywordflow">continue</span>; <span class="comment">// This side has finished.</span>
<a name="l26844"></a>26844       torg = org(tetloop);
<a name="l26845"></a>26845       tdest = dest(tetloop);
<a name="l26846"></a>26846       tapex = apex(tetloop);
<a name="l26847"></a>26847       iorg = pointmark(torg) - in-&gt;firstnumber;
<a name="l26848"></a>26848       idest = pointmark(tdest) - in-&gt;firstnumber;
<a name="l26849"></a>26849       iapex = pointmark(tapex) - in-&gt;firstnumber;
<a name="l26850"></a>26850       worklist[iorg] = 1;
<a name="l26851"></a>26851       worklist[idest] = 1;
<a name="l26852"></a>26852       worklist[iapex] = 1;
<a name="l26853"></a>26853       bondflag = <span class="keyword">false</span>;
<a name="l26854"></a>26854       <span class="comment">// Search its neighbor in the adjacent tets of torg.</span>
<a name="l26855"></a>26855       <span class="keywordflow">for</span> (j = idx2tetlist[iorg]; j &lt; idx2tetlist[iorg + 1] &amp;&amp; !bondflag;
<a name="l26856"></a>26856            j++) {
<a name="l26857"></a>26857         <span class="keywordflow">if</span> (tetsperverlist[j] == tetloop.tet) <span class="keywordflow">continue</span>; <span class="comment">// Skip myself.</span>
<a name="l26858"></a>26858         neightet.tet = tetsperverlist[j];
<a name="l26859"></a>26859         <span class="keywordflow">for</span> (neightet.loc = 0; neightet.loc &lt; 4; neightet.loc++) {
<a name="l26860"></a>26860           sym(neightet, neineightet);
<a name="l26861"></a>26861           <span class="keywordflow">if</span> (neineightet.tet == dummytet) {
<a name="l26862"></a>26862             norg = org(neightet);
<a name="l26863"></a>26863             ndest = dest(neightet);
<a name="l26864"></a>26864             napex = apex(neightet);
<a name="l26865"></a>26865             inorg = pointmark(norg) - in-&gt;firstnumber;
<a name="l26866"></a>26866             indest = pointmark(ndest) - in-&gt;firstnumber;
<a name="l26867"></a>26867             inapex = pointmark(napex) - in-&gt;firstnumber;
<a name="l26868"></a>26868             <span class="keywordflow">if</span> ((worklist[inorg] + worklist[indest] + worklist[inapex]) == 3) {
<a name="l26869"></a>26869               <span class="comment">// Find! Bond them together and break the loop.</span>
<a name="l26870"></a>26870               bond(tetloop, neightet);
<a name="l26871"></a>26871               bondflag = <span class="keyword">true</span>;
<a name="l26872"></a>26872               <span class="keywordflow">break</span>;
<a name="l26873"></a>26873             }
<a name="l26874"></a>26874           }
<a name="l26875"></a>26875         }
<a name="l26876"></a>26876       }
<a name="l26877"></a>26877       <span class="keywordflow">if</span> (!bondflag) {
<a name="l26878"></a>26878         hullsize++;  <span class="comment">// It&#39;s a hull face.</span>
<a name="l26879"></a>26879         <span class="comment">// Bond this side to outer space.</span>
<a name="l26880"></a>26880         dummytet[0] = encode(tetloop);
<a name="l26881"></a>26881         <span class="keywordflow">if</span> ((in-&gt;pointmarkerlist != (<span class="keywordtype">int</span> *) NULL) &amp;&amp; !b-&gt;coarse) {
<a name="l26882"></a>26882           <span class="comment">// Set its three corners&#39;s markers be boundary (hull) vertices.</span>
<a name="l26883"></a>26883           <span class="keywordflow">if</span> (in-&gt;pointmarkerlist[iorg] == 0) {
<a name="l26884"></a>26884             in-&gt;pointmarkerlist[iorg] = 1;
<a name="l26885"></a>26885           }
<a name="l26886"></a>26886           <span class="keywordflow">if</span> (in-&gt;pointmarkerlist[idest] == 0) {
<a name="l26887"></a>26887             in-&gt;pointmarkerlist[idest] = 1;
<a name="l26888"></a>26888           }
<a name="l26889"></a>26889           <span class="keywordflow">if</span> (in-&gt;pointmarkerlist[iapex] == 0) {
<a name="l26890"></a>26890             in-&gt;pointmarkerlist[iapex] = 1;
<a name="l26891"></a>26891           }
<a name="l26892"></a>26892         }
<a name="l26893"></a>26893       }
<a name="l26894"></a>26894       worklist[iorg] = 0;
<a name="l26895"></a>26895       worklist[idest] = 0;
<a name="l26896"></a>26896       worklist[iapex] = 0;
<a name="l26897"></a>26897     }
<a name="l26898"></a>26898     tetloop.tet = tetrahedrontraverse();
<a name="l26899"></a>26899   }
<a name="l26900"></a>26900 
<a name="l26901"></a>26901   <span class="comment">// Subfaces will be inserted into the mesh. It has two phases:</span>
<a name="l26902"></a>26902   <span class="comment">//   (1) Insert subfaces provided by user (in-&gt;trifacelist);</span>
<a name="l26903"></a>26903   <span class="comment">//   (2) Create subfaces for hull faces (if they&#39;re not subface yet) and</span>
<a name="l26904"></a>26904   <span class="comment">//       interior faces which separate two different materials.</span>
<a name="l26905"></a>26905 
<a name="l26906"></a>26906   <span class="comment">// Phase (1). Is there a list of user-provided subfaces?</span>
<a name="l26907"></a>26907   <span class="keywordflow">if</span> (in-&gt;trifacelist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l26908"></a>26908     <span class="comment">// Recover subfaces from &#39;in-&gt;trifacelist&#39;.</span>
<a name="l26909"></a>26909     <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoftrifaces; i++) {
<a name="l26910"></a>26910       index = i * 3;
<a name="l26911"></a>26911       iorg = in-&gt;trifacelist[index] - in-&gt;firstnumber;
<a name="l26912"></a>26912       idest = in-&gt;trifacelist[index + 1] - in-&gt;firstnumber;
<a name="l26913"></a>26913       iapex = in-&gt;trifacelist[index + 2] - in-&gt;firstnumber;
<a name="l26914"></a>26914       <span class="comment">// Look for the location of this subface.</span>
<a name="l26915"></a>26915       worklist[iorg] = 1;
<a name="l26916"></a>26916       worklist[idest] = 1;
<a name="l26917"></a>26917       worklist[iapex] = 1;
<a name="l26918"></a>26918       bondflag = <span class="keyword">false</span>;
<a name="l26919"></a>26919       <span class="comment">// Search its neighbor in the adjacent tets of torg.</span>
<a name="l26920"></a>26920       <span class="keywordflow">for</span> (j = idx2tetlist[iorg]; j &lt; idx2tetlist[iorg + 1] &amp;&amp; !bondflag;
<a name="l26921"></a>26921            j++) {
<a name="l26922"></a>26922         neightet.tet = tetsperverlist[j];
<a name="l26923"></a>26923         <span class="keywordflow">for</span> (neightet.loc = 0; neightet.loc &lt; 4; neightet.loc++) {
<a name="l26924"></a>26924           norg = org(neightet);
<a name="l26925"></a>26925           ndest = dest(neightet);
<a name="l26926"></a>26926           napex = apex(neightet);
<a name="l26927"></a>26927           inorg = pointmark(norg) - in-&gt;firstnumber;
<a name="l26928"></a>26928           indest = pointmark(ndest) - in-&gt;firstnumber;
<a name="l26929"></a>26929           inapex = pointmark(napex) - in-&gt;firstnumber;
<a name="l26930"></a>26930           <span class="keywordflow">if</span> ((worklist[inorg] + worklist[indest] + worklist[inapex]) == 3) {
<a name="l26931"></a>26931             bondflag = <span class="keyword">true</span>;  <span class="comment">// Find!</span>
<a name="l26932"></a>26932             <span class="keywordflow">break</span>;
<a name="l26933"></a>26933           }
<a name="l26934"></a>26934         }
<a name="l26935"></a>26935       }
<a name="l26936"></a>26936       <span class="keywordflow">if</span> (bondflag) {
<a name="l26937"></a>26937         <span class="comment">// Create a new subface and insert it into the mesh.</span>
<a name="l26938"></a>26938         makeshellface(subfaces, &amp;subloop);
<a name="l26939"></a>26939         torg = idx2verlist[iorg];
<a name="l26940"></a>26940         tdest = idx2verlist[idest];
<a name="l26941"></a>26941         tapex = idx2verlist[iapex];
<a name="l26942"></a>26942         setsorg(subloop, torg);
<a name="l26943"></a>26943         setsdest(subloop, tdest);
<a name="l26944"></a>26944         setsapex(subloop, tapex);
<a name="l26945"></a>26945         <span class="comment">// Set the vertices be FREESUBVERTEX to indicate they belong to a</span>
<a name="l26946"></a>26946         <span class="comment">//   facet of the domain.  They may be changed later.</span>
<a name="l26947"></a>26947         setpointtype(torg, FREESUBVERTEX);
<a name="l26948"></a>26948         setpointtype(tdest, FREESUBVERTEX);
<a name="l26949"></a>26949         setpointtype(tapex, FREESUBVERTEX);
<a name="l26950"></a>26950         <span class="keywordflow">if</span> (in-&gt;trifacemarkerlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l26951"></a>26951           setshellmark(subloop, in-&gt;trifacemarkerlist[i]);
<a name="l26952"></a>26952         }
<a name="l26953"></a>26953         adjustedgering(neightet, CCW);
<a name="l26954"></a>26954         findedge(&amp;subloop, org(neightet), dest(neightet));
<a name="l26955"></a>26955         tsbond(neightet, subloop);
<a name="l26956"></a>26956         sym(neightet, neineightet);
<a name="l26957"></a>26957         <span class="keywordflow">if</span> (neineightet.tet != dummytet) {
<a name="l26958"></a>26958           sesymself(subloop);
<a name="l26959"></a>26959           tsbond(neineightet, subloop);
<a name="l26960"></a>26960         }
<a name="l26961"></a>26961       } <span class="keywordflow">else</span> {
<a name="l26962"></a>26962         <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l26963"></a>26963           printf(<span class="stringliteral">&quot;Warning:  Subface %d is discarded.\n&quot;</span>, i + in-&gt;firstnumber);
<a name="l26964"></a>26964         }
<a name="l26965"></a>26965       }
<a name="l26966"></a>26966       worklist[iorg] = 0;
<a name="l26967"></a>26967       worklist[idest] = 0;
<a name="l26968"></a>26968       worklist[iapex] = 0;
<a name="l26969"></a>26969     }
<a name="l26970"></a>26970   }
<a name="l26971"></a>26971 
<a name="l26972"></a>26972   <span class="comment">// Phase (2). Indentify subfaces from the mesh.</span>
<a name="l26973"></a>26973   tetrahedrons-&gt;traversalinit();
<a name="l26974"></a>26974   tetloop.tet = tetrahedrontraverse();
<a name="l26975"></a>26975   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l26976"></a>26976     <span class="comment">// Loop the four sides of the tetrahedron.</span>
<a name="l26977"></a>26977     <span class="keywordflow">for</span> (tetloop.loc = 0; tetloop.loc &lt; 4; tetloop.loc++) {
<a name="l26978"></a>26978       tspivot(tetloop, subloop);
<a name="l26979"></a>26979       <span class="keywordflow">if</span> (subloop.sh != dummysh) <span class="keywordflow">continue</span>;
<a name="l26980"></a>26980       bondflag = <span class="keyword">false</span>;
<a name="l26981"></a>26981       sym(tetloop, neightet);
<a name="l26982"></a>26982       <span class="keywordflow">if</span> (neightet.tet == dummytet) {
<a name="l26983"></a>26983         <span class="comment">// It&#39;s a hull face. Insert a subface at here.</span>
<a name="l26984"></a>26984         bondflag = <span class="keyword">true</span>;
<a name="l26985"></a>26985       } <span class="keywordflow">else</span> {
<a name="l26986"></a>26986         <span class="comment">// It&#39;s an interior face. Insert a subface if two tetrahedra have</span>
<a name="l26987"></a>26987         <span class="comment">//   different attributes (i.e., they belong to two regions).</span>
<a name="l26988"></a>26988         <span class="keywordflow">if</span> (in-&gt;numberoftetrahedronattributes &gt; 0) {
<a name="l26989"></a>26989           <span class="keywordflow">if</span> (elemattribute(neightet.tet,
<a name="l26990"></a>26990               in-&gt;numberoftetrahedronattributes - 1) !=
<a name="l26991"></a>26991               elemattribute(tetloop.tet,
<a name="l26992"></a>26992               in-&gt;numberoftetrahedronattributes - 1)) {
<a name="l26993"></a>26993             bondflag = <span class="keyword">true</span>;
<a name="l26994"></a>26994           }
<a name="l26995"></a>26995         }
<a name="l26996"></a>26996       }
<a name="l26997"></a>26997       <span class="keywordflow">if</span> (bondflag) {
<a name="l26998"></a>26998         adjustedgering(tetloop, CCW);
<a name="l26999"></a>26999         makeshellface(subfaces, &amp;subloop);
<a name="l27000"></a>27000         torg = org(tetloop);
<a name="l27001"></a>27001         tdest = dest(tetloop);
<a name="l27002"></a>27002         tapex = apex(tetloop);
<a name="l27003"></a>27003         setsorg(subloop, torg);
<a name="l27004"></a>27004         setsdest(subloop, tdest);
<a name="l27005"></a>27005         setsapex(subloop, tapex);
<a name="l27006"></a>27006         <span class="comment">// Set the vertices be FREESUBVERTEX to indicate they belong to a</span>
<a name="l27007"></a>27007         <span class="comment">//   facet of the domain.  They may be changed later.</span>
<a name="l27008"></a>27008         setpointtype(torg, FREESUBVERTEX);
<a name="l27009"></a>27009         setpointtype(tdest, FREESUBVERTEX);
<a name="l27010"></a>27010         setpointtype(tapex, FREESUBVERTEX);
<a name="l27011"></a>27011         tsbond(tetloop, subloop);
<a name="l27012"></a>27012         <span class="keywordflow">if</span> (neightet.tet != dummytet) {
<a name="l27013"></a>27013           sesymself(subloop);
<a name="l27014"></a>27014           tsbond(neightet, subloop);
<a name="l27015"></a>27015         }
<a name="l27016"></a>27016       }
<a name="l27017"></a>27017     }
<a name="l27018"></a>27018     tetloop.tet = tetrahedrontraverse();
<a name="l27019"></a>27019   }
<a name="l27020"></a>27020 
<a name="l27021"></a>27021   <span class="comment">// Set the connection between subfaces. A subsegment may have more than</span>
<a name="l27022"></a>27022   <span class="comment">//   two subfaces sharing it, &#39;neighshlist&#39; stores all subfaces sharing</span>
<a name="l27023"></a>27023   <span class="comment">//   one edge.</span>
<a name="l27024"></a>27024   neighshlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL);
<a name="l27025"></a>27025   <span class="comment">// Create a map from nodes to subfaces.</span>
<a name="l27026"></a>27026   makesubfacemap(idx2facelist, facesperverlist);
<a name="l27027"></a>27027 
<a name="l27028"></a>27028   <span class="comment">// Loop over the set of subfaces, setup the connection between subfaces.</span>
<a name="l27029"></a>27029   subfaces-&gt;traversalinit();
<a name="l27030"></a>27030   subloop.sh = shellfacetraverse(subfaces);
<a name="l27031"></a>27031   <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l27032"></a>27032     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l27033"></a>27033       spivot(subloop, neighsh);
<a name="l27034"></a>27034       <span class="keywordflow">if</span> (neighsh.sh == dummysh) {
<a name="l27035"></a>27035         <span class="comment">// This side is &#39;empty&#39;, operate on it.</span>
<a name="l27036"></a>27036         torg = sorg(subloop);
<a name="l27037"></a>27037         tdest = sdest(subloop);
<a name="l27038"></a>27038         tapex = sapex(subloop);
<a name="l27039"></a>27039         neighshlist-&gt;append(&amp;subloop);
<a name="l27040"></a>27040         iorg = pointmark(torg) - in-&gt;firstnumber;
<a name="l27041"></a>27041         <span class="comment">// Search its neighbor in the adjacent list of torg.</span>
<a name="l27042"></a>27042         <span class="keywordflow">for</span> (j = idx2facelist[iorg]; j &lt; idx2facelist[iorg + 1]; j++) {
<a name="l27043"></a>27043           neighsh.sh = facesperverlist[j];
<a name="l27044"></a>27044           <span class="keywordflow">if</span> (neighsh.sh == subloop.sh) <span class="keywordflow">continue</span>;
<a name="l27045"></a>27045           neighsh.shver = 0;
<a name="l27046"></a>27046           <span class="keywordflow">if</span> (isfacehasedge(&amp;neighsh, torg, tdest)) {
<a name="l27047"></a>27047             findedge(&amp;neighsh, torg, tdest);
<a name="l27048"></a>27048             <span class="comment">// Insert &#39;neighsh&#39; into &#39;neighshlist&#39;.</span>
<a name="l27049"></a>27049             <span class="keywordflow">if</span> (neighshlist-&gt;len() &lt; 2) {
<a name="l27050"></a>27050               neighshlist-&gt;append(&amp;neighsh);
<a name="l27051"></a>27051             } <span class="keywordflow">else</span> {
<a name="l27052"></a>27052               <span class="keywordflow">for</span> (index = 0; index &lt; neighshlist-&gt;len() - 1; index++) {
<a name="l27053"></a>27053                 sface1 = * (face *)(* neighshlist)[index];
<a name="l27054"></a>27054                 sface2 = * (face *)(* neighshlist)[index + 1];
<a name="l27055"></a>27055                 da1 = facedihedral(torg, tdest, sapex(sface1), sapex(neighsh));
<a name="l27056"></a>27056                 da2 = facedihedral(torg, tdest, sapex(sface1), sapex(sface2));
<a name="l27057"></a>27057                 <span class="keywordflow">if</span> (da1 &lt; da2) {
<a name="l27058"></a>27058                   <span class="keywordflow">break</span>;  <span class="comment">// Insert it after index.</span>
<a name="l27059"></a>27059                 }
<a name="l27060"></a>27060               }
<a name="l27061"></a>27061               neighshlist-&gt;insert(index + 1, &amp;neighsh);
<a name="l27062"></a>27062             }
<a name="l27063"></a>27063           }
<a name="l27064"></a>27064         }
<a name="l27065"></a>27065         <span class="comment">// Bond the subfaces in &#39;neighshlist&#39;.</span>
<a name="l27066"></a>27066         <span class="keywordflow">if</span> (neighshlist-&gt;len() &gt; 1) {
<a name="l27067"></a>27067           neighsh = * (face *)(* neighshlist)[0];
<a name="l27068"></a>27068           <span class="keywordflow">for</span> (j = 1; j &lt;= neighshlist-&gt;len(); j++) {
<a name="l27069"></a>27069             <span class="keywordflow">if</span> (j &lt; neighshlist-&gt;len()) {
<a name="l27070"></a>27070               neineighsh = * (face *)(* neighshlist)[j];
<a name="l27071"></a>27071             } <span class="keywordflow">else</span> {
<a name="l27072"></a>27072               neineighsh = * (face *)(* neighshlist)[0];
<a name="l27073"></a>27073             }
<a name="l27074"></a>27074             sbond1(neighsh, neineighsh);
<a name="l27075"></a>27075             neighsh = neineighsh;
<a name="l27076"></a>27076           }
<a name="l27077"></a>27077         } <span class="keywordflow">else</span> {
<a name="l27078"></a>27078           <span class="comment">// No neighbor subface be found, bond &#39;subloop&#39; to itself.</span>
<a name="l27079"></a>27079           sbond(subloop, subloop);
<a name="l27080"></a>27080         }
<a name="l27081"></a>27081         neighshlist-&gt;clear();
<a name="l27082"></a>27082       }
<a name="l27083"></a>27083       senextself(subloop);
<a name="l27084"></a>27084     }
<a name="l27085"></a>27085     subloop.sh = shellfacetraverse(subfaces);
<a name="l27086"></a>27086   }
<a name="l27087"></a>27087 
<a name="l27088"></a>27088   <span class="comment">// Segments will be introudced. Each segment has a unique marker (1-based).</span>
<a name="l27089"></a>27089   marker = 1;
<a name="l27090"></a>27090   subfaces-&gt;traversalinit();
<a name="l27091"></a>27091   subloop.sh = shellfacetraverse(subfaces);
<a name="l27092"></a>27092   <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l27093"></a>27093     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l27094"></a>27094       sspivot(subloop, subseg);
<a name="l27095"></a>27095       <span class="keywordflow">if</span> (subseg.sh == dummysh) {
<a name="l27096"></a>27096         <span class="comment">// This side has no subsegment bonded, check it.</span>
<a name="l27097"></a>27097         torg = sorg(subloop);
<a name="l27098"></a>27098         tdest = sdest(subloop);
<a name="l27099"></a>27099         tapex = sapex(subloop);
<a name="l27100"></a>27100         spivot(subloop, neighsh);
<a name="l27101"></a>27101         spivot(neighsh, neineighsh);
<a name="l27102"></a>27102         insertsegflag = <span class="keyword">false</span>;
<a name="l27103"></a>27103         <span class="keywordflow">if</span> (subloop.sh == neighsh.sh || subloop.sh != neineighsh.sh) {
<a name="l27104"></a>27104           <span class="comment">// This side is either self-bonded or more than two subfaces,</span>
<a name="l27105"></a>27105           <span class="comment">//   insert a subsegment at this side.</span>
<a name="l27106"></a>27106           insertsegflag = <span class="keyword">true</span>;
<a name="l27107"></a>27107         } <span class="keywordflow">else</span> {
<a name="l27108"></a>27108           <span class="comment">// Only two subfaces case.</span>
<a name="l27109"></a>27109 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l27110"></a>27110 <span class="preprocessor"></span>          assert(subloop.sh != neighsh.sh);
<a name="l27111"></a>27111 <span class="preprocessor">#endif</span>
<a name="l27112"></a>27112 <span class="preprocessor"></span>          napex = sapex(neighsh);
<a name="l27113"></a>27113           sign = orient3d(torg, tdest, tapex, napex);
<a name="l27114"></a>27114           <span class="keywordflow">if</span> (iscoplanar(torg, tdest, tapex, napex, sign, b-&gt;epsilon)) {
<a name="l27115"></a>27115             <span class="comment">// Although they are coplanar, we still need to check if they</span>
<a name="l27116"></a>27116             <span class="comment">//   have the same boundary marker.</span>
<a name="l27117"></a>27117             insertsegflag = (shellmark(subloop) != shellmark(neighsh));
<a name="l27118"></a>27118           } <span class="keywordflow">else</span> {
<a name="l27119"></a>27119             <span class="comment">// Non-coplanar.</span>
<a name="l27120"></a>27120             insertsegflag = <span class="keyword">true</span>;
<a name="l27121"></a>27121           }
<a name="l27122"></a>27122         }
<a name="l27123"></a>27123         <span class="keywordflow">if</span> (insertsegflag) {
<a name="l27124"></a>27124           <span class="comment">// Create a subsegment at this side.</span>
<a name="l27125"></a>27125           makeshellface(subsegs, &amp;subseg);
<a name="l27126"></a>27126           setsorg(subseg, torg);
<a name="l27127"></a>27127           setsdest(subseg, tdest);
<a name="l27128"></a>27128           <span class="comment">// The two vertices have been marked as FREESUBVERTEX. Now mark</span>
<a name="l27129"></a>27129           <span class="comment">//   them as NACUTEVERTEX.</span>
<a name="l27130"></a>27130           setpointtype(torg, NACUTEVERTEX);
<a name="l27131"></a>27131           setpointtype(tdest, NACUTEVERTEX);
<a name="l27132"></a>27132           setshellmark(subseg, marker);
<a name="l27133"></a>27133           marker++;
<a name="l27134"></a>27134           <span class="comment">// Bond all subfaces to this subsegment.</span>
<a name="l27135"></a>27135           neighsh = subloop;
<a name="l27136"></a>27136           <span class="keywordflow">do</span> {
<a name="l27137"></a>27137             ssbond(neighsh, subseg);
<a name="l27138"></a>27138             spivotself(neighsh);
<a name="l27139"></a>27139           } <span class="keywordflow">while</span> (neighsh.sh != subloop.sh);
<a name="l27140"></a>27140         }
<a name="l27141"></a>27141       }
<a name="l27142"></a>27142       senextself(subloop);
<a name="l27143"></a>27143     }
<a name="l27144"></a>27144     subloop.sh = shellfacetraverse(subfaces);
<a name="l27145"></a>27145   }
<a name="l27146"></a>27146   <span class="comment">// Remember the number of input segments.</span>
<a name="l27147"></a>27147   insegments = subsegs-&gt;items;
<a name="l27148"></a>27148   <span class="comment">// Find the acute vertices and set them be type ACUTEVERTEX.</span>
<a name="l27149"></a>27149 
<a name="l27150"></a>27150   <span class="comment">// Indentify facets and set the facet marker (1-based) for subfaces.</span>
<a name="l27151"></a>27151   markerlist = <span class="keyword">new</span> list((<span class="keywordtype">char</span>*)<span class="stringliteral">&quot;int&quot;</span>);
<a name="l27152"></a>27152 
<a name="l27153"></a>27153   subfaces-&gt;traversalinit();
<a name="l27154"></a>27154   subloop.sh = shellfacetraverse(subfaces);
<a name="l27155"></a>27155   <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l27156"></a>27156     <span class="comment">// Only operate on uninfected subface, after operating, infect it.</span>
<a name="l27157"></a>27157     <span class="keywordflow">if</span> (!sinfected(subloop)) {
<a name="l27158"></a>27158       <span class="comment">// A new facet is found.</span>
<a name="l27159"></a>27159       marker = shellmark(subloop);
<a name="l27160"></a>27160       markerlist-&gt;append(&amp;marker);
<a name="l27161"></a>27161       facetidx = markerlist-&gt;len(); <span class="comment">// &#39;facetidx&#39; starts from 1.</span>
<a name="l27162"></a>27162       setshellmark(subloop, facetidx);
<a name="l27163"></a>27163       sinfect(subloop);
<a name="l27164"></a>27164       neighshlist-&gt;append(&amp;subloop);
<a name="l27165"></a>27165       <span class="comment">// Find out all subfaces of this facet (bounded by subsegments).</span>
<a name="l27166"></a>27166       <span class="keywordflow">for</span> (i = 0; i &lt; neighshlist-&gt;len(); i++) {
<a name="l27167"></a>27167         neighsh = * (face *) (* neighshlist)[i];
<a name="l27168"></a>27168         <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l27169"></a>27169           sspivot(neighsh, subseg);
<a name="l27170"></a>27170           <span class="keywordflow">if</span> (subseg.sh == dummysh) {
<a name="l27171"></a>27171             spivot(neighsh, neineighsh);
<a name="l27172"></a>27172             <span class="keywordflow">if</span> (!sinfected(neineighsh)) {
<a name="l27173"></a>27173               <span class="comment">// &#39;neineighsh&#39; is in the same facet as &#39;subloop&#39;.</span>
<a name="l27174"></a>27174 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l27175"></a>27175 <span class="preprocessor"></span>              assert(shellmark(neineighsh) == marker);
<a name="l27176"></a>27176 <span class="preprocessor">#endif</span>
<a name="l27177"></a>27177 <span class="preprocessor"></span>              setshellmark(neineighsh, facetidx);
<a name="l27178"></a>27178               sinfect(neineighsh);
<a name="l27179"></a>27179               neighshlist-&gt;append(&amp;neineighsh);
<a name="l27180"></a>27180             }
<a name="l27181"></a>27181           }
<a name="l27182"></a>27182           senextself(neighsh);
<a name="l27183"></a>27183         }
<a name="l27184"></a>27184       }
<a name="l27185"></a>27185       neighshlist-&gt;clear();
<a name="l27186"></a>27186     }
<a name="l27187"></a>27187     subloop.sh = shellfacetraverse(subfaces);
<a name="l27188"></a>27188   }
<a name="l27189"></a>27189   <span class="comment">// Uninfect all subfaces.</span>
<a name="l27190"></a>27190   subfaces-&gt;traversalinit();
<a name="l27191"></a>27191   subloop.sh = shellfacetraverse(subfaces);
<a name="l27192"></a>27192   <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l27193"></a>27193 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l27194"></a>27194 <span class="preprocessor"></span>    assert(sinfected(subloop));
<a name="l27195"></a>27195 <span class="preprocessor">#endif</span>
<a name="l27196"></a>27196 <span class="preprocessor"></span>    suninfect(subloop);
<a name="l27197"></a>27197     subloop.sh = shellfacetraverse(subfaces);
<a name="l27198"></a>27198   }
<a name="l27199"></a>27199   <span class="comment">// Save the facet markers in &#39;in-&gt;facetmarkerlist&#39;.</span>
<a name="l27200"></a>27200   in-&gt;numberoffacets = markerlist-&gt;len();
<a name="l27201"></a>27201   in-&gt;facetmarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[in-&gt;numberoffacets];
<a name="l27202"></a>27202   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoffacets; i++) {
<a name="l27203"></a>27203     marker = * (<span class="keywordtype">int</span> *) (* markerlist)[i];
<a name="l27204"></a>27204     in-&gt;facetmarkerlist[i] = marker;
<a name="l27205"></a>27205   }
<a name="l27206"></a>27206   <span class="comment">// Initialize the &#39;facetabovepointlist&#39;.</span>
<a name="l27207"></a>27207   facetabovepointarray = <span class="keyword">new</span> point[in-&gt;numberoffacets + 1];
<a name="l27208"></a>27208   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberoffacets + 1; i++) {
<a name="l27209"></a>27209     facetabovepointarray[i] = (point) NULL;
<a name="l27210"></a>27210   }
<a name="l27211"></a>27211 
<a name="l27212"></a>27212   <span class="comment">// The mesh contains boundary now.</span>
<a name="l27213"></a>27213   checksubfaces = 1;
<a name="l27214"></a>27214   <span class="comment">// The mesh is nonconvex now.</span>
<a name="l27215"></a>27215   nonconvex = 1;
<a name="l27216"></a>27216 
<a name="l27217"></a>27217   <span class="comment">// Is there periodic boundary confitions?</span>
<a name="l27218"></a>27218   <span class="keywordflow">if</span> (checkpbcs) {
<a name="l27219"></a>27219     tetgenio::pbcgroup *pg;
<a name="l27220"></a>27220     pbcdata *pd;
<a name="l27221"></a>27221     <span class="comment">// Initialize the global array &#39;subpbcgrouptable&#39;.</span>
<a name="l27222"></a>27222     createsubpbcgrouptable();
<a name="l27223"></a>27223     <span class="comment">// Loop for each pbcgroup i.</span>
<a name="l27224"></a>27224     <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofpbcgroups; i++) {
<a name="l27225"></a>27225       pg = &amp;(in-&gt;pbcgrouplist[i]);
<a name="l27226"></a>27226       pd = &amp;(subpbcgrouptable[i]);
<a name="l27227"></a>27227       <span class="comment">// Find all subfaces of pd, set each subface&#39;s group id be i.</span>
<a name="l27228"></a>27228       <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l27229"></a>27229         subfaces-&gt;traversalinit();
<a name="l27230"></a>27230         subloop.sh = shellfacetraverse(subfaces);
<a name="l27231"></a>27231         <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l27232"></a>27232           facetidx = shellmark(subloop);
<a name="l27233"></a>27233           marker = in-&gt;facetmarkerlist[facetidx - 1];
<a name="l27234"></a>27234           <span class="keywordflow">if</span> (marker == pd-&gt;fmark[j]) {
<a name="l27235"></a>27235             setshellpbcgroup(subloop, i);
<a name="l27236"></a>27236             pd-&gt;ss[j] = subloop;
<a name="l27237"></a>27237           }
<a name="l27238"></a>27238           subloop.sh = shellfacetraverse(subfaces);
<a name="l27239"></a>27239         }
<a name="l27240"></a>27240       }
<a name="l27241"></a>27241       <span class="keywordflow">if</span> (pg-&gt;pointpairlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l27242"></a>27242         <span class="comment">// Set the connections between pbc point pairs.</span>
<a name="l27243"></a>27243         <span class="keywordflow">for</span> (j = 0; j &lt; pg-&gt;numberofpointpairs; j++) {
<a name="l27244"></a>27244           iorg = pg-&gt;pointpairlist[j * 2] - in-&gt;firstnumber;
<a name="l27245"></a>27245           idest = pg-&gt;pointpairlist[j * 2 + 1] - in-&gt;firstnumber;
<a name="l27246"></a>27246           torg = idx2verlist[iorg];
<a name="l27247"></a>27247           tdest = idx2verlist[idest];
<a name="l27248"></a>27248           setpoint2pbcpt(torg, tdest);
<a name="l27249"></a>27249           setpoint2pbcpt(tdest, torg);
<a name="l27250"></a>27250         }
<a name="l27251"></a>27251       }
<a name="l27252"></a>27252     }
<a name="l27253"></a>27253     <span class="comment">// Create the global array &#39;segpbcgrouptable&#39;.</span>
<a name="l27254"></a>27254     createsegpbcgrouptable();
<a name="l27255"></a>27255   }
<a name="l27256"></a>27256 
<a name="l27257"></a>27257   <span class="keyword">delete</span> markerlist;
<a name="l27258"></a>27258   <span class="keyword">delete</span> neighshlist;
<a name="l27259"></a>27259   <span class="keyword">delete</span> [] worklist;
<a name="l27260"></a>27260   <span class="keyword">delete</span> [] idx2tetlist;
<a name="l27261"></a>27261   <span class="keyword">delete</span> [] tetsperverlist;
<a name="l27262"></a>27262   <span class="keyword">delete</span> [] idx2facelist;
<a name="l27263"></a>27263   <span class="keyword">delete</span> [] facesperverlist;
<a name="l27264"></a>27264   <span class="keyword">delete</span> [] idx2verlist;
<a name="l27265"></a>27265 
<a name="l27266"></a>27266   <span class="keywordflow">return</span> hullsize;
<a name="l27267"></a>27267 }
<a name="l27268"></a>27268 
<a name="l27270"></a>27270 <span class="comment">//                                                                           //</span>
<a name="l27271"></a>27271 <span class="comment">// insertconstrainedpoints()    Insert a list of constrained points.         //</span>
<a name="l27272"></a>27272 <span class="comment">//                                                                           //</span>
<a name="l27274"></a>27274 <span class="comment"></span>
<a name="l27275"></a>27275 <span class="keywordtype">void</span> tetgenmesh::insertconstrainedpoints(tetgenio *addio)
<a name="l27276"></a>27276 {
<a name="l27277"></a>27277   queue *flipqueue;
<a name="l27278"></a>27278   triface searchtet;
<a name="l27279"></a>27279   face checksh, checkseg;
<a name="l27280"></a>27280   point newpoint;
<a name="l27281"></a>27281   <span class="keyword">enum</span> locateresult loc;
<a name="l27282"></a>27282   REAL *attr;
<a name="l27283"></a>27283   <span class="keywordtype">bool</span> insertflag;
<a name="l27284"></a>27284   <span class="keywordtype">int</span> covertices, outvertices;
<a name="l27285"></a>27285   <span class="keywordtype">int</span> index;
<a name="l27286"></a>27286   <span class="keywordtype">int</span> i, j;
<a name="l27287"></a>27287 
<a name="l27288"></a>27288   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l27289"></a>27289     printf(<span class="stringliteral">&quot;Insert additional points into mesh.\n&quot;</span>);
<a name="l27290"></a>27290   }
<a name="l27291"></a>27291   <span class="comment">// Initialize &#39;flipqueue&#39;.</span>
<a name="l27292"></a>27292   flipqueue = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l27293"></a>27293   recenttet.tet = dummytet;
<a name="l27294"></a>27294   covertices = outvertices = 0;
<a name="l27295"></a>27295 
<a name="l27296"></a>27296   index = 0;
<a name="l27297"></a>27297   <span class="keywordflow">for</span> (i = 0; i &lt; addio-&gt;numberofpoints; i++) {
<a name="l27298"></a>27298     <span class="comment">// Create a newpoint.</span>
<a name="l27299"></a>27299     makepoint(&amp;newpoint);
<a name="l27300"></a>27300     newpoint[0] = addio-&gt;pointlist[index++];
<a name="l27301"></a>27301     newpoint[1] = addio-&gt;pointlist[index++];
<a name="l27302"></a>27302     newpoint[2] = addio-&gt;pointlist[index++];
<a name="l27303"></a>27303     <span class="comment">// Read the add point attributes if current points have attributes.</span>
<a name="l27304"></a>27304     <span class="keywordflow">if</span> ((addio-&gt;numberofpointattributes &gt; 0) &amp;&amp;
<a name="l27305"></a>27305         (in-&gt;numberofpointattributes &gt; 0)) {
<a name="l27306"></a>27306       attr = addio-&gt;pointattributelist + addio-&gt;numberofpointattributes * i;
<a name="l27307"></a>27307       <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberofpointattributes; j++) {
<a name="l27308"></a>27308         <span class="keywordflow">if</span> (j &lt; addio-&gt;numberofpointattributes) {
<a name="l27309"></a>27309           newpoint[3 + j] = attr[j];
<a name="l27310"></a>27310         }
<a name="l27311"></a>27311       }
<a name="l27312"></a>27312     }
<a name="l27313"></a>27313     <span class="comment">// Find the location of the inserted point.</span>
<a name="l27314"></a>27314     searchtet = recenttet;
<a name="l27315"></a>27315     loc = locate(newpoint, &amp;searchtet);
<a name="l27316"></a>27316     <span class="keywordflow">if</span> (loc != ONVERTEX) {
<a name="l27317"></a>27317       loc = adjustlocate(newpoint, &amp;searchtet, loc, b-&gt;epsilon2);
<a name="l27318"></a>27318     }
<a name="l27319"></a>27319     <span class="keywordflow">if</span> (loc == OUTSIDE) {
<a name="l27320"></a>27320       loc = hullwalk(newpoint, &amp;searchtet);
<a name="l27321"></a>27321       <span class="keywordflow">if</span> (loc == OUTSIDE) {
<a name="l27322"></a>27322         <span class="comment">// Perform a brute-force search.</span>
<a name="l27323"></a>27323         tetrahedrons-&gt;traversalinit();
<a name="l27324"></a>27324         searchtet.tet = tetrahedrontraverse();
<a name="l27325"></a>27325         <span class="keywordflow">while</span> (searchtet.tet != (tetrahedron *) NULL) {
<a name="l27326"></a>27326           loc = adjustlocate(newpoint, &amp;searchtet, OUTSIDE, b-&gt;epsilon2);
<a name="l27327"></a>27327           <span class="keywordflow">if</span> (loc != OUTSIDE) <span class="keywordflow">break</span>;
<a name="l27328"></a>27328           searchtet.tet = tetrahedrontraverse();
<a name="l27329"></a>27329         }
<a name="l27330"></a>27330       }
<a name="l27331"></a>27331     }
<a name="l27332"></a>27332     <span class="comment">// Insert the point if it not lies outside or on a vertex.</span>
<a name="l27333"></a>27333     insertflag = <span class="keyword">true</span>;
<a name="l27334"></a>27334     <span class="keywordflow">switch</span> (loc) {
<a name="l27335"></a>27335     <span class="keywordflow">case</span> INTETRAHEDRON:
<a name="l27336"></a>27336       setpointtype(newpoint, FREEVOLVERTEX);
<a name="l27337"></a>27337       splittetrahedron(newpoint, &amp;searchtet, flipqueue);
<a name="l27338"></a>27338       <span class="keywordflow">break</span>;
<a name="l27339"></a>27339     <span class="keywordflow">case</span> ONFACE:
<a name="l27340"></a>27340       tspivot(searchtet, checksh);
<a name="l27341"></a>27341       <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l27342"></a>27342         <span class="comment">// It is a boundary face. Don&#39;t insert it if -Y option is used.</span>
<a name="l27343"></a>27343         <span class="keywordflow">if</span> (b-&gt;nobisect) {
<a name="l27344"></a>27344           insertflag = <span class="keyword">false</span>;
<a name="l27345"></a>27345         } <span class="keywordflow">else</span> {
<a name="l27346"></a>27346           setpointtype(newpoint, FREESUBVERTEX);
<a name="l27347"></a>27347         }
<a name="l27348"></a>27348       } <span class="keywordflow">else</span> {
<a name="l27349"></a>27349         setpointtype(newpoint, FREEVOLVERTEX);
<a name="l27350"></a>27350       }
<a name="l27351"></a>27351       <span class="keywordflow">if</span> (insertflag) {
<a name="l27352"></a>27352         splittetface(newpoint, &amp;searchtet, flipqueue);
<a name="l27353"></a>27353       }
<a name="l27354"></a>27354       <span class="keywordflow">break</span>;
<a name="l27355"></a>27355     <span class="keywordflow">case</span> ONEDGE:
<a name="l27356"></a>27356       tsspivot(&amp;searchtet, &amp;checkseg);
<a name="l27357"></a>27357       <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l27358"></a>27358         <span class="keywordflow">if</span> (b-&gt;nobisect) {
<a name="l27359"></a>27359           insertflag = <span class="keyword">false</span>;
<a name="l27360"></a>27360         } <span class="keywordflow">else</span> {
<a name="l27361"></a>27361           setpointtype(newpoint, FREESEGVERTEX);
<a name="l27362"></a>27362           setpoint2sh(newpoint, sencode(checkseg));
<a name="l27363"></a>27363         }
<a name="l27364"></a>27364       } <span class="keywordflow">else</span> {
<a name="l27365"></a>27365         tspivot(searchtet, checksh);
<a name="l27366"></a>27366         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l27367"></a>27367           <span class="keywordflow">if</span> (b-&gt;nobisect) {
<a name="l27368"></a>27368             insertflag = <span class="keyword">false</span>;
<a name="l27369"></a>27369           } <span class="keywordflow">else</span> {
<a name="l27370"></a>27370             setpointtype(newpoint, FREESUBVERTEX);
<a name="l27371"></a>27371           }
<a name="l27372"></a>27372         } <span class="keywordflow">else</span> {
<a name="l27373"></a>27373           setpointtype(newpoint, FREEVOLVERTEX);
<a name="l27374"></a>27374         }
<a name="l27375"></a>27375       }
<a name="l27376"></a>27376       <span class="keywordflow">if</span> (insertflag) {
<a name="l27377"></a>27377         splittetedge(newpoint, &amp;searchtet, flipqueue);
<a name="l27378"></a>27378       }
<a name="l27379"></a>27379       <span class="keywordflow">break</span>;
<a name="l27380"></a>27380     <span class="keywordflow">case</span> ONVERTEX:
<a name="l27381"></a>27381       insertflag = <span class="keyword">false</span>;
<a name="l27382"></a>27382       covertices++;
<a name="l27383"></a>27383       <span class="keywordflow">break</span>;
<a name="l27384"></a>27384     <span class="keywordflow">case</span> OUTSIDE:
<a name="l27385"></a>27385       insertflag = <span class="keyword">false</span>;
<a name="l27386"></a>27386       outvertices++;
<a name="l27387"></a>27387       <span class="keywordflow">break</span>;
<a name="l27388"></a>27388     }
<a name="l27389"></a>27389     <span class="comment">// Remember the tetrahedron for next point searching.</span>
<a name="l27390"></a>27390     recenttet = searchtet;
<a name="l27391"></a>27391     <span class="keywordflow">if</span> (!insertflag) {
<a name="l27392"></a>27392       pointdealloc(newpoint);
<a name="l27393"></a>27393     } <span class="keywordflow">else</span> {
<a name="l27394"></a>27394       flip(flipqueue, NULL);
<a name="l27395"></a>27395     }
<a name="l27396"></a>27396   }
<a name="l27397"></a>27397 
<a name="l27398"></a>27398   <span class="keywordflow">if</span> (b-&gt;verbose) {
<a name="l27399"></a>27399     <span class="keywordflow">if</span> (covertices &gt; 0) {
<a name="l27400"></a>27400       printf(<span class="stringliteral">&quot;  %d constrained points already exist.\n&quot;</span>, covertices);
<a name="l27401"></a>27401     }
<a name="l27402"></a>27402     <span class="keywordflow">if</span> (outvertices &gt; 0) {
<a name="l27403"></a>27403       printf(<span class="stringliteral">&quot;  %d constrained points lie outside the mesh.\n&quot;</span>, outvertices);
<a name="l27404"></a>27404     }
<a name="l27405"></a>27405     printf(<span class="stringliteral">&quot;  %d constrained points have been inserted.\n&quot;</span>,
<a name="l27406"></a>27406            addio-&gt;numberofpoints - covertices - outvertices);
<a name="l27407"></a>27407   }
<a name="l27408"></a>27408 
<a name="l27409"></a>27409   <span class="keyword">delete</span> flipqueue;
<a name="l27410"></a>27410 }
<a name="l27411"></a>27411 
<a name="l27413"></a>27413 <span class="comment">//                                                                           //</span>
<a name="l27414"></a>27414 <span class="comment">// p1interpolatebgm()    Set pt size by p^1 interpolation in background mesh.//</span>
<a name="l27415"></a>27415 <span class="comment">//                                                                           //</span>
<a name="l27416"></a>27416 <span class="comment">// On input, &#39;bgmtet&#39; is a suggesting tet in background mesh for searching   //</span>
<a name="l27417"></a>27417 <span class="comment">// &#39;pt&#39;. It returns the tet containing &#39;pt&#39;.                                 //</span>
<a name="l27418"></a>27418 <span class="comment">//                                                                           //</span>
<a name="l27420"></a>27420 <span class="comment"></span>
<a name="l27421"></a>27421 <span class="keywordtype">bool</span> tetgenmesh::p1interpolatebgm(point pt, triface* bgmtet, <span class="keywordtype">long</span> *scount)
<a name="l27422"></a>27422 {
<a name="l27423"></a>27423   point bgmpt[4];
<a name="l27424"></a>27424   <span class="keyword">enum</span> locateresult loc;
<a name="l27425"></a>27425   REAL vol, volpt[4], weights[4];
<a name="l27426"></a>27426   <span class="keywordtype">int</span> i;
<a name="l27427"></a>27427 
<a name="l27428"></a>27428   loc = bgm-&gt;preciselocate(pt, bgmtet, bgm-&gt;tetrahedrons-&gt;items);
<a name="l27429"></a>27429   <span class="keywordflow">if</span> (loc == OUTSIDE) {
<a name="l27430"></a>27430     loc = bgm-&gt;hullwalk(pt, bgmtet);
<a name="l27431"></a>27431     <span class="keywordflow">if</span> (loc == OUTSIDE) {
<a name="l27432"></a>27432       <span class="comment">// Perform a brute-force search.</span>
<a name="l27433"></a>27433       <span class="keywordflow">if</span> (b-&gt;verbose) {
<a name="l27434"></a>27434         printf(<span class="stringliteral">&quot;Warning:  Global point location.\n&quot;</span>);
<a name="l27435"></a>27435       }
<a name="l27436"></a>27436       <span class="keywordflow">if</span> (scount) (*scount)++;
<a name="l27437"></a>27437       bgm-&gt;tetrahedrons-&gt;traversalinit(); <span class="comment">// in bgm</span>
<a name="l27438"></a>27438       bgmtet-&gt;tet = bgm-&gt;tetrahedrontraverse(); <span class="comment">// in bgm</span>
<a name="l27439"></a>27439       <span class="keywordflow">while</span> (bgmtet-&gt;tet != (tetrahedron *) NULL) {
<a name="l27440"></a>27440         loc = bgm-&gt;adjustlocate(pt, bgmtet, OUTSIDE, b-&gt;epsilon);
<a name="l27441"></a>27441         <span class="keywordflow">if</span> (loc != OUTSIDE) <span class="keywordflow">break</span>;
<a name="l27442"></a>27442         bgmtet-&gt;tet = bgm-&gt;tetrahedrontraverse(); <span class="comment">// in bgm</span>
<a name="l27443"></a>27443       }
<a name="l27444"></a>27444     }
<a name="l27445"></a>27445   }
<a name="l27446"></a>27446   <span class="keywordflow">if</span> (loc != OUTSIDE) {
<a name="l27447"></a>27447     <span class="comment">// Let p remember t.</span>
<a name="l27448"></a>27448     setpoint2bgmtet(pt, encode(*bgmtet)); <span class="comment">// in m</span>
<a name="l27449"></a>27449     <span class="comment">// get the corners of t.</span>
<a name="l27450"></a>27450     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) bgmpt[i] = (point) bgmtet-&gt;tet[4 + i];
<a name="l27451"></a>27451     <span class="comment">// Calculate the weighted coordinates of p in t.</span>
<a name="l27452"></a>27452     vol = orient3d(bgmpt[0], bgmpt[1], bgmpt[2], bgmpt[3]);
<a name="l27453"></a>27453     volpt[0] = orient3d(pt, bgmpt[1], bgmpt[2], bgmpt[3]);
<a name="l27454"></a>27454     volpt[1] = orient3d(bgmpt[0], pt, bgmpt[2], bgmpt[3]);
<a name="l27455"></a>27455     volpt[2] = orient3d(bgmpt[0], bgmpt[1], pt, bgmpt[3]);
<a name="l27456"></a>27456     volpt[3] = orient3d(bgmpt[0], bgmpt[1], bgmpt[2], pt);
<a name="l27457"></a>27457     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) weights[i] = fabs(volpt[i] / vol);
<a name="l27458"></a>27458     <span class="comment">// Interpolate the solution for p.</span>
<a name="l27459"></a>27459     <span class="keywordflow">for</span> (i = 0; i &lt; bgm-&gt;in-&gt;numberofpointmtrs; i++) {
<a name="l27460"></a>27460       pt[pointmtrindex + i] = weights[0] * bgmpt[0][bgm-&gt;pointmtrindex + i]
<a name="l27461"></a>27461                             + weights[1] * bgmpt[1][bgm-&gt;pointmtrindex + i]
<a name="l27462"></a>27462                             + weights[2] * bgmpt[2][bgm-&gt;pointmtrindex + i]
<a name="l27463"></a>27463                             + weights[3] * bgmpt[3][bgm-&gt;pointmtrindex + i];
<a name="l27464"></a>27464     }
<a name="l27465"></a>27465   } <span class="keywordflow">else</span> {
<a name="l27466"></a>27466     setpoint2bgmtet(pt, (tetrahedron) NULL);  <span class="comment">// in m</span>
<a name="l27467"></a>27467   }
<a name="l27468"></a>27468   <span class="keywordflow">return</span> loc != OUTSIDE;
<a name="l27469"></a>27469 }
<a name="l27470"></a>27470 
<a name="l27472"></a>27472 <span class="comment">//                                                                           //</span>
<a name="l27473"></a>27473 <span class="comment">// interpolatesizemap()    Interpolate the point sizes in the given size map.//</span>
<a name="l27474"></a>27474 <span class="comment">//                                                                           //</span>
<a name="l27475"></a>27475 <span class="comment">// The size map is specified on each node of the background mesh. The points //</span>
<a name="l27476"></a>27476 <span class="comment">// of current mesh get their sizes by interpolating.                         //</span>
<a name="l27477"></a>27477 <span class="comment">//                                                                           //</span>
<a name="l27478"></a>27478 <span class="comment">// This function operation on two meshes simultaneously, the current mesh m, //</span>
<a name="l27479"></a>27479 <span class="comment">// and the background mesh bgm. After this function, each point p in m will  //</span>
<a name="l27480"></a>27480 <span class="comment">// have a pointer to a tet of bgm.                                           //</span>
<a name="l27481"></a>27481 <span class="comment">//                                                                           //</span>
<a name="l27483"></a>27483 <span class="comment"></span>
<a name="l27484"></a>27484 <span class="keywordtype">void</span> tetgenmesh::interpolatesizemap()
<a name="l27485"></a>27485 {
<a name="l27486"></a>27486   list *adjtetlist;
<a name="l27487"></a>27487   triface tetloop, neightet, bgmtet;
<a name="l27488"></a>27488   point searchpt;
<a name="l27489"></a>27489   <span class="keywordtype">long</span> scount;
<a name="l27490"></a>27490   <span class="keywordtype">int</span> *worklist;
<a name="l27491"></a>27491   <span class="keywordtype">int</span> sepcount;
<a name="l27492"></a>27492   <span class="keywordtype">int</span> i;
<a name="l27493"></a>27493 
<a name="l27494"></a>27494   <span class="keywordflow">if</span> (b-&gt;verbose) {
<a name="l27495"></a>27495     printf(<span class="stringliteral">&quot;  Interpolating size map.\n&quot;</span>);
<a name="l27496"></a>27496   }
<a name="l27497"></a>27497 
<a name="l27498"></a>27498   worklist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l27499"></a>27499   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) worklist[i] = 0;
<a name="l27500"></a>27500   sepcount = 0;
<a name="l27501"></a>27501   scount = 0l;
<a name="l27502"></a>27502 
<a name="l27503"></a>27503   tetrahedrons-&gt;traversalinit();
<a name="l27504"></a>27504   tetloop.tet = tetrahedrontraverse();
<a name="l27505"></a>27505   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l27506"></a>27506     <span class="keywordflow">if</span> (!infected(tetloop)) {
<a name="l27507"></a>27507       <span class="comment">// Find a new subdomain.</span>
<a name="l27508"></a>27508       adjtetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 1024);
<a name="l27509"></a>27509       infect(tetloop);
<a name="l27510"></a>27510       <span class="comment">// Search the four corners in background mesh.</span>
<a name="l27511"></a>27511       <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l27512"></a>27512         searchpt = (point) tetloop.tet[4 + i];
<a name="l27513"></a>27513         <span class="comment">// Mark the point for avoiding multiple searchings.</span>
<a name="l27514"></a>27514         <span class="comment">// assert(worklist[pointmark(searchpt)] == 0);</span>
<a name="l27515"></a>27515         worklist[pointmark(searchpt)] = 1;
<a name="l27516"></a>27516         <span class="comment">// Does it contain a pointer to bgm tet?</span>
<a name="l27517"></a>27517         bgm-&gt;decode(point2bgmtet(searchpt), bgmtet);
<a name="l27518"></a>27518         <span class="keywordflow">if</span> (bgm-&gt;isdead(&amp;bgmtet)) {
<a name="l27519"></a>27519           bgmtet = bgm-&gt;recenttet;
<a name="l27520"></a>27520         }
<a name="l27521"></a>27521         <span class="keywordflow">if</span> (p1interpolatebgm(searchpt, &amp;bgmtet, &amp;scount)) {
<a name="l27522"></a>27522           bgm-&gt;recenttet = bgmtet;
<a name="l27523"></a>27523         }
<a name="l27524"></a>27524       } <span class="comment">// for (i = 0; i &lt; 4; i++)</span>
<a name="l27525"></a>27525       <span class="comment">// Collect all tets in this region.</span>
<a name="l27526"></a>27526       adjtetlist-&gt;append(&amp;tetloop);
<a name="l27527"></a>27527       <span class="comment">// Collect the tets in the subdomain.</span>
<a name="l27528"></a>27528       <span class="keywordflow">for</span> (i = 0; i &lt; adjtetlist-&gt;len(); i++) {
<a name="l27529"></a>27529         tetloop = * (triface *)(* adjtetlist)[i];
<a name="l27530"></a>27530         <span class="keywordflow">for</span> (tetloop.loc = 0; tetloop.loc &lt; 4; tetloop.loc++) {
<a name="l27531"></a>27531           sym(tetloop, neightet);
<a name="l27532"></a>27532           <span class="keywordflow">if</span> ((neightet.tet != dummytet) &amp;&amp; !infected(neightet)) {
<a name="l27533"></a>27533             <span class="comment">// Only need to search for the opposite point.</span>
<a name="l27534"></a>27534             searchpt = oppo(neightet);
<a name="l27535"></a>27535             <span class="keywordflow">if</span> (worklist[pointmark(searchpt)] == 0) {
<a name="l27536"></a>27536               worklist[pointmark(searchpt)] = 1;
<a name="l27537"></a>27537               decode(point2bgmtet(searchpt), bgmtet);
<a name="l27538"></a>27538               <span class="keywordflow">if</span> (bgm-&gt;isdead(&amp;bgmtet)) {
<a name="l27539"></a>27539                 bgmtet = bgm-&gt;recenttet;
<a name="l27540"></a>27540               }
<a name="l27541"></a>27541               <span class="keywordflow">if</span> (p1interpolatebgm(searchpt, &amp;bgmtet, &amp;scount)) {
<a name="l27542"></a>27542                 bgm-&gt;recenttet = bgmtet;
<a name="l27543"></a>27543               }
<a name="l27544"></a>27544             }
<a name="l27545"></a>27545             infect(neightet);
<a name="l27546"></a>27546             adjtetlist-&gt;append(&amp;neightet);
<a name="l27547"></a>27547           }
<a name="l27548"></a>27548         }
<a name="l27549"></a>27549       }
<a name="l27550"></a>27550       <span class="comment">// Increase the number of separated domains.</span>
<a name="l27551"></a>27551       sepcount++;
<a name="l27552"></a>27552       <span class="keyword">delete</span> adjtetlist;
<a name="l27553"></a>27553     } <span class="comment">// if (!infect())</span>
<a name="l27554"></a>27554     tetloop.tet = tetrahedrontraverse();
<a name="l27555"></a>27555   }
<a name="l27556"></a>27556 
<a name="l27557"></a>27557   <span class="comment">// Unmark all tets.</span>
<a name="l27558"></a>27558   tetrahedrons-&gt;traversalinit();
<a name="l27559"></a>27559   tetloop.tet = tetrahedrontraverse();
<a name="l27560"></a>27560   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l27561"></a>27561     assert(infected(tetloop));
<a name="l27562"></a>27562     uninfect(tetloop);
<a name="l27563"></a>27563     tetloop.tet = tetrahedrontraverse();
<a name="l27564"></a>27564   }
<a name="l27565"></a>27565   <span class="keyword">delete</span> [] worklist;
<a name="l27566"></a>27566 
<a name="l27567"></a>27567 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l27568"></a>27568 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (b-&gt;verbose &amp;&amp; scount &gt; 0l) {
<a name="l27569"></a>27569     printf(<span class="stringliteral">&quot;  %ld brute-force searches.\n&quot;</span>, scount);
<a name="l27570"></a>27570   }
<a name="l27571"></a>27571   <span class="keywordflow">if</span> (b-&gt;verbose &amp;&amp; sepcount &gt; 0) {
<a name="l27572"></a>27572     printf(<span class="stringliteral">&quot;  %d separate domains.\n&quot;</span>, sepcount);
<a name="l27573"></a>27573   }
<a name="l27574"></a>27574 <span class="preprocessor">#endif</span>
<a name="l27575"></a>27575 <span class="preprocessor"></span>}
<a name="l27576"></a>27576 
<a name="l27578"></a>27578 <span class="comment">//                                                                           //</span>
<a name="l27579"></a>27579 <span class="comment">// duplicatebgmesh()    Duplicate current mesh to background mesh.           //</span>
<a name="l27580"></a>27580 <span class="comment">//                                                                           //</span>
<a name="l27581"></a>27581 <span class="comment">// Current mesh &#39;this&#39; is copied into &#39;this-&gt;bgm&#39;.Both meshes share the same //</span>
<a name="l27582"></a>27582 <span class="comment">// input tetgenio object, &#39;this-&gt;in&#39;, same tetgenbehavior object &#39;this-&gt;b&#39;.  //</span>
<a name="l27583"></a>27583 <span class="comment">//                                                                           //</span>
<a name="l27585"></a>27585 <span class="comment"></span>
<a name="l27586"></a>27586 <span class="keywordtype">void</span> tetgenmesh::duplicatebgmesh()
<a name="l27587"></a>27587 {
<a name="l27588"></a>27588   triface tetloop, btetloop;
<a name="l27589"></a>27589   triface symtet, bsymtet;
<a name="l27590"></a>27590   face bhullsh, bneighsh;
<a name="l27591"></a>27591   point *idx2bplist, *tetptbaklist;
<a name="l27592"></a>27592   point ploop, bploop;
<a name="l27593"></a>27593   <span class="keywordtype">int</span> idx, i;
<a name="l27594"></a>27594 
<a name="l27595"></a>27595   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l27596"></a>27596     printf(<span class="stringliteral">&quot;Duplicating background mesh.\n&quot;</span>);
<a name="l27597"></a>27597   }
<a name="l27598"></a>27598 
<a name="l27599"></a>27599   <span class="comment">// The background mesh itself has no background mesh.</span>
<a name="l27600"></a>27600   <span class="comment">// assert(bgm-&gt;bgm == (tetgenmesh *) NULL);</span>
<a name="l27601"></a>27601   <span class="comment">// The space for metric tensor should be allocated.</span>
<a name="l27602"></a>27602   <span class="comment">// assert(bgm-&gt;sizeoftensor &gt; 0);</span>
<a name="l27603"></a>27603 
<a name="l27604"></a>27604   <span class="comment">// Copy point list.</span>
<a name="l27605"></a>27605   idx2bplist = <span class="keyword">new</span> point[points-&gt;items + 1];
<a name="l27606"></a>27606   idx = in-&gt;firstnumber;
<a name="l27607"></a>27607   points-&gt;traversalinit();
<a name="l27608"></a>27608   ploop = pointtraverse();
<a name="l27609"></a>27609   <span class="keywordflow">while</span> (ploop != (point) NULL) {
<a name="l27610"></a>27610     bgm-&gt;makepoint(&amp;bploop);
<a name="l27611"></a>27611     <span class="comment">// Copy coordinates, attributes.</span>
<a name="l27612"></a>27612     <span class="keywordflow">for</span> (i = 0; i &lt; 3 + in-&gt;numberofpointattributes; i++) {
<a name="l27613"></a>27613       bploop[i] = ploop[i];
<a name="l27614"></a>27614     }
<a name="l27615"></a>27615     <span class="comment">// Transfer the metric tensor.</span>
<a name="l27616"></a>27616     <span class="keywordflow">for</span> (i = 0; i &lt; bgm-&gt;sizeoftensor; i++) {
<a name="l27617"></a>27617       bploop[bgm-&gt;pointmtrindex + i] = ploop[pointmtrindex + i];
<a name="l27618"></a>27618       <span class="comment">// Metric tensor should have a positive value.</span>
<a name="l27619"></a>27619       <span class="keywordflow">if</span> (bploop[bgm-&gt;pointmtrindex + i] &lt;= 0.0) {
<a name="l27620"></a>27620         printf(<span class="stringliteral">&quot;Error:  Point %d has non-positive size %g (-m option).\n&quot;</span>,
<a name="l27621"></a>27621                bgm-&gt;pointmark(bploop), bploop[bgm-&gt;pointmtrindex + i]);
<a name="l27622"></a>27622         terminatetetgen(1);
<a name="l27623"></a>27623       }
<a name="l27624"></a>27624     }
<a name="l27625"></a>27625     <span class="comment">// Remember the point for searching.</span>
<a name="l27626"></a>27626     idx2bplist[idx++] = bploop;
<a name="l27627"></a>27627     ploop = pointtraverse();
<a name="l27628"></a>27628   }
<a name="l27629"></a>27629 
<a name="l27630"></a>27630   <span class="comment">// Copy tetrahedra list.</span>
<a name="l27631"></a>27631   tetptbaklist = <span class="keyword">new</span> point[tetrahedrons-&gt;items + 1];
<a name="l27632"></a>27632   idx = in-&gt;firstnumber;
<a name="l27633"></a>27633   tetrahedrons-&gt;traversalinit();
<a name="l27634"></a>27634   tetloop.tet = tetrahedrontraverse();
<a name="l27635"></a>27635   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l27636"></a>27636     bgm-&gt;maketetrahedron(&amp;btetloop);
<a name="l27637"></a>27637     <span class="comment">// Set the four corners.</span>
<a name="l27638"></a>27638     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l27639"></a>27639       ploop = (point) tetloop.tet[4 + i];
<a name="l27640"></a>27640       bploop = idx2bplist[pointmark(ploop)];
<a name="l27641"></a>27641       btetloop.tet[4 + i] = (tetrahedron) bploop;
<a name="l27642"></a>27642     }
<a name="l27643"></a>27643     <span class="comment">// Remember the tet for setting neighbor connections.</span>
<a name="l27644"></a>27644     tetptbaklist[idx++] = (point) tetloop.tet[4];
<a name="l27645"></a>27645     tetloop.tet[4] = (tetrahedron) btetloop.tet;
<a name="l27646"></a>27646     tetloop.tet = tetrahedrontraverse();
<a name="l27647"></a>27647   }
<a name="l27648"></a>27648 
<a name="l27649"></a>27649   <span class="comment">// Set the connections between background tetrahedra. Create background</span>
<a name="l27650"></a>27650   <span class="comment">//   hull subfaces. Create the map of point-to-bgmtet.</span>
<a name="l27651"></a>27651   idx = in-&gt;firstnumber;
<a name="l27652"></a>27652   tetrahedrons-&gt;traversalinit();
<a name="l27653"></a>27653   tetloop.tet = tetrahedrontraverse();
<a name="l27654"></a>27654   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l27655"></a>27655     <span class="comment">// Get the corresponding background tet.</span>
<a name="l27656"></a>27656     btetloop.tet = (tetrahedron *) tetloop.tet[4];
<a name="l27657"></a>27657     <span class="comment">// Set the four neighbors.</span>
<a name="l27658"></a>27658     for (tetloop.loc = 0; tetloop.loc &lt; 4; tetloop.loc++) {
<a name="l27659"></a>27659       btetloop.loc = tetloop.loc;
<a name="l27660"></a>27660       sym(tetloop, symtet);
<a name="l27661"></a>27661       <span class="keywordflow">if</span> ((symtet.tet != dummytet) &amp;&amp; (symtet.tet &gt; tetloop.tet)) {
<a name="l27662"></a>27662         <span class="comment">// Operate on the un-connected interior face.</span>
<a name="l27663"></a>27663         bsymtet.tet = (tetrahedron *) symtet.tet[4]; <span class="comment">// The saved bgm tet.</span>
<a name="l27664"></a>27664         bsymtet.loc = symtet.loc;
<a name="l27665"></a>27665         bgm-&gt;bond(btetloop, bsymtet);
<a name="l27666"></a>27666       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (symtet.tet == dummytet) {
<a name="l27667"></a>27667         <span class="comment">// Create a subface in background mesh.</span>
<a name="l27668"></a>27668         bgm-&gt;makeshellface(bgm-&gt;subfaces, &amp;bhullsh);
<a name="l27669"></a>27669         bgm-&gt;adjustedgering(btetloop, CCW); <span class="comment">// face to inside.</span>
<a name="l27670"></a>27670         bgm-&gt;setsorg(bhullsh, bgm-&gt;org(btetloop));
<a name="l27671"></a>27671         bgm-&gt;setsdest(bhullsh, bgm-&gt;dest(btetloop));
<a name="l27672"></a>27672         bgm-&gt;setsapex(bhullsh, bgm-&gt;apex(btetloop));
<a name="l27673"></a>27673         bgm-&gt;tsbond(btetloop, bhullsh);
<a name="l27674"></a>27674         <span class="comment">// Remember a hull face for point location.</span>
<a name="l27675"></a>27675         bgm-&gt;dummytet[0] = bgm-&gt;encode(btetloop);
<a name="l27676"></a>27676       }
<a name="l27677"></a>27677     }
<a name="l27678"></a>27678     <span class="comment">// Restore the backup tet point.</span>
<a name="l27679"></a>27679     tetloop.tet[4] = (tetrahedron) tetptbaklist[idx++];
<a name="l27680"></a>27680     <span class="comment">// Make the point-to-bgmtet map for size interpolation.</span>
<a name="l27681"></a>27681     btetloop.loc = 0;
<a name="l27682"></a>27682     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l27683"></a>27683       ploop = (point) tetloop.tet[4 + i];
<a name="l27684"></a>27684       setpoint2bgmtet(ploop, bgm-&gt;encode(btetloop));
<a name="l27685"></a>27685     }
<a name="l27686"></a>27686     <span class="comment">// Go to the next tet, btet.</span>
<a name="l27687"></a>27687     tetloop.tet = tetrahedrontraverse();
<a name="l27688"></a>27688   }
<a name="l27689"></a>27689 
<a name="l27690"></a>27690   <span class="comment">// Connect bgm hull subfaces. Note: all hull subfaces form a 2-manifold.</span>
<a name="l27691"></a>27691   bgm-&gt;subfaces-&gt;traversalinit();
<a name="l27692"></a>27692   bhullsh.sh = bgm-&gt;shellfacetraverse(bgm-&gt;subfaces);
<a name="l27693"></a>27693   <span class="keywordflow">while</span> (bhullsh.sh != (shellface *) NULL) {
<a name="l27694"></a>27694     bhullsh.shver = 0;
<a name="l27695"></a>27695     bgm-&gt;stpivot(bhullsh, btetloop);
<a name="l27696"></a>27696     assert(btetloop.tet != bgm-&gt;dummytet);
<a name="l27697"></a>27697     bgm-&gt;adjustedgering(btetloop, CCW);
<a name="l27698"></a>27698     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l27699"></a>27699       bgm-&gt;spivot(bhullsh, bneighsh);
<a name="l27700"></a>27700       <span class="keywordflow">if</span> (bneighsh.sh == bgm-&gt;dummysh) {
<a name="l27701"></a>27701         <span class="comment">// This side is open, operate on it.</span>
<a name="l27702"></a>27702         bsymtet = btetloop;
<a name="l27703"></a>27703         <span class="keywordflow">while</span> (bgm-&gt;fnextself(bsymtet));
<a name="l27704"></a>27704         bgm-&gt;tspivot(bsymtet, bneighsh);
<a name="l27705"></a>27705         bgm-&gt;findedge(&amp;bneighsh, bgm-&gt;sdest(bhullsh), bgm-&gt;sorg(bhullsh));
<a name="l27706"></a>27706         bgm-&gt;sbond(bhullsh, bneighsh);
<a name="l27707"></a>27707       }
<a name="l27708"></a>27708       bgm-&gt;enextself(btetloop);
<a name="l27709"></a>27709       bgm-&gt;senextself(bhullsh);
<a name="l27710"></a>27710     }
<a name="l27711"></a>27711     bhullsh.sh = bgm-&gt;shellfacetraverse(bgm-&gt;subfaces);
<a name="l27712"></a>27712   }
<a name="l27713"></a>27713 
<a name="l27714"></a>27714   <span class="keyword">delete</span> [] tetptbaklist;
<a name="l27715"></a>27715   <span class="keyword">delete</span> [] idx2bplist;
<a name="l27716"></a>27716 }
<a name="l27717"></a>27717 
<a name="l27718"></a>27718 <span class="comment">//</span>
<a name="l27719"></a>27719 <span class="comment">// Begin of Delaunay refinement routines</span>
<a name="l27720"></a>27720 <span class="comment">//</span>
<a name="l27721"></a>27721 
<a name="l27723"></a>27723 <span class="comment">//                                                                           //</span>
<a name="l27724"></a>27724 <span class="comment">// marksharpsegments()    Mark sharp segments.                               //</span>
<a name="l27725"></a>27725 <span class="comment">//                                                                           //</span>
<a name="l27726"></a>27726 <span class="comment">// A segment s is called sharp if it is in one of the two cases:             //</span>
<a name="l27727"></a>27727 <span class="comment">//  (1) There is a segment s&#39; intersecting with s.  The internal angle (*)   //</span>
<a name="l27728"></a>27728 <span class="comment">//      between s and s&#39; is acute.                                           //</span>
<a name="l27729"></a>27729 <span class="comment">//  (2) There are two facets f1 and f2 intersecting at s.  The internal      //</span>
<a name="l27730"></a>27730 <span class="comment">//      dihedral angle (*) between f1 and f2 is acute.                       //</span>
<a name="l27731"></a>27731 <span class="comment">// This routine finds the sharp segments and marked them as type SHARP.      //</span>
<a name="l27732"></a>27732 <span class="comment">// The minimum angle between segments (minfaceang) and the minimum dihedral  //</span>
<a name="l27733"></a>27733 <span class="comment">// angle between facets (minfacetdihed) are calulcated.                      //</span>
<a name="l27734"></a>27734 <span class="comment">//                                                                           //</span>
<a name="l27735"></a>27735 <span class="comment">// (*) The internal angle (or dihedral) bewteen two features means the angle //</span>
<a name="l27736"></a>27736 <span class="comment">// inside the mesh domain.                                                   //</span>
<a name="l27737"></a>27737 <span class="comment">//                                                                           //</span>
<a name="l27739"></a>27739 <span class="comment"></span>
<a name="l27740"></a>27740 <span class="keywordtype">void</span> tetgenmesh::marksharpsegments(REAL sharpangle)
<a name="l27741"></a>27741 {
<a name="l27742"></a>27742   triface adjtet;
<a name="l27743"></a>27743   face startsh, spinsh, neighsh;
<a name="l27744"></a>27744   face segloop, prevseg, nextseg;
<a name="l27745"></a>27745   point eorg, edest;
<a name="l27746"></a>27746   REAL ang, smallang;
<a name="l27747"></a>27747   <span class="keywordtype">bool</span> issharp;
<a name="l27748"></a>27748   <span class="keywordtype">int</span> sharpsegcount;
<a name="l27749"></a>27749 
<a name="l27750"></a>27750   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l27751"></a>27751     printf(<span class="stringliteral">&quot;  Marking sharp segments.\n&quot;</span>);
<a name="l27752"></a>27752   }
<a name="l27753"></a>27753 
<a name="l27754"></a>27754   smallang = sharpangle * PI / 180.;
<a name="l27755"></a>27755   sharpsegcount = 0;
<a name="l27756"></a>27756   eorg = edest = (point) NULL; <span class="comment">// To avoid compiler warnings.</span>
<a name="l27757"></a>27757 
<a name="l27758"></a>27758   <span class="comment">// A segment s may have been split into many subsegments. Operate the one</span>
<a name="l27759"></a>27759   <span class="comment">//   which contains the origin of s. Then mark the rest of subsegments.</span>
<a name="l27760"></a>27760   subsegs-&gt;traversalinit();
<a name="l27761"></a>27761   segloop.sh = shellfacetraverse(subsegs);
<a name="l27762"></a>27762   <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l27763"></a>27763     segloop.shver = 0;
<a name="l27764"></a>27764     senext2(segloop, prevseg);
<a name="l27765"></a>27765     spivotself(prevseg);
<a name="l27766"></a>27766     <span class="keywordflow">if</span> (prevseg.sh == dummysh) {
<a name="l27767"></a>27767       <span class="comment">// Operate on this seg s.</span>
<a name="l27768"></a>27768       assert(shelltype(segloop) != SHARP); <span class="comment">// It should be unmarked.</span>
<a name="l27769"></a>27769       issharp = <span class="keyword">false</span>;
<a name="l27770"></a>27770       spivot(segloop, startsh);
<a name="l27771"></a>27771       <span class="keywordflow">if</span> (startsh.sh != dummysh) {
<a name="l27772"></a>27772         <span class="comment">// First check if two facets form an acute dihedral angle at s.</span>
<a name="l27773"></a>27773         eorg = sorg(segloop);
<a name="l27774"></a>27774         edest = sdest(segloop);
<a name="l27775"></a>27775         spinsh = startsh;
<a name="l27776"></a>27776         <span class="keywordflow">do</span> {
<a name="l27777"></a>27777           <span class="keywordflow">if</span> (sorg(spinsh) != eorg) {
<a name="l27778"></a>27778             sesymself(spinsh);
<a name="l27779"></a>27779           }
<a name="l27780"></a>27780           <span class="comment">// Only do test when the spinsh is faceing inward.</span>
<a name="l27781"></a>27781           stpivot(spinsh, adjtet);
<a name="l27782"></a>27782           <span class="keywordflow">if</span> (adjtet.tet != dummytet) {
<a name="l27783"></a>27783             <span class="comment">// Get the subface on the adjacent facet.</span>
<a name="l27784"></a>27784             spivot(spinsh, neighsh);
<a name="l27785"></a>27785             <span class="comment">// Do not calculate if it is self-bonded.</span>
<a name="l27786"></a>27786             <span class="keywordflow">if</span> (neighsh.sh != spinsh.sh) {
<a name="l27787"></a>27787               <span class="comment">// Calculate the dihedral angle between the two subfaces.</span>
<a name="l27788"></a>27788               ang = facedihedral(eorg, edest, sapex(spinsh), sapex(neighsh));
<a name="l27789"></a>27789               <span class="comment">// Only do check if a sharp angle has not been found.</span>
<a name="l27790"></a>27790               <span class="keywordflow">if</span> (!issharp) issharp = (ang &lt; smallang);
<a name="l27791"></a>27791               <span class="comment">// Remember the smallest facet dihedral angle.</span>
<a name="l27792"></a>27792               minfacetdihed = minfacetdihed &lt; ang ? minfacetdihed : ang;
<a name="l27793"></a>27793             }
<a name="l27794"></a>27794           }
<a name="l27795"></a>27795           <span class="comment">// Go to the next facet.</span>
<a name="l27796"></a>27796           spivotself(spinsh);
<a name="l27797"></a>27797         } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l27798"></a>27798         <span class="comment">// if (!issharp) {</span>
<a name="l27799"></a>27799           <span class="comment">// Second check if s forms an acute angle with another seg.</span>
<a name="l27800"></a>27800           spinsh = startsh;
<a name="l27801"></a>27801           <span class="keywordflow">do</span> {
<a name="l27802"></a>27802             <span class="keywordflow">if</span> (sorg(spinsh) != eorg) {
<a name="l27803"></a>27803               sesymself(spinsh);
<a name="l27804"></a>27804             }
<a name="l27805"></a>27805             <span class="comment">// Calculate the angle between s and s&#39; of this facet.</span>
<a name="l27806"></a>27806             neighsh = spinsh;
<a name="l27807"></a>27807             <span class="comment">// Rotate edges around &#39;eorg&#39; until meeting another seg s&#39;. Such</span>
<a name="l27808"></a>27808             <span class="comment">//   seg (s&#39;) must exist since the facet is segment-bounded.</span>
<a name="l27809"></a>27809             <span class="comment">//   The sum of the angles of faces at &#39;eorg&#39; gives the internal</span>
<a name="l27810"></a>27810             <span class="comment">//   angle between the two segments.</span>
<a name="l27811"></a>27811             ang = 0.0;
<a name="l27812"></a>27812             <span class="keywordflow">do</span> {
<a name="l27813"></a>27813               ang += interiorangle(eorg, sdest(neighsh), sapex(neighsh), NULL);
<a name="l27814"></a>27814               senext2self(neighsh);
<a name="l27815"></a>27815               sspivot(neighsh, nextseg);
<a name="l27816"></a>27816               <span class="keywordflow">if</span> (nextseg.sh != dummysh) <span class="keywordflow">break</span>;
<a name="l27817"></a>27817               <span class="comment">// Go to the next coplanar subface.</span>
<a name="l27818"></a>27818               spivotself(neighsh);
<a name="l27819"></a>27819               assert(neighsh.sh != dummysh);
<a name="l27820"></a>27820               <span class="keywordflow">if</span> (sorg(neighsh) != eorg) {
<a name="l27821"></a>27821                 sesymself(neighsh);
<a name="l27822"></a>27822               }
<a name="l27823"></a>27823             } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l27824"></a>27824             <span class="comment">// Only do check if a sharp angle has not been found.</span>
<a name="l27825"></a>27825             <span class="keywordflow">if</span> (!issharp) issharp = (ang &lt; smallang);
<a name="l27826"></a>27826             <span class="comment">// Remember the smallest input face angle.</span>
<a name="l27827"></a>27827             minfaceang = minfaceang &lt; ang ? minfaceang : ang;
<a name="l27828"></a>27828             <span class="comment">// Go to the next facet.</span>
<a name="l27829"></a>27829             spivotself(spinsh);
<a name="l27830"></a>27830           } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l27831"></a>27831         <span class="comment">// }</span>
<a name="l27832"></a>27832       }
<a name="l27833"></a>27833       <span class="keywordflow">if</span> (issharp) {
<a name="l27834"></a>27834         setshelltype(segloop, SHARP);
<a name="l27835"></a>27835         <span class="comment">// Set the type for all subsegments at forwards.</span>
<a name="l27836"></a>27836         senext(segloop, nextseg);
<a name="l27837"></a>27837         spivotself(nextseg);
<a name="l27838"></a>27838         <span class="keywordflow">while</span> (nextseg.sh != dummysh) {
<a name="l27839"></a>27839           nextseg.shver = 0;
<a name="l27840"></a>27840           setshelltype(nextseg, SHARP);
<a name="l27841"></a>27841           senextself(nextseg);
<a name="l27842"></a>27842           spivotself(nextseg);
<a name="l27843"></a>27843         }
<a name="l27844"></a>27844         sharpsegcount++;
<a name="l27845"></a>27845       }
<a name="l27846"></a>27846     }
<a name="l27847"></a>27847     segloop.sh = shellfacetraverse(subsegs);
<a name="l27848"></a>27848   }
<a name="l27849"></a>27849 
<a name="l27850"></a>27850   <span class="comment">// So far we have marked all segments which have an acute dihedral angle</span>
<a name="l27851"></a>27851   <span class="comment">//   or whose ORIGINs have an acute angle. In the un-marked subsegments,</span>
<a name="l27852"></a>27852   <span class="comment">//   there are possible ones whose DESTINATIONs have an acute angle.</span>
<a name="l27853"></a>27853   subsegs-&gt;traversalinit();
<a name="l27854"></a>27854   segloop.sh = shellfacetraverse(subsegs);
<a name="l27855"></a>27855   <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l27856"></a>27856     <span class="comment">// Only operate if s is non-sharp and contains the dest.</span>
<a name="l27857"></a>27857     segloop.shver = 0;
<a name="l27858"></a>27858     senext(segloop, nextseg);
<a name="l27859"></a>27859     spivotself(nextseg);
<a name="l27860"></a>27860     <span class="comment">// if ((nextseg.sh == dummysh) &amp;&amp; (shelltype(segloop) != SHARP)) {</span>
<a name="l27861"></a>27861     <span class="keywordflow">if</span> (nextseg.sh == dummysh) {
<a name="l27862"></a>27862       <span class="comment">// issharp = false;</span>
<a name="l27863"></a>27863       issharp = (shelltype(segloop) == SHARP);
<a name="l27864"></a>27864       spivot(segloop, startsh);
<a name="l27865"></a>27865       <span class="keywordflow">if</span> (startsh.sh != dummysh) {
<a name="l27866"></a>27866         <span class="comment">// Check if s forms an acute angle with another seg.</span>
<a name="l27867"></a>27867         eorg = sdest(segloop);
<a name="l27868"></a>27868         spinsh = startsh;
<a name="l27869"></a>27869         <span class="keywordflow">do</span> {
<a name="l27870"></a>27870           <span class="keywordflow">if</span> (sorg(spinsh) != eorg) {
<a name="l27871"></a>27871             sesymself(spinsh);
<a name="l27872"></a>27872           }
<a name="l27873"></a>27873           <span class="comment">// Calculate the angle between s and s&#39; of this facet.</span>
<a name="l27874"></a>27874           neighsh = spinsh;
<a name="l27875"></a>27875           ang = 0.0;
<a name="l27876"></a>27876           <span class="keywordflow">do</span> {
<a name="l27877"></a>27877             ang += interiorangle(eorg, sdest(neighsh), sapex(neighsh), NULL);
<a name="l27878"></a>27878             senext2self(neighsh);
<a name="l27879"></a>27879             sspivot(neighsh, nextseg);
<a name="l27880"></a>27880             <span class="keywordflow">if</span> (nextseg.sh != dummysh) <span class="keywordflow">break</span>;
<a name="l27881"></a>27881             <span class="comment">// Go to the next coplanar subface.</span>
<a name="l27882"></a>27882             spivotself(neighsh);
<a name="l27883"></a>27883             assert(neighsh.sh != dummysh);
<a name="l27884"></a>27884             <span class="keywordflow">if</span> (sorg(neighsh) != eorg) {
<a name="l27885"></a>27885               sesymself(neighsh);
<a name="l27886"></a>27886             }
<a name="l27887"></a>27887           } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l27888"></a>27888           <span class="comment">// Only do check if a sharp angle has not been found.</span>
<a name="l27889"></a>27889           <span class="keywordflow">if</span> (!issharp) issharp = (ang &lt; smallang);
<a name="l27890"></a>27890           <span class="comment">// Remember the smallest input face angle.</span>
<a name="l27891"></a>27891           minfaceang = minfaceang &lt; ang ? minfaceang : ang;
<a name="l27892"></a>27892           <span class="comment">// Go to the next facet.</span>
<a name="l27893"></a>27893           spivotself(spinsh);
<a name="l27894"></a>27894         } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l27895"></a>27895       }
<a name="l27896"></a>27896       <span class="keywordflow">if</span> (issharp) {
<a name="l27897"></a>27897         setshelltype(segloop, SHARP);
<a name="l27898"></a>27898         <span class="comment">// Set the type for all subsegments at backwards.</span>
<a name="l27899"></a>27899         senext2(segloop, prevseg);
<a name="l27900"></a>27900         spivotself(prevseg);
<a name="l27901"></a>27901         <span class="keywordflow">while</span> (prevseg.sh != dummysh) {
<a name="l27902"></a>27902           prevseg.shver = 0;
<a name="l27903"></a>27903           setshelltype(prevseg, SHARP);
<a name="l27904"></a>27904           senext2self(prevseg);
<a name="l27905"></a>27905           spivotself(prevseg);
<a name="l27906"></a>27906         }
<a name="l27907"></a>27907         sharpsegcount++;
<a name="l27908"></a>27908       }
<a name="l27909"></a>27909     }
<a name="l27910"></a>27910     segloop.sh = shellfacetraverse(subsegs);
<a name="l27911"></a>27911   }
<a name="l27912"></a>27912 
<a name="l27913"></a>27913   <span class="keywordflow">if</span> ((b-&gt;verbose &gt; 0) &amp;&amp; (sharpsegcount &gt; 0)) {
<a name="l27914"></a>27914     printf(<span class="stringliteral">&quot;  %d sharp segments.\n&quot;</span>, sharpsegcount);
<a name="l27915"></a>27915   }
<a name="l27916"></a>27916 }
<a name="l27917"></a>27917 
<a name="l27919"></a>27919 <span class="comment">//                                                                           //</span>
<a name="l27920"></a>27920 <span class="comment">// decidefeaturepointsizes()    Decide the sizes for all feature points.     //</span>
<a name="l27921"></a>27921 <span class="comment">//                                                                           //</span>
<a name="l27922"></a>27922 <span class="comment">// A feature point is a point on a sharp segment. Every feature point p will //</span>
<a name="l27923"></a>27923 <span class="comment">// be assigned a positive size which is the radius of the protecting ball.   //</span>
<a name="l27924"></a>27924 <span class="comment">//                                                                           //</span>
<a name="l27925"></a>27925 <span class="comment">// The size of a feature point may be specified by one of the following ways://</span>
<a name="l27926"></a>27926 <span class="comment">//   (1) directly specifying on an input vertex (by using .mtr file);        //</span>
<a name="l27927"></a>27927 <span class="comment">//   (2) imposing a fixed maximal volume constraint (&#39;-a__&#39; option);         //</span>
<a name="l27928"></a>27928 <span class="comment">//   (3) imposing a maximal volume constraint in a region (&#39;-a&#39; option);     //</span>
<a name="l27929"></a>27929 <span class="comment">//   (4) imposing a maximal area constraint on a facet (in .var file);       //</span>
<a name="l27930"></a>27930 <span class="comment">//   (5) imposing a maximal length constraint on a segment (in .var file);   //</span>
<a name="l27931"></a>27931 <span class="comment">//   (6) combining (1) - (5).                                                //</span>
<a name="l27932"></a>27932 <span class="comment">//   (7) automatically deriving a size if none of (1) - (6) is available.    //</span>
<a name="l27933"></a>27933 <span class="comment">// In case (7),the size of p is set to be the smallest edge length among all //</span>
<a name="l27934"></a>27934 <span class="comment">// edges connecting at p.  The final size of p is the minimum of (1) - (7).  //</span>
<a name="l27935"></a>27935 <span class="comment">//                                                                           //</span>
<a name="l27937"></a>27937 <span class="comment"></span>
<a name="l27938"></a>27938 <span class="keywordtype">void</span> tetgenmesh::decidefeaturepointsizes()
<a name="l27939"></a>27939 {
<a name="l27940"></a>27940   list *tetlist, *verlist;
<a name="l27941"></a>27941   shellface **segsperverlist;
<a name="l27942"></a>27942   triface starttet;
<a name="l27943"></a>27943   face shloop;
<a name="l27944"></a>27944   face checkseg, prevseg, nextseg, testseg;
<a name="l27945"></a>27945   point ploop, adjpt, e1, e2;
<a name="l27946"></a>27946   REAL lfs_0, len, vol, maxlen, varlen;
<a name="l27947"></a>27947   <span class="keywordtype">bool</span> isfeature;
<a name="l27948"></a>27948   <span class="keywordtype">int</span> *idx2seglist;
<a name="l27949"></a>27949   <span class="keywordtype">int</span> featurecount;
<a name="l27950"></a>27950   <span class="keywordtype">int</span> idx, i, j;
<a name="l27951"></a>27951 
<a name="l27952"></a>27952   maxlen = 0.0;
<a name="l27953"></a>27953 
<a name="l27954"></a>27954   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l27955"></a>27955     printf(<span class="stringliteral">&quot;  Deciding feature-point sizes.\n&quot;</span>);
<a name="l27956"></a>27956   }
<a name="l27957"></a>27957 
<a name="l27958"></a>27958   <span class="comment">// Constructing a map from vertices to segments.</span>
<a name="l27959"></a>27959   makesegmentmap(idx2seglist, segsperverlist);
<a name="l27960"></a>27960   <span class="comment">// Initialize working lists.</span>
<a name="l27961"></a>27961   tetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l27962"></a>27962   verlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL, 256);
<a name="l27963"></a>27963 
<a name="l27964"></a>27964   <span class="keywordflow">if</span> (b-&gt;fixedvolume) {
<a name="l27965"></a>27965     <span class="comment">// A fixed volume constraint is imposed. This gives an upper bound of</span>
<a name="l27966"></a>27966     <span class="comment">//   the maximal radius of the protect ball of a vertex.</span>
<a name="l27967"></a>27967     maxlen = pow(6.0 * b-&gt;maxvolume, 1.0/3.0);
<a name="l27968"></a>27968   }
<a name="l27969"></a>27969 
<a name="l27970"></a>27970   <span class="keywordflow">if</span> (!b-&gt;refine) {
<a name="l27971"></a>27971     <span class="comment">// Initially correct types for Steiner points.</span>
<a name="l27972"></a>27972     featurecount = 0;
<a name="l27973"></a>27973     points-&gt;traversalinit();
<a name="l27974"></a>27974     ploop = pointtraverse();
<a name="l27975"></a>27975     <span class="keywordflow">while</span> (ploop != (point) NULL) {
<a name="l27976"></a>27976       <span class="keywordflow">if</span> (pointtype(ploop) == NACUTEVERTEX) {
<a name="l27977"></a>27977         <span class="keywordflow">if</span> (point2sh(ploop) != (shellface) NULL) {
<a name="l27978"></a>27978           setpointtype(ploop, FREESEGVERTEX);
<a name="l27979"></a>27979           featurecount++;
<a name="l27980"></a>27980         }
<a name="l27981"></a>27981       }
<a name="l27982"></a>27982       ploop = pointtraverse();
<a name="l27983"></a>27983     }
<a name="l27984"></a>27984 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l27985"></a>27985 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ((b-&gt;verbose &gt; 0) &amp;&amp; (featurecount &gt; 0)) {
<a name="l27986"></a>27986       printf(<span class="stringliteral">&quot;  %d Steiner points correction.\n&quot;</span>, featurecount);
<a name="l27987"></a>27987     }
<a name="l27988"></a>27988 <span class="preprocessor">#endif</span>
<a name="l27989"></a>27989 <span class="preprocessor"></span>  }
<a name="l27990"></a>27990 
<a name="l27991"></a>27991   <span class="comment">// First only assign a size of p if p is not a Steiner point. The size of</span>
<a name="l27992"></a>27992   <span class="comment">//   a Steiner point will be interpolated later from the endpoints of the</span>
<a name="l27993"></a>27993   <span class="comment">//   segment on which it lies.</span>
<a name="l27994"></a>27994   featurecount = 0;
<a name="l27995"></a>27995   points-&gt;traversalinit();
<a name="l27996"></a>27996   ploop = pointtraverse();
<a name="l27997"></a>27997   <span class="keywordflow">while</span> (ploop != (point) NULL) {
<a name="l27998"></a>27998     <span class="keywordflow">if</span> (pointtype(ploop) != FREESEGVERTEX) {
<a name="l27999"></a>27999       <span class="comment">// Is p a feature point?</span>
<a name="l28000"></a>28000       isfeature = <span class="keyword">false</span>;
<a name="l28001"></a>28001       idx = pointmark(ploop) - in-&gt;firstnumber;
<a name="l28002"></a>28002       <span class="keywordflow">for</span> (i = idx2seglist[idx]; i &lt; idx2seglist[idx + 1] &amp;&amp; !isfeature; i++) {
<a name="l28003"></a>28003         checkseg.sh = segsperverlist[i];
<a name="l28004"></a>28004         isfeature = (shelltype(checkseg) == SHARP);
<a name="l28005"></a>28005       }
<a name="l28006"></a>28006       <span class="comment">// Decide the size of p if it is on a sharp segment.</span>
<a name="l28007"></a>28007       <span class="keywordflow">if</span> (isfeature) {
<a name="l28008"></a>28008         <span class="comment">// Find a tet containing p (checkseg is a sharp seg which contains p).</span>
<a name="l28009"></a>28009         sstpivot(&amp;checkseg, &amp;starttet);
<a name="l28010"></a>28010         <span class="comment">// Form star(p).</span>
<a name="l28011"></a>28011         tetlist-&gt;append(&amp;starttet);
<a name="l28012"></a>28012         formstarpolyhedron(ploop, tetlist, verlist, <span class="keyword">true</span>);
<a name="l28013"></a>28013         <span class="comment">// Decide the size for p if no input size is given on input.</span>
<a name="l28014"></a>28014         <span class="keywordflow">if</span> (ploop[pointmtrindex] == 0.0) {
<a name="l28015"></a>28015           <span class="comment">// Calculate lfs_0(p).</span>
<a name="l28016"></a>28016           lfs_0 = longest;
<a name="l28017"></a>28017           <span class="keywordflow">for</span> (i = 0; i &lt; verlist-&gt;len(); i++) {
<a name="l28018"></a>28018             adjpt = * (point *)(* verlist)[i];
<a name="l28019"></a>28019             <span class="keywordflow">if</span> (pointtype(adjpt) == FREESEGVERTEX) {
<a name="l28020"></a>28020               <span class="comment">// A Steiner point q. Find the seg it lies on.</span>
<a name="l28021"></a>28021               sdecode(point2sh(adjpt), checkseg);
<a name="l28022"></a>28022               assert(checkseg.sh != dummysh);
<a name="l28023"></a>28023               checkseg.shver = 0;
<a name="l28024"></a>28024               <span class="comment">// Find the origin of this seg.</span>
<a name="l28025"></a>28025               prevseg = checkseg;
<a name="l28026"></a>28026               <span class="keywordflow">do</span> {
<a name="l28027"></a>28027                 senext2(prevseg, testseg);
<a name="l28028"></a>28028                 spivotself(testseg);
<a name="l28029"></a>28029                 <span class="keywordflow">if</span> (testseg.sh == dummysh) <span class="keywordflow">break</span>;
<a name="l28030"></a>28030                 prevseg = testseg; <span class="comment">// Go to the previous subseg.</span>
<a name="l28031"></a>28031                 prevseg.shver = 0;
<a name="l28032"></a>28032               } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l28033"></a>28033               <span class="comment">// Find the dest of this seg.</span>
<a name="l28034"></a>28034               nextseg = checkseg;
<a name="l28035"></a>28035               <span class="keywordflow">do</span> {
<a name="l28036"></a>28036                 senext(nextseg, testseg);
<a name="l28037"></a>28037                 spivotself(testseg);
<a name="l28038"></a>28038                 <span class="keywordflow">if</span> (testseg.sh == dummysh) <span class="keywordflow">break</span>;
<a name="l28039"></a>28039                 nextseg = testseg; <span class="comment">// Go to the next subseg.</span>
<a name="l28040"></a>28040                 nextseg.shver = 0;
<a name="l28041"></a>28041               } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l28042"></a>28042               e1 = sorg(prevseg);
<a name="l28043"></a>28043               e2 = sdest(nextseg);
<a name="l28044"></a>28044               <span class="comment">// Check if p is the origin or the dest of this seg.</span>
<a name="l28045"></a>28045               <span class="keywordflow">if</span> (ploop == e1) {
<a name="l28046"></a>28046                 <span class="comment">// Set q to be the dest of this seg.</span>
<a name="l28047"></a>28047                 adjpt = e2;
<a name="l28048"></a>28048               } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ploop == e2) {
<a name="l28049"></a>28049                 <span class="comment">// Set q to be the org of this seg.</span>
<a name="l28050"></a>28050                 adjpt = e1;
<a name="l28051"></a>28051               }
<a name="l28052"></a>28052             }
<a name="l28053"></a>28053             len = distance(ploop, adjpt);
<a name="l28054"></a>28054             <span class="keywordflow">if</span> (lfs_0 &gt; len) lfs_0 = len;
<a name="l28055"></a>28055           }
<a name="l28056"></a>28056           ploop[pointmtrindex] = lfs_0;
<a name="l28057"></a>28057         }
<a name="l28058"></a>28058         <span class="keywordflow">if</span> (b-&gt;fixedvolume) {
<a name="l28059"></a>28059           <span class="comment">// A fixed volume constraint is imposed. Adjust H(p) &lt;= maxlen.</span>
<a name="l28060"></a>28060           <span class="keywordflow">if</span> (ploop[pointmtrindex] &gt; maxlen) {
<a name="l28061"></a>28061             ploop[pointmtrindex] = maxlen;
<a name="l28062"></a>28062           }
<a name="l28063"></a>28063         }
<a name="l28064"></a>28064         <span class="keywordflow">if</span> (b-&gt;varvolume) {
<a name="l28065"></a>28065           <span class="comment">// Variant volume constraints are imposed. Adjust H(p) &lt;= varlen.</span>
<a name="l28066"></a>28066           <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l28067"></a>28067             starttet = * (triface *)(* tetlist)[i];
<a name="l28068"></a>28068             vol = volumebound(starttet.tet);
<a name="l28069"></a>28069             <span class="keywordflow">if</span> (vol &gt; 0.0) {
<a name="l28070"></a>28070               varlen = pow(6 * vol, 1.0/3.0);
<a name="l28071"></a>28071               <span class="keywordflow">if</span> (ploop[pointmtrindex] &gt; varlen) {
<a name="l28072"></a>28072                 ploop[pointmtrindex] = varlen;
<a name="l28073"></a>28073               }
<a name="l28074"></a>28074             }
<a name="l28075"></a>28075           }
<a name="l28076"></a>28076         }
<a name="l28077"></a>28077         <span class="comment">// Clear working lists.</span>
<a name="l28078"></a>28078         tetlist-&gt;clear();
<a name="l28079"></a>28079         verlist-&gt;clear();
<a name="l28080"></a>28080         featurecount++;
<a name="l28081"></a>28081       } <span class="keywordflow">else</span> {
<a name="l28082"></a>28082         <span class="comment">// NO feature point, set the size of p be zero.</span>
<a name="l28083"></a>28083         ploop[pointmtrindex] = 0.0;
<a name="l28084"></a>28084       }
<a name="l28085"></a>28085     } <span class="comment">// if (pointtype(ploop) != FREESEGVERTEX) {</span>
<a name="l28086"></a>28086     ploop = pointtraverse();
<a name="l28087"></a>28087   }
<a name="l28088"></a>28088 
<a name="l28089"></a>28089   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l28090"></a>28090     printf(<span class="stringliteral">&quot;  %d feature points.\n&quot;</span>, featurecount);
<a name="l28091"></a>28091   }
<a name="l28092"></a>28092 
<a name="l28093"></a>28093   <span class="keywordflow">if</span> (!b-&gt;refine) {
<a name="l28094"></a>28094     <span class="comment">// Second only assign sizes for all Steiner points. A Steiner point p</span>
<a name="l28095"></a>28095     <span class="comment">//   inserted on a sharp segment s is assigned a size by interpolating</span>
<a name="l28096"></a>28096     <span class="comment">//   the sizes of the original endpoints of s.</span>
<a name="l28097"></a>28097     featurecount = 0;
<a name="l28098"></a>28098     points-&gt;traversalinit();
<a name="l28099"></a>28099     ploop = pointtraverse();
<a name="l28100"></a>28100     <span class="keywordflow">while</span> (ploop != (point) NULL) {
<a name="l28101"></a>28101       <span class="keywordflow">if</span> (pointtype(ploop) == FREESEGVERTEX) {
<a name="l28102"></a>28102         <span class="keywordflow">if</span> (ploop[pointmtrindex] == 0.0) {
<a name="l28103"></a>28103           sdecode(point2sh(ploop), checkseg);
<a name="l28104"></a>28104           assert(checkseg.sh != dummysh);
<a name="l28105"></a>28105           <span class="keywordflow">if</span> (shelltype(checkseg) == SHARP) {
<a name="l28106"></a>28106             checkseg.shver = 0;
<a name="l28107"></a>28107             <span class="comment">// Find the origin of this seg.</span>
<a name="l28108"></a>28108             prevseg = checkseg;
<a name="l28109"></a>28109             <span class="keywordflow">do</span> {
<a name="l28110"></a>28110               senext2(prevseg, testseg);
<a name="l28111"></a>28111               spivotself(testseg);
<a name="l28112"></a>28112               <span class="keywordflow">if</span> (testseg.sh == dummysh) <span class="keywordflow">break</span>;
<a name="l28113"></a>28113               prevseg = testseg; <span class="comment">// Go the previous subseg.</span>
<a name="l28114"></a>28114               prevseg.shver = 0;
<a name="l28115"></a>28115             } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l28116"></a>28116             <span class="comment">// Find the dest of this seg.</span>
<a name="l28117"></a>28117             nextseg = checkseg;
<a name="l28118"></a>28118             <span class="keywordflow">do</span> {
<a name="l28119"></a>28119               senext(nextseg, testseg);
<a name="l28120"></a>28120               spivotself(testseg);
<a name="l28121"></a>28121               <span class="keywordflow">if</span> (testseg.sh == dummysh) <span class="keywordflow">break</span>;
<a name="l28122"></a>28122               nextseg = testseg; <span class="comment">// Go the next subseg.</span>
<a name="l28123"></a>28123               nextseg.shver = 0;
<a name="l28124"></a>28124             } <span class="keywordflow">while</span> (<span class="keyword">true</span>);
<a name="l28125"></a>28125             e1 = sorg(prevseg);
<a name="l28126"></a>28126             e2 = sdest(nextseg);
<a name="l28127"></a>28127             len = distance(e1, e2);
<a name="l28128"></a>28128             lfs_0 = distance(e1, ploop);
<a name="l28129"></a>28129             <span class="comment">// The following assert() happens when -Y option is used.</span>
<a name="l28130"></a>28130             <span class="keywordflow">if</span> (b-&gt;nobisect == 0) {
<a name="l28131"></a>28131               assert(lfs_0 &lt; len);
<a name="l28132"></a>28132             }
<a name="l28133"></a>28133             ploop[pointmtrindex] = e1[pointmtrindex]
<a name="l28134"></a>28134               + (lfs_0 / len) * (e2[pointmtrindex] - e1[pointmtrindex]);
<a name="l28135"></a>28135             featurecount++;
<a name="l28136"></a>28136           } <span class="keywordflow">else</span> {
<a name="l28137"></a>28137             <span class="comment">// NO feature point, set the size of p be zero.</span>
<a name="l28138"></a>28138             ploop[pointmtrindex] = 0.0;
<a name="l28139"></a>28139           } <span class="comment">// if (shelltype(checkseg) == SHARP)</span>
<a name="l28140"></a>28140         } <span class="comment">// if (ploop[pointmtrindex] == 0.0)</span>
<a name="l28141"></a>28141       } <span class="comment">// if (pointtype(ploop) != FREESEGVERTEX)</span>
<a name="l28142"></a>28142       ploop = pointtraverse();
<a name="l28143"></a>28143     }
<a name="l28144"></a>28144     <span class="keywordflow">if</span> ((b-&gt;verbose &gt; 0) &amp;&amp; (featurecount &gt; 0)) {
<a name="l28145"></a>28145       printf(<span class="stringliteral">&quot;  %d Steiner feature points.\n&quot;</span>, featurecount);
<a name="l28146"></a>28146     }
<a name="l28147"></a>28147   }
<a name="l28148"></a>28148 
<a name="l28149"></a>28149   <span class="keywordflow">if</span> (varconstraint) {
<a name="l28150"></a>28150     <span class="comment">// A .var file exists. Adjust feature sizes.</span>
<a name="l28151"></a>28151     <span class="keywordflow">if</span> (in-&gt;facetconstraintlist) {
<a name="l28152"></a>28152       <span class="comment">// Have facet area constrains.</span>
<a name="l28153"></a>28153       subfaces-&gt;traversalinit();
<a name="l28154"></a>28154       shloop.sh = shellfacetraverse(subfaces);
<a name="l28155"></a>28155       <span class="keywordflow">while</span> (shloop.sh != (shellface *) NULL) {
<a name="l28156"></a>28156         varlen = areabound(shloop);
<a name="l28157"></a>28157         <span class="keywordflow">if</span> (varlen &gt; 0.0) {
<a name="l28158"></a>28158           <span class="comment">// Check if the three corners are feature points.</span>
<a name="l28159"></a>28159           varlen = sqrt(varlen);
<a name="l28160"></a>28160           <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l28161"></a>28161             ploop = (point) shloop.sh[3 + j];
<a name="l28162"></a>28162             isfeature = <span class="keyword">false</span>;
<a name="l28163"></a>28163             idx = pointmark(ploop) - in-&gt;firstnumber;
<a name="l28164"></a>28164             <span class="keywordflow">for</span> (i = idx2seglist[idx]; i &lt; idx2seglist[idx + 1] &amp;&amp; !isfeature;
<a name="l28165"></a>28165                  i++) {
<a name="l28166"></a>28166               checkseg.sh = segsperverlist[i];
<a name="l28167"></a>28167               isfeature = (shelltype(checkseg) == SHARP);
<a name="l28168"></a>28168             }
<a name="l28169"></a>28169             <span class="keywordflow">if</span> (isfeature) {
<a name="l28170"></a>28170               assert(ploop[pointmtrindex] &gt; 0.0);
<a name="l28171"></a>28171               <span class="keywordflow">if</span> (ploop[pointmtrindex] &gt; varlen) {
<a name="l28172"></a>28172                 ploop[pointmtrindex] = varlen;
<a name="l28173"></a>28173               }
<a name="l28174"></a>28174             }
<a name="l28175"></a>28175           } <span class="comment">// for (j = 0; j &lt; 3; j++)</span>
<a name="l28176"></a>28176         }
<a name="l28177"></a>28177         shloop.sh = shellfacetraverse(subfaces);
<a name="l28178"></a>28178       }
<a name="l28179"></a>28179     }
<a name="l28180"></a>28180     <span class="keywordflow">if</span> (in-&gt;segmentconstraintlist) {
<a name="l28181"></a>28181       <span class="comment">// Have facet area constrains.</span>
<a name="l28182"></a>28182       subsegs-&gt;traversalinit();
<a name="l28183"></a>28183       shloop.sh = shellfacetraverse(subsegs);
<a name="l28184"></a>28184       <span class="keywordflow">while</span> (shloop.sh != (shellface *) NULL) {
<a name="l28185"></a>28185         varlen = areabound(shloop);
<a name="l28186"></a>28186         <span class="keywordflow">if</span> (varlen &gt; 0.0) {
<a name="l28187"></a>28187           <span class="comment">// Check if the two endpoints are feature points.</span>
<a name="l28188"></a>28188           <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l28189"></a>28189             ploop = (point) shloop.sh[3 + j];
<a name="l28190"></a>28190             isfeature = <span class="keyword">false</span>;
<a name="l28191"></a>28191             idx = pointmark(ploop) - in-&gt;firstnumber;
<a name="l28192"></a>28192             <span class="keywordflow">for</span> (i = idx2seglist[idx]; i &lt; idx2seglist[idx + 1] &amp;&amp; !isfeature;
<a name="l28193"></a>28193                  i++) {
<a name="l28194"></a>28194               checkseg.sh = segsperverlist[i];
<a name="l28195"></a>28195               isfeature = (shelltype(checkseg) == SHARP);
<a name="l28196"></a>28196             }
<a name="l28197"></a>28197             <span class="keywordflow">if</span> (isfeature) {
<a name="l28198"></a>28198               assert(ploop[pointmtrindex] &gt; 0.0);
<a name="l28199"></a>28199               <span class="keywordflow">if</span> (ploop[pointmtrindex] &gt; varlen) {
<a name="l28200"></a>28200                 ploop[pointmtrindex] = varlen;
<a name="l28201"></a>28201               }
<a name="l28202"></a>28202             }
<a name="l28203"></a>28203           } <span class="comment">// for (j = 0; j &lt; 2; j++)</span>
<a name="l28204"></a>28204         }
<a name="l28205"></a>28205         shloop.sh = shellfacetraverse(subsegs);
<a name="l28206"></a>28206       }
<a name="l28207"></a>28207     }
<a name="l28208"></a>28208   } <span class="comment">// if (varconstraint)</span>
<a name="l28209"></a>28209 
<a name="l28210"></a>28210   <span class="keyword">delete</span> [] segsperverlist;
<a name="l28211"></a>28211   <span class="keyword">delete</span> [] idx2seglist;
<a name="l28212"></a>28212   <span class="keyword">delete</span> tetlist;
<a name="l28213"></a>28213   <span class="keyword">delete</span> verlist;
<a name="l28214"></a>28214 }
<a name="l28215"></a>28215 
<a name="l28217"></a>28217 <span class="comment">//                                                                           //</span>
<a name="l28218"></a>28218 <span class="comment">// enqueueencsub()    Add an encroached subface into the queue.              //</span>
<a name="l28219"></a>28219 <span class="comment">//                                                                           //</span>
<a name="l28221"></a>28221 <span class="comment"></span>
<a name="l28222"></a>28222 <span class="keywordtype">void</span> tetgenmesh::enqueueencsub(face* testsub, point encpt, <span class="keywordtype">int</span> quenumber,
<a name="l28223"></a>28223   REAL* cent)
<a name="l28224"></a>28224 {
<a name="l28225"></a>28225   badface *encsub;
<a name="l28226"></a>28226   <span class="keywordtype">int</span> i;
<a name="l28227"></a>28227 
<a name="l28228"></a>28228   encsub = (badface *) badsubfaces-&gt;alloc();
<a name="l28229"></a>28229   encsub-&gt;ss = *testsub;
<a name="l28230"></a>28230   encsub-&gt;forg = sorg(*testsub);
<a name="l28231"></a>28231   encsub-&gt;fdest = sdest(*testsub);
<a name="l28232"></a>28232   encsub-&gt;fapex = sapex(*testsub);
<a name="l28233"></a>28233   encsub-&gt;foppo = (point) encpt;
<a name="l28234"></a>28234   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) encsub-&gt;cent[i] = cent[i];
<a name="l28235"></a>28235   encsub-&gt;nextitem = (badface *) NULL;
<a name="l28236"></a>28236   <span class="comment">// Set the pointer of &#39;encsubseg&#39; into &#39;testsub&#39;.  It has two purposes:</span>
<a name="l28237"></a>28237   <span class="comment">//   (1) We can regonize it is encroached; (2) It is uniquely queued.</span>
<a name="l28238"></a>28238   setshell2badface(encsub-&gt;ss, encsub);
<a name="l28239"></a>28239   <span class="comment">// Add the subface to the end of a queue (quenumber = 2, high priority).</span>
<a name="l28240"></a>28240   *subquetail[quenumber] = encsub;
<a name="l28241"></a>28241   <span class="comment">// Maintain a pointer to the NULL pointer at the end of the queue.</span>
<a name="l28242"></a>28242   subquetail[quenumber] = &amp;encsub-&gt;nextitem;
<a name="l28243"></a>28243   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l28244"></a>28244     printf(<span class="stringliteral">&quot;    Queuing subface (%d, %d, %d) [%d].\n&quot;</span>, pointmark(encsub-&gt;forg),
<a name="l28245"></a>28245            pointmark(encsub-&gt;fdest), pointmark(encsub-&gt;fapex), quenumber);
<a name="l28246"></a>28246   }
<a name="l28247"></a>28247 }
<a name="l28248"></a>28248 
<a name="l28250"></a>28250 <span class="comment">//                                                                           //</span>
<a name="l28251"></a>28251 <span class="comment">// dequeueencsub()    Remove an enc-subface from the front of the queue.     //</span>
<a name="l28252"></a>28252 <span class="comment">//                                                                           //</span>
<a name="l28254"></a>28254 <span class="comment"></span>
<a name="l28255"></a>28255 tetgenmesh::badface* tetgenmesh::dequeueencsub(<span class="keywordtype">int</span>* pquenumber)
<a name="l28256"></a>28256 {
<a name="l28257"></a>28257   badface *result;
<a name="l28258"></a>28258   <span class="keywordtype">int</span> quenumber;
<a name="l28259"></a>28259 
<a name="l28260"></a>28260   <span class="comment">// Look for a nonempty queue.</span>
<a name="l28261"></a>28261   <span class="keywordflow">for</span> (quenumber = 2; quenumber &gt;= 0; quenumber--) {
<a name="l28262"></a>28262     result = subquefront[quenumber];
<a name="l28263"></a>28263     <span class="keywordflow">if</span> (result != (badface *) NULL) {
<a name="l28264"></a>28264       <span class="comment">// Remove the badface from the queue.</span>
<a name="l28265"></a>28265       subquefront[quenumber] = result-&gt;nextitem;
<a name="l28266"></a>28266       <span class="comment">// Maintain a pointer to the NULL pointer at the end of the queue.</span>
<a name="l28267"></a>28267       <span class="keywordflow">if</span> (subquefront[quenumber] == (badface *) NULL) {
<a name="l28268"></a>28268         subquetail[quenumber] = &amp;subquefront[quenumber];
<a name="l28269"></a>28269       }
<a name="l28270"></a>28270       *pquenumber = quenumber;
<a name="l28271"></a>28271       <span class="keywordflow">return</span> result;
<a name="l28272"></a>28272     }
<a name="l28273"></a>28273   }
<a name="l28274"></a>28274   <span class="keywordflow">return</span> (badface *) NULL;
<a name="l28275"></a>28275 }
<a name="l28276"></a>28276 
<a name="l28278"></a>28278 <span class="comment">//                                                                           //</span>
<a name="l28279"></a>28279 <span class="comment">// enqueuebadtet()    Add a tetrahedron into the queue.                      //</span>
<a name="l28280"></a>28280 <span class="comment">//                                                                           //</span>
<a name="l28282"></a>28282 <span class="comment"></span>
<a name="l28283"></a>28283 <span class="keywordtype">void</span> tetgenmesh::enqueuebadtet(triface* testtet, REAL ratio2, REAL* cent)
<a name="l28284"></a>28284 {
<a name="l28285"></a>28285   badface *newbadtet;
<a name="l28286"></a>28286   <span class="keywordtype">int</span> queuenumber;
<a name="l28287"></a>28287   <span class="keywordtype">int</span> i;
<a name="l28288"></a>28288 
<a name="l28289"></a>28289   <span class="comment">// Allocate space for the bad tetrahedron.</span>
<a name="l28290"></a>28290   newbadtet = (badface *) badtetrahedrons-&gt;alloc();
<a name="l28291"></a>28291   newbadtet-&gt;tt = *testtet;
<a name="l28292"></a>28292   newbadtet-&gt;key = ratio2;
<a name="l28293"></a>28293   <span class="keywordflow">if</span> (cent != NULL) {
<a name="l28294"></a>28294     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newbadtet-&gt;cent[i] = cent[i];
<a name="l28295"></a>28295   } <span class="keywordflow">else</span> {
<a name="l28296"></a>28296     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newbadtet-&gt;cent[i] = 0.0;
<a name="l28297"></a>28297   }
<a name="l28298"></a>28298   newbadtet-&gt;forg = org(*testtet);
<a name="l28299"></a>28299   newbadtet-&gt;fdest = dest(*testtet);
<a name="l28300"></a>28300   newbadtet-&gt;fapex = apex(*testtet);
<a name="l28301"></a>28301   newbadtet-&gt;foppo = oppo(*testtet);
<a name="l28302"></a>28302   newbadtet-&gt;nextitem = (badface *) NULL;
<a name="l28303"></a>28303   <span class="comment">// Determine the appropriate queue to put the bad tetrahedron into.</span>
<a name="l28304"></a>28304   <span class="keywordflow">if</span> (ratio2 &gt; b-&gt;goodratio) {
<a name="l28305"></a>28305     <span class="comment">// queuenumber = (int) ((ratio2 - b-&gt;goodratio) / 0.5);</span>
<a name="l28306"></a>28306     queuenumber = (int) (64.0 - 64.0 / ratio2);
<a name="l28307"></a>28307     <span class="comment">// &#39;queuenumber&#39; may overflow (negative) caused by a very large ratio.</span>
<a name="l28308"></a>28308     <span class="keywordflow">if</span> ((queuenumber &gt; 63) || (queuenumber &lt; 0)) {
<a name="l28309"></a>28309       queuenumber = 63;
<a name="l28310"></a>28310     }
<a name="l28311"></a>28311   } <span class="keywordflow">else</span> {
<a name="l28312"></a>28312     <span class="comment">// It&#39;s not a bad ratio; put the tet in the lowest-priority queue.</span>
<a name="l28313"></a>28313     queuenumber = 0;
<a name="l28314"></a>28314   }
<a name="l28315"></a>28315 
<a name="l28316"></a>28316   <span class="comment">// Are we inserting into an empty queue?</span>
<a name="l28317"></a>28317   <span class="keywordflow">if</span> (tetquefront[queuenumber] == (badface *) NULL) {
<a name="l28318"></a>28318     <span class="comment">// Yes. Will this become the highest-priority queue?</span>
<a name="l28319"></a>28319     <span class="keywordflow">if</span> (queuenumber &gt; firstnonemptyq) {
<a name="l28320"></a>28320       <span class="comment">// Yes, this is the highest-priority queue.</span>
<a name="l28321"></a>28321       nextnonemptyq[queuenumber] = firstnonemptyq;
<a name="l28322"></a>28322       firstnonemptyq = queuenumber;
<a name="l28323"></a>28323     } <span class="keywordflow">else</span> {
<a name="l28324"></a>28324       <span class="comment">// No. Find the queue with next higher priority.</span>
<a name="l28325"></a>28325       i = queuenumber + 1;
<a name="l28326"></a>28326       <span class="keywordflow">while</span> (tetquefront[i] == (badface *) NULL) {
<a name="l28327"></a>28327         i++;
<a name="l28328"></a>28328       }
<a name="l28329"></a>28329       <span class="comment">// Mark the newly nonempty queue as following a higher-priority queue.</span>
<a name="l28330"></a>28330       nextnonemptyq[queuenumber] = nextnonemptyq[i];
<a name="l28331"></a>28331       nextnonemptyq[i] = queuenumber;
<a name="l28332"></a>28332     }
<a name="l28333"></a>28333     <span class="comment">// Put the bad tetrahedron at the beginning of the (empty) queue.</span>
<a name="l28334"></a>28334     tetquefront[queuenumber] = newbadtet;
<a name="l28335"></a>28335   } <span class="keywordflow">else</span> {
<a name="l28336"></a>28336     <span class="comment">// Add the bad tetrahedron to the end of an already nonempty queue.</span>
<a name="l28337"></a>28337     tetquetail[queuenumber]-&gt;nextitem = newbadtet;
<a name="l28338"></a>28338   }
<a name="l28339"></a>28339   <span class="comment">// Maintain a pointer to the last tetrahedron of the queue.</span>
<a name="l28340"></a>28340   tetquetail[queuenumber] = newbadtet;
<a name="l28341"></a>28341 
<a name="l28342"></a>28342   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l28343"></a>28343     printf(<span class="stringliteral">&quot;    Queueing bad tet: (%d, %d, %d, %d), ratio %g, qnum %d.\n&quot;</span>,
<a name="l28344"></a>28344            pointmark(newbadtet-&gt;forg), pointmark(newbadtet-&gt;fdest),
<a name="l28345"></a>28345            pointmark(newbadtet-&gt;fapex), pointmark(newbadtet-&gt;foppo),
<a name="l28346"></a>28346            sqrt(ratio2), queuenumber);
<a name="l28347"></a>28347   }
<a name="l28348"></a>28348 }
<a name="l28349"></a>28349 
<a name="l28351"></a>28351 <span class="comment">//                                                                           //</span>
<a name="l28352"></a>28352 <span class="comment">// dequeuebadtet()    Remove a tetrahedron from the front of the queue.      //</span>
<a name="l28353"></a>28353 <span class="comment">//                                                                           //</span>
<a name="l28355"></a>28355 <span class="comment"></span>
<a name="l28356"></a>28356 tetgenmesh::badface* tetgenmesh::topbadtetra()
<a name="l28357"></a>28357 {
<a name="l28358"></a>28358   <span class="comment">// Keep a record of which queue was accessed in case dequeuebadtetra()</span>
<a name="l28359"></a>28359   <span class="comment">//   is called later.</span>
<a name="l28360"></a>28360   recentq = firstnonemptyq;
<a name="l28361"></a>28361   <span class="comment">// If no queues are nonempty, return NULL.</span>
<a name="l28362"></a>28362   <span class="keywordflow">if</span> (firstnonemptyq &lt; 0) {
<a name="l28363"></a>28363     <span class="keywordflow">return</span> (badface *) NULL;
<a name="l28364"></a>28364   } <span class="keywordflow">else</span> {
<a name="l28365"></a>28365     <span class="comment">// Return the first tetrahedron of the highest-priority queue.</span>
<a name="l28366"></a>28366     <span class="keywordflow">return</span> tetquefront[firstnonemptyq];
<a name="l28367"></a>28367   }
<a name="l28368"></a>28368 }
<a name="l28369"></a>28369 
<a name="l28370"></a>28370 <span class="keywordtype">void</span> tetgenmesh::dequeuebadtet()
<a name="l28371"></a>28371 {
<a name="l28372"></a>28372   badface *deadbadtet;
<a name="l28373"></a>28373   <span class="keywordtype">int</span> i;
<a name="l28374"></a>28374 
<a name="l28375"></a>28375   <span class="comment">// If queues were empty last time topbadtetra() was called, do nothing.</span>
<a name="l28376"></a>28376   <span class="keywordflow">if</span> (recentq &gt;= 0) {
<a name="l28377"></a>28377     <span class="comment">// Find the tetrahedron last returned by topbadtetra().</span>
<a name="l28378"></a>28378     deadbadtet = tetquefront[recentq];
<a name="l28379"></a>28379     <span class="comment">// Remove the tetrahedron from the queue.</span>
<a name="l28380"></a>28380     tetquefront[recentq] = deadbadtet-&gt;nextitem;
<a name="l28381"></a>28381     <span class="comment">// If this queue is now empty, update the list of nonempty queues.</span>
<a name="l28382"></a>28382     <span class="keywordflow">if</span> (deadbadtet == tetquetail[recentq]) {
<a name="l28383"></a>28383       <span class="comment">// Was this the highest-priority queue?</span>
<a name="l28384"></a>28384       <span class="keywordflow">if</span> (firstnonemptyq == recentq) {
<a name="l28385"></a>28385         <span class="comment">// Yes; find the queue with next lower priority.</span>
<a name="l28386"></a>28386         firstnonemptyq = nextnonemptyq[firstnonemptyq];
<a name="l28387"></a>28387       } <span class="keywordflow">else</span> {
<a name="l28388"></a>28388         <span class="comment">// No; find the queue with next higher priority.</span>
<a name="l28389"></a>28389         i = recentq + 1;
<a name="l28390"></a>28390         <span class="keywordflow">while</span> (tetquefront[i] == (badface *) NULL) {
<a name="l28391"></a>28391           i++;
<a name="l28392"></a>28392         }
<a name="l28393"></a>28393         nextnonemptyq[i] = nextnonemptyq[recentq];
<a name="l28394"></a>28394       }
<a name="l28395"></a>28395     }
<a name="l28396"></a>28396     <span class="comment">// Return the bad tetrahedron to the pool.</span>
<a name="l28397"></a>28397     badfacedealloc(badtetrahedrons, deadbadtet);
<a name="l28398"></a>28398   }
<a name="l28399"></a>28399 }
<a name="l28400"></a>28400 
<a name="l28402"></a>28402 <span class="comment">//                                                                           //</span>
<a name="l28403"></a>28403 <span class="comment">// checkseg4encroach()    Check a subsegment to see if it is encroached.     //</span>
<a name="l28404"></a>28404 <span class="comment">//                                                                           //</span>
<a name="l28405"></a>28405 <span class="comment">// A segment s is encroached if there is a vertex lies inside or on its dia- //</span>
<a name="l28406"></a>28406 <span class="comment">// metral circumsphere, i.e., s faces an angle theta &gt;= 90 degrees.          //</span>
<a name="l28407"></a>28407 <span class="comment">//                                                                           //</span>
<a name="l28408"></a>28408 <span class="comment">// If &#39;testpt&#39; (p) != NULL, only test if &#39;testseg&#39; (s) is encroached by it,  //</span>
<a name="l28409"></a>28409 <span class="comment">// else, check all apexes of faces around s. Return TRUE if s is encroached. //</span>
<a name="l28410"></a>28410 <span class="comment">// If and &#39;enqflag&#39; is TRUE, add it into &#39;badsubsegs&#39; if s is encroached.    //</span>
<a name="l28411"></a>28411 <span class="comment">//                                                                           //</span>
<a name="l28412"></a>28412 <span class="comment">// If &#39;prefpt&#39; != NULL, it returns the reference point (defined in my paper) //</span>
<a name="l28413"></a>28413 <span class="comment">// if it exists.  This point is will be used to split s.                     //</span>
<a name="l28414"></a>28414 <span class="comment">//                                                                           //</span>
<a name="l28416"></a>28416 <span class="comment"></span>
<a name="l28417"></a>28417 <span class="keywordtype">bool</span> tetgenmesh::checkseg4encroach(face* testseg, point testpt, point* prefpt,
<a name="l28418"></a>28418   <span class="keywordtype">bool</span> enqflag)
<a name="l28419"></a>28419 {
<a name="l28420"></a>28420   badface *encsubseg;
<a name="l28421"></a>28421   triface starttet, spintet;
<a name="l28422"></a>28422   point eorg, edest, eapex, encpt;
<a name="l28423"></a>28423   REAL cent[3], radius, dist, diff;
<a name="l28424"></a>28424   REAL maxradius;
<a name="l28425"></a>28425   <span class="keywordtype">bool</span> enq;
<a name="l28426"></a>28426   <span class="keywordtype">int</span> hitbdry;
<a name="l28427"></a>28427 
<a name="l28428"></a>28428   enq = <span class="keyword">false</span>;
<a name="l28429"></a>28429   eorg = sorg(*testseg);
<a name="l28430"></a>28430   edest = sdest(*testseg);
<a name="l28431"></a>28431   cent[0] = 0.5 * (eorg[0] + edest[0]);
<a name="l28432"></a>28432   cent[1] = 0.5 * (eorg[1] + edest[1]);
<a name="l28433"></a>28433   cent[2] = 0.5 * (eorg[2] + edest[2]);
<a name="l28434"></a>28434   radius = distance(cent, eorg);
<a name="l28435"></a>28435 
<a name="l28436"></a>28436   <span class="keywordflow">if</span> (varconstraint &amp;&amp; (areabound(*testseg) &gt; 0.0)) {
<a name="l28437"></a>28437     enq = (2.0 * radius) &gt; areabound(*testseg);
<a name="l28438"></a>28438   }
<a name="l28439"></a>28439 
<a name="l28440"></a>28440   <span class="keywordflow">if</span> (!enq) {
<a name="l28441"></a>28441     maxradius = 0.0;
<a name="l28442"></a>28442     <span class="keywordflow">if</span> (testpt == (point) NULL) {
<a name="l28443"></a>28443       <span class="comment">// Check if it is encroached by traversing all faces containing it.</span>
<a name="l28444"></a>28444       sstpivot(testseg, &amp;starttet);
<a name="l28445"></a>28445       eapex = apex(starttet);
<a name="l28446"></a>28446       spintet = starttet;
<a name="l28447"></a>28447       hitbdry = 0;
<a name="l28448"></a>28448       <span class="keywordflow">do</span> {
<a name="l28449"></a>28449         dist = distance(cent, apex(spintet));
<a name="l28450"></a>28450         diff = dist - radius;
<a name="l28451"></a>28451         <span class="keywordflow">if</span> (fabs(diff) / radius &lt;= b-&gt;epsilon) diff = 0.0; <span class="comment">// Rounding.</span>
<a name="l28452"></a>28452         <span class="keywordflow">if</span> (diff &lt;= 0.0) {
<a name="l28453"></a>28453           <span class="comment">// s is encroached.</span>
<a name="l28454"></a>28454           enq = <span class="keyword">true</span>;
<a name="l28455"></a>28455           <span class="keywordflow">if</span> (prefpt != (point *) NULL) {
<a name="l28456"></a>28456             <span class="comment">// Find the reference point.</span>
<a name="l28457"></a>28457             encpt = apex(spintet);
<a name="l28458"></a>28458             circumsphere(eorg, edest, encpt, NULL, NULL, &amp;dist);
<a name="l28459"></a>28459             <span class="keywordflow">if</span> (dist &gt; maxradius) {
<a name="l28460"></a>28460               <span class="comment">// Rememebr this point.</span>
<a name="l28461"></a>28461               *prefpt = encpt;
<a name="l28462"></a>28462               maxradius = dist;
<a name="l28463"></a>28463             }
<a name="l28464"></a>28464           } <span class="keywordflow">else</span> {
<a name="l28465"></a>28465             <span class="keywordflow">break</span>;
<a name="l28466"></a>28466           }
<a name="l28467"></a>28467         }
<a name="l28468"></a>28468         <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l28469"></a>28469           hitbdry++;
<a name="l28470"></a>28470           <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l28471"></a>28471             esym(starttet, spintet);
<a name="l28472"></a>28472             <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l28473"></a>28473               hitbdry++;
<a name="l28474"></a>28474             }
<a name="l28475"></a>28475           }
<a name="l28476"></a>28476         }
<a name="l28477"></a>28477       } <span class="keywordflow">while</span> (apex(spintet) != eapex &amp;&amp; (hitbdry &lt; 2));
<a name="l28478"></a>28478     } <span class="keywordflow">else</span> {
<a name="l28479"></a>28479       <span class="comment">// Only check if &#39;testseg&#39; is encroached by &#39;testpt&#39;.</span>
<a name="l28480"></a>28480       dist = distance(cent, testpt);
<a name="l28481"></a>28481       diff = dist - radius;
<a name="l28482"></a>28482       <span class="keywordflow">if</span> (fabs(diff) / radius &lt;= b-&gt;epsilon) diff = 0.0; <span class="comment">// Rounding.</span>
<a name="l28483"></a>28483       enq = (diff &lt;= 0.0);
<a name="l28484"></a>28484     }
<a name="l28485"></a>28485   }
<a name="l28486"></a>28486 
<a name="l28487"></a>28487   <span class="keywordflow">if</span> (enq &amp;&amp; enqflag) {
<a name="l28488"></a>28488     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l28489"></a>28489       printf(<span class="stringliteral">&quot;    Queuing encroaching subsegment (%d, %d).\n&quot;</span>,
<a name="l28490"></a>28490              pointmark(eorg), pointmark(edest));
<a name="l28491"></a>28491     }
<a name="l28492"></a>28492     encsubseg = (badface *) badsubsegs-&gt;alloc();
<a name="l28493"></a>28493     encsubseg-&gt;ss = *testseg;
<a name="l28494"></a>28494     encsubseg-&gt;forg = eorg;
<a name="l28495"></a>28495     encsubseg-&gt;fdest = edest;
<a name="l28496"></a>28496     encsubseg-&gt;foppo = (point) NULL; <span class="comment">// Not used.</span>
<a name="l28497"></a>28497     <span class="comment">// Set the pointer of &#39;encsubseg&#39; into &#39;testseg&#39;.  It has two purposes:</span>
<a name="l28498"></a>28498     <span class="comment">//   (1) We can regonize it is encroached; (2) It is uniquely queued.</span>
<a name="l28499"></a>28499     setshell2badface(encsubseg-&gt;ss, encsubseg);
<a name="l28500"></a>28500   }
<a name="l28501"></a>28501 
<a name="l28502"></a>28502   <span class="keywordflow">return</span> enq;
<a name="l28503"></a>28503 }
<a name="l28504"></a>28504 
<a name="l28506"></a>28506 <span class="comment">//                                                                           //</span>
<a name="l28507"></a>28507 <span class="comment">// checksub4encroach()    Check a subface to see if it is encroached.        //</span>
<a name="l28508"></a>28508 <span class="comment">//                                                                           //</span>
<a name="l28509"></a>28509 <span class="comment">// A subface f is encroached if there is a vertex inside or on its diametral //</span>
<a name="l28510"></a>28510 <span class="comment">// circumsphere.                                                             //</span>
<a name="l28511"></a>28511 <span class="comment">//                                                                           //</span>
<a name="l28512"></a>28512 <span class="comment">// If &#39;testpt (p) != NULL&#39;, test if &#39;testsub&#39; (f) is encroached by it, else, //</span>
<a name="l28513"></a>28513 <span class="comment">// test if f is encroached by one of the two opposites of the adjacent tets. //</span>
<a name="l28514"></a>28514 <span class="comment">// Return TRUE if f is encroached and queue it if &#39;enqflag&#39; is set.          //</span>
<a name="l28515"></a>28515 <span class="comment">//                                                                           //</span>
<a name="l28517"></a>28517 <span class="comment"></span>
<a name="l28518"></a>28518 <span class="keywordtype">bool</span> tetgenmesh::checksub4encroach(face* testsub, point testpt, <span class="keywordtype">bool</span> enqflag)
<a name="l28519"></a>28519 {
<a name="l28520"></a>28520   triface abuttet;
<a name="l28521"></a>28521   point pa, pb, pc, encpt;
<a name="l28522"></a>28522   REAL A[4][4], rhs[4], D;
<a name="l28523"></a>28523   REAL cent[3], area;
<a name="l28524"></a>28524   REAL radius, dist, diff;
<a name="l28525"></a>28525   <span class="keywordtype">bool</span> enq;
<a name="l28526"></a>28526   <span class="keywordtype">int</span> indx[4];
<a name="l28527"></a>28527   <span class="keywordtype">int</span> quenumber;
<a name="l28528"></a>28528 
<a name="l28529"></a>28529   enq = <span class="keyword">false</span>;
<a name="l28530"></a>28530   radius = 0.0;
<a name="l28531"></a>28531   encpt = (point) NULL;
<a name="l28532"></a>28532 
<a name="l28533"></a>28533   pa = sorg(*testsub);
<a name="l28534"></a>28534   pb = sdest(*testsub);
<a name="l28535"></a>28535   pc = sapex(*testsub);
<a name="l28536"></a>28536 
<a name="l28537"></a>28537   <span class="comment">// Compute the coefficient matrix A (3x3).</span>
<a name="l28538"></a>28538   A[0][0] = pb[0] - pa[0];
<a name="l28539"></a>28539   A[0][1] = pb[1] - pa[1];
<a name="l28540"></a>28540   A[0][2] = pb[2] - pa[2]; <span class="comment">// vector V1 (pa-&gt;pb)</span>
<a name="l28541"></a>28541   A[1][0] = pc[0] - pa[0];
<a name="l28542"></a>28542   A[1][1] = pc[1] - pa[1];
<a name="l28543"></a>28543   A[1][2] = pc[2] - pa[2]; <span class="comment">// vector V2 (pa-&gt;pc)</span>
<a name="l28544"></a>28544   cross(A[0], A[1], A[2]); <span class="comment">// vector V3 (V1 X V2)</span>
<a name="l28545"></a>28545 
<a name="l28546"></a>28546   <span class="keywordflow">if</span> (varconstraint &amp;&amp; (areabound(*testsub) &gt; 0.0)) {
<a name="l28547"></a>28547     <span class="comment">// Check if the subface has too big area.</span>
<a name="l28548"></a>28548     area = 0.5 * sqrt(dot(A[2], A[2]));
<a name="l28549"></a>28549     enq = area &gt; areabound(*testsub);
<a name="l28550"></a>28550     <span class="keywordflow">if</span> (enq) {
<a name="l28551"></a>28551       quenumber = 2; <span class="comment">// A queue of subfaces having too big area.</span>
<a name="l28552"></a>28552     }
<a name="l28553"></a>28553   }
<a name="l28554"></a>28554 
<a name="l28555"></a>28555   <span class="comment">// Compute the right hand side vector b (3x1).</span>
<a name="l28556"></a>28556   rhs[0] = 0.5 * dot(A[0], A[0]);
<a name="l28557"></a>28557   rhs[1] = 0.5 * dot(A[1], A[1]);
<a name="l28558"></a>28558   rhs[2] = 0.0;
<a name="l28559"></a>28559   <span class="comment">// Solve the 3 by 3 equations use LU decomposition with partial pivoting</span>
<a name="l28560"></a>28560   <span class="comment">//   and backward and forward substitute..</span>
<a name="l28561"></a>28561   <span class="keywordflow">if</span> (lu_decmp(A, 3, indx, &amp;D, 0)) {
<a name="l28562"></a>28562     lu_solve(A, 3, indx, rhs, 0);
<a name="l28563"></a>28563     cent[0] = pa[0] + rhs[0];
<a name="l28564"></a>28564     cent[1] = pa[1] + rhs[1];
<a name="l28565"></a>28565     cent[2] = pa[2] + rhs[2];
<a name="l28566"></a>28566     radius = sqrt(rhs[0] * rhs[0] + rhs[1] * rhs[1] + rhs[2] * rhs[2]);
<a name="l28567"></a>28567   }
<a name="l28568"></a>28568 
<a name="l28569"></a>28569   <span class="keywordflow">if</span> (!enq) {
<a name="l28570"></a>28570     <span class="comment">// Check if the subface is encroached.</span>
<a name="l28571"></a>28571     <span class="keywordflow">if</span> (testpt == (point) NULL) {
<a name="l28572"></a>28572       stpivot(*testsub, abuttet);
<a name="l28573"></a>28573       <span class="keywordflow">if</span> (abuttet.tet != dummytet) {
<a name="l28574"></a>28574         dist = distance(cent, oppo(abuttet));
<a name="l28575"></a>28575         diff = dist - radius;
<a name="l28576"></a>28576         <span class="keywordflow">if</span> (fabs(diff) / radius &lt;= b-&gt;epsilon) diff = 0.0; <span class="comment">// Rounding.</span>
<a name="l28577"></a>28577         enq = (diff &lt;= 0.0);
<a name="l28578"></a>28578         <span class="keywordflow">if</span> (enq) encpt = oppo(abuttet);
<a name="l28579"></a>28579       }
<a name="l28580"></a>28580       <span class="keywordflow">if</span> (!enq) {
<a name="l28581"></a>28581         sesymself(*testsub);
<a name="l28582"></a>28582         stpivot(*testsub, abuttet);
<a name="l28583"></a>28583         <span class="keywordflow">if</span> (abuttet.tet != dummytet) {
<a name="l28584"></a>28584           dist = distance(cent, oppo(abuttet));
<a name="l28585"></a>28585           diff = dist - radius;
<a name="l28586"></a>28586           <span class="keywordflow">if</span> (fabs(diff) / radius &lt;= b-&gt;epsilon) diff = 0.0; <span class="comment">// Rounding.</span>
<a name="l28587"></a>28587           enq = (diff &lt;= 0.0);
<a name="l28588"></a>28588           <span class="keywordflow">if</span> (enq) encpt = oppo(abuttet);
<a name="l28589"></a>28589         }
<a name="l28590"></a>28590       }
<a name="l28591"></a>28591     } <span class="keywordflow">else</span> {
<a name="l28592"></a>28592       dist = distance(cent, testpt);
<a name="l28593"></a>28593       diff = dist - radius;
<a name="l28594"></a>28594       <span class="keywordflow">if</span> (fabs(diff) / radius &lt;= b-&gt;epsilon) diff = 0.0; <span class="comment">// Rounding.</span>
<a name="l28595"></a>28595       enq = (diff &lt;= 0.0);
<a name="l28596"></a>28596     }
<a name="l28597"></a>28597     <span class="keywordflow">if</span> (enq) {
<a name="l28598"></a>28598       quenumber = 0; <span class="comment">// A queue of encroached subfaces.</span>
<a name="l28599"></a>28599     }
<a name="l28600"></a>28600   }
<a name="l28601"></a>28601 
<a name="l28602"></a>28602   <span class="keywordflow">if</span> (enq &amp;&amp; enqflag) {
<a name="l28603"></a>28603     enqueueencsub(testsub, encpt, quenumber, cent);
<a name="l28604"></a>28604   }
<a name="l28605"></a>28605 
<a name="l28606"></a>28606   <span class="keywordflow">return</span> enq;
<a name="l28607"></a>28607 }
<a name="l28608"></a>28608 
<a name="l28610"></a>28610 <span class="comment">//                                                                           //</span>
<a name="l28611"></a>28611 <span class="comment">// checktet4badqual()    Test a tetrahedron for quality measures.            //</span>
<a name="l28612"></a>28612 <span class="comment">//                                                                           //</span>
<a name="l28613"></a>28613 <span class="comment">// Tests a tetrahedron to see if it satisfies the minimum ratio condition    //</span>
<a name="l28614"></a>28614 <span class="comment">// and the maximum volume condition. Tetrahedra that aren&#39;t upto spec are    //</span>
<a name="l28615"></a>28615 <span class="comment">// added to the bad tetrahedron queue.                                       //</span>
<a name="l28616"></a>28616 <span class="comment">//                                                                           //</span>
<a name="l28618"></a>28618 <span class="comment"></span>
<a name="l28619"></a>28619 <span class="keywordtype">bool</span> tetgenmesh::checktet4badqual(triface* testtet, <span class="keywordtype">bool</span> enqflag)
<a name="l28620"></a>28620 {
<a name="l28621"></a>28621   point pa, pb, pc, pd, pe1, pe2;
<a name="l28622"></a>28622   REAL vda[3], vdb[3], vdc[3];
<a name="l28623"></a>28623   REAL vab[3], vbc[3], vca[3];
<a name="l28624"></a>28624   REAL N[4][3], A[4][4], rhs[4], D;
<a name="l28625"></a>28625   REAL elen[6], circumcent[3];
<a name="l28626"></a>28626   REAL bicent[3], offcent[3];
<a name="l28627"></a>28627   offcent[0] = 0.0; <span class="comment">// Just to avoid uninitialised value warnings.</span>
<a name="l28628"></a>28628   offcent[1] = 0.0; <span class="comment">// Just to avoid uninitialised value warnings.</span>
<a name="l28629"></a>28629   offcent[2] = 0.0; <span class="comment">// Just to avoid uninitialised value warnings.</span>
<a name="l28630"></a>28630   REAL volume, L, cosd;
<a name="l28631"></a>28631   REAL radius2, smlen2, ratio2;
<a name="l28632"></a>28632   REAL dist, sdist, split;
<a name="l28633"></a>28633   <span class="keywordtype">bool</span> enq;
<a name="l28634"></a>28634   <span class="keywordtype">int</span> indx[4];
<a name="l28635"></a>28635   <span class="keywordtype">int</span> sidx, i, j;
<a name="l28636"></a>28636 
<a name="l28637"></a>28637   pa = (point) testtet-&gt;tet[4];
<a name="l28638"></a>28638   pb = (point) testtet-&gt;tet[5];
<a name="l28639"></a>28639   pc = (point) testtet-&gt;tet[6];
<a name="l28640"></a>28640   pd = (point) testtet-&gt;tet[7];
<a name="l28641"></a>28641 
<a name="l28642"></a>28642   <span class="comment">// Get the edge vectors vda: d-&gt;a, vdb: d-&gt;b, vdc: d-&gt;c.</span>
<a name="l28643"></a>28643   <span class="comment">// Set the matrix A = [vda, vdb, vdc]^T.</span>
<a name="l28644"></a>28644   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[0][i] = vda[i] = pa[i] - pd[i];
<a name="l28645"></a>28645   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[1][i] = vdb[i] = pb[i] - pd[i];
<a name="l28646"></a>28646   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[2][i] = vdc[i] = pc[i] - pd[i];
<a name="l28647"></a>28647   <span class="comment">// Get the rest edge vectors</span>
<a name="l28648"></a>28648   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) vab[i] = pb[i] - pa[i];
<a name="l28649"></a>28649   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) vbc[i] = pc[i] - pb[i];
<a name="l28650"></a>28650   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) vca[i] = pa[i] - pc[i];
<a name="l28651"></a>28651 
<a name="l28652"></a>28652   <span class="comment">// Lu-decompose the matrix A.</span>
<a name="l28653"></a>28653   lu_decmp(A, 3, indx, &amp;D, 0);
<a name="l28654"></a>28654   <span class="comment">// Get the volume of abcd.</span>
<a name="l28655"></a>28655   volume = (A[indx[0]][0] * A[indx[1]][1] * A[indx[2]][2]) / 6.0;
<a name="l28656"></a>28656   <span class="keywordflow">if</span> (volume &lt; 0.0) volume = -volume;
<a name="l28657"></a>28657   <span class="comment">// Check the radiu-edge ratio of the tet.</span>
<a name="l28658"></a>28658   rhs[0] = 0.5 * dot(vda, vda);
<a name="l28659"></a>28659   rhs[1] = 0.5 * dot(vdb, vdb);
<a name="l28660"></a>28660   rhs[2] = 0.5 * dot(vdc, vdc);
<a name="l28661"></a>28661   lu_solve(A, 3, indx, rhs, 0);
<a name="l28662"></a>28662   <span class="comment">// Get the circumcenter.</span>
<a name="l28663"></a>28663   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) circumcent[i] = pd[i] + rhs[i];
<a name="l28664"></a>28664   <span class="comment">// Get the square of the circumradius.</span>
<a name="l28665"></a>28665   radius2 = dot(rhs, rhs);
<a name="l28666"></a>28666   <span class="comment">// Find the square of the shortest edge length.</span>
<a name="l28667"></a>28667   elen[0] = dot(vda, vda);
<a name="l28668"></a>28668   elen[1] = dot(vdb, vdb);
<a name="l28669"></a>28669   elen[2] = dot(vdc, vdc);
<a name="l28670"></a>28670   elen[3] = dot(vab, vab);
<a name="l28671"></a>28671   elen[4] = dot(vbc, vbc);
<a name="l28672"></a>28672   elen[5] = dot(vca, vca);
<a name="l28673"></a>28673   smlen2 = elen[0]; sidx = 0;
<a name="l28674"></a>28674   <span class="keywordflow">for</span> (i = 1; i &lt; 6; i++) {
<a name="l28675"></a>28675     <span class="keywordflow">if</span> (smlen2 &gt; elen[i]) { smlen2 = elen[i]; sidx = i; }
<a name="l28676"></a>28676   }
<a name="l28677"></a>28677   <span class="comment">// Calculate the square of radius-edge ratio.</span>
<a name="l28678"></a>28678   ratio2 = radius2 / smlen2;
<a name="l28679"></a>28679   <span class="comment">// Check whether the ratio is smaller than permitted.</span>
<a name="l28680"></a>28680   enq = ratio2 &gt; b-&gt;goodratio;
<a name="l28681"></a>28681   <span class="keywordflow">if</span> (!enq) {
<a name="l28682"></a>28682     <span class="comment">// abcd has good ratio.</span>
<a name="l28683"></a>28683     <span class="comment">// ratio2 = 0.0;</span>
<a name="l28684"></a>28684     <span class="comment">// if (b-&gt;offcenter) {</span>
<a name="l28685"></a>28685       <span class="comment">// Test if it is a sliver.</span>
<a name="l28686"></a>28686       <span class="comment">// Compute the 4 face normals (N[0], ..., N[3]).</span>
<a name="l28687"></a>28687       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l28688"></a>28688         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) rhs[i] = 0.0;
<a name="l28689"></a>28689         rhs[j] = 1.0;  <span class="comment">// Positive means the inside direction</span>
<a name="l28690"></a>28690         lu_solve(A, 3, indx, rhs, 0);
<a name="l28691"></a>28691         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) N[j][i] = rhs[i];
<a name="l28692"></a>28692       }
<a name="l28693"></a>28693       <span class="comment">// Get the fourth normal by summing up the first three.</span>
<a name="l28694"></a>28694       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) N[3][i] = - N[0][i] - N[1][i] - N[2][i];
<a name="l28695"></a>28695       <span class="comment">// Normalized the normals.</span>
<a name="l28696"></a>28696       <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l28697"></a>28697         L = sqrt(dot(N[i], N[i]));
<a name="l28698"></a>28698         <span class="keywordflow">if</span> (L &gt; 0.0) {
<a name="l28699"></a>28699           <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) N[i][j] /= L;
<a name="l28700"></a>28700         }
<a name="l28701"></a>28701       }
<a name="l28702"></a>28702       <span class="comment">// N[0] is the normal of face bcd. Test the dihedral angles at edge</span>
<a name="l28703"></a>28703       <span class="comment">//   cd, bd, and bc to see if they are too small or too big.</span>
<a name="l28704"></a>28704       <span class="keywordflow">for</span> (i = 1; i &lt; 4 &amp;&amp; !enq; i++) {
<a name="l28705"></a>28705         cosd = -dot(N[0], N[i]); <span class="comment">// Edge cd, bd, bc.</span>
<a name="l28706"></a>28706         enq = cosd &gt; cosmindihed;
<a name="l28707"></a>28707       }
<a name="l28708"></a>28708       <span class="keywordflow">if</span> (!enq) {
<a name="l28709"></a>28709         <span class="keywordflow">for</span> (i = 2; i &lt; 4 &amp;&amp; !enq; i++) {
<a name="l28710"></a>28710           cosd = -dot(N[1], N[i]); <span class="comment">// Edge ad, ac</span>
<a name="l28711"></a>28711           enq = cosd &gt; cosmindihed;
<a name="l28712"></a>28712         }
<a name="l28713"></a>28713         <span class="keywordflow">if</span> (!enq) {
<a name="l28714"></a>28714           cosd = -dot(N[2], N[3]); <span class="comment">// Edge ab</span>
<a name="l28715"></a>28715           enq = cosd &gt; cosmindihed;
<a name="l28716"></a>28716         }
<a name="l28717"></a>28717       }
<a name="l28718"></a>28718     <span class="comment">// }</span>
<a name="l28719"></a>28719   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;offcenter) {
<a name="l28720"></a>28720     <span class="comment">// abcd has bad-quality. Use off-center instead of circumcenter.</span>
<a name="l28721"></a>28721     <span class="keywordflow">switch</span> (sidx) {
<a name="l28722"></a>28722     <span class="keywordflow">case</span> 0: <span class="comment">// edge da.</span>
<a name="l28723"></a>28723       pe1 = pd; pe2 = pa; <span class="keywordflow">break</span>;
<a name="l28724"></a>28724     <span class="keywordflow">case</span> 1: <span class="comment">// edge db.</span>
<a name="l28725"></a>28725       pe1 = pd; pe2 = pb; <span class="keywordflow">break</span>;
<a name="l28726"></a>28726     <span class="keywordflow">case</span> 2: <span class="comment">// edge dc.</span>
<a name="l28727"></a>28727       pe1 = pd; pe2 = pc; <span class="keywordflow">break</span>;
<a name="l28728"></a>28728     <span class="keywordflow">case</span> 3: <span class="comment">// edge ab.</span>
<a name="l28729"></a>28729       pe1 = pa; pe2 = pb; <span class="keywordflow">break</span>;
<a name="l28730"></a>28730     <span class="keywordflow">case</span> 4: <span class="comment">// edge bc.</span>
<a name="l28731"></a>28731       pe1 = pb; pe2 = pc; <span class="keywordflow">break</span>;
<a name="l28732"></a>28732     <span class="keywordflow">case</span> 5: <span class="comment">// edge ca.</span>
<a name="l28733"></a>28733       pe1 = pc; pe2 = pa; <span class="keywordflow">break</span>;
<a name="l28734"></a>28734     <span class="keywordflow">default</span>:
<a name="l28735"></a>28735       pe1 = pe2 = (point) NULL; <span class="comment">// Avoid a compile warning.</span>
<a name="l28736"></a>28736     }
<a name="l28737"></a>28737     <span class="comment">// The shortest edge is e1-&gt;e2.</span>
<a name="l28738"></a>28738     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) bicent[i] = 0.5 * (pe1[i] + pe2[i]);
<a name="l28739"></a>28739     dist = distance(bicent, circumcent);
<a name="l28740"></a>28740     <span class="comment">// sdist = sqrt(smlen2) * sin(PI / 3.0); // A icoso-triangle.</span>
<a name="l28741"></a>28741     <span class="comment">// The following formulae is from</span>
<a name="l28742"></a>28742     sdist = b-&gt;alpha3 * (b-&gt;minratio+sqrt(b-&gt;goodratio-0.25))* sqrt(smlen2);
<a name="l28743"></a>28743     split = sdist / dist;
<a name="l28744"></a>28744     <span class="keywordflow">if</span> (split &gt; 1.0) split = 1.0;
<a name="l28745"></a>28745     <span class="comment">// Get the off-center.</span>
<a name="l28746"></a>28746     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l28747"></a>28747       offcent[i] = bicent[i] + split * (circumcent[i] - bicent[i]);
<a name="l28748"></a>28748     }
<a name="l28749"></a>28749   }
<a name="l28750"></a>28750 
<a name="l28751"></a>28751   <span class="keywordflow">if</span> (!enq &amp;&amp; (b-&gt;varvolume || b-&gt;fixedvolume)) {
<a name="l28752"></a>28752     <span class="comment">// Check if the tet has too big volume.</span>
<a name="l28753"></a>28753     enq = b-&gt;fixedvolume &amp;&amp; (volume &gt; b-&gt;maxvolume);
<a name="l28754"></a>28754     <span class="keywordflow">if</span> (!enq &amp;&amp; b-&gt;varvolume) {
<a name="l28755"></a>28755       enq = (volume &gt; volumebound(testtet-&gt;tet)) &amp;&amp;
<a name="l28756"></a>28756             (volumebound(testtet-&gt;tet) &gt; 0.0);
<a name="l28757"></a>28757     }
<a name="l28758"></a>28758   }
<a name="l28759"></a>28759 
<a name="l28760"></a>28760   <span class="keywordflow">if</span> (!enq) {
<a name="l28761"></a>28761     <span class="comment">// Check if the user-defined sizing function is satisfied.</span>
<a name="l28762"></a>28762     <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l28763"></a>28763       <span class="comment">// assert(b-&gt;alpha1 &gt; 0.0);</span>
<a name="l28764"></a>28764       sdist = sqrt(radius2) / b-&gt;alpha1;
<a name="l28765"></a>28765       <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l28766"></a>28766         pa = (point) testtet-&gt;tet[4 + i];
<a name="l28767"></a>28767         <span class="comment">// Get the indicated size of p.</span>
<a name="l28768"></a>28768         dist = pa[pointmtrindex]; <span class="comment">// dist = b-&gt;alpha1 * pa[pointmtrindex];</span>
<a name="l28769"></a>28769         enq = ((dist &lt; sdist) &amp;&amp; (dist &gt; 0.0));
<a name="l28770"></a>28770         <span class="keywordflow">if</span> (enq) <span class="keywordflow">break</span>; <span class="comment">// It is bad wrt. a node constraint.</span>
<a name="l28771"></a>28771         <span class="comment">// *** Experiment ! Stop test if c is inside H(a).</span>
<a name="l28772"></a>28772         <span class="comment">// if ((dist &gt; 0.0) &amp;&amp; (dist &gt; sdist)) break;</span>
<a name="l28773"></a>28773       }
<a name="l28774"></a>28774       <span class="comment">// *** Experiment !</span>
<a name="l28775"></a>28775       <span class="comment">// enq = (i == 4); // Does c lies outside all sparse-ball?</span>
<a name="l28776"></a>28776     } <span class="comment">// if (b-&gt;metric)</span>
<a name="l28777"></a>28777   }
<a name="l28778"></a>28778 
<a name="l28779"></a>28779   <span class="keywordflow">if</span> (enq &amp;&amp; enqflag) {
<a name="l28780"></a>28780     <span class="keywordflow">if</span> (b-&gt;offcenter &amp;&amp; (ratio2 &gt; b-&gt;goodratio)) {
<a name="l28781"></a>28781       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) circumcent[i] = offcent[i];
<a name="l28782"></a>28782     }
<a name="l28783"></a>28783     enqueuebadtet(testtet, ratio2, circumcent);
<a name="l28784"></a>28784   }
<a name="l28785"></a>28785 
<a name="l28786"></a>28786   <span class="keywordflow">return</span> enq;
<a name="l28787"></a>28787 }
<a name="l28788"></a>28788 
<a name="l28790"></a>28790 <span class="comment">//                                                                           //</span>
<a name="l28791"></a>28791 <span class="comment">// acceptsegpt()    Check if a segment point can be inserted or not.         //</span>
<a name="l28792"></a>28792 <span class="comment">//                                                                           //</span>
<a name="l28793"></a>28793 <span class="comment">// Segment(ab) is indicated to be split by a point p (\in ab). This routine  //</span>
<a name="l28794"></a>28794 <span class="comment">// decides whether p can be inserted or not.                                 //</span>
<a name="l28795"></a>28795 <span class="comment">//                                                                           //</span>
<a name="l28796"></a>28796 <span class="comment">// p can not be inserted either the &#39;-Y&#39; option is used and ab is a hull     //</span>
<a name="l28797"></a>28797 <span class="comment">// segment or &#39;-YY&#39; option is used.                                          //</span>
<a name="l28798"></a>28798 <span class="comment">//                                                                           //</span>
<a name="l28799"></a>28799 <span class="comment">// p can be inserted if it is in one of the following cases:                 //</span>
<a name="l28800"></a>28800 <span class="comment">//   (1) if L = |a - b| is too long wrt the edge constraint; or              //</span>
<a name="l28801"></a>28801 <span class="comment">//   (2) if |x - p| &gt; \alpha_2 H(x) for x = a, b; or                         //</span>
<a name="l28802"></a>28802 <span class="comment">//   (3) if &#39;refpt&#39; != NULL.                                                 //</span>
<a name="l28803"></a>28803 <span class="comment">//                                                                           //</span>
<a name="l28805"></a>28805 <span class="comment"></span>
<a name="l28806"></a>28806 <span class="keywordtype">bool</span> tetgenmesh::acceptsegpt(point segpt, point refpt, face* splitseg)
<a name="l28807"></a>28807 {
<a name="l28808"></a>28808   point p[2];
<a name="l28809"></a>28809   REAL L, lfs;
<a name="l28810"></a>28810   <span class="keywordtype">int</span> i, j;
<a name="l28811"></a>28811 
<a name="l28812"></a>28812   <span class="keywordflow">if</span> (b-&gt;nobisect == 1) {
<a name="l28813"></a>28813     <span class="comment">// &#39;-Y&#39;. It can not be split if it is on the hull.</span>
<a name="l28814"></a>28814     triface spintet;
<a name="l28815"></a>28815     point pc;
<a name="l28816"></a>28816     sstpivot(splitseg, &amp;spintet);
<a name="l28817"></a>28817     assert(spintet.tet != dummytet);
<a name="l28818"></a>28818     pc = apex(spintet);
<a name="l28819"></a>28819     <span class="keywordflow">do</span> {
<a name="l28820"></a>28820       <span class="keywordflow">if</span> (!fnextself(spintet)) {
<a name="l28821"></a>28821         <span class="comment">// Meet a boundary face - s is on the hull.</span>
<a name="l28822"></a>28822         <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l28823"></a>28823       }
<a name="l28824"></a>28824     } <span class="keywordflow">while</span> (pc != apex(spintet));
<a name="l28825"></a>28825   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;nobisect &gt; 1) {
<a name="l28826"></a>28826     <span class="comment">// &#39;-YY&#39;. Do not split it.</span>
<a name="l28827"></a>28827     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l28828"></a>28828   }
<a name="l28829"></a>28829 
<a name="l28830"></a>28830   p[0] = sorg(*splitseg);
<a name="l28831"></a>28831   p[1] = sdest(*splitseg);
<a name="l28832"></a>28832   <span class="keywordflow">if</span> (varconstraint &amp;&amp; (areabound(*splitseg) &gt; 0)) {
<a name="l28833"></a>28833     lfs = areabound(*splitseg);
<a name="l28834"></a>28834     L = distance(p[0], p[1]);
<a name="l28835"></a>28835     <span class="keywordflow">if</span> (L &gt; lfs) {
<a name="l28836"></a>28836       <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// case (1)</span>
<a name="l28837"></a>28837     }
<a name="l28838"></a>28838   }
<a name="l28839"></a>28839 
<a name="l28840"></a>28840   j = 0; <span class="comment">// Use j to count the number of inside balls.</span>
<a name="l28841"></a>28841   <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l28842"></a>28842     <span class="comment">// Check if p is inside the protect ball of q.</span>
<a name="l28843"></a>28843     <span class="keywordflow">if</span> (p[i][pointmtrindex] &gt; 0.0) {
<a name="l28844"></a>28844       lfs = b-&gt;alpha2 * p[i][pointmtrindex];
<a name="l28845"></a>28845       L = distance(p[i], segpt);
<a name="l28846"></a>28846       <span class="keywordflow">if</span> (L &lt; lfs) j++; <span class="comment">// p is inside ball.</span>
<a name="l28847"></a>28847     }
<a name="l28848"></a>28848   }
<a name="l28849"></a>28849   <span class="keywordflow">if</span> (j == 0) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// case (3).</span>
<a name="l28850"></a>28850 
<a name="l28851"></a>28851   <span class="comment">// If &#39;refpt&#39; != NULL, force p to be inserted.</span>
<a name="l28852"></a>28852   <span class="keywordflow">if</span> (refpt != (point) NULL) {
<a name="l28853"></a>28853     cdtenforcesegpts++;
<a name="l28854"></a>28854     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l28855"></a>28855   }
<a name="l28856"></a>28856 
<a name="l28857"></a>28857   <span class="comment">// Do not split it.</span>
<a name="l28858"></a>28858   rejsegpts++;
<a name="l28859"></a>28859   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l28860"></a>28860 }
<a name="l28861"></a>28861 
<a name="l28863"></a>28863 <span class="comment">//                                                                           //</span>
<a name="l28864"></a>28864 <span class="comment">// acceptfacpt()    Check if a facet point can be inserted or not.           //</span>
<a name="l28865"></a>28865 <span class="comment">//                                                                           //</span>
<a name="l28866"></a>28866 <span class="comment">// &#39;subceillist&#39; is CBC(p). &#39;verlist&#39; (V) is empty on input, it returns the  //</span>
<a name="l28867"></a>28867 <span class="comment">// set of vertices of CBC(p).                                                //</span>
<a name="l28868"></a>28868 <span class="comment">//                                                                           //</span>
<a name="l28869"></a>28869 <span class="comment">// p can not be inserted either the &#39;-Y&#39; option is used and the facet is on  //</span>
<a name="l28870"></a>28870 <span class="comment">// the hull or &#39;-YY&#39; option is used.                                         //</span>
<a name="l28871"></a>28871 <span class="comment">//                                                                           //</span>
<a name="l28872"></a>28872 <span class="comment">// p can be inserted if |p - v| &gt; \alpha_2 H(v), for all v \in V.            //</span>
<a name="l28873"></a>28873 <span class="comment">//                                                                           //</span>
<a name="l28875"></a>28875 <span class="comment"></span>
<a name="l28876"></a>28876 <span class="keywordtype">bool</span> tetgenmesh::acceptfacpt(point facpt, list* subceillist, list* verlist)
<a name="l28877"></a>28877 {
<a name="l28878"></a>28878   face *testsh;
<a name="l28879"></a>28879   point p[2], ploop;
<a name="l28880"></a>28880   REAL L, lfs;
<a name="l28881"></a>28881   <span class="keywordtype">int</span> idx, i, j;
<a name="l28882"></a>28882 
<a name="l28883"></a>28883   <span class="keywordflow">if</span> (b-&gt;nobisect == 1) {
<a name="l28884"></a>28884     <span class="comment">// &#39;-Y&#39;. p can not be inserted if CBC(p) is on the hull.</span>
<a name="l28885"></a>28885     triface testtet;
<a name="l28886"></a>28886     testsh = (face *)(* subceillist)[0];
<a name="l28887"></a>28887     stpivot(*testsh, testtet);
<a name="l28888"></a>28888     <span class="keywordflow">if</span> (testtet.tet != dummytet) {
<a name="l28889"></a>28889       sesymself(*testsh);
<a name="l28890"></a>28890       stpivot(*testsh, testtet);
<a name="l28891"></a>28891     }
<a name="l28892"></a>28892     <span class="keywordflow">if</span> (testtet.tet == dummytet) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l28893"></a>28893   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;nobisect &gt; 1) {
<a name="l28894"></a>28894     <span class="comment">// &#39;-YY&#39;. Do not split s.</span>
<a name="l28895"></a>28895     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l28896"></a>28896   }
<a name="l28897"></a>28897 
<a name="l28898"></a>28898   <span class="comment">// Collect the vertices of CBC(p), save them in V.</span>
<a name="l28899"></a>28899   <span class="keywordflow">for</span> (i = 0; i &lt; subceillist-&gt;len(); i++) {
<a name="l28900"></a>28900     testsh = (face *)(* subceillist)[i];
<a name="l28901"></a>28901     p[0] = sorg(*testsh);
<a name="l28902"></a>28902     p[1] = sdest(*testsh);
<a name="l28903"></a>28903     <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l28904"></a>28904       idx = pointmark(p[j]);
<a name="l28905"></a>28905       <span class="keywordflow">if</span> (idx &gt;= 0) {
<a name="l28906"></a>28906         setpointmark(p[j], -idx - 1);
<a name="l28907"></a>28907         verlist-&gt;append(&amp;(p[j]));
<a name="l28908"></a>28908       }
<a name="l28909"></a>28909     }
<a name="l28910"></a>28910   }
<a name="l28911"></a>28911 
<a name="l28912"></a>28912   j = 0; <span class="comment">// Use j to count the number of inside balls.</span>
<a name="l28913"></a>28913   <span class="keywordflow">for</span> (i = 0; i &lt; verlist-&gt;len(); i++) {
<a name="l28914"></a>28914     ploop = * (point *)(* verlist)[i];
<a name="l28915"></a>28915     <span class="comment">// Uninfect q.</span>
<a name="l28916"></a>28916     idx = pointmark(ploop);
<a name="l28917"></a>28917     setpointmark(ploop, -(idx + 1));
<a name="l28918"></a>28918     <span class="comment">// Check if p is inside the protect ball of q.</span>
<a name="l28919"></a>28919     <span class="keywordflow">if</span> (ploop[pointmtrindex] &gt; 0.0) {
<a name="l28920"></a>28920       lfs = b-&gt;alpha2 * ploop[pointmtrindex];
<a name="l28921"></a>28921       L = distance(ploop, facpt);
<a name="l28922"></a>28922       <span class="keywordflow">if</span> (L &lt; lfs) j++; <span class="comment">// p is inside ball.</span>
<a name="l28923"></a>28923     }
<a name="l28924"></a>28924   }
<a name="l28925"></a>28925   verlist-&gt;clear();
<a name="l28926"></a>28926 
<a name="l28927"></a>28927   <span class="keywordflow">if</span> (j == 0) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// case (3).</span>
<a name="l28928"></a>28928 
<a name="l28929"></a>28929   rejsubpts++;
<a name="l28930"></a>28930   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l28931"></a>28931 }
<a name="l28932"></a>28932 
<a name="l28934"></a>28934 <span class="comment">//                                                                           //</span>
<a name="l28935"></a>28935 <span class="comment">// acceptvolpt()    Check if a volume point can be inserted or not.          //</span>
<a name="l28936"></a>28936 <span class="comment">//                                                                           //</span>
<a name="l28937"></a>28937 <span class="comment">// &#39;ceillist&#39; is B(p).  &#39;verlist&#39; (V) is empty on input, it returns the set  //</span>
<a name="l28938"></a>28938 <span class="comment">// of vertices of B(p).                                                      //</span>
<a name="l28939"></a>28939 <span class="comment">//                                                                           //</span>
<a name="l28940"></a>28940 <span class="comment">// p can be split if |p - v| &gt; \alpha_2 H(v), for all v \in V.               //</span>
<a name="l28941"></a>28941 <span class="comment">//                                                                           //</span>
<a name="l28943"></a>28943 <span class="comment"></span>
<a name="l28944"></a>28944 <span class="keywordtype">bool</span> tetgenmesh::acceptvolpt(point volpt, list* ceillist, list* verlist)
<a name="l28945"></a>28945 {
<a name="l28946"></a>28946   triface* testtet;
<a name="l28947"></a>28947   point p[3], ploop;
<a name="l28948"></a>28948   REAL L, lfs;
<a name="l28949"></a>28949   <span class="keywordtype">int</span> idx, i, j;
<a name="l28950"></a>28950 
<a name="l28951"></a>28951   <span class="comment">// Collect the vertices of CBC(p), save them in V.</span>
<a name="l28952"></a>28952   <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l28953"></a>28953     testtet = (triface *)(* ceillist)[i];
<a name="l28954"></a>28954     p[0] = org(*testtet);
<a name="l28955"></a>28955     p[1] = dest(*testtet);
<a name="l28956"></a>28956     p[2] = apex(*testtet);
<a name="l28957"></a>28957     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l28958"></a>28958       idx = pointmark(p[j]);
<a name="l28959"></a>28959       <span class="keywordflow">if</span> (idx &gt;= 0) {
<a name="l28960"></a>28960         setpointmark(p[j], -idx - 1);
<a name="l28961"></a>28961         verlist-&gt;append(&amp;(p[j]));
<a name="l28962"></a>28962       }
<a name="l28963"></a>28963     }
<a name="l28964"></a>28964   }
<a name="l28965"></a>28965 
<a name="l28966"></a>28966   j = 0; <span class="comment">// Use j to counte the number of inside balls.</span>
<a name="l28967"></a>28967   <span class="keywordflow">for</span> (i = 0; i &lt; verlist-&gt;len(); i++) {
<a name="l28968"></a>28968     ploop = * (point *)(* verlist)[i];
<a name="l28969"></a>28969     <span class="comment">// Uninfect q.</span>
<a name="l28970"></a>28970     idx = pointmark(ploop);
<a name="l28971"></a>28971     setpointmark(ploop, -(idx + 1));
<a name="l28972"></a>28972     <span class="comment">// Check if p is inside the protect ball of q.</span>
<a name="l28973"></a>28973     <span class="keywordflow">if</span> (ploop[pointmtrindex] &gt; 0.0) {
<a name="l28974"></a>28974       lfs = b-&gt;alpha2 * ploop[pointmtrindex];
<a name="l28975"></a>28975       L = distance(ploop, volpt);
<a name="l28976"></a>28976       <span class="keywordflow">if</span> (L &lt; lfs) j++; <span class="comment">// p is inside the protect ball.</span>
<a name="l28977"></a>28977     }
<a name="l28978"></a>28978   }
<a name="l28979"></a>28979   verlist-&gt;clear();
<a name="l28980"></a>28980 
<a name="l28981"></a>28981   <span class="keywordflow">if</span> (j == 0) <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// case (2).</span>
<a name="l28982"></a>28982 
<a name="l28983"></a>28983   rejtetpts++;
<a name="l28984"></a>28984   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l28985"></a>28985 }
<a name="l28986"></a>28986 
<a name="l28988"></a>28988 <span class="comment">//                                                                           //</span>
<a name="l28989"></a>28989 <span class="comment">// getsplitpoint()    Get the inserting point in a segment.                  //</span>
<a name="l28990"></a>28990 <span class="comment">//                                                                           //</span>
<a name="l28992"></a>28992 <span class="comment"></span>
<a name="l28993"></a>28993 <span class="keywordtype">void</span> tetgenmesh::getsplitpoint(point e1, point e2, point refpt, point newpt)
<a name="l28994"></a>28994 {
<a name="l28995"></a>28995   point ei, ej;
<a name="l28996"></a>28996   REAL split, L, d1, d2, ps, rs;
<a name="l28997"></a>28997   <span class="keywordtype">bool</span> acutea, acuteb;
<a name="l28998"></a>28998   <span class="keywordtype">int</span> i;
<a name="l28999"></a>28999 
<a name="l29000"></a>29000   <span class="keywordflow">if</span> (refpt != (point) NULL) {
<a name="l29001"></a>29001     <span class="comment">// Use the CDT rules to split the segment.</span>
<a name="l29002"></a>29002     acutea = (pointtype(e1) == ACUTEVERTEX);
<a name="l29003"></a>29003     acuteb = (pointtype(e2) == ACUTEVERTEX);
<a name="l29004"></a>29004     <span class="keywordflow">if</span> (acutea ^ acuteb) {
<a name="l29005"></a>29005       <span class="comment">// Only one endpoint is acute. Use rule-2 or rule-3.</span>
<a name="l29006"></a>29006       ei = acutea ? e1 : e2;
<a name="l29007"></a>29007       ej = acutea ? e2 : e1;
<a name="l29008"></a>29008       L = distance(ei, ej);
<a name="l29009"></a>29009       <span class="comment">// Apply rule-2.</span>
<a name="l29010"></a>29010       d1 = distance(ei, refpt);
<a name="l29011"></a>29011       split = d1 / L;
<a name="l29012"></a>29012       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = ei[i] + split * (ej[i] - ei[i]);
<a name="l29013"></a>29013       <span class="comment">// Check if rule-3 is needed.</span>
<a name="l29014"></a>29014       d2 = distance(refpt, newpt);
<a name="l29015"></a>29015       <span class="keywordflow">if</span> (d2 &gt; (L - d1)) {
<a name="l29016"></a>29016         <span class="comment">// Apply rule-3.</span>
<a name="l29017"></a>29017         <span class="keywordflow">if</span> ((d1 - d2) &gt; (0.5 * d1)) {
<a name="l29018"></a>29018           split = (d1 - d2) / L;
<a name="l29019"></a>29019         } <span class="keywordflow">else</span> {
<a name="l29020"></a>29020           split = 0.5 * d1 / L;
<a name="l29021"></a>29021         }
<a name="l29022"></a>29022         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = ei[i] + split * (ej[i] - ei[i]);
<a name="l29023"></a>29023         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l29024"></a>29024           printf(<span class="stringliteral">&quot;    Found by rule-3:&quot;</span>);
<a name="l29025"></a>29025         }
<a name="l29026"></a>29026         r3count++;
<a name="l29027"></a>29027       } <span class="keywordflow">else</span> {
<a name="l29028"></a>29028         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l29029"></a>29029           printf(<span class="stringliteral">&quot;    Found by rule-2:&quot;</span>);
<a name="l29030"></a>29030         }
<a name="l29031"></a>29031         r2count++;
<a name="l29032"></a>29032       }
<a name="l29033"></a>29033       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l29034"></a>29034         printf(<span class="stringliteral">&quot; center %d, split = %.12g.\n&quot;</span>, pointmark(ei), split);
<a name="l29035"></a>29035       }
<a name="l29036"></a>29036       <span class="comment">// Add a random perturbation on newpt.</span>
<a name="l29037"></a>29037       d1 = distance(ei, newpt);
<a name="l29038"></a>29038       d2 = distance(newpt, refpt);
<a name="l29039"></a>29039       ps = randgenerator(d2 * b-&gt;epsilon2 * 1e+2);
<a name="l29040"></a>29040       rs = ps / d1;
<a name="l29041"></a>29041       <span class="comment">// Perturb newpt away from ei.</span>
<a name="l29042"></a>29042       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = ei[i] + (1.0+rs) * (newpt[i] - ei[i]);
<a name="l29043"></a>29043     } <span class="keywordflow">else</span> {
<a name="l29044"></a>29044       <span class="comment">// Both endpoints are acute or not. Split it at the middle.</span>
<a name="l29045"></a>29045       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = 0.5 * (e1[i] + e2[i]);
<a name="l29046"></a>29046       <span class="comment">// Add a random perturbation on newpt.</span>
<a name="l29047"></a>29047       d1 = 0.5 * distance(e1, e2);
<a name="l29048"></a>29048       ps = randgenerator(d1 * b-&gt;epsilon2 * 1e+2);
<a name="l29049"></a>29049       rs = ps / d1;
<a name="l29050"></a>29050       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = e1[i] + (1.0+rs) * (newpt[i] - e1[i]);
<a name="l29051"></a>29051     }
<a name="l29052"></a>29052   } <span class="keywordflow">else</span> {
<a name="l29053"></a>29053     <span class="comment">// Split the segment at its midpoint.</span>
<a name="l29054"></a>29054     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = 0.5 * (e1[i] + e2[i]);
<a name="l29055"></a>29055     <span class="comment">// Add a random perturbation on newpt.</span>
<a name="l29056"></a>29056     d1 = 0.5 * distance(e1, e2);
<a name="l29057"></a>29057     ps = randgenerator(d1 * b-&gt;epsilon2 * 1e+2);
<a name="l29058"></a>29058     rs = ps / d1;
<a name="l29059"></a>29059     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = e1[i] + (1.0+rs) * (newpt[i] - e1[i]);
<a name="l29060"></a>29060   }
<a name="l29061"></a>29061 }
<a name="l29062"></a>29062 
<a name="l29064"></a>29064 <span class="comment">//                                                                           //</span>
<a name="l29065"></a>29065 <span class="comment">// shepardinterpolation()    Interpolate the local size of a newpoint.       //</span>
<a name="l29066"></a>29066 <span class="comment">//                                                                           //</span>
<a name="l29067"></a>29067 <span class="comment">// The classical Shepard interoplation (inversed weighted distance) is used. //</span>
<a name="l29068"></a>29068 <span class="comment">// (With the choice p = 2).                                                  //</span>
<a name="l29069"></a>29069 <span class="comment">//                                                                           //</span>
<a name="l29070"></a>29070 <span class="comment">// &#39;verlist&#39; contains a list vertices neighboring to &#39;newpt&#39;.                //</span>
<a name="l29071"></a>29071 <span class="comment">//                                                                           //</span>
<a name="l29073"></a>29073 <span class="comment"></span>
<a name="l29074"></a>29074 <span class="keywordtype">void</span> tetgenmesh::shepardinterpolate(point newpt, list *verlist)
<a name="l29075"></a>29075 {
<a name="l29076"></a>29076   point neipt;
<a name="l29077"></a>29077   REAL *weights, sumweight;
<a name="l29078"></a>29078   REAL vec[3];
<a name="l29079"></a>29079   <span class="keywordtype">int</span> i, j;
<a name="l29080"></a>29080 
<a name="l29081"></a>29081   weights = <span class="keyword">new</span> REAL[verlist-&gt;len()];
<a name="l29082"></a>29082   sumweight = 0.0;
<a name="l29083"></a>29083 
<a name="l29084"></a>29084   <span class="comment">// Calculate the weight of each point.</span>
<a name="l29085"></a>29085   <span class="keywordflow">for</span> (i = 0; i &lt; verlist-&gt;len(); i++) {
<a name="l29086"></a>29086     neipt = * (point *)(* verlist)[i];
<a name="l29087"></a>29087     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) vec[j] = neipt[j] - newpt[j];
<a name="l29088"></a>29088     weights[i] = 1.0 / dot(vec, vec);
<a name="l29089"></a>29089     sumweight += weights[i];
<a name="l29090"></a>29090   }
<a name="l29091"></a>29091   <span class="comment">// Interpolate.</span>
<a name="l29092"></a>29092   newpt[pointmtrindex] = 0.0;
<a name="l29093"></a>29093   <span class="keywordflow">for</span> (i = 0; i &lt; verlist-&gt;len(); i++) {
<a name="l29094"></a>29094     neipt = * (point *)(* verlist)[i];
<a name="l29095"></a>29095     newpt[pointmtrindex] += (weights[i] * neipt[pointmtrindex]) / sumweight;
<a name="l29096"></a>29096   }
<a name="l29097"></a>29097 
<a name="l29098"></a>29098   <span class="keyword">delete</span> [] weights;
<a name="l29099"></a>29099 }
<a name="l29100"></a>29100 
<a name="l29102"></a>29102 <span class="comment">//                                                                           //</span>
<a name="l29103"></a>29103 <span class="comment">// setnewpointsize()    Set the size for a new point.                        //</span>
<a name="l29104"></a>29104 <span class="comment">//                                                                           //</span>
<a name="l29105"></a>29105 <span class="comment">// The size of the new point p is interpolated either from a background mesh //</span>
<a name="l29106"></a>29106 <span class="comment">// (b-&gt;bgmesh) or from the two input endpoints.                              //</span>
<a name="l29107"></a>29107 <span class="comment">//                                                                           //</span>
<a name="l29109"></a>29109 <span class="comment"></span>
<a name="l29110"></a>29110 <span class="keywordtype">void</span> tetgenmesh::setnewpointsize(point newpt, point e1, point e2)
<a name="l29111"></a>29111 {
<a name="l29112"></a>29112   <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l29113"></a>29113     <span class="comment">// Interpolate the point size in a background mesh.</span>
<a name="l29114"></a>29114     triface bgmtet;
<a name="l29115"></a>29115     <span class="comment">// Get a tet in background mesh for locating p.</span>
<a name="l29116"></a>29116     decode(point2bgmtet(e1), bgmtet);
<a name="l29117"></a>29117     p1interpolatebgm(newpt, &amp;bgmtet, NULL);
<a name="l29118"></a>29118   } <span class="keywordflow">else</span> {
<a name="l29119"></a>29119     <span class="keywordflow">if</span> (e2 != (point) NULL) {
<a name="l29120"></a>29120       <span class="comment">// Interpolate the size between the two endpoints.</span>
<a name="l29121"></a>29121       REAL split, l, d;
<a name="l29122"></a>29122       l = distance(e1, e2);
<a name="l29123"></a>29123       d = distance(e1, newpt);
<a name="l29124"></a>29124       split = d / l;
<a name="l29125"></a>29125 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l29126"></a>29126 <span class="preprocessor"></span>      <span class="comment">// Check if e1 and e2 are endpoints of a sharp segment.</span>
<a name="l29127"></a>29127       assert(e1[pointmtrindex] &gt; 0.0);
<a name="l29128"></a>29128       assert(e2[pointmtrindex] &gt; 0.0);
<a name="l29129"></a>29129 <span class="preprocessor">#endif</span>
<a name="l29130"></a>29130 <span class="preprocessor"></span>      newpt[pointmtrindex] = (1.0 - split) * e1[pointmtrindex]
<a name="l29131"></a>29131                            + split * e2[pointmtrindex];
<a name="l29132"></a>29132     }
<a name="l29133"></a>29133   }
<a name="l29134"></a>29134 }
<a name="l29135"></a>29135 
<a name="l29137"></a>29137 <span class="comment">//                                                                           //</span>
<a name="l29138"></a>29138 <span class="comment">// splitencseg()    Split an enc-seg and recover the Delaunayness by flips.  //</span>
<a name="l29139"></a>29139 <span class="comment">//                                                                           //</span>
<a name="l29141"></a>29141 <span class="comment"></span>
<a name="l29142"></a>29142 <span class="keywordtype">void</span> tetgenmesh::splitencseg(point newpt, face* splitseg, list* tetlist,
<a name="l29143"></a>29143   list* sublist, list* verlist, queue* flipque, <span class="keywordtype">bool</span> chkencsub, <span class="keywordtype">bool</span> chkbadtet,
<a name="l29144"></a>29144   <span class="keywordtype">bool</span> optflag)
<a name="l29145"></a>29145 {
<a name="l29146"></a>29146   list *mytetlist;
<a name="l29147"></a>29147   queue *myflipque;
<a name="l29148"></a>29148   triface starttet;
<a name="l29149"></a>29149   face startsh, spinsh, checksh;
<a name="l29150"></a>29150   <span class="keywordtype">int</span> i;
<a name="l29151"></a>29151 
<a name="l29152"></a>29152   mytetlist = NULL;
<a name="l29153"></a>29153   myflipque = NULL;
<a name="l29154"></a>29154 
<a name="l29155"></a>29155   <span class="keywordflow">if</span> (optflag) {
<a name="l29156"></a>29156     mytetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 1024);
<a name="l29157"></a>29157     myflipque = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l29158"></a>29158     tetlist = mytetlist;
<a name="l29159"></a>29159     flipque = myflipque;
<a name="l29160"></a>29160   }
<a name="l29161"></a>29161 
<a name="l29162"></a>29162   <span class="comment">// Use the base orientation (important in this routine).</span>
<a name="l29163"></a>29163   splitseg-&gt;shver = 0;
<a name="l29164"></a>29164   <span class="comment">// Insert p, this should always success.</span>
<a name="l29165"></a>29165   sstpivot(splitseg, &amp;starttet);
<a name="l29166"></a>29166   splittetedge(newpt, &amp;starttet, flipque);
<a name="l29167"></a>29167   <span class="comment">// Remove locally non-Delaunay faces by flipping.</span>
<a name="l29168"></a>29168   flip(flipque, NULL); <span class="comment">// lawson(NULL, flipque);</span>
<a name="l29169"></a>29169 
<a name="l29170"></a>29170   <span class="keywordflow">if</span> (!optflag) {
<a name="l29171"></a>29171     <span class="comment">// Check the two new subsegs to see if they&#39;re encroached (not by p).</span>
<a name="l29172"></a>29172     <span class="keywordflow">for</span> (i = 0; i &lt; 2; i++) {
<a name="l29173"></a>29173       <span class="keywordflow">if</span> (!shell2badface(*splitseg)) {
<a name="l29174"></a>29174         checkseg4encroach(splitseg, NULL, NULL, <span class="keyword">true</span>);
<a name="l29175"></a>29175       }
<a name="l29176"></a>29176       <span class="keywordflow">if</span> (i == 1) <span class="keywordflow">break</span>; <span class="comment">// Two new segs have been checked.</span>
<a name="l29177"></a>29177       senextself(*splitseg);
<a name="l29178"></a>29178       spivotself(*splitseg);
<a name="l29179"></a>29179 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l29180"></a>29180 <span class="preprocessor"></span>      assert(splitseg-&gt;sh != (shellface *) NULL);
<a name="l29181"></a>29181 <span class="preprocessor">#endif</span>
<a name="l29182"></a>29182 <span class="preprocessor"></span>      splitseg-&gt;shver = 0;
<a name="l29183"></a>29183     }
<a name="l29184"></a>29184     <span class="comment">// Check the new subfaces to see if they&#39;re encroached (not by p).</span>
<a name="l29185"></a>29185     <span class="keywordflow">if</span> (chkencsub) {
<a name="l29186"></a>29186       spivot(*splitseg, startsh);
<a name="l29187"></a>29187       spinsh = startsh;
<a name="l29188"></a>29188       <span class="keywordflow">do</span> {
<a name="l29189"></a>29189         sublist-&gt;append(&amp;spinsh);
<a name="l29190"></a>29190         formstarpolygon(newpt, sublist, verlist);
<a name="l29191"></a>29191         <span class="keywordflow">for</span> (i = 0; i &lt; sublist-&gt;len(); i++) {
<a name="l29192"></a>29192           checksh = * (face *)(* sublist)[i];
<a name="l29193"></a>29193           <span class="keywordflow">if</span> (!shell2badface(checksh)) {
<a name="l29194"></a>29194             checksub4encroach(&amp;checksh, NULL, <span class="keyword">true</span>);
<a name="l29195"></a>29195           }
<a name="l29196"></a>29196         }
<a name="l29197"></a>29197         sublist-&gt;clear();
<a name="l29198"></a>29198         <span class="keywordflow">if</span> (verlist) verlist-&gt;clear();
<a name="l29199"></a>29199         spivotself(spinsh);
<a name="l29200"></a>29200       } <span class="keywordflow">while</span> (spinsh.sh != startsh.sh);
<a name="l29201"></a>29201     }
<a name="l29202"></a>29202   } <span class="comment">// if (!optflag)</span>
<a name="l29203"></a>29203 
<a name="l29204"></a>29204   <span class="comment">// Collect the new tets connecting at p.</span>
<a name="l29205"></a>29205   sstpivot(splitseg, &amp;starttet);
<a name="l29206"></a>29206   tetlist-&gt;append(&amp;starttet);
<a name="l29207"></a>29207   formstarpolyhedron(newpt, tetlist, verlist, <span class="keyword">true</span>);
<a name="l29208"></a>29208 
<a name="l29209"></a>29209   <span class="keywordflow">if</span> (!optflag) {
<a name="l29210"></a>29210     <span class="comment">// Check if p encroaches adjacent segments.</span>
<a name="l29211"></a>29211     tallencsegs(newpt, 1, &amp;tetlist);
<a name="l29212"></a>29212     <span class="keywordflow">if</span> (chkencsub) {
<a name="l29213"></a>29213       <span class="comment">// Check if p encroaches adjacent subfaces.</span>
<a name="l29214"></a>29214       tallencsubs(newpt, 1, &amp;tetlist);
<a name="l29215"></a>29215     }
<a name="l29216"></a>29216     <span class="keywordflow">if</span> (chkbadtet) {
<a name="l29217"></a>29217       <span class="comment">// Check if there are new bad quality tets at p.</span>
<a name="l29218"></a>29218       <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l29219"></a>29219         starttet = * (triface *)(* tetlist)[i];
<a name="l29220"></a>29220         checktet4badqual(&amp;starttet, <span class="keyword">true</span>);
<a name="l29221"></a>29221       }
<a name="l29222"></a>29222     }
<a name="l29223"></a>29223     tetlist-&gt;clear();
<a name="l29224"></a>29224   } <span class="keywordflow">else</span> {
<a name="l29225"></a>29225     <span class="comment">// Check if new tets are non-optimal.</span>
<a name="l29226"></a>29226     <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l29227"></a>29227       starttet = * (triface *)(* tetlist)[i];
<a name="l29228"></a>29228       checktet4opt(&amp;starttet, <span class="keyword">true</span>);
<a name="l29229"></a>29229     }
<a name="l29230"></a>29230     <span class="keyword">delete</span> mytetlist;
<a name="l29231"></a>29231     <span class="keyword">delete</span> myflipque;
<a name="l29232"></a>29232   }
<a name="l29233"></a>29233 }
<a name="l29234"></a>29234 
<a name="l29236"></a>29236 <span class="comment">//                                                                           //</span>
<a name="l29237"></a>29237 <span class="comment">// tallencsegs()    Check for encroached segments and save them in list.     //</span>
<a name="l29238"></a>29238 <span class="comment">//                                                                           //</span>
<a name="l29239"></a>29239 <span class="comment">// If &#39;testpt&#39; (p) != NULL, only check if segments are encroached by p, else,//</span>
<a name="l29240"></a>29240 <span class="comment">// check all the nearby mesh vertices.                                       //</span>
<a name="l29241"></a>29241 <span class="comment">//                                                                           //</span>
<a name="l29242"></a>29242 <span class="comment">// If &#39;ceillists&#39; (B_i(p)) != NULL, there are &#39;n&#39; B_i(p)s, only check the    //</span>
<a name="l29243"></a>29243 <span class="comment">// segments which are on B_i(p)s, else, check the entire list of segments    //</span>
<a name="l29244"></a>29244 <span class="comment">// (in the pool &#39;this-&gt;subsegs&#39;).                                            //</span>
<a name="l29245"></a>29245 <span class="comment">//                                                                           //</span>
<a name="l29247"></a>29247 <span class="comment"></span>
<a name="l29248"></a>29248 <span class="keywordtype">bool</span> tetgenmesh::tallencsegs(point testpt, <span class="keywordtype">int</span> n, list **ceillists)
<a name="l29249"></a>29249 {
<a name="l29250"></a>29250   list *ceillist;
<a name="l29251"></a>29251   triface ceiltet;
<a name="l29252"></a>29252   face checkseg;
<a name="l29253"></a>29253   <span class="keywordtype">long</span> oldencnum;
<a name="l29254"></a>29254   <span class="keywordtype">int</span> i, j, k;
<a name="l29255"></a>29255 
<a name="l29256"></a>29256   <span class="comment">// Remember the current number of encroached segments.</span>
<a name="l29257"></a>29257   oldencnum = badsubsegs-&gt;items;
<a name="l29258"></a>29258 
<a name="l29259"></a>29259   <span class="keywordflow">if</span> (ceillists != (list **) NULL) {
<a name="l29260"></a>29260     <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l29261"></a>29261       ceillist = ceillists[k];
<a name="l29262"></a>29262       <span class="comment">// Check the segments on B_i(p).</span>
<a name="l29263"></a>29263       <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l29264"></a>29264         ceiltet = * (triface *)(* ceillist)[i];
<a name="l29265"></a>29265         ceiltet.ver = 0;
<a name="l29266"></a>29266         <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l29267"></a>29267           tsspivot(&amp;ceiltet, &amp;checkseg);
<a name="l29268"></a>29268           <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l29269"></a>29269             <span class="comment">// Found a segment. Test it if it isn&#39;t in enc-list.</span>
<a name="l29270"></a>29270             <span class="keywordflow">if</span> (!shell2badface(checkseg)) {
<a name="l29271"></a>29271               checkseg4encroach(&amp;checkseg, testpt, NULL, <span class="keyword">true</span>);
<a name="l29272"></a>29272             }
<a name="l29273"></a>29273           }
<a name="l29274"></a>29274           enextself(ceiltet);
<a name="l29275"></a>29275         }
<a name="l29276"></a>29276       }
<a name="l29277"></a>29277     }
<a name="l29278"></a>29278   } <span class="keywordflow">else</span> {
<a name="l29279"></a>29279     <span class="comment">// Check the entire list of segments.</span>
<a name="l29280"></a>29280     subsegs-&gt;traversalinit();
<a name="l29281"></a>29281     checkseg.sh = shellfacetraverse(subsegs);
<a name="l29282"></a>29282     <span class="keywordflow">while</span> (checkseg.sh != (shellface *) NULL) {
<a name="l29283"></a>29283       <span class="comment">// Test it if it isn&#39;t in enc-list.</span>
<a name="l29284"></a>29284       <span class="keywordflow">if</span> (!shell2badface(checkseg)) {
<a name="l29285"></a>29285         checkseg4encroach(&amp;checkseg, testpt, NULL, <span class="keyword">true</span>);
<a name="l29286"></a>29286       }
<a name="l29287"></a>29287       checkseg.sh = shellfacetraverse(subsegs);
<a name="l29288"></a>29288     }
<a name="l29289"></a>29289   }
<a name="l29290"></a>29290 
<a name="l29291"></a>29291   <span class="keywordflow">return</span> (badsubsegs-&gt;items &gt; oldencnum);
<a name="l29292"></a>29292 }
<a name="l29293"></a>29293 
<a name="l29295"></a>29295 <span class="comment">//                                                                           //</span>
<a name="l29296"></a>29296 <span class="comment">// tallencsubs()    Find all encroached subfaces and save them in list.      //</span>
<a name="l29297"></a>29297 <span class="comment">//                                                                           //</span>
<a name="l29298"></a>29298 <span class="comment">// If &#39;testpt&#39; (p) != NULL, only check if subfaces are encroached by p, else,//</span>
<a name="l29299"></a>29299 <span class="comment">// check the adjacent vertices of subfaces.                                  //</span>
<a name="l29300"></a>29300 <span class="comment">//                                                                           //</span>
<a name="l29301"></a>29301 <span class="comment">// If &#39;ceillists&#39; (B_i(p)) != NULL, there are &#39;n&#39; B_i(p)s, only check the    //</span>
<a name="l29302"></a>29302 <span class="comment">// subfaces which are on B_i(p)s, else, check the entire list of subfaces    //</span>
<a name="l29303"></a>29303 <span class="comment">// (in the pool &#39;this-&gt;subfaces&#39;).                                           //</span>
<a name="l29304"></a>29304 <span class="comment">//                                                                           //</span>
<a name="l29306"></a>29306 <span class="comment"></span>
<a name="l29307"></a>29307 <span class="keywordtype">bool</span> tetgenmesh::tallencsubs(point testpt, <span class="keywordtype">int</span> n, list** ceillists)
<a name="l29308"></a>29308 {
<a name="l29309"></a>29309   list *ceillist;
<a name="l29310"></a>29310   triface ceiltet;
<a name="l29311"></a>29311   face checksh;
<a name="l29312"></a>29312   <span class="keywordtype">long</span> oldencnum;
<a name="l29313"></a>29313   <span class="keywordtype">int</span> i, k;
<a name="l29314"></a>29314 
<a name="l29315"></a>29315   <span class="comment">// Remember the current number of encroached segments.</span>
<a name="l29316"></a>29316   oldencnum = badsubfaces-&gt;items;
<a name="l29317"></a>29317 
<a name="l29318"></a>29318   <span class="keywordflow">if</span> (ceillists != (list **) NULL) {
<a name="l29319"></a>29319     <span class="keywordflow">for</span> (k = 0; k &lt; n; k++) {
<a name="l29320"></a>29320       ceillist = ceillists[k];
<a name="l29321"></a>29321       <span class="comment">// Check the subfaces on B_i(p).</span>
<a name="l29322"></a>29322       <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l29323"></a>29323         ceiltet = * (triface *)(* ceillist)[i];
<a name="l29324"></a>29324         tspivot(ceiltet, checksh);
<a name="l29325"></a>29325         <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l29326"></a>29326           <span class="comment">// Found a subface. Test it if it isn&#39;t in enc-list.</span>
<a name="l29327"></a>29327           <span class="keywordflow">if</span> (!shell2badface(checksh)) {
<a name="l29328"></a>29328             checksub4encroach(&amp;checksh, testpt, <span class="keyword">true</span>);
<a name="l29329"></a>29329           }
<a name="l29330"></a>29330         }
<a name="l29331"></a>29331       }
<a name="l29332"></a>29332     }
<a name="l29333"></a>29333   } <span class="keywordflow">else</span> {
<a name="l29334"></a>29334     <span class="comment">// Check the entire list of subfaces.</span>
<a name="l29335"></a>29335     subfaces-&gt;traversalinit();
<a name="l29336"></a>29336     checksh.sh = shellfacetraverse(subfaces);
<a name="l29337"></a>29337     <span class="keywordflow">while</span> (checksh.sh != (shellface *) NULL) {
<a name="l29338"></a>29338       <span class="comment">// Test it if it isn&#39;t in enc-list.</span>
<a name="l29339"></a>29339       <span class="keywordflow">if</span> (!shell2badface(checksh)) {
<a name="l29340"></a>29340         checksub4encroach(&amp;checksh, testpt, <span class="keyword">true</span>);
<a name="l29341"></a>29341       }
<a name="l29342"></a>29342       checksh.sh = shellfacetraverse(subfaces);
<a name="l29343"></a>29343     }
<a name="l29344"></a>29344   }
<a name="l29345"></a>29345 
<a name="l29346"></a>29346   <span class="keywordflow">return</span> (badsubfaces-&gt;items &gt; oldencnum);
<a name="l29347"></a>29347 }
<a name="l29348"></a>29348 
<a name="l29350"></a>29350 <span class="comment">//                                                                           //</span>
<a name="l29351"></a>29351 <span class="comment">// tallbadtetrahedrons()    Queue all the bad-quality tetrahedra in the mesh.//</span>
<a name="l29352"></a>29352 <span class="comment">//                                                                           //</span>
<a name="l29354"></a>29354 <span class="comment"></span>
<a name="l29355"></a>29355 <span class="keywordtype">void</span> tetgenmesh::tallbadtetrahedrons()
<a name="l29356"></a>29356 {
<a name="l29357"></a>29357   triface tetloop;
<a name="l29358"></a>29358 
<a name="l29359"></a>29359   tetrahedrons-&gt;traversalinit();
<a name="l29360"></a>29360   tetloop.tet = tetrahedrontraverse();
<a name="l29361"></a>29361   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l29362"></a>29362     checktet4badqual(&amp;tetloop, <span class="keyword">true</span>);
<a name="l29363"></a>29363     tetloop.tet = tetrahedrontraverse();
<a name="l29364"></a>29364   }
<a name="l29365"></a>29365 }
<a name="l29366"></a>29366 
<a name="l29368"></a>29368 <span class="comment">//                                                                           //</span>
<a name="l29369"></a>29369 <span class="comment">// repairencsegs()    Repair (split) all the encroached segments.            //</span>
<a name="l29370"></a>29370 <span class="comment">//                                                                           //</span>
<a name="l29371"></a>29371 <span class="comment">// Each encroached segment is repaired by splitting it - inserting a vertex  //</span>
<a name="l29372"></a>29372 <span class="comment">// at or near its midpoint.  Newly inserted vertices may encroach upon other //</span>
<a name="l29373"></a>29373 <span class="comment">// subsegments, these are also repaired.                                     //</span>
<a name="l29374"></a>29374 <span class="comment">//                                                                           //</span>
<a name="l29375"></a>29375 <span class="comment">// &#39;chkencsub&#39; and &#39;chkbadtet&#39; are two flags that specify whether one should //</span>
<a name="l29376"></a>29376 <span class="comment">// take note of new encroaced subfaces and bad quality tets that result from //</span>
<a name="l29377"></a>29377 <span class="comment">// inserting vertices to repair encroached subsegments.                      //</span>
<a name="l29378"></a>29378 <span class="comment">//                                                                           //</span>
<a name="l29380"></a>29380 <span class="comment"></span>
<a name="l29381"></a>29381 <span class="keywordtype">void</span> tetgenmesh::repairencsegs(<span class="keywordtype">bool</span> chkencsub, <span class="keywordtype">bool</span> chkbadtet)
<a name="l29382"></a>29382 {
<a name="l29383"></a>29383   list **tetlists, **ceillists;
<a name="l29384"></a>29384   list **sublists, **subceillists;
<a name="l29385"></a>29385   list *tetlist, *sublist;
<a name="l29386"></a>29386   queue *flipque;
<a name="l29387"></a>29387   badface *encloop;
<a name="l29388"></a>29388   face splitseg, symsplitseg;
<a name="l29389"></a>29389   point newpt, sympt, refpt;
<a name="l29390"></a>29390   point e1, e2;
<a name="l29391"></a>29391   <span class="keyword">enum</span> locateresult symloc;
<a name="l29392"></a>29392   <span class="keywordtype">int</span> nmax, n, i, j;
<a name="l29393"></a>29393 
<a name="l29394"></a>29394   ceillists = NULL;
<a name="l29395"></a>29395   flipque = NULL;
<a name="l29396"></a>29396   subceillists = NULL;
<a name="l29397"></a>29397   sublist = NULL;
<a name="l29398"></a>29398   sublists = NULL;
<a name="l29399"></a>29399   tetlist = NULL;
<a name="l29400"></a>29400   tetlists = NULL;
<a name="l29401"></a>29401 
<a name="l29402"></a>29402   n = 0;
<a name="l29403"></a>29403   nmax = 128;
<a name="l29404"></a>29404   <span class="keywordflow">if</span> (!b-&gt;fliprepair) {
<a name="l29405"></a>29405     tetlists = <span class="keyword">new</span> list*[nmax];
<a name="l29406"></a>29406     ceillists = <span class="keyword">new</span> list*[nmax];
<a name="l29407"></a>29407     sublists = <span class="keyword">new</span> list*[nmax];
<a name="l29408"></a>29408     subceillists = <span class="keyword">new</span> list*[nmax];
<a name="l29409"></a>29409   } <span class="keywordflow">else</span> {
<a name="l29410"></a>29410     tetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 1024);
<a name="l29411"></a>29411     sublist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(face), NULL, 256);
<a name="l29412"></a>29412     flipque = <span class="keyword">new</span> queue(<span class="keyword">sizeof</span>(badface));
<a name="l29413"></a>29413   }
<a name="l29414"></a>29414 
<a name="l29415"></a>29415   <span class="comment">// Loop until the pool &#39;badsubsegs&#39; is empty. Note that steinerleft == -1</span>
<a name="l29416"></a>29416   <span class="comment">//   if an unlimited number of Steiner points is allowed.</span>
<a name="l29417"></a>29417   <span class="keywordflow">while</span> ((badsubsegs-&gt;items &gt; 0) &amp;&amp; (steinerleft != 0)) {
<a name="l29418"></a>29418     badsubsegs-&gt;traversalinit();
<a name="l29419"></a>29419     encloop = badfacetraverse(badsubsegs);
<a name="l29420"></a>29420     <span class="keywordflow">while</span> ((encloop != (badface *) NULL) &amp;&amp; (steinerleft != 0)) {
<a name="l29421"></a>29421       <span class="comment">// Get an encroached subsegment s.</span>
<a name="l29422"></a>29422       splitseg = encloop-&gt;ss;
<a name="l29423"></a>29423       <span class="comment">// Clear the in-queue flag in s.</span>
<a name="l29424"></a>29424       setshell2badface(splitseg, NULL);
<a name="l29425"></a>29425       <span class="keywordflow">if</span> ((sorg(splitseg) == encloop-&gt;forg) &amp;&amp;
<a name="l29426"></a>29426           (sdest(splitseg) == encloop-&gt;fdest)) {
<a name="l29427"></a>29427         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l29428"></a>29428           printf(<span class="stringliteral">&quot;  Get an enc-seg (%d, %d)\n&quot;</span>, pointmark(encloop-&gt;forg),
<a name="l29429"></a>29429                  pointmark(encloop-&gt;fdest));
<a name="l29430"></a>29430         }
<a name="l29431"></a>29431         refpt = (point) NULL;
<a name="l29432"></a>29432         <span class="keywordflow">if</span> (b-&gt;conformdel) {
<a name="l29433"></a>29433           <span class="comment">// Look for a reference point.</span>
<a name="l29434"></a>29434           checkseg4encroach(&amp;splitseg, NULL, &amp;refpt, <span class="keyword">false</span>);
<a name="l29435"></a>29435         }
<a name="l29436"></a>29436         <span class="comment">// Create the new point p (at the middle of s).</span>
<a name="l29437"></a>29437         makepoint(&amp;newpt);
<a name="l29438"></a>29438         getsplitpoint(encloop-&gt;forg, encloop-&gt;fdest, refpt, newpt);
<a name="l29439"></a>29439         setpointtype(newpt, FREESEGVERTEX);
<a name="l29440"></a>29440         setpoint2sh(newpt, sencode(splitseg));
<a name="l29441"></a>29441         <span class="comment">// Decide whether p can be inserted or not.</span>
<a name="l29442"></a>29442         <span class="keywordflow">if</span> (acceptsegpt(newpt, refpt, &amp;splitseg)) {
<a name="l29443"></a>29443           <span class="comment">// Is there periodic boundary condition?</span>
<a name="l29444"></a>29444           <span class="keywordflow">if</span> (checkpbcs) {
<a name="l29445"></a>29445             <span class="comment">// Insert points on other segments of incident pbcgroups.</span>
<a name="l29446"></a>29446             i = shellmark(splitseg) - 1;
<a name="l29447"></a>29447             <span class="keywordflow">for</span> (j = idx2segpglist[i]; j &lt; idx2segpglist[i + 1]; j++) {
<a name="l29448"></a>29448               makepoint(&amp;sympt);
<a name="l29449"></a>29449               symloc = getsegpbcsympoint(newpt, &amp;splitseg, sympt, &amp;symsplitseg,
<a name="l29450"></a>29450                                          segpglist[j]);
<a name="l29451"></a>29451               <span class="keywordflow">if</span> (symloc == ONEDGE) {
<a name="l29452"></a>29452                 <span class="keywordflow">if</span> (symsplitseg.sh != splitseg.sh) {
<a name="l29453"></a>29453                   <span class="comment">// Insert sympt.</span>
<a name="l29454"></a>29454                   setpointtype(sympt, FREESEGVERTEX);
<a name="l29455"></a>29455                   setpoint2sh(sympt, sencode(symsplitseg));
<a name="l29456"></a>29456                   <span class="comment">// Save the endpoints of the seg for size interpolation.</span>
<a name="l29457"></a>29457                   e1 = sorg(symsplitseg);
<a name="l29458"></a>29458                   <span class="keywordflow">if</span> (shelltype(symsplitseg) == SHARP) {
<a name="l29459"></a>29459                     e2 = sdest(symsplitseg);
<a name="l29460"></a>29460                   } <span class="keywordflow">else</span> {
<a name="l29461"></a>29461                     e2 = (point) NULL; <span class="comment">// No need to do size interpolation.</span>
<a name="l29462"></a>29462                   }
<a name="l29463"></a>29463                   <span class="keywordflow">if</span> (!b-&gt;fliprepair) {
<a name="l29464"></a>29464                     <span class="comment">// Form BC(symp), B(symp), CBC(symp)s, C(symp)s.</span>
<a name="l29465"></a>29465                     formbowatcavity(sympt, &amp;symsplitseg, NULL, &amp;n, &amp;nmax,
<a name="l29466"></a>29466                       sublists, subceillists, tetlists, ceillists);
<a name="l29467"></a>29467                     <span class="comment">// Validate BC(symp), B(symp), CBC(symp)s, C(symp)s.</span>
<a name="l29468"></a>29468                     <span class="keywordflow">if</span> (trimbowatcavity(sympt, &amp;symsplitseg, n, sublists,
<a name="l29469"></a>29469                           subceillists, tetlists, ceillists, -1.0)) {
<a name="l29470"></a>29470                       bowatinsertsite(sympt, &amp;symsplitseg, n, sublists,
<a name="l29471"></a>29471                         subceillists, tetlists, ceillists, NULL, flipque,
<a name="l29472"></a>29472                         <span class="keyword">true</span>, chkencsub, chkbadtet);
<a name="l29473"></a>29473                       setnewpointsize(sympt, e1, e2);
<a name="l29474"></a>29474                       <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l29475"></a>29475                     } <span class="keywordflow">else</span> {
<a name="l29476"></a>29476                       <span class="comment">// p did not insert for invalid BC(symp).</span>
<a name="l29477"></a>29477                       pointdealloc(sympt);
<a name="l29478"></a>29478                     }
<a name="l29479"></a>29479                     <span class="comment">// Free the memory allocated in formbowatcavity().</span>
<a name="l29480"></a>29480                     releasebowatcavity(&amp;symsplitseg, n, sublists, subceillists,
<a name="l29481"></a>29481                                        tetlists, ceillists);
<a name="l29482"></a>29482                   } <span class="keywordflow">else</span> {
<a name="l29483"></a>29483                     splitencseg(sympt, &amp;symsplitseg, tetlist, sublist, NULL,
<a name="l29484"></a>29484                                 flipque, chkencsub, chkbadtet, <span class="keyword">false</span>);
<a name="l29485"></a>29485                     setnewpointsize(sympt, e1, e2);
<a name="l29486"></a>29486                     <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l29487"></a>29487                   }
<a name="l29488"></a>29488                 } <span class="keywordflow">else</span> {
<a name="l29489"></a>29489                   <span class="comment">// The sympt are on the same segment. It is possible when</span>
<a name="l29490"></a>29490                   <span class="comment">//   splitseg is the symmetric rotating axes.</span>
<a name="l29491"></a>29491                   pointdealloc(sympt);
<a name="l29492"></a>29492                 }
<a name="l29493"></a>29493               } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (symloc == ONVERTEX) {
<a name="l29494"></a>29494                 <span class="comment">// The sympt already exists. It is possible when two pbc</span>
<a name="l29495"></a>29495                 <span class="comment">//   groups are exactly the same. Omit this point.</span>
<a name="l29496"></a>29496                 pointdealloc(sympt);
<a name="l29497"></a>29497               } <span class="keywordflow">else</span> {
<a name="l29498"></a>29498                 <span class="comment">// Do not isnert symp for unknown cases: ONFACE, OUTSIDE.</span>
<a name="l29499"></a>29499                 <span class="comment">// assert(0);</span>
<a name="l29500"></a>29500                 pointdealloc(sympt);
<a name="l29501"></a>29501               }
<a name="l29502"></a>29502             } <span class="comment">// for (j = idx2segpglist[i]; j &lt; idx2segpglist[i + 1]; j++)</span>
<a name="l29503"></a>29503           } <span class="comment">// if (checkpbcs)</span>
<a name="l29504"></a>29504           <span class="comment">// Save the endpoints of the seg for size interpolation.</span>
<a name="l29505"></a>29505           e1 = sorg(splitseg);
<a name="l29506"></a>29506           <span class="keywordflow">if</span> (shelltype(splitseg) == SHARP) {
<a name="l29507"></a>29507             e2 = sdest(splitseg);
<a name="l29508"></a>29508           } <span class="keywordflow">else</span> {
<a name="l29509"></a>29509             e2 = (point) NULL; <span class="comment">// No need to do size interoplation.</span>
<a name="l29510"></a>29510           }
<a name="l29511"></a>29511           <span class="keywordflow">if</span> (!b-&gt;fliprepair) {
<a name="l29512"></a>29512             <span class="comment">// Form BC(p), B(p), CBC(p)s, and C(p)s.</span>
<a name="l29513"></a>29513             formbowatcavity(newpt, &amp;splitseg, NULL, &amp;n, &amp;nmax, sublists,
<a name="l29514"></a>29514                             subceillists, tetlists, ceillists);
<a name="l29515"></a>29515             <span class="comment">// Validate/update BC(p), B(p), CBC(p)s, and C(p)s.</span>
<a name="l29516"></a>29516             <span class="keywordflow">if</span> (trimbowatcavity(newpt, &amp;splitseg, n, sublists, subceillists,
<a name="l29517"></a>29517                                 tetlists, ceillists, -1.0)) {
<a name="l29518"></a>29518               bowatinsertsite(newpt, &amp;splitseg, n, sublists, subceillists,
<a name="l29519"></a>29519                               tetlists, ceillists, NULL, flipque, <span class="keyword">true</span>,
<a name="l29520"></a>29520                               chkencsub, chkbadtet);
<a name="l29521"></a>29521               setnewpointsize(newpt, e1, e2);
<a name="l29522"></a>29522               <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l29523"></a>29523             } <span class="keywordflow">else</span> {
<a name="l29524"></a>29524               <span class="comment">// p did not insert for invalid B(p).</span>
<a name="l29525"></a>29525               pointdealloc(newpt);
<a name="l29526"></a>29526             }
<a name="l29527"></a>29527             <span class="comment">// Free the memory allocated in formbowatcavity().</span>
<a name="l29528"></a>29528             releasebowatcavity(&amp;splitseg, n, sublists, subceillists, tetlists,
<a name="l29529"></a>29529                                ceillists);
<a name="l29530"></a>29530           } <span class="keywordflow">else</span> {
<a name="l29531"></a>29531             splitencseg(newpt, &amp;splitseg, tetlist, sublist, NULL, flipque,
<a name="l29532"></a>29532                         chkencsub, chkbadtet, <span class="keyword">false</span>);
<a name="l29533"></a>29533             setnewpointsize(newpt, e1, e2);
<a name="l29534"></a>29534             <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l29535"></a>29535           }
<a name="l29536"></a>29536         } <span class="keywordflow">else</span> {
<a name="l29537"></a>29537           <span class="comment">// p did not accept for insertion.</span>
<a name="l29538"></a>29538           pointdealloc(newpt);
<a name="l29539"></a>29539         } <span class="comment">// if (checkseg4splitting(newpt, &amp;splitseg))</span>
<a name="l29540"></a>29540       } <span class="comment">// if ((encloop-&gt;forg == pa) &amp;&amp; (encloop-&gt;fdest == pb))</span>
<a name="l29541"></a>29541       badfacedealloc(badsubsegs, encloop); <span class="comment">// Remove this entry from list.</span>
<a name="l29542"></a>29542       encloop = badfacetraverse(badsubsegs); <span class="comment">// Get the next enc-segment.</span>
<a name="l29543"></a>29543     } <span class="comment">// while ((encloop != (badface *) NULL) &amp;&amp; (steinerleft != 0))</span>
<a name="l29544"></a>29544   } <span class="comment">// while ((badsubsegs-&gt;items &gt; 0) &amp;&amp; (steinerleft != 0))</span>
<a name="l29545"></a>29545 
<a name="l29546"></a>29546   <span class="keywordflow">if</span> (!b-&gt;fliprepair) {
<a name="l29547"></a>29547     <span class="keyword">delete</span> [] tetlists;
<a name="l29548"></a>29548     <span class="keyword">delete</span> [] ceillists;
<a name="l29549"></a>29549     <span class="keyword">delete</span> [] sublists;
<a name="l29550"></a>29550     <span class="keyword">delete</span> [] subceillists;
<a name="l29551"></a>29551   } <span class="keywordflow">else</span> {
<a name="l29552"></a>29552     <span class="keyword">delete</span> tetlist;
<a name="l29553"></a>29553     <span class="keyword">delete</span> sublist;
<a name="l29554"></a>29554     <span class="keyword">delete</span> flipque;
<a name="l29555"></a>29555   }
<a name="l29556"></a>29556 }
<a name="l29557"></a>29557 
<a name="l29559"></a>29559 <span class="comment">//                                                                           //</span>
<a name="l29560"></a>29560 <span class="comment">// repairencsubs()    Repair (split) all the encroached subfaces.            //</span>
<a name="l29561"></a>29561 <span class="comment">//                                                                           //</span>
<a name="l29562"></a>29562 <span class="comment">// Each encroached subface is repaired by splitting it - inserting a vertex  //</span>
<a name="l29563"></a>29563 <span class="comment">// at or near its circumcenter.  Newly inserted vertices may encroach upon   //</span>
<a name="l29564"></a>29564 <span class="comment">// other subfaces, these are also repaired.                                  //</span>
<a name="l29565"></a>29565 <span class="comment">//                                                                           //</span>
<a name="l29566"></a>29566 <span class="comment">// &#39;chkbadtet&#39; is a flag that specifies whether one should take note of new  //</span>
<a name="l29567"></a>29567 <span class="comment">// bad quality tets that result from inserted vertices.                      //</span>
<a name="l29568"></a>29568 <span class="comment">//                                                                           //</span>
<a name="l29570"></a>29570 <span class="comment"></span>
<a name="l29571"></a>29571 <span class="keywordtype">void</span> tetgenmesh::repairencsubs(<span class="keywordtype">bool</span> chkbadtet)
<a name="l29572"></a>29572 {
<a name="l29573"></a>29573   list *tetlists[2], *ceillists[2];
<a name="l29574"></a>29574   list *sublist, *subceillist;
<a name="l29575"></a>29575   list *verlist;
<a name="l29576"></a>29576   badface *encloop;
<a name="l29577"></a>29577   face splitsub, symsplitsub;
<a name="l29578"></a>29578   point newpt, sympt, e1;
<a name="l29579"></a>29579   <span class="keyword">enum</span> locateresult loc, symloc;
<a name="l29580"></a>29580   <span class="keywordtype">bool</span> reject;
<a name="l29581"></a>29581   <span class="keywordtype">long</span> oldptnum;
<a name="l29582"></a>29582   <span class="keywordtype">int</span> quenumber, n, i;
<a name="l29583"></a>29583 
<a name="l29584"></a>29584   quenumber = 0;
<a name="l29585"></a>29585   n = 0;
<a name="l29586"></a>29586   sublist = (list *) NULL;
<a name="l29587"></a>29587   subceillist = (list *) NULL;
<a name="l29588"></a>29588   verlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL, 256);
<a name="l29589"></a>29589 
<a name="l29590"></a>29590   <span class="comment">// Loop until the pool &#39;badsubfaces&#39; is empty. Note that steinerleft == -1</span>
<a name="l29591"></a>29591   <span class="comment">//   if an unlimited number of Steiner points is allowed.</span>
<a name="l29592"></a>29592   <span class="keywordflow">while</span> ((badsubfaces-&gt;items &gt; 0) &amp;&amp; (steinerleft != 0)) {
<a name="l29593"></a>29593     <span class="comment">// Get an encroached subface f.</span>
<a name="l29594"></a>29594     encloop = dequeueencsub(&amp;quenumber);
<a name="l29595"></a>29595     splitsub = encloop-&gt;ss;
<a name="l29596"></a>29596     <span class="comment">// Clear the in-queue flag of f.</span>
<a name="l29597"></a>29597     setshell2badface(splitsub, NULL);
<a name="l29598"></a>29598     <span class="comment">// f may not be the same one when it was determined to be encroached.</span>
<a name="l29599"></a>29599     <span class="keywordflow">if</span> (!isdead(&amp;splitsub)
<a name="l29600"></a>29600         &amp;&amp; (sorg(splitsub) == encloop-&gt;forg)
<a name="l29601"></a>29601         &amp;&amp; (sdest(splitsub) == encloop-&gt;fdest)
<a name="l29602"></a>29602         &amp;&amp; (sapex(splitsub) == encloop-&gt;fapex)) {
<a name="l29603"></a>29603       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l29604"></a>29604         printf(<span class="stringliteral">&quot;    Dequeuing ensub (%d, %d, %d) [%d].\n&quot;</span>,
<a name="l29605"></a>29605                pointmark(encloop-&gt;forg), pointmark(encloop-&gt;fdest),
<a name="l29606"></a>29606                pointmark(encloop-&gt;fapex), quenumber);
<a name="l29607"></a>29607       }
<a name="l29608"></a>29608       <span class="comment">// Create a new point p at the circumcenter of f.</span>
<a name="l29609"></a>29609       makepoint(&amp;newpt);
<a name="l29610"></a>29610       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = encloop-&gt;cent[i];
<a name="l29611"></a>29611       setpointtype(newpt, FREESUBVERTEX);
<a name="l29612"></a>29612       setpoint2sh(newpt, sencode(splitsub));
<a name="l29613"></a>29613       <span class="comment">// Set the abovepoint of f for point location.</span>
<a name="l29614"></a>29614       abovepoint = facetabovepointarray[shellmark(splitsub)];
<a name="l29615"></a>29615       <span class="keywordflow">if</span> (abovepoint == (point) NULL) {
<a name="l29616"></a>29616         getfacetabovepoint(&amp;splitsub);
<a name="l29617"></a>29617       }
<a name="l29618"></a>29618       <span class="comment">// Locate p, start from f, stop at segment (1), use a tolerance to</span>
<a name="l29619"></a>29619       <span class="comment">//   detect ONVERTEX or OUTSIDE case. Update f on return.</span>
<a name="l29620"></a>29620       loc = locatesub(newpt, &amp;splitsub, 1, b-&gt;epsilon * 1e+2);
<a name="l29621"></a>29621       <span class="keywordflow">if</span> ((loc != ONVERTEX) &amp;&amp; (loc != OUTSIDE)) {
<a name="l29622"></a>29622         <span class="comment">// Form BC(p), B(p), CBC(p) and C(p).</span>
<a name="l29623"></a>29623         formbowatcavity(newpt, NULL, &amp;splitsub, &amp;n, NULL, &amp;sublist,
<a name="l29624"></a>29624                         &amp;subceillist, tetlists, ceillists);
<a name="l29625"></a>29625         <span class="comment">// Check for encroached subsegments (on B(p)).</span>
<a name="l29626"></a>29626         reject = tallencsegs(newpt, 2, ceillists);
<a name="l29627"></a>29627         <span class="comment">// Execute point accept rule if p does not encroach upon any segment.</span>
<a name="l29628"></a>29628         <span class="keywordflow">if</span> (!reject) {
<a name="l29629"></a>29629           reject = !acceptfacpt(newpt, subceillist, verlist);
<a name="l29630"></a>29630         }
<a name="l29631"></a>29631         <span class="keywordflow">if</span> (!reject) {
<a name="l29632"></a>29632           <span class="comment">// Validate/update cavity.</span>
<a name="l29633"></a>29633           reject = !trimbowatcavity(newpt, NULL, n, &amp;sublist, &amp;subceillist,
<a name="l29634"></a>29634                                     tetlists, ceillists, -1.0);
<a name="l29635"></a>29635         }
<a name="l29636"></a>29636         <span class="keywordflow">if</span> (!reject) {
<a name="l29637"></a>29637           <span class="comment">// CBC(p) should include s, so that s can be removed after CBC(p)</span>
<a name="l29638"></a>29638           <span class="comment">//   is remeshed. However, if there are locally non-Delaunay faces</span>
<a name="l29639"></a>29639           <span class="comment">//   and encroached subsegments, s may not be collected in CBC(p).</span>
<a name="l29640"></a>29640           <span class="comment">//   p should not be inserted in such case.</span>
<a name="l29641"></a>29641           reject = !sinfected(encloop-&gt;ss);
<a name="l29642"></a>29642         }
<a name="l29643"></a>29643         <span class="keywordflow">if</span> (!reject) {
<a name="l29644"></a>29644           <span class="keywordflow">if</span> (checkpbcs) {
<a name="l29645"></a>29645             <span class="keywordflow">if</span> (shellpbcgroup(splitsub) &gt;= 0) {
<a name="l29646"></a>29646               <span class="comment">// Check for splitting of the symmetric subface of f.</span>
<a name="l29647"></a>29647               makepoint(&amp;sympt);
<a name="l29648"></a>29648               symloc = getsubpbcsympoint(newpt,&amp;splitsub,sympt,&amp;symsplitsub);
<a name="l29649"></a>29649               <span class="keywordflow">if</span> (symloc != ONVERTEX) {
<a name="l29650"></a>29650                 <span class="comment">// Release CBC(p) and BC(p) and free the memory..</span>
<a name="l29651"></a>29651                 releasebowatcavity(NULL, 2, &amp;sublist, &amp;subceillist, tetlists,
<a name="l29652"></a>29652                                    ceillists);
<a name="l29653"></a>29653                 <span class="comment">// Form CBC(symp), C(symp), BC(sympt) and B(sympt).</span>
<a name="l29654"></a>29654                 formbowatcavity(sympt, NULL, &amp;symsplitsub, &amp;n, NULL, &amp;sublist,
<a name="l29655"></a>29655                                 &amp;subceillist, tetlists, ceillists);
<a name="l29656"></a>29656                 reject = tallencsegs(sympt, 2, ceillists);
<a name="l29657"></a>29657                 <span class="keywordflow">if</span> (!reject) {
<a name="l29658"></a>29658                   reject = !acceptfacpt(sympt, subceillist, verlist);
<a name="l29659"></a>29659                 }
<a name="l29660"></a>29660                 <span class="keywordflow">if</span> (!reject) {
<a name="l29661"></a>29661                   reject = !trimbowatcavity(sympt,NULL,n,&amp;sublist,&amp;subceillist,
<a name="l29662"></a>29662                                             tetlists, ceillists, -1.0);
<a name="l29663"></a>29663                 }
<a name="l29664"></a>29664                 <span class="keywordflow">if</span> (!reject) {
<a name="l29665"></a>29665                   <span class="comment">// Insert sympt.</span>
<a name="l29666"></a>29666                   setpoint2pbcpt(newpt, sympt);
<a name="l29667"></a>29667                   setpoint2pbcpt(sympt, newpt);
<a name="l29668"></a>29668                   setpointtype(sympt, FREESUBVERTEX);
<a name="l29669"></a>29669                   setpoint2sh(sympt, sencode(symsplitsub));
<a name="l29670"></a>29670                   <span class="comment">// Save a point for size interpolation.</span>
<a name="l29671"></a>29671                   e1 = sorg(symsplitsub);
<a name="l29672"></a>29672                   bowatinsertsite(sympt, NULL, n, &amp;sublist, &amp;subceillist,
<a name="l29673"></a>29673                      tetlists,ceillists,NULL,NULL,<span class="keyword">false</span>,<span class="keyword">true</span>,chkbadtet);
<a name="l29674"></a>29674                   setnewpointsize(sympt, e1, NULL);
<a name="l29675"></a>29675                   <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l29676"></a>29676                   <span class="comment">// Release CBC(symp) and BC(symp) and free the memory..</span>
<a name="l29677"></a>29677                   releasebowatcavity(NULL, n, &amp;sublist, &amp;subceillist, tetlists,
<a name="l29678"></a>29678                                      ceillists);
<a name="l29679"></a>29679                 } <span class="keywordflow">else</span> {
<a name="l29680"></a>29680                   <span class="comment">// symp is rejected for one of the following reasons:</span>
<a name="l29681"></a>29681                   <span class="comment">//   (1) BC(symp) is not valid; or</span>
<a name="l29682"></a>29682                   <span class="comment">//   (2) symp encroaches upon some subsegments (queued); or</span>
<a name="l29683"></a>29683                   <span class="comment">//   (3) symp is rejected by point accepting rule.</span>
<a name="l29684"></a>29684                   pointdealloc(sympt);
<a name="l29685"></a>29685                   <span class="comment">// Cavity will be released by the following code.</span>
<a name="l29686"></a>29686                 }
<a name="l29687"></a>29687               } <span class="keywordflow">else</span> {
<a name="l29688"></a>29688                 <span class="comment">// Do not insert sympt for invalid PBC data.</span>
<a name="l29689"></a>29689                 pointdealloc(sympt);
<a name="l29690"></a>29690                 <span class="comment">// p is rejected due to symp.</span>
<a name="l29691"></a>29691                 reject = <span class="keyword">true</span>;
<a name="l29692"></a>29692               }
<a name="l29693"></a>29693             }
<a name="l29694"></a>29694           } <span class="comment">// if (checkpbcs)</span>
<a name="l29695"></a>29695         }
<a name="l29696"></a>29696         <span class="keywordflow">if</span> (!reject) {
<a name="l29697"></a>29697           <span class="comment">// Insert p.</span>
<a name="l29698"></a>29698           <span class="keywordflow">if</span> (checkpbcs) {
<a name="l29699"></a>29699             <span class="keywordflow">if</span> (shellpbcgroup(splitsub) &gt;= 0) {
<a name="l29700"></a>29700               <span class="comment">// Form CBC(p), C(p), BC(p) and B(p).</span>
<a name="l29701"></a>29701               formbowatcavity(newpt, NULL, &amp;splitsub, &amp;n, NULL, &amp;sublist,
<a name="l29702"></a>29702                               &amp;subceillist, tetlists, ceillists);
<a name="l29703"></a>29703               trimbowatcavity(newpt, NULL, n, &amp;sublist, &amp;subceillist, tetlists,
<a name="l29704"></a>29704                               ceillists, -1.0);
<a name="l29705"></a>29705             }
<a name="l29706"></a>29706           }
<a name="l29707"></a>29707           <span class="comment">// Save a point for size interpolation.</span>
<a name="l29708"></a>29708           e1 = sorg(splitsub);
<a name="l29709"></a>29709           bowatinsertsite(newpt, NULL, n, &amp;sublist, &amp;subceillist, tetlists,
<a name="l29710"></a>29710                           ceillists, NULL, NULL, <span class="keyword">true</span>, <span class="keyword">true</span>, chkbadtet);
<a name="l29711"></a>29711           setnewpointsize(newpt, e1, NULL);
<a name="l29712"></a>29712           <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l29713"></a>29713         } <span class="keywordflow">else</span> {
<a name="l29714"></a>29714           <span class="comment">// p is rejected for the one of the following reasons:</span>
<a name="l29715"></a>29715           <span class="comment">//   (1) BC(p) is not valid.</span>
<a name="l29716"></a>29716           <span class="comment">//   (2) s does not in CBC(p).</span>
<a name="l29717"></a>29717           <span class="comment">//   (3) p encroaches upon some segments (queued); or</span>
<a name="l29718"></a>29718           <span class="comment">//   (4) p is rejected by point accepting rule, or</span>
<a name="l29719"></a>29719           <span class="comment">//   (5) due to the rejection of symp (the PBC).</span>
<a name="l29720"></a>29720           pointdealloc(newpt);
<a name="l29721"></a>29721         } <span class="comment">// if (!reject)</span>
<a name="l29722"></a>29722         <span class="comment">// Release the cavity and free the memory.</span>
<a name="l29723"></a>29723         releasebowatcavity(NULL,n,&amp;sublist,&amp;subceillist,tetlists,ceillists);
<a name="l29724"></a>29724         <span class="keywordflow">if</span> (reject) {
<a name="l29725"></a>29725           <span class="comment">// Are there queued encroached subsegments.</span>
<a name="l29726"></a>29726           <span class="keywordflow">if</span> (badsubsegs-&gt;items &gt; 0) {
<a name="l29727"></a>29727             <span class="comment">// Repair enc-subsegments.</span>
<a name="l29728"></a>29728             oldptnum = points-&gt;items;
<a name="l29729"></a>29729             repairencsegs(<span class="keyword">true</span>, chkbadtet);
<a name="l29730"></a>29730             <span class="keywordflow">if</span> (points-&gt;items &gt; oldptnum) {
<a name="l29731"></a>29731               <span class="comment">// Some enc-subsegments got split. Try to repair f later.</span>
<a name="l29732"></a>29732               splitsub = encloop-&gt;ss;
<a name="l29733"></a>29733               <span class="keywordflow">if</span> (!isdead(&amp;splitsub)) {
<a name="l29734"></a>29734                 <span class="keywordflow">if</span> (!shell2badface(splitsub)) {
<a name="l29735"></a>29735                   checksub4encroach(&amp;splitsub, NULL, <span class="keyword">true</span>);
<a name="l29736"></a>29736                 }
<a name="l29737"></a>29737               }
<a name="l29738"></a>29738             }
<a name="l29739"></a>29739           }
<a name="l29740"></a>29740         }
<a name="l29741"></a>29741       } <span class="keywordflow">else</span> {
<a name="l29742"></a>29742         <span class="comment">// Don&#39;t insert p for one of the following reasons:</span>
<a name="l29743"></a>29743         <span class="comment">//   (1) Locate on an existing vertex; or</span>
<a name="l29744"></a>29744         <span class="comment">//   (2) locate outside the domain.</span>
<a name="l29745"></a>29745         <span class="comment">// Case (1) should not be possible. If such vertex v exists, it is</span>
<a name="l29746"></a>29746         <span class="comment">//   the circumcenter of f, ie., f is non-Delaunay. Either f was got</span>
<a name="l29747"></a>29747         <span class="comment">//   split before by v, but survived after v was inserted, or the</span>
<a name="l29748"></a>29748         <span class="comment">//   same for a f&#39; which is nearly co-circular with f.  Whatsoever,</span>
<a name="l29749"></a>29749         <span class="comment">//   there are encroached segs by v, but the routine tallencsegs()</span>
<a name="l29750"></a>29750         <span class="comment">//   did not find them out.</span>
<a name="l29751"></a>29751         <span class="keywordflow">if</span> (loc == ONVERTEX) {
<a name="l29752"></a>29752           printf(<span class="stringliteral">&quot;Internal error in repairencsubs():\n&quot;</span>);
<a name="l29753"></a>29753           printf(<span class="stringliteral">&quot;  During repairing encroached subface (%d, %d, %d)\n&quot;</span>,
<a name="l29754"></a>29754                  pointmark(encloop-&gt;forg), pointmark(encloop-&gt;fdest),
<a name="l29755"></a>29755                  pointmark(encloop-&gt;fapex));
<a name="l29756"></a>29756           printf(<span class="stringliteral">&quot;  New point %d is coincident with an existing vertex %d\n&quot;</span>,
<a name="l29757"></a>29757                  pointmark(newpt), pointmark(sorg(splitsub)));
<a name="l29758"></a>29758           internalerror();
<a name="l29759"></a>29759         }
<a name="l29760"></a>29760         <span class="comment">// Case (2) can happen when thers is a segment s which is close to f</span>
<a name="l29761"></a>29761         <span class="comment">//   and is non-conforming Delaunay. The circumcenter of f encroaches</span>
<a name="l29762"></a>29762         <span class="comment">//   upon s, but the circumcenter of s is rejected for insertion.</span>
<a name="l29763"></a>29763         pointdealloc(newpt);
<a name="l29764"></a>29764       } <span class="comment">// if ((loc != ONVERTEX) &amp;&amp; (loc != OUTSIDE))</span>
<a name="l29765"></a>29765     } <span class="keywordflow">else</span> {
<a name="l29766"></a>29766       <span class="keywordflow">if</span> (!isdead(&amp;splitsub)) {
<a name="l29767"></a>29767         <span class="comment">// The subface has been changed, re-check it.</span>
<a name="l29768"></a>29768         checksub4encroach(&amp;splitsub, NULL, <span class="keyword">true</span>);
<a name="l29769"></a>29769       }
<a name="l29770"></a>29770     } <span class="comment">// if (!isdead(&amp;splitsub) &amp;&amp; (sorg(splitsub) == encloop-&gt;forg) &amp;&amp;</span>
<a name="l29771"></a>29771     <span class="comment">// Remove this entry from list.</span>
<a name="l29772"></a>29772     badfacedealloc(badsubfaces, encloop);
<a name="l29773"></a>29773   } <span class="comment">// while ((badsubfaces-&gt;items &gt; 0) &amp;&amp; (steinerleft != 0))</span>
<a name="l29774"></a>29774 
<a name="l29775"></a>29775   <span class="keyword">delete</span> verlist;
<a name="l29776"></a>29776 }
<a name="l29777"></a>29777 
<a name="l29779"></a>29779 <span class="comment">//                                                                           //</span>
<a name="l29780"></a>29780 <span class="comment">// repairbadtets()    Repair all bad-quality tetrahedra.                     //</span>
<a name="l29781"></a>29781 <span class="comment">//                                                                           //</span>
<a name="l29782"></a>29782 <span class="comment">// All bad-quality tets are stored in pool &#39;badtetrahedrons&#39;.  Each bad tet  //</span>
<a name="l29783"></a>29783 <span class="comment">// is repaired by inserting a point at or near its circumcenter. However, if //</span>
<a name="l29784"></a>29784 <span class="comment">// this point encroaches any subsegment or subface, it is not inserted. Ins- //</span>
<a name="l29785"></a>29785 <span class="comment">// tead the encroached segment and subface are split.  Newly inserted points //</span>
<a name="l29786"></a>29786 <span class="comment">// may create other bad-quality tets, these are also repaired.               //</span>
<a name="l29787"></a>29787 <span class="comment">//                                                                           //</span>
<a name="l29789"></a>29789 <span class="comment"></span>
<a name="l29790"></a>29790 <span class="keywordtype">void</span> tetgenmesh::repairbadtets()
<a name="l29791"></a>29791 {
<a name="l29792"></a>29792   list *tetlist, *ceillist;
<a name="l29793"></a>29793   list *verlist;
<a name="l29794"></a>29794   badface *badtet;
<a name="l29795"></a>29795   triface starttet;
<a name="l29796"></a>29796   point newpt, e1;
<a name="l29797"></a>29797   <span class="keyword">enum</span> locateresult loc;
<a name="l29798"></a>29798   <span class="keywordtype">bool</span> reject;
<a name="l29799"></a>29799   <span class="keywordtype">long</span> oldptnum;
<a name="l29800"></a>29800   <span class="keywordtype">int</span> i;
<a name="l29801"></a>29801 
<a name="l29802"></a>29802   tetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 1024);
<a name="l29803"></a>29803   ceillist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 1024);
<a name="l29804"></a>29804   verlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL, 256);
<a name="l29805"></a>29805 
<a name="l29806"></a>29806   <span class="comment">// Loop until pool &#39;badtetrahedrons&#39; is empty. Note that steinerleft == -1</span>
<a name="l29807"></a>29807   <span class="comment">//   if an unlimited number of Steiner points is allowed.</span>
<a name="l29808"></a>29808   <span class="keywordflow">while</span> ((badtetrahedrons-&gt;items &gt; 0) &amp;&amp; (steinerleft != 0)) {
<a name="l29809"></a>29809     <span class="comment">// Get a bad-quality tet t.</span>
<a name="l29810"></a>29810     badtet = topbadtetra();
<a name="l29811"></a>29811     <span class="comment">// Make sure that the tet is still the same one when it was tested.</span>
<a name="l29812"></a>29812     <span class="comment">//   Subsequent transformations may have made it a different tet.</span>
<a name="l29813"></a>29813     <span class="keywordflow">if</span> ((badtet != (badface *) NULL) &amp;&amp; !isdead(&amp;badtet-&gt;tt)
<a name="l29814"></a>29814          &amp;&amp; org(badtet-&gt;tt) == badtet-&gt;forg
<a name="l29815"></a>29815          &amp;&amp; dest(badtet-&gt;tt) == badtet-&gt;fdest
<a name="l29816"></a>29816          &amp;&amp; apex(badtet-&gt;tt) == badtet-&gt;fapex
<a name="l29817"></a>29817          &amp;&amp; oppo(badtet-&gt;tt) == badtet-&gt;foppo) {
<a name="l29818"></a>29818       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l29819"></a>29819         printf(<span class="stringliteral">&quot;    Dequeuing btet (%d, %d, %d, %d).\n&quot;</span>,
<a name="l29820"></a>29820                pointmark(badtet-&gt;forg), pointmark(badtet-&gt;fdest),
<a name="l29821"></a>29821                pointmark(badtet-&gt;fapex), pointmark(badtet-&gt;foppo));
<a name="l29822"></a>29822       }
<a name="l29823"></a>29823       <span class="comment">// Create the new point p (at the circumcenter of t).</span>
<a name="l29824"></a>29824       makepoint(&amp;newpt);
<a name="l29825"></a>29825       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newpt[i] = badtet-&gt;cent[i];
<a name="l29826"></a>29826       setpointtype(newpt, FREEVOLVERTEX);
<a name="l29827"></a>29827       <span class="comment">// Locate p.</span>
<a name="l29828"></a>29828       starttet = badtet-&gt;tt;
<a name="l29829"></a>29829       loc = preciselocate(newpt, &amp;starttet, tetrahedrons-&gt;items);
<a name="l29830"></a>29830       <span class="keywordflow">if</span> ((loc != ONVERTEX) &amp;&amp; (loc != OUTSIDE)) {
<a name="l29831"></a>29831         <span class="comment">// For BC(p) and B(p).</span>
<a name="l29832"></a>29832         infect(starttet);
<a name="l29833"></a>29833         tetlist-&gt;append(&amp;starttet);
<a name="l29834"></a>29834         formbowatcavityquad(newpt, tetlist, ceillist);
<a name="l29835"></a>29835         <span class="comment">// Check for encroached subsegments.</span>
<a name="l29836"></a>29836         reject = tallencsegs(newpt, 1, &amp;ceillist);
<a name="l29837"></a>29837         <span class="keywordflow">if</span> (!reject) {
<a name="l29838"></a>29838           <span class="comment">// Check for encroached subfaces.</span>
<a name="l29839"></a>29839           reject = tallencsubs(newpt, 1, &amp;ceillist);
<a name="l29840"></a>29840         }
<a name="l29841"></a>29841         <span class="comment">// Execute point accepting rule if p does not encroach upon any</span>
<a name="l29842"></a>29842         <span class="comment">//   subsegment and subface.</span>
<a name="l29843"></a>29843         <span class="keywordflow">if</span> (!reject) {
<a name="l29844"></a>29844           reject = !acceptvolpt(newpt, ceillist, verlist);
<a name="l29845"></a>29845         }
<a name="l29846"></a>29846         <span class="keywordflow">if</span> (!reject) {
<a name="l29847"></a>29847           reject = !trimbowatcavity(newpt, NULL, 1, NULL, NULL, &amp;tetlist,
<a name="l29848"></a>29848                                     &amp;ceillist, -1.0);
<a name="l29849"></a>29849         }
<a name="l29850"></a>29850         <span class="keywordflow">if</span> (!reject) {
<a name="l29851"></a>29851           <span class="comment">// BC(p) should include t, so that t can be removed after BC(p) is</span>
<a name="l29852"></a>29852           <span class="comment">//   remeshed. However, if there are locally non-Delaunay faces</span>
<a name="l29853"></a>29853           <span class="comment">//   and encroached subsegments/subfaces, t may not be collected</span>
<a name="l29854"></a>29854           <span class="comment">//   in BC(p). p should not be inserted in such case.</span>
<a name="l29855"></a>29855           reject = !infected(badtet-&gt;tt);
<a name="l29856"></a>29856           <span class="keywordflow">if</span> (reject) outbowatcircumcount++;
<a name="l29857"></a>29857         }
<a name="l29858"></a>29858         <span class="keywordflow">if</span> (!reject) {
<a name="l29859"></a>29859           <span class="comment">// Save a point for size interpolation.</span>
<a name="l29860"></a>29860           e1 = org(starttet);
<a name="l29861"></a>29861           <span class="comment">// Insert p.</span>
<a name="l29862"></a>29862           bowatinsertsite(newpt, NULL, 1, NULL, NULL, &amp;tetlist, &amp;ceillist,
<a name="l29863"></a>29863                           NULL, NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);
<a name="l29864"></a>29864           setnewpointsize(newpt, e1, NULL);
<a name="l29865"></a>29865           <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l29866"></a>29866         } <span class="keywordflow">else</span> {
<a name="l29867"></a>29867           <span class="comment">// p is rejected for one of the following reasons:</span>
<a name="l29868"></a>29868           <span class="comment">//   (1) BC(p) is not valid.</span>
<a name="l29869"></a>29869           <span class="comment">//   (2) t does not in BC(p).</span>
<a name="l29870"></a>29870           <span class="comment">//   (3) p encroaches upon some segments;</span>
<a name="l29871"></a>29871           <span class="comment">//   (4) p encroaches upon some subfaces;</span>
<a name="l29872"></a>29872           <span class="comment">//   (5) p is rejected by the point accepting rule.</span>
<a name="l29873"></a>29873           pointdealloc(newpt);
<a name="l29874"></a>29874           <span class="comment">// Uninfect tets of BC(p).</span>
<a name="l29875"></a>29875           <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l29876"></a>29876             starttet = * (triface *)(* tetlist)[i];
<a name="l29877"></a>29877             uninfect(starttet);
<a name="l29878"></a>29878           }
<a name="l29879"></a>29879         }
<a name="l29880"></a>29880         tetlist-&gt;clear();
<a name="l29881"></a>29881         ceillist-&gt;clear();
<a name="l29882"></a>29882         <span class="comment">// Split encroached subsegments/subfaces if there are.</span>
<a name="l29883"></a>29883         <span class="keywordflow">if</span> (reject) {
<a name="l29884"></a>29884           oldptnum = points-&gt;items;
<a name="l29885"></a>29885           <span class="keywordflow">if</span> (badsubsegs-&gt;items &gt; 0) {
<a name="l29886"></a>29886             repairencsegs(<span class="keyword">true</span>, <span class="keyword">true</span>);
<a name="l29887"></a>29887           }
<a name="l29888"></a>29888           <span class="keywordflow">if</span> (badsubfaces-&gt;items &gt; 0) {
<a name="l29889"></a>29889             repairencsubs(<span class="keyword">true</span>);
<a name="l29890"></a>29890           }
<a name="l29891"></a>29891           <span class="keywordflow">if</span> (points-&gt;items &gt; oldptnum) {
<a name="l29892"></a>29892             <span class="comment">// Some encroaching subsegments/subfaces got split. Re-queue the</span>
<a name="l29893"></a>29893             <span class="comment">//   tet if it is still alive.</span>
<a name="l29894"></a>29894             starttet = badtet-&gt;tt;
<a name="l29895"></a>29895             <span class="keywordflow">if</span> (!isdead(&amp;starttet)) {
<a name="l29896"></a>29896               checktet4badqual(&amp;starttet, <span class="keyword">true</span>);
<a name="l29897"></a>29897             }
<a name="l29898"></a>29898           }
<a name="l29899"></a>29899         }
<a name="l29900"></a>29900       } <span class="keywordflow">else</span> {
<a name="l29901"></a>29901         <span class="comment">// Do not insert p. The reason may be one of:</span>
<a name="l29902"></a>29902         <span class="comment">//   (1) p is coincident (ONVERTEX) with an existing vertex; or</span>
<a name="l29903"></a>29903         <span class="comment">//   (2) p is outside (OUTSIDE) the mesh.</span>
<a name="l29904"></a>29904         <span class="comment">// Case (1) should not be possible. If such vertex v exists, it is</span>
<a name="l29905"></a>29905         <span class="comment">//   the circumcenter of t, ie., t is non-Delaunay. Either t was got</span>
<a name="l29906"></a>29906         <span class="comment">//   split before by v, but survived after v was inserted, or the</span>
<a name="l29907"></a>29907         <span class="comment">//   same for a t&#39; which is nearly co-spherical with t.  Whatsoever,</span>
<a name="l29908"></a>29908         <span class="comment">//   there are encroached segments or subfaces by v but the routines</span>
<a name="l29909"></a>29909         <span class="comment">//   tallencsegs() or tallencsubs() did not find them out.</span>
<a name="l29910"></a>29910         <span class="keywordflow">if</span> (loc == ONVERTEX) {
<a name="l29911"></a>29911           printf(<span class="stringliteral">&quot;Internal error in repairbadtets():\n&quot;</span>);
<a name="l29912"></a>29912           printf(<span class="stringliteral">&quot;  During repairing bad tet (%d, %d, %d, %d)\n&quot;</span>,
<a name="l29913"></a>29913                  pointmark(badtet-&gt;forg), pointmark(badtet-&gt;fdest),
<a name="l29914"></a>29914                  pointmark(badtet-&gt;fapex), pointmark(badtet-&gt;foppo));
<a name="l29915"></a>29915           printf(<span class="stringliteral">&quot;  New point %d is coincident with an existing vertex %d\n&quot;</span>,
<a name="l29916"></a>29916                  pointmark(newpt), pointmark(org(starttet)));
<a name="l29917"></a>29917           internalerror();
<a name="l29918"></a>29918         }
<a name="l29919"></a>29919         <span class="comment">// Case (2) can happen when there is a segment s (or subface f) which</span>
<a name="l29920"></a>29920         <span class="comment">//   is close to f and is non-conforming Delaunay.  The circumcenter</span>
<a name="l29921"></a>29921         <span class="comment">//   of t encroaches upon s (or f), but the circumcenter of s (or f)</span>
<a name="l29922"></a>29922         <span class="comment">//   is rejected for insertion.</span>
<a name="l29923"></a>29923         pointdealloc(newpt);
<a name="l29924"></a>29924       } <span class="comment">// if ((loc != ONVERTEX) &amp;&amp; (loc != OUTSIDE))</span>
<a name="l29925"></a>29925     } <span class="comment">// if (!isdead(&amp;badtet-&gt;tt) &amp;&amp; org(badtet-&gt;tt) == badtet-&gt;forg &amp;&amp;</span>
<a name="l29926"></a>29926     <span class="comment">// Remove the tet from the queue.</span>
<a name="l29927"></a>29927     dequeuebadtet();
<a name="l29928"></a>29928   } <span class="comment">// while ((badtetrahedrons-&gt;items &gt; 0) &amp;&amp; (steinerleft != 0))</span>
<a name="l29929"></a>29929 
<a name="l29930"></a>29930   <span class="keyword">delete</span> tetlist;
<a name="l29931"></a>29931   <span class="keyword">delete</span> ceillist;
<a name="l29932"></a>29932   <span class="keyword">delete</span> verlist;
<a name="l29933"></a>29933 }
<a name="l29934"></a>29934 
<a name="l29936"></a>29936 <span class="comment">//                                                                           //</span>
<a name="l29937"></a>29937 <span class="comment">// enforcequality()    Refine the mesh.                                      //</span>
<a name="l29938"></a>29938 <span class="comment">//                                                                           //</span>
<a name="l29940"></a>29940 <span class="comment"></span>
<a name="l29941"></a>29941 <span class="keywordtype">void</span> tetgenmesh::enforcequality()
<a name="l29942"></a>29942 {
<a name="l29943"></a>29943   <span class="keywordtype">long</span> total, vertcount;
<a name="l29944"></a>29944   <span class="keywordtype">int</span> i;
<a name="l29945"></a>29945 
<a name="l29946"></a>29946   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l29947"></a>29947     printf(<span class="stringliteral">&quot;Adding Steiner points to enforce quality.\n&quot;</span>);
<a name="l29948"></a>29948   }
<a name="l29949"></a>29949 
<a name="l29950"></a>29950   total = vertcount = 0l;
<a name="l29951"></a>29951   <span class="keywordflow">if</span> (b-&gt;conformdel) {
<a name="l29952"></a>29952     r2count = r3count = 0l;
<a name="l29953"></a>29953   }
<a name="l29954"></a>29954 
<a name="l29955"></a>29955   <span class="comment">// If both &#39;-D&#39; and &#39;-r&#39; options are used.</span>
<a name="l29956"></a>29956   <span class="keywordflow">if</span> (b-&gt;conformdel &amp;&amp; b-&gt;refine) {
<a name="l29957"></a>29957     markacutevertices(65.0);
<a name="l29958"></a>29958   }
<a name="l29959"></a>29959   <span class="comment">// If &#39;-m&#39; is not used.</span>
<a name="l29960"></a>29960   <span class="keywordflow">if</span> (!b-&gt;metric) {
<a name="l29961"></a>29961     <span class="comment">// Find and mark all sharp segments.</span>
<a name="l29962"></a>29962     marksharpsegments(65.0);
<a name="l29963"></a>29963     <span class="comment">// Decide the sizes for feature points.</span>
<a name="l29964"></a>29964     decidefeaturepointsizes();
<a name="l29965"></a>29965   }
<a name="l29966"></a>29966 
<a name="l29967"></a>29967   <span class="comment">// Initialize the pool of encroached subsegments.</span>
<a name="l29968"></a>29968   badsubsegs = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(badface), SUBPERBLOCK, POINTER, 0);
<a name="l29969"></a>29969   <span class="comment">// Looking for encroached subsegments.</span>
<a name="l29970"></a>29970   tallencsegs(NULL, 0, NULL);
<a name="l29971"></a>29971   <span class="keywordflow">if</span> (b-&gt;verbose &amp;&amp; badsubsegs-&gt;items &gt; 0) {
<a name="l29972"></a>29972     printf(<span class="stringliteral">&quot;  Splitting encroached subsegments.\n&quot;</span>);
<a name="l29973"></a>29973   }
<a name="l29974"></a>29974   vertcount = points-&gt;items;
<a name="l29975"></a>29975   <span class="comment">// Fix encroached segments without noting any enc subfaces.</span>
<a name="l29976"></a>29976   repairencsegs(<span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l29977"></a>29977   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l29978"></a>29978     printf(<span class="stringliteral">&quot;  %ld split points.\n&quot;</span>, points-&gt;items - vertcount);
<a name="l29979"></a>29979   }
<a name="l29980"></a>29980   total += points-&gt;items - vertcount;
<a name="l29981"></a>29981 
<a name="l29982"></a>29982   <span class="comment">// Initialize the pool of encroached subfaces.</span>
<a name="l29983"></a>29983   badsubfaces = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(badface), SUBPERBLOCK, POINTER, 0);
<a name="l29984"></a>29984   <span class="comment">// Initialize the priority queues of badfaces.</span>
<a name="l29985"></a>29985   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) subquefront[i] = (badface *) NULL;
<a name="l29986"></a>29986   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) subquetail[i] = &amp;subquefront[i];
<a name="l29987"></a>29987   <span class="comment">// Looking for encroached subfaces.</span>
<a name="l29988"></a>29988   tallencsubs(NULL, 0, NULL);
<a name="l29989"></a>29989   <span class="keywordflow">if</span> (b-&gt;verbose &amp;&amp; badsubfaces-&gt;items &gt; 0) {
<a name="l29990"></a>29990     printf(<span class="stringliteral">&quot;  Splitting encroached subfaces.\n&quot;</span>);
<a name="l29991"></a>29991   }
<a name="l29992"></a>29992   vertcount = points-&gt;items;
<a name="l29993"></a>29993   <span class="comment">// Fix encroached subfaces without noting bad tetrahedra.</span>
<a name="l29994"></a>29994   repairencsubs(<span class="keyword">false</span>);
<a name="l29995"></a>29995   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l29996"></a>29996     printf(<span class="stringliteral">&quot;  %ld split points.\n&quot;</span>, points-&gt;items - vertcount);
<a name="l29997"></a>29997   }
<a name="l29998"></a>29998   total += points-&gt;items - vertcount;
<a name="l29999"></a>29999   <span class="comment">// At this point, the mesh should be conforming Delaunay if no input</span>
<a name="l30000"></a>30000   <span class="comment">//   angle is smaller than 90 degree.</span>
<a name="l30001"></a>30001 
<a name="l30002"></a>30002   <span class="comment">// Next, fix bad quality tetrahedra.</span>
<a name="l30003"></a>30003   <span class="keywordflow">if</span> ((b-&gt;minratio &gt; 0.0) || b-&gt;varvolume || b-&gt;fixedvolume) {
<a name="l30004"></a>30004     <span class="comment">// Initialize the pool of bad tets</span>
<a name="l30005"></a>30005     badtetrahedrons = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(badface), ELEPERBLOCK, POINTER, 0);
<a name="l30006"></a>30006     <span class="comment">// Initialize the priority queues of bad tets.</span>
<a name="l30007"></a>30007     <span class="keywordflow">for</span> (i = 0; i &lt; 64; i++) tetquefront[i] = (badface *) NULL;
<a name="l30008"></a>30008     firstnonemptyq = -1;
<a name="l30009"></a>30009     recentq = -1;
<a name="l30010"></a>30010     <span class="comment">// Looking for bad quality tets.</span>
<a name="l30011"></a>30011     cosmaxdihed = cos(b-&gt;maxdihedral * PI / 180.0);
<a name="l30012"></a>30012     cosmindihed = cos(b-&gt;mindihedral * PI / 180.0);
<a name="l30013"></a>30013     tallbadtetrahedrons();
<a name="l30014"></a>30014     <span class="keywordflow">if</span> (b-&gt;verbose &amp;&amp; badtetrahedrons-&gt;items &gt; 0) {
<a name="l30015"></a>30015       printf(<span class="stringliteral">&quot;  Splitting bad tetrahedra.\n&quot;</span>);
<a name="l30016"></a>30016     }
<a name="l30017"></a>30017     vertcount = points-&gt;items;
<a name="l30018"></a>30018     repairbadtets();
<a name="l30019"></a>30019     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l30020"></a>30020       printf(<span class="stringliteral">&quot;  %ld refinement points.\n&quot;</span>, points-&gt;items - vertcount);
<a name="l30021"></a>30021     }
<a name="l30022"></a>30022     total += points-&gt;items - vertcount;
<a name="l30023"></a>30023     <span class="keyword">delete</span> badtetrahedrons;
<a name="l30024"></a>30024   }
<a name="l30025"></a>30025 
<a name="l30026"></a>30026   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l30027"></a>30027     printf(<span class="stringliteral">&quot;  Totally added %ld points.\n&quot;</span>, total);
<a name="l30028"></a>30028   }
<a name="l30029"></a>30029 
<a name="l30030"></a>30030   <span class="keyword">delete</span> badsubfaces;
<a name="l30031"></a>30031   <span class="keyword">delete</span> badsubsegs;
<a name="l30032"></a>30032 }
<a name="l30033"></a>30033 
<a name="l30034"></a>30034 <span class="comment">//</span>
<a name="l30035"></a>30035 <span class="comment">// End of Delaunay refinement routines</span>
<a name="l30036"></a>30036 <span class="comment">//</span>
<a name="l30037"></a>30037 
<a name="l30038"></a>30038 <span class="comment">//</span>
<a name="l30039"></a>30039 <span class="comment">// Begin of mesh optimization routines</span>
<a name="l30040"></a>30040 <span class="comment">//</span>
<a name="l30041"></a>30041 
<a name="l30042"></a>30042 <span class="keywordtype">void</span> tetgenmesh::dumpbadtets()
<a name="l30043"></a>30043 {
<a name="l30044"></a>30044   FILE *fout;
<a name="l30045"></a>30045   badface *remtet;
<a name="l30046"></a>30046 
<a name="l30047"></a>30047   <span class="comment">// Write out a file of remaining bad tets.</span>
<a name="l30048"></a>30048   printf(<span class="stringliteral">&quot;  Writing bad tets to file bad-dump.lua.\n&quot;</span>);
<a name="l30049"></a>30049   fout = fopen(<span class="stringliteral">&quot;bad-dump.lua&quot;</span>, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l30050"></a>30050   fprintf(fout, <span class="stringliteral">&quot;-- %ld remaining bad tets (&gt; %g degree).\n&quot;</span>,
<a name="l30051"></a>30051           badtetrahedrons-&gt;items, b-&gt;maxdihedral);
<a name="l30052"></a>30052   badtetrahedrons-&gt;traversalinit();
<a name="l30053"></a>30053   remtet = badfacetraverse(badtetrahedrons);
<a name="l30054"></a>30054   <span class="keywordflow">while</span> (remtet != (badface *) NULL) {
<a name="l30055"></a>30055     <span class="keywordflow">if</span> (!isdead(&amp;remtet-&gt;tt) &amp;&amp; org(remtet-&gt;tt) == remtet-&gt;forg &amp;&amp;
<a name="l30056"></a>30056         dest(remtet-&gt;tt) == remtet-&gt;fdest &amp;&amp;
<a name="l30057"></a>30057         apex(remtet-&gt;tt) == remtet-&gt;fapex &amp;&amp;
<a name="l30058"></a>30058         oppo(remtet-&gt;tt) == remtet-&gt;foppo) {
<a name="l30059"></a>30059       fprintf(fout, <span class="stringliteral">&quot;p:draw_tet(%d, %d, %d, %d) -- %g\n&quot;</span>,
<a name="l30060"></a>30060               pointmark(remtet-&gt;forg), pointmark(remtet-&gt;fdest),
<a name="l30061"></a>30061               pointmark(remtet-&gt;fapex), pointmark(remtet-&gt;foppo),
<a name="l30062"></a>30062               acos(remtet-&gt;key) * 180.0 / PI);
<a name="l30063"></a>30063     }
<a name="l30064"></a>30064     remtet = badfacetraverse(badtetrahedrons);
<a name="l30065"></a>30065   }
<a name="l30066"></a>30066   fclose(fout);
<a name="l30067"></a>30067 }
<a name="l30068"></a>30068 
<a name="l30070"></a>30070 <span class="comment">//                                                                           //</span>
<a name="l30071"></a>30071 <span class="comment">// checktet4ill()    Check a tet to see if it is illegal.                    //</span>
<a name="l30072"></a>30072 <span class="comment">//                                                                           //</span>
<a name="l30073"></a>30073 <span class="comment">// A tet is &quot;illegal&quot; if it spans on one input facet.  Save the tet in queue //</span>
<a name="l30074"></a>30074 <span class="comment">// if it is illegal and the flag &#39;enqflag&#39; is set.                           //</span>
<a name="l30075"></a>30075 <span class="comment">//                                                                           //</span>
<a name="l30076"></a>30076 <span class="comment">// Note: Such case can happen when the input facet has non-coplanar vertices //</span>
<a name="l30077"></a>30077 <span class="comment">// and the Delaunay tetrahedralization of the vertices may creat such tets.  //</span>
<a name="l30078"></a>30078 <span class="comment">//                                                                           //</span>
<a name="l30080"></a>30080 <span class="comment"></span>
<a name="l30081"></a>30081 <span class="keywordtype">bool</span> tetgenmesh::checktet4ill(triface* testtet, <span class="keywordtype">bool</span> enqflag)
<a name="l30082"></a>30082 {
<a name="l30083"></a>30083   badface *newbadtet;
<a name="l30084"></a>30084   triface checktet;
<a name="l30085"></a>30085   face checksh1, checksh2;
<a name="l30086"></a>30086   face checkseg;
<a name="l30087"></a>30087   <span class="keywordtype">bool</span> illflag;
<a name="l30088"></a>30088   <span class="keywordtype">int</span> i;
<a name="l30089"></a>30089 
<a name="l30090"></a>30090   illflag = <span class="keyword">false</span>;
<a name="l30091"></a>30091   <span class="keywordflow">for</span> (testtet-&gt;loc = 0; testtet-&gt;loc &lt; 4; testtet-&gt;loc++) {
<a name="l30092"></a>30092     tspivot(*testtet, checksh1);
<a name="l30093"></a>30093     <span class="keywordflow">if</span> (checksh1.sh != dummysh) {
<a name="l30094"></a>30094       testtet-&gt;ver = 0;
<a name="l30095"></a>30095       findedge(&amp;checksh1, org(*testtet), dest(*testtet));
<a name="l30096"></a>30096       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l30097"></a>30097         fnext(*testtet, checktet);
<a name="l30098"></a>30098         tspivot(checktet, checksh2);
<a name="l30099"></a>30099         <span class="keywordflow">if</span> (checksh2.sh != dummysh) {
<a name="l30100"></a>30100           <span class="comment">// Two subfaces share this edge.</span>
<a name="l30101"></a>30101           sspivot(checksh1, checkseg);
<a name="l30102"></a>30102           <span class="keywordflow">if</span> (checkseg.sh == dummysh) {
<a name="l30103"></a>30103             <span class="comment">// The four corners of the tet are on one facet. Illegal! Try to</span>
<a name="l30104"></a>30104             <span class="comment">//   flip the opposite edge of the current one.</span>
<a name="l30105"></a>30105             enextfnextself(*testtet);
<a name="l30106"></a>30106             enextself(*testtet);
<a name="l30107"></a>30107             illflag = <span class="keyword">true</span>;
<a name="l30108"></a>30108             <span class="keywordflow">break</span>;
<a name="l30109"></a>30109           }
<a name="l30110"></a>30110         }
<a name="l30111"></a>30111         enextself(*testtet);
<a name="l30112"></a>30112         senextself(checksh1);
<a name="l30113"></a>30113       }
<a name="l30114"></a>30114     }
<a name="l30115"></a>30115     <span class="keywordflow">if</span> (illflag) <span class="keywordflow">break</span>;
<a name="l30116"></a>30116   }
<a name="l30117"></a>30117 
<a name="l30118"></a>30118   <span class="keywordflow">if</span> (illflag &amp;&amp; enqflag) {
<a name="l30119"></a>30119     <span class="comment">// Allocate space for the bad tetrahedron.</span>
<a name="l30120"></a>30120     newbadtet = (badface *) badtetrahedrons-&gt;alloc();
<a name="l30121"></a>30121     newbadtet-&gt;tt = *testtet;
<a name="l30122"></a>30122     newbadtet-&gt;key = -1.0; <span class="comment">// = 180 degree.</span>
<a name="l30123"></a>30123     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) newbadtet-&gt;cent[i] = 0.0;
<a name="l30124"></a>30124     newbadtet-&gt;forg = org(*testtet);
<a name="l30125"></a>30125     newbadtet-&gt;fdest = dest(*testtet);
<a name="l30126"></a>30126     newbadtet-&gt;fapex = apex(*testtet);
<a name="l30127"></a>30127     newbadtet-&gt;foppo = oppo(*testtet);
<a name="l30128"></a>30128     newbadtet-&gt;nextitem = (badface *) NULL;
<a name="l30129"></a>30129     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l30130"></a>30130       printf(<span class="stringliteral">&quot;    Queueing illtet: (%d, %d, %d, %d).\n&quot;</span>,
<a name="l30131"></a>30131              pointmark(newbadtet-&gt;forg), pointmark(newbadtet-&gt;fdest),
<a name="l30132"></a>30132              pointmark(newbadtet-&gt;fapex), pointmark(newbadtet-&gt;foppo));
<a name="l30133"></a>30133     }
<a name="l30134"></a>30134   }
<a name="l30135"></a>30135 
<a name="l30136"></a>30136   <span class="keywordflow">return</span> illflag;
<a name="l30137"></a>30137 }
<a name="l30138"></a>30138 
<a name="l30140"></a>30140 <span class="comment">//                                                                           //</span>
<a name="l30141"></a>30141 <span class="comment">// checktet4opt()    Check a tet to see if it needs to be optimized.         //</span>
<a name="l30142"></a>30142 <span class="comment">//                                                                           //</span>
<a name="l30143"></a>30143 <span class="comment">// A tet t needs to be optimized if it fails to certain quality measures.    //</span>
<a name="l30144"></a>30144 <span class="comment">// The only quality measure currently used is the maximal dihedral angle at  //</span>
<a name="l30145"></a>30145 <span class="comment">// edges. The desired maximal dihedral angle is b-&gt;maxdihed (set by the &#39;-s&#39; //</span>
<a name="l30146"></a>30146 <span class="comment">// option.                                                                   //</span>
<a name="l30147"></a>30147 <span class="comment">//                                                                           //</span>
<a name="l30148"></a>30148 <span class="comment">// A tet may have one, two, or three big dihedral angles. Examples: Let the  //</span>
<a name="l30149"></a>30149 <span class="comment">// tet t = abcd, and its four corners are nearly co-planar. Then t has one   //</span>
<a name="l30150"></a>30150 <span class="comment">// big dihedral angle if d is very close to the edge ab; t has three big     //</span>
<a name="l30151"></a>30151 <span class="comment">// dihedral angles if d&#39;s projection on the face abc is also inside abc, i.e.//</span>
<a name="l30152"></a>30152 <span class="comment">// the shape of t likes a hat; finally, t has two big dihedral angles if d&#39;s //</span>
<a name="l30153"></a>30153 <span class="comment">// projection onto abc is outside abc.                                       //</span>
<a name="l30154"></a>30154 <span class="comment">//                                                                           //</span>
<a name="l30156"></a>30156 <span class="comment"></span>
<a name="l30157"></a>30157 <span class="keywordtype">bool</span> tetgenmesh::checktet4opt(triface* testtet, <span class="keywordtype">bool</span> enqflag)
<a name="l30158"></a>30158 {
<a name="l30159"></a>30159   badface *newbadtet;
<a name="l30160"></a>30160   point pa, pb, pc, pd;
<a name="l30161"></a>30161   REAL N[4][3], len;
<a name="l30162"></a>30162   REAL cosd;
<a name="l30163"></a>30163   <span class="keywordtype">bool</span> enq;
<a name="l30164"></a>30164   <span class="keywordtype">int</span> i, j;
<a name="l30165"></a>30165 
<a name="l30166"></a>30166   cosd = 0.0;
<a name="l30167"></a>30167   enq = <span class="keyword">false</span>;
<a name="l30168"></a>30168   pa = (point) testtet-&gt;tet[4];
<a name="l30169"></a>30169   pb = (point) testtet-&gt;tet[5];
<a name="l30170"></a>30170   pc = (point) testtet-&gt;tet[6];
<a name="l30171"></a>30171   pd = (point) testtet-&gt;tet[7];
<a name="l30172"></a>30172   <span class="comment">// Compute the 4 face normals: N[0] cbd, N[1] acd, N[2] bad, N[3] abc.</span>
<a name="l30173"></a>30173   tetallnormal(pa, pb, pc, pd, N, NULL);
<a name="l30174"></a>30174   <span class="comment">// Normalize the normals.</span>
<a name="l30175"></a>30175   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l30176"></a>30176     len = sqrt(dot(N[i], N[i]));
<a name="l30177"></a>30177     <span class="keywordflow">if</span> (len != 0.0) {
<a name="l30178"></a>30178       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) N[i][j] /= len;
<a name="l30179"></a>30179     }
<a name="l30180"></a>30180   }
<a name="l30181"></a>30181   <span class="comment">// Find all large dihedral angles.</span>
<a name="l30182"></a>30182   <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l30183"></a>30183     <span class="comment">// Locate the edge i and calculate the dihedral angle at the edge.</span>
<a name="l30184"></a>30184     testtet-&gt;loc = 0;
<a name="l30185"></a>30185     testtet-&gt;ver = 0;
<a name="l30186"></a>30186     <span class="keywordflow">switch</span> (i) {
<a name="l30187"></a>30187     <span class="keywordflow">case</span> 0: <span class="comment">// edge ab</span>
<a name="l30188"></a>30188       cosd = -dot(N[2], N[3]);
<a name="l30189"></a>30189       <span class="keywordflow">break</span>;
<a name="l30190"></a>30190     <span class="keywordflow">case</span> 1: <span class="comment">// edge cd</span>
<a name="l30191"></a>30191       enextfnextself(*testtet);
<a name="l30192"></a>30192       enextself(*testtet);
<a name="l30193"></a>30193       cosd = -dot(N[0], N[1]);
<a name="l30194"></a>30194       <span class="keywordflow">break</span>;
<a name="l30195"></a>30195     <span class="keywordflow">case</span> 2: <span class="comment">// edge bd</span>
<a name="l30196"></a>30196       enextfnextself(*testtet);
<a name="l30197"></a>30197       enext2self(*testtet);
<a name="l30198"></a>30198       cosd = -dot(N[0], N[2]);
<a name="l30199"></a>30199       <span class="keywordflow">break</span>;
<a name="l30200"></a>30200     <span class="keywordflow">case</span> 3: <span class="comment">// edge bc</span>
<a name="l30201"></a>30201       enextself(*testtet);
<a name="l30202"></a>30202       cosd = -dot(N[0], N[3]);
<a name="l30203"></a>30203       <span class="keywordflow">break</span>;
<a name="l30204"></a>30204     <span class="keywordflow">case</span> 4: <span class="comment">// edge ad</span>
<a name="l30205"></a>30205       enext2fnextself(*testtet);
<a name="l30206"></a>30206       enextself(*testtet);
<a name="l30207"></a>30207       cosd = -dot(N[1], N[2]);
<a name="l30208"></a>30208       <span class="keywordflow">break</span>;
<a name="l30209"></a>30209     <span class="keywordflow">case</span> 5: <span class="comment">// edge ac</span>
<a name="l30210"></a>30210       enext2self(*testtet);
<a name="l30211"></a>30211       cosd = -dot(N[1], N[3]);
<a name="l30212"></a>30212       <span class="keywordflow">break</span>;
<a name="l30213"></a>30213     }
<a name="l30214"></a>30214     <span class="keywordflow">if</span> (cosd &lt; cosmaxdihed) {
<a name="l30215"></a>30215       <span class="comment">// A bigger dihedral angle.</span>
<a name="l30216"></a>30216       <span class="keywordflow">if</span> (enqflag) {
<a name="l30217"></a>30217         <span class="comment">// Allocate space for the bad tetrahedron.</span>
<a name="l30218"></a>30218         newbadtet = (badface *) badtetrahedrons-&gt;alloc();
<a name="l30219"></a>30219         newbadtet-&gt;tt = *testtet;
<a name="l30220"></a>30220         newbadtet-&gt;key = cosd;
<a name="l30221"></a>30221         <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) newbadtet-&gt;cent[j] = 0.0;
<a name="l30222"></a>30222         newbadtet-&gt;forg = org(*testtet);
<a name="l30223"></a>30223         newbadtet-&gt;fdest = dest(*testtet);
<a name="l30224"></a>30224         newbadtet-&gt;fapex = apex(*testtet);
<a name="l30225"></a>30225         newbadtet-&gt;foppo = oppo(*testtet);
<a name="l30226"></a>30226         newbadtet-&gt;nextitem = (badface *) NULL;
<a name="l30227"></a>30227         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 2) {
<a name="l30228"></a>30228           printf(<span class="stringliteral">&quot;    Queueing tet: (%d, %d, %d, %d), dihed %g (degree).\n&quot;</span>,
<a name="l30229"></a>30229                  pointmark(newbadtet-&gt;forg), pointmark(newbadtet-&gt;fdest),
<a name="l30230"></a>30230                  pointmark(newbadtet-&gt;fapex), pointmark(newbadtet-&gt;foppo),
<a name="l30231"></a>30231                  acos(cosd) * 180.0 / PI);
<a name="l30232"></a>30232         }
<a name="l30233"></a>30233       }
<a name="l30234"></a>30234       enq = <span class="keyword">true</span>;
<a name="l30235"></a>30235     }
<a name="l30236"></a>30236   }
<a name="l30237"></a>30237 
<a name="l30238"></a>30238   <span class="keywordflow">return</span> enq;
<a name="l30239"></a>30239 }
<a name="l30240"></a>30240 
<a name="l30242"></a>30242 <span class="comment">//                                                                           //</span>
<a name="l30243"></a>30243 <span class="comment">// removeedge()    Remove an edge                                            //</span>
<a name="l30244"></a>30244 <span class="comment">//                                                                           //</span>
<a name="l30245"></a>30245 <span class="comment">// &#39;remedge&#39; is a tet (abcd) having the edge ab wanted to be removed.  Local //</span>
<a name="l30246"></a>30246 <span class="comment">// reconnecting operations are used to remove edge ab.  The following opera- //</span>
<a name="l30247"></a>30247 <span class="comment">// tion will be tryed.                                                       //</span>
<a name="l30248"></a>30248 <span class="comment">//                                                                           //</span>
<a name="l30249"></a>30249 <span class="comment">// If ab is on the hull, and abc and abd are both hull faces. Then ab can be //</span>
<a name="l30250"></a>30250 <span class="comment">// removed by stripping abcd from the mesh. However, if ab is a segemnt, do  //</span>
<a name="l30251"></a>30251 <span class="comment">// the operation only if &#39;b-&gt;optlevel&#39; &gt; 1 and &#39;b-&gt;nobisect == 0&#39;.           //</span>
<a name="l30252"></a>30252 <span class="comment">//                                                                           //</span>
<a name="l30253"></a>30253 <span class="comment">// If ab is an internal edge, there are n tets contains it.  Then ab can be  //</span>
<a name="l30254"></a>30254 <span class="comment">// removed if there exists another m tets which can replace the n tets with- //</span>
<a name="l30255"></a>30255 <span class="comment">// out changing the boundary of the n tets.                                  //</span>
<a name="l30256"></a>30256 <span class="comment">//                                                                           //</span>
<a name="l30257"></a>30257 <span class="comment">// If &#39;optflag&#39; is set.  The value &#39;remedge-&gt;key&#39; means cos(theta), where    //</span>
<a name="l30258"></a>30258 <span class="comment">// &#39;theta&#39; is the maximal dishedral angle at ab. In this case, even if the   //</span>
<a name="l30259"></a>30259 <span class="comment">// n-to-m flip exists, it will not be performed if the maximum dihedral of   //</span>
<a name="l30260"></a>30260 <span class="comment">// the new tets is larger than &#39;theta&#39;.                                      //</span>
<a name="l30261"></a>30261 <span class="comment">//                                                                           //</span>
<a name="l30263"></a>30263 <span class="comment"></span>
<a name="l30264"></a>30264 <span class="keywordtype">bool</span> tetgenmesh::removeedge(badface* remedge, <span class="keywordtype">bool</span> optflag)
<a name="l30265"></a>30265 {
<a name="l30266"></a>30266   triface abcd, badc;  <span class="comment">// Tet configuration at edge ab.</span>
<a name="l30267"></a>30267   triface baccasing, abdcasing;
<a name="l30268"></a>30268   triface abtetlist[11];  <span class="comment">// Old configuration at ab, save maximum 10 tets.</span>
<a name="l30269"></a>30269   triface bftetlist[11];  <span class="comment">// Old configuration at bf, save maximum 10 tets.</span>
<a name="l30270"></a>30270   triface newtetlist[33]; <span class="comment">// New configuration after removing ab.</span>
<a name="l30271"></a>30271   face checksh;
<a name="l30272"></a>30272   <span class="keyword">enum</span> fliptype fty;
<a name="l30273"></a>30273   REAL key;
<a name="l30274"></a>30274   <span class="keywordtype">bool</span> remflag, subflag;
<a name="l30275"></a>30275   <span class="keywordtype">int</span> n, n1, m, i, j;
<a name="l30276"></a>30276 
<a name="l30277"></a>30277   <span class="comment">// First try to strip abcd from the mesh. This needs to check either ab</span>
<a name="l30278"></a>30278   <span class="comment">//   or cd is on the hull. Try to strip it whichever is true.</span>
<a name="l30279"></a>30279   abcd = remedge-&gt;tt;
<a name="l30280"></a>30280   adjustedgering(abcd, CCW);
<a name="l30281"></a>30281   i = 0;
<a name="l30282"></a>30282   <span class="keywordflow">do</span> {
<a name="l30283"></a>30283     sym(abcd, baccasing);
<a name="l30284"></a>30284     <span class="comment">// Is the tet on the hull?</span>
<a name="l30285"></a>30285     <span class="keywordflow">if</span> (baccasing.tet == dummytet) {
<a name="l30286"></a>30286       fnext(abcd, badc);
<a name="l30287"></a>30287       sym(badc, abdcasing);
<a name="l30288"></a>30288       <span class="keywordflow">if</span> (abdcasing.tet == dummytet) {
<a name="l30289"></a>30289         <span class="comment">// Strip the tet from the mesh -&gt; ab is removed as well.</span>
<a name="l30290"></a>30290         <span class="keywordflow">if</span> (removetetbypeeloff(&amp;abcd)) {
<a name="l30291"></a>30291           <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l30292"></a>30292             printf(<span class="stringliteral">&quot;    Stripped tet from the mesh.\n&quot;</span>);
<a name="l30293"></a>30293           }
<a name="l30294"></a>30294           optcount[0]++;
<a name="l30295"></a>30295           <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l30296"></a>30296         }
<a name="l30297"></a>30297       }
<a name="l30298"></a>30298     }
<a name="l30299"></a>30299     <span class="comment">// Check if the oppsite edge cd is on the hull.</span>
<a name="l30300"></a>30300     enext2fnextself(abcd);
<a name="l30301"></a>30301     enext2self(abcd);
<a name="l30302"></a>30302     esymself(abcd); <span class="comment">// --&gt; cdab</span>
<a name="l30303"></a>30303     i++;
<a name="l30304"></a>30304   } <span class="keywordflow">while</span> (i &lt; 2);
<a name="l30305"></a>30305 
<a name="l30306"></a>30306   <span class="comment">// Get the tets configuration at ab. Collect maximum 10 tets.</span>
<a name="l30307"></a>30307   subflag = <span class="keyword">false</span>;
<a name="l30308"></a>30308   abcd = remedge-&gt;tt;
<a name="l30309"></a>30309   adjustedgering(abcd, CW);
<a name="l30310"></a>30310   n = 0;
<a name="l30311"></a>30311   abtetlist[n] = abcd;
<a name="l30312"></a>30312   <span class="keywordflow">do</span> {
<a name="l30313"></a>30313     <span class="comment">// Is the list full?</span>
<a name="l30314"></a>30314     <span class="keywordflow">if</span> (n == 10) <span class="keywordflow">break</span>;
<a name="l30315"></a>30315     <span class="comment">// Stop if a subface appears.</span>
<a name="l30316"></a>30316     tspivot(abtetlist[n], checksh);
<a name="l30317"></a>30317     <span class="keywordflow">if</span> (checksh.sh != dummysh) {
<a name="l30318"></a>30318       <span class="comment">// ab is either a segment or a facet edge. The latter case is not</span>
<a name="l30319"></a>30319       <span class="comment">//   handled yet! An edge flip is needed.</span>
<a name="l30320"></a>30320       subflag = <span class="keyword">true</span>; <span class="keywordflow">break</span>; <span class="comment">// return false;</span>
<a name="l30321"></a>30321     }
<a name="l30322"></a>30322     <span class="comment">// Get the next tet at ab.</span>
<a name="l30323"></a>30323     fnext(abtetlist[n], abtetlist[n + 1]);
<a name="l30324"></a>30324     n++;
<a name="l30325"></a>30325   } <span class="keywordflow">while</span> (apex(abtetlist[n]) != apex(abcd));
<a name="l30326"></a>30326 
<a name="l30327"></a>30327   remflag = <span class="keyword">false</span>;
<a name="l30328"></a>30328   key = remedge-&gt;key;
<a name="l30329"></a>30329 
<a name="l30330"></a>30330   <span class="keywordflow">if</span> (subflag &amp;&amp; optflag) {
<a name="l30331"></a>30331     abcd = remedge-&gt;tt;
<a name="l30332"></a>30332     adjustedgering(abcd, CCW);
<a name="l30333"></a>30333     <span class="comment">// Try to flip face cda or cdb to improve quality.</span>
<a name="l30334"></a>30334     <span class="keywordflow">for</span> (j = 0; j &lt; 2; j++) {
<a name="l30335"></a>30335       <span class="keywordflow">if</span> (j == 0) {
<a name="l30336"></a>30336         enext2fnext(abcd, abtetlist[0]); <span class="comment">// Goto cda.</span>
<a name="l30337"></a>30337       } <span class="keywordflow">else</span> {
<a name="l30338"></a>30338         enextfnext(abcd, abtetlist[0]); <span class="comment">// Goto cdb.</span>
<a name="l30339"></a>30339       }
<a name="l30340"></a>30340       fty = categorizeface(abtetlist[0]);
<a name="l30341"></a>30341       <span class="keywordflow">if</span> (fty == T23) {
<a name="l30342"></a>30342         <span class="comment">// A 2-to-3 flip is possible.</span>
<a name="l30343"></a>30343         sym(abtetlist[0], abtetlist[1]);
<a name="l30344"></a>30344         assert(abtetlist[1].tet != dummytet);
<a name="l30345"></a>30345         n = 2;
<a name="l30346"></a>30346         m = 3;
<a name="l30347"></a>30347         remflag = removefacebyflip23(&amp;key, abtetlist, newtetlist, NULL);
<a name="l30348"></a>30348       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fty == T22) {
<a name="l30349"></a>30349         <span class="comment">// A 2-to-2 or 4-to-4 flip is possible.</span>
<a name="l30350"></a>30350         n = 2;
<a name="l30351"></a>30351         newtetlist[0] = abtetlist[0];
<a name="l30352"></a>30352         adjustedgering(newtetlist[0], CW);
<a name="l30353"></a>30353         fnext(newtetlist[0], newtetlist[1]);
<a name="l30354"></a>30354         assert(newtetlist[1].tet != dummytet);
<a name="l30355"></a>30355         <span class="comment">// May it is 4-to-4 flip.</span>
<a name="l30356"></a>30356         <span class="keywordflow">if</span> (fnext(newtetlist[1], newtetlist[2])) {
<a name="l30357"></a>30357           fnext(newtetlist[2], newtetlist[3]);
<a name="l30358"></a>30358           assert(newtetlist[3].tet != dummytet);
<a name="l30359"></a>30359           n = 4;
<a name="l30360"></a>30360         }
<a name="l30361"></a>30361         m = n;
<a name="l30362"></a>30362         remflag = removeedgebyflip22(&amp;key, n, newtetlist, NULL);
<a name="l30363"></a>30363       }
<a name="l30364"></a>30364       <span class="comment">// Has quality been improved?</span>
<a name="l30365"></a>30365       <span class="keywordflow">if</span> (remflag) {
<a name="l30366"></a>30366         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l30367"></a>30367           printf(<span class="stringliteral">&quot;  Done flip %d-to-%d. Qual: %g -&gt; %g.\n&quot;</span>, n, m,
<a name="l30368"></a>30368                  acos(remedge-&gt;key) / PI * 180.0, acos(key) / PI * 180.0);
<a name="l30369"></a>30369         }
<a name="l30370"></a>30370         <span class="comment">// Delete the old tets. Note, flip22() does not create new tets.</span>
<a name="l30371"></a>30371         <span class="keywordflow">if</span> (m == 3) {
<a name="l30372"></a>30372           <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l30373"></a>30373             tetrahedrondealloc(abtetlist[i].tet);
<a name="l30374"></a>30374           }
<a name="l30375"></a>30375         }
<a name="l30376"></a>30376         <span class="keywordflow">for</span> (i = 0; i &lt; m; i++) {
<a name="l30377"></a>30377           checktet4opt(&amp;(newtetlist[i]), <span class="keyword">true</span>);
<a name="l30378"></a>30378         }
<a name="l30379"></a>30379         optcount[1]++;
<a name="l30380"></a>30380         <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l30381"></a>30381       }
<a name="l30382"></a>30382     } <span class="comment">// if (j = 0; j &lt; 2; j++)</span>
<a name="l30383"></a>30383     <span class="comment">// Faces are not flipable. Return.</span>
<a name="l30384"></a>30384     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l30385"></a>30385   }
<a name="l30386"></a>30386 
<a name="l30387"></a>30387   <span class="comment">// 2 &lt;= n &lt;= 10.</span>
<a name="l30388"></a>30388   <span class="keywordflow">if</span> (n == 3) {
<a name="l30389"></a>30389     <span class="comment">// There are three tets at ab. Try to do a flip32 at ab.</span>
<a name="l30390"></a>30390     remflag = removeedgebyflip32(&amp;key, abtetlist, newtetlist, NULL);
<a name="l30391"></a>30391   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((n == 4) || (n == 5) || (n == 6)) {
<a name="l30392"></a>30392     <span class="comment">// Four tets case. Try to do edge transformation.</span>
<a name="l30393"></a>30393     remflag = removeedgebytranNM(&amp;key,n,abtetlist,newtetlist,NULL,NULL,NULL);
<a name="l30394"></a>30394   } <span class="keywordflow">else</span> {
<a name="l30395"></a>30395     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l30396"></a>30396       printf(<span class="stringliteral">&quot;  !! Unhandled case: n = %d.\n&quot;</span>, n);
<a name="l30397"></a>30397     }
<a name="l30398"></a>30398   }
<a name="l30399"></a>30399   <span class="keywordflow">if</span> (remflag) {
<a name="l30400"></a>30400     optcount[n]++;
<a name="l30401"></a>30401     <span class="comment">// Delete the old tets.</span>
<a name="l30402"></a>30402     <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l30403"></a>30403       tetrahedrondealloc(abtetlist[i].tet);
<a name="l30404"></a>30404     }
<a name="l30405"></a>30405     m = (n - 2) * 2; <span class="comment">// The numebr of new tets.</span>
<a name="l30406"></a>30406     <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l30407"></a>30407       printf(<span class="stringliteral">&quot;  Done flip %d-to-%d. &quot;</span>, n, m);
<a name="l30408"></a>30408       <span class="keywordflow">if</span> (optflag) {
<a name="l30409"></a>30409         printf(<span class="stringliteral">&quot;Qual: %g -&gt; %g.&quot;</span>, acos(remedge-&gt;key) / PI * 180.0,
<a name="l30410"></a>30410                acos(key) / PI * 180.0);
<a name="l30411"></a>30411       }
<a name="l30412"></a>30412       printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l30413"></a>30413     }
<a name="l30414"></a>30414   }
<a name="l30415"></a>30415 
<a name="l30416"></a>30416   <span class="keywordflow">if</span> (!remflag &amp;&amp; (key == remedge-&gt;key) &amp;&amp; (n &lt; 7)) {
<a name="l30417"></a>30417     <span class="comment">// Try to do a combination of flips.</span>
<a name="l30418"></a>30418     n1 = 0;
<a name="l30419"></a>30419     remflag = removeedgebycombNM(&amp;key, n, abtetlist, &amp;n1, bftetlist,
<a name="l30420"></a>30420       newtetlist, NULL);
<a name="l30421"></a>30421     <span class="keywordflow">if</span> (remflag) {
<a name="l30422"></a>30422       optcount[9]++;
<a name="l30423"></a>30423       <span class="comment">// Delete the old tets.</span>
<a name="l30424"></a>30424       <span class="keywordflow">for</span> (i = 0; i &lt; n; i++) {
<a name="l30425"></a>30425         tetrahedrondealloc(abtetlist[i].tet);
<a name="l30426"></a>30426       }
<a name="l30427"></a>30427       <span class="keywordflow">for</span> (i = 0; i &lt; n1; i++) {
<a name="l30428"></a>30428         <span class="keywordflow">if</span> (!isdead(&amp;(bftetlist[i]))) {
<a name="l30429"></a>30429           tetrahedrondealloc(bftetlist[i].tet);
<a name="l30430"></a>30430         }
<a name="l30431"></a>30431       }
<a name="l30432"></a>30432       m = ((n1 - 2) * 2 - 1) + (n - 3) * 2; <span class="comment">// The number of new tets.</span>
<a name="l30433"></a>30433       <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l30434"></a>30434         printf(<span class="stringliteral">&quot;  Done flip %d-to-%d (n-1=%d, n1=%d). &quot;</span>, n+n1-2, m, n-1,n1);
<a name="l30435"></a>30435         <span class="keywordflow">if</span> (optflag) {
<a name="l30436"></a>30436           printf(<span class="stringliteral">&quot;Qual: %g -&gt; %g.&quot;</span>, acos(remedge-&gt;key) / PI * 180.0,
<a name="l30437"></a>30437                acos(key) / PI * 180.0);
<a name="l30438"></a>30438         }
<a name="l30439"></a>30439         printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l30440"></a>30440       }
<a name="l30441"></a>30441     }
<a name="l30442"></a>30442   }
<a name="l30443"></a>30443 
<a name="l30444"></a>30444   <span class="keywordflow">if</span> (remflag) {
<a name="l30445"></a>30445     <span class="comment">// edge is removed. Test new tets for further optimization.</span>
<a name="l30446"></a>30446     <span class="keywordflow">for</span> (i = 0; i &lt; m; i++) {
<a name="l30447"></a>30447       <span class="keywordflow">if</span> (optflag) {
<a name="l30448"></a>30448         checktet4opt(&amp;(newtetlist[i]), <span class="keyword">true</span>);
<a name="l30449"></a>30449       } <span class="keywordflow">else</span> {
<a name="l30450"></a>30450         checktet4ill(&amp;(newtetlist[i]), <span class="keyword">true</span>);
<a name="l30451"></a>30451       }
<a name="l30452"></a>30452     }
<a name="l30453"></a>30453   }
<a name="l30454"></a>30454 
<a name="l30455"></a>30455   <span class="keywordflow">return</span> remflag;
<a name="l30456"></a>30456 }
<a name="l30457"></a>30457 
<a name="l30459"></a>30459 <span class="comment">//                                                                           //</span>
<a name="l30460"></a>30460 <span class="comment">// smoothsliver()    Remove a sliver by smoothing a vertex of it.            //</span>
<a name="l30461"></a>30461 <span class="comment">//                                                                           //</span>
<a name="l30462"></a>30462 <span class="comment">// The &#39;slivtet&#39; represents a sliver abcd, and ab is the current edge which  //</span>
<a name="l30463"></a>30463 <span class="comment">// has a large dihedral angle (close to 180 degree).                         //</span>
<a name="l30464"></a>30464 <span class="comment">//                                                                           //</span>
<a name="l30466"></a>30466 <span class="comment"></span>
<a name="l30467"></a>30467 <span class="keywordtype">bool</span> tetgenmesh::smoothsliver(badface* remedge, list *starlist)
<a name="l30468"></a>30468 {
<a name="l30469"></a>30469   triface checktet;
<a name="l30470"></a>30470   point smthpt;
<a name="l30471"></a>30471   <span class="keywordtype">bool</span> smthed;
<a name="l30472"></a>30472   <span class="keywordtype">int</span> idx, i, j;
<a name="l30473"></a>30473 
<a name="l30474"></a>30474   <span class="comment">// Find a Steiner volume point and smooth it.</span>
<a name="l30475"></a>30475   smthed = <span class="keyword">false</span>;
<a name="l30476"></a>30476   <span class="keywordflow">for</span> (i = 0; i &lt; 4 &amp;&amp; !smthed; i++) {
<a name="l30477"></a>30477     smthpt = (point) remedge-&gt;tt.tet[4 + i];
<a name="l30478"></a>30478     <span class="comment">// Is it a volume point?</span>
<a name="l30479"></a>30479     if (pointtype(smthpt) == FREEVOLVERTEX) {
<a name="l30480"></a>30480       <span class="comment">// Is it a Steiner point?</span>
<a name="l30481"></a>30481       idx = pointmark(smthpt) - in-&gt;firstnumber;
<a name="l30482"></a>30482       <span class="keywordflow">if</span> (!(idx &lt; in-&gt;numberofpoints)) {
<a name="l30483"></a>30483         <span class="comment">// Smooth a Steiner volume point.</span>
<a name="l30484"></a>30484         starlist-&gt;append(&amp;(remedge-&gt;tt.tet));
<a name="l30485"></a>30485         formstarpolyhedron(smthpt, starlist, NULL, <span class="keyword">false</span>);
<a name="l30486"></a>30486         smthed = smoothpoint(smthpt,NULL,NULL,starlist,<span class="keyword">false</span>,&amp;remedge-&gt;key);
<a name="l30487"></a>30487         <span class="comment">// If it is smoothed. Queue new bad tets.</span>
<a name="l30488"></a>30488         <span class="keywordflow">if</span> (smthed) {
<a name="l30489"></a>30489           <span class="keywordflow">for</span> (j = 0; j &lt; starlist-&gt;len(); j++) {
<a name="l30490"></a>30490             checktet = * (triface *)(* starlist)[j];
<a name="l30491"></a>30491             checktet4opt(&amp;checktet, <span class="keyword">true</span>);
<a name="l30492"></a>30492           }
<a name="l30493"></a>30493         }
<a name="l30494"></a>30494         starlist-&gt;clear();
<a name="l30495"></a>30495       }
<a name="l30496"></a>30496     }
<a name="l30497"></a>30497   }
<a name="l30498"></a>30498 
<a name="l30499"></a>30499   <span class="comment">/* Omit to smooth segment points. This may cause infinite loop.</span>
<a name="l30500"></a>30500 <span class="comment">  if (smthed) {</span>
<a name="l30501"></a>30501 <span class="comment">    return true;</span>
<a name="l30502"></a>30502 <span class="comment">  }</span>
<a name="l30503"></a>30503 <span class="comment">  face abseg, nextseg, prevseg;</span>
<a name="l30504"></a>30504 <span class="comment">  point pt[2];</span>
<a name="l30505"></a>30505 <span class="comment">  // Check if ab is a segment.</span>
<a name="l30506"></a>30506 <span class="comment">  tsspivot(slivtet, &amp;abseg);</span>
<a name="l30507"></a>30507 <span class="comment">  if (abseg.sh == dummysh) {</span>
<a name="l30508"></a>30508 <span class="comment">    // ab is not a segment. Check if a or b is a Steiner segment point.</span>
<a name="l30509"></a>30509 <span class="comment">    for (i = 0; i &lt; 2 &amp;&amp; !smthed; i++) {</span>
<a name="l30510"></a>30510 <span class="comment">      smthpt = (i == 0 ? org(*slivtet) : dest(*slivtet));</span>
<a name="l30511"></a>30511 <span class="comment">      if (pointtype(smthpt) == FREESEGVERTEX) {</span>
<a name="l30512"></a>30512 <span class="comment">        // Is it a Steiner point?</span>
<a name="l30513"></a>30513 <span class="comment">        idx = pointmark(smthpt) - in-&gt;firstnumber;</span>
<a name="l30514"></a>30514 <span class="comment">        if (!(idx &lt; in-&gt;numberofpoints)) {</span>
<a name="l30515"></a>30515 <span class="comment">          // Smooth a Steiner segment point. Get the segment.</span>
<a name="l30516"></a>30516 <span class="comment">          sdecode(point2sh(smthpt), nextseg);</span>
<a name="l30517"></a>30517 <span class="comment">          locateseg(smthpt, &amp;nextseg);</span>
<a name="l30518"></a>30518 <span class="comment">          assert(sorg(nextseg) == smthpt);</span>
<a name="l30519"></a>30519 <span class="comment">          pt[0] = sdest(nextseg);</span>
<a name="l30520"></a>30520 <span class="comment">          senext2(nextseg, prevseg);</span>
<a name="l30521"></a>30521 <span class="comment">          spivotself(prevseg);</span>
<a name="l30522"></a>30522 <span class="comment">          prevseg.shver = 0;</span>
<a name="l30523"></a>30523 <span class="comment">          if (sorg(prevseg) == smthpt) sesymself(prevseg);</span>
<a name="l30524"></a>30524 <span class="comment">          assert(sdest(prevseg) == smthpt);</span>
<a name="l30525"></a>30525 <span class="comment">          pt[1] = sorg(prevseg);</span>
<a name="l30526"></a>30526 <span class="comment">          starlist-&gt;append(slivtet);</span>
<a name="l30527"></a>30527 <span class="comment">          formstarpolyhedron(smthpt, starlist, NULL, true);</span>
<a name="l30528"></a>30528 <span class="comment">          smthed = smoothpoint(smthpt, pt[0], pt[1], starlist, false);</span>
<a name="l30529"></a>30529 <span class="comment">          // If it is smoothed. Check if the tet is still a sliver.</span>
<a name="l30530"></a>30530 <span class="comment">          if (smthed) checktet4opt(slivtet, true);</span>
<a name="l30531"></a>30531 <span class="comment">          starlist-&gt;clear();</span>
<a name="l30532"></a>30532 <span class="comment">        }</span>
<a name="l30533"></a>30533 <span class="comment">      }</span>
<a name="l30534"></a>30534 <span class="comment">    }</span>
<a name="l30535"></a>30535 <span class="comment">  }</span>
<a name="l30536"></a>30536 <span class="comment">  */</span>
<a name="l30537"></a>30537 
<a name="l30538"></a>30538   <span class="keywordflow">return</span> smthed;
<a name="l30539"></a>30539 }
<a name="l30540"></a>30540 
<a name="l30542"></a>30542 <span class="comment">//                                                                           //</span>
<a name="l30543"></a>30543 <span class="comment">// splitsliver()    Remove a sliver by inserting a point.                    //</span>
<a name="l30544"></a>30544 <span class="comment">//                                                                           //</span>
<a name="l30545"></a>30545 <span class="comment">// The &#39;remedge-&gt;tt&#39; represents a sliver abcd, ab is the current edge which  //</span>
<a name="l30546"></a>30546 <span class="comment">// has a large dihedral angle (close to 180 degree).                         //</span>
<a name="l30547"></a>30547 <span class="comment">//                                                                           //</span>
<a name="l30549"></a>30549 <span class="comment"></span>
<a name="l30550"></a>30550 <span class="keywordtype">bool</span> tetgenmesh::splitsliver(badface *remedge, list *tetlist, list *ceillist)
<a name="l30551"></a>30551 {
<a name="l30552"></a>30552   triface starttet;
<a name="l30553"></a>30553   face checkseg;
<a name="l30554"></a>30554   point newpt, pt[4];
<a name="l30555"></a>30555   <span class="keywordtype">bool</span> remflag;
<a name="l30556"></a>30556   <span class="keywordtype">int</span> i;
<a name="l30557"></a>30557 
<a name="l30558"></a>30558   starttet = remedge-&gt;tt;
<a name="l30559"></a>30559 
<a name="l30560"></a>30560   <span class="comment">// Check if cd is a segment.</span>
<a name="l30561"></a>30561   adjustedgering(starttet, CCW);
<a name="l30562"></a>30562   enextfnextself(starttet);
<a name="l30563"></a>30563   enextself(starttet);
<a name="l30564"></a>30564   tsspivot(&amp;starttet, &amp;checkseg);
<a name="l30565"></a>30565   <span class="keywordflow">if</span> (b-&gt;nobisect == 0) {
<a name="l30566"></a>30566     <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l30567"></a>30567       <span class="comment">// cd is a segment. The seg will be split. BUT do not flip! Due to the</span>
<a name="l30568"></a>30568       <span class="comment">//   exact predicates, lot of slivers ay be rsulted and hard to remove.</span>
<a name="l30569"></a>30569       checkseg.shver = 0;
<a name="l30570"></a>30570       pt[0] = sorg(checkseg);
<a name="l30571"></a>30571       pt[1] = sdest(checkseg);
<a name="l30572"></a>30572       makepoint(&amp;newpt);
<a name="l30573"></a>30573       getsplitpoint(pt[0], pt[1], NULL, newpt);
<a name="l30574"></a>30574       setpointtype(newpt, FREESEGVERTEX);
<a name="l30575"></a>30575       setpoint2sh(newpt, sencode(checkseg));
<a name="l30576"></a>30576       <span class="comment">// Insert p, this should always success.</span>
<a name="l30577"></a>30577       sstpivot(&amp;checkseg, &amp;starttet);
<a name="l30578"></a>30578       splittetedge(newpt, &amp;starttet, NULL);
<a name="l30579"></a>30579       <span class="comment">// Collect the new tets connecting at p.</span>
<a name="l30580"></a>30580       sstpivot(&amp;checkseg, &amp;starttet);
<a name="l30581"></a>30581       ceillist-&gt;append(&amp;starttet);
<a name="l30582"></a>30582       formstarpolyhedron(newpt, ceillist, NULL, <span class="keyword">true</span>);
<a name="l30583"></a>30583       setnewpointsize(newpt, pt[0], NULL);
<a name="l30584"></a>30584       <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l30585"></a>30585       <span class="comment">// Smooth p.</span>
<a name="l30586"></a>30586       smoothpoint(newpt, pt[0], pt[1], ceillist, <span class="keyword">false</span>, NULL);
<a name="l30587"></a>30587       <span class="comment">// Queue new slivers.</span>
<a name="l30588"></a>30588       <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l30589"></a>30589         starttet = * (triface *)(* ceillist)[i];
<a name="l30590"></a>30590         checktet4opt(&amp;starttet, <span class="keyword">true</span>);
<a name="l30591"></a>30591       }
<a name="l30592"></a>30592       ceillist-&gt;clear();
<a name="l30593"></a>30593       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l30594"></a>30594     }
<a name="l30595"></a>30595   }
<a name="l30596"></a>30596 
<a name="l30597"></a>30597   <span class="comment">// Get the four corners.</span>
<a name="l30598"></a>30598   <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l30599"></a>30599     pt[i] = (point) starttet.tet[4 + i];
<a name="l30600"></a>30600   }
<a name="l30601"></a>30601   <span class="comment">// Create the new point p (at the circumcenter of t).</span>
<a name="l30602"></a>30602   makepoint(&amp;newpt);
<a name="l30603"></a>30603   <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l30604"></a>30604     newpt[i] = 0.25 * (pt[0][i] + pt[1][i] + pt[2][i] + pt[3][i]);
<a name="l30605"></a>30605   }
<a name="l30606"></a>30606   setpointtype(newpt, FREEVOLVERTEX);
<a name="l30607"></a>30607 
<a name="l30608"></a>30608   <span class="comment">// Form the Bowyer-Watson cavity of p.</span>
<a name="l30609"></a>30609   remflag = <span class="keyword">false</span>;
<a name="l30610"></a>30610   infect(starttet);
<a name="l30611"></a>30611   tetlist-&gt;append(&amp;starttet);
<a name="l30612"></a>30612   formbowatcavityquad(newpt, tetlist, ceillist);
<a name="l30613"></a>30613   <span class="keywordflow">if</span> (trimbowatcavity(newpt, NULL, 1, NULL, NULL, &amp;tetlist, &amp;ceillist, -1.0)) {
<a name="l30614"></a>30614     <span class="comment">// Smooth p.</span>
<a name="l30615"></a>30615     <span class="keywordflow">if</span> (smoothpoint( newpt, NULL, NULL, ceillist, <span class="keyword">false</span>, &amp;remedge-&gt;key)) {
<a name="l30616"></a>30616       <span class="comment">// Insert p.</span>
<a name="l30617"></a>30617       bowatinsertsite(newpt, NULL, 1, NULL, NULL, &amp;tetlist, &amp;ceillist, NULL,
<a name="l30618"></a>30618                       NULL, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);
<a name="l30619"></a>30619       setnewpointsize(newpt, pt[0], NULL);
<a name="l30620"></a>30620       <span class="keywordflow">if</span> (steinerleft &gt; 0) steinerleft--;
<a name="l30621"></a>30621       <span class="comment">// Queue new slivers.</span>
<a name="l30622"></a>30622       <span class="keywordflow">for</span> (i = 0; i &lt; ceillist-&gt;len(); i++) {
<a name="l30623"></a>30623         starttet = * (triface *)(* ceillist)[i];
<a name="l30624"></a>30624         checktet4opt(&amp;starttet, <span class="keyword">true</span>);
<a name="l30625"></a>30625       }
<a name="l30626"></a>30626       remflag = <span class="keyword">true</span>;
<a name="l30627"></a>30627     } <span class="comment">// if (smoothpoint)</span>
<a name="l30628"></a>30628   } <span class="comment">// if (trimbowatcavity)</span>
<a name="l30629"></a>30629 
<a name="l30630"></a>30630   <span class="keywordflow">if</span> (!remflag) {
<a name="l30631"></a>30631     <span class="comment">// p is rejected for BC(p) is not valid.</span>
<a name="l30632"></a>30632     pointdealloc(newpt);
<a name="l30633"></a>30633     <span class="comment">// Uninfect tets of BC(p).</span>
<a name="l30634"></a>30634     <span class="keywordflow">for</span> (i = 0; i &lt; tetlist-&gt;len(); i++) {
<a name="l30635"></a>30635       starttet = * (triface *)(* tetlist)[i];
<a name="l30636"></a>30636       uninfect(starttet);
<a name="l30637"></a>30637     }
<a name="l30638"></a>30638   }
<a name="l30639"></a>30639   tetlist-&gt;clear();
<a name="l30640"></a>30640   ceillist-&gt;clear();
<a name="l30641"></a>30641 
<a name="l30642"></a>30642   <span class="keywordflow">return</span> remflag;
<a name="l30643"></a>30643 }
<a name="l30644"></a>30644 
<a name="l30646"></a>30646 <span class="comment">//                                                                           //</span>
<a name="l30647"></a>30647 <span class="comment">// tallslivers()    Queue all the slivers in the mesh.                       //</span>
<a name="l30648"></a>30648 <span class="comment">//                                                                           //</span>
<a name="l30650"></a>30650 <span class="comment"></span>
<a name="l30651"></a>30651 <span class="keywordtype">void</span> tetgenmesh::tallslivers(<span class="keywordtype">bool</span> optflag)
<a name="l30652"></a>30652 {
<a name="l30653"></a>30653   triface tetloop;
<a name="l30654"></a>30654 
<a name="l30655"></a>30655   tetrahedrons-&gt;traversalinit();
<a name="l30656"></a>30656   tetloop.tet = tetrahedrontraverse();
<a name="l30657"></a>30657   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l30658"></a>30658     <span class="keywordflow">if</span> (optflag) {
<a name="l30659"></a>30659       checktet4opt(&amp;tetloop, <span class="keyword">true</span>);
<a name="l30660"></a>30660     } <span class="keywordflow">else</span> {
<a name="l30661"></a>30661       checktet4ill(&amp;tetloop, <span class="keyword">true</span>);
<a name="l30662"></a>30662     }
<a name="l30663"></a>30663     tetloop.tet = tetrahedrontraverse();
<a name="l30664"></a>30664   }
<a name="l30665"></a>30665 }
<a name="l30666"></a>30666 
<a name="l30668"></a>30668 <span class="comment">//                                                                           //</span>
<a name="l30669"></a>30669 <span class="comment">// optimizemesh()    Improve mesh quality by mesh optimizations.             //</span>
<a name="l30670"></a>30670 <span class="comment">//                                                                           //</span>
<a name="l30671"></a>30671 <span class="comment">// Available mesh optimizing operations are: (1) multiple edge flips (3-to-2,//</span>
<a name="l30672"></a>30672 <span class="comment">// 4-to-4, 5-to-6, etc), (2) free vertex deletion, (3) new vertex insertion. //</span>
<a name="l30673"></a>30673 <span class="comment">// (1) is mandatory, while (2) and (3) are optionally.                       //</span>
<a name="l30674"></a>30674 <span class="comment">//                                                                           //</span>
<a name="l30675"></a>30675 <span class="comment">// The variable &#39;b-&gt;optlevel&#39; (set after &#39;-s&#39;) determines the use of these   //</span>
<a name="l30676"></a>30676 <span class="comment">// operations. If it is: 0, do no optimization; 1, only do (1) operation; 2, //</span>
<a name="l30677"></a>30677 <span class="comment">// do (1) and (2) operations; 3, do all operations. Deault, b-&gt;optlvel = 2.  //</span>
<a name="l30678"></a>30678 <span class="comment">//                                                                           //</span>
<a name="l30680"></a>30680 <span class="comment"></span>
<a name="l30681"></a>30681 <span class="keywordtype">void</span> tetgenmesh::optimizemesh(<span class="keywordtype">bool</span> optflag)
<a name="l30682"></a>30682 {
<a name="l30683"></a>30683   list *splittetlist, *tetlist, *ceillist;
<a name="l30684"></a>30684   badface *remtet, *lastentry;
<a name="l30685"></a>30685   <span class="comment">//REAL maxdihed, objdihed, curdihed; // maxdihead commented out to get gcc 4.6 working</span>
<a name="l30686"></a>30686   REAL objdihed, curdihed;
<a name="l30687"></a>30687   <span class="keywordtype">long</span> oldnum;
<a name="l30688"></a>30688   <span class="keywordtype">int</span> iter, i;
<a name="l30689"></a>30689 
<a name="l30690"></a>30690   objdihed = 0.0;
<a name="l30691"></a>30691 
<a name="l30692"></a>30692   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l30693"></a>30693     <span class="keywordflow">if</span> (optflag) {
<a name="l30694"></a>30694       printf(<span class="stringliteral">&quot;Optimizing mesh.\n&quot;</span>);
<a name="l30695"></a>30695     } <span class="keywordflow">else</span> {
<a name="l30696"></a>30696       printf(<span class="stringliteral">&quot;Repairing mesh.\n&quot;</span>);
<a name="l30697"></a>30697     }
<a name="l30698"></a>30698   }
<a name="l30699"></a>30699 
<a name="l30700"></a>30700 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l30701"></a>30701 <span class="preprocessor"></span>  <span class="keywordflow">if</span> (optflag &amp;&amp; (b-&gt;verbose)) {
<a name="l30702"></a>30702     printf(<span class="stringliteral">&quot;  level = %d.\n&quot;</span>, b-&gt;optlevel);
<a name="l30703"></a>30703   }
<a name="l30704"></a>30704 <span class="preprocessor">#endif</span>
<a name="l30705"></a>30705 <span class="preprocessor"></span>
<a name="l30706"></a>30706   <span class="comment">// Initialize the pool of bad tets.</span>
<a name="l30707"></a>30707   badtetrahedrons = <span class="keyword">new</span> <a class="code" href="structmemorypool.html">memorypool</a>(<span class="keyword">sizeof</span>(badface), ELEPERBLOCK, POINTER, 0);
<a name="l30708"></a>30708   <span class="keywordflow">if</span> (optflag) {
<a name="l30709"></a>30709     cosmaxdihed = cos(b-&gt;maxdihedral * PI / 180.0);
<a name="l30710"></a>30710     cosmindihed = cos(b-&gt;mindihedral * PI / 180.0);
<a name="l30711"></a>30711     <span class="comment">// The radian of the maximum dihedral angle.</span>
<a name="l30712"></a>30712     <span class="comment">//maxdihed = b-&gt;maxdihedral / 180.0 * PI; // maxdihead commented out to get gcc 4.6 working</span>
<a name="l30713"></a>30713     <span class="comment">// A sliver has an angle large than &#39;objdihed&#39; will be split.</span>
<a name="l30714"></a>30714     objdihed = b-&gt;maxdihedral + 5.0;
<a name="l30715"></a>30715     <span class="keywordflow">if</span> (objdihed &lt; 170.0) objdihed = 170.0;
<a name="l30716"></a>30716     objdihed = objdihed / 180.0 * PI;
<a name="l30717"></a>30717   }
<a name="l30718"></a>30718   <span class="comment">// Looking for non-optimal tets.</span>
<a name="l30719"></a>30719   tallslivers(optflag);
<a name="l30720"></a>30720 
<a name="l30721"></a>30721   optcount[0] = 0l;  <span class="comment">// tet strip count.</span>
<a name="l30722"></a>30722   optcount[1] = 0l;  <span class="comment">// face (2-3) and edge (2-2) flip count.</span>
<a name="l30723"></a>30723   optcount[3] = optcount[4] = optcount[5] = optcount[6] = 0l; <span class="comment">// edge flips.</span>
<a name="l30724"></a>30724   optcount[9] = 0l;  <span class="comment">// combined flip count.</span>
<a name="l30725"></a>30725 
<a name="l30726"></a>30726   <span class="comment">// Perform edge flip to improve quality.</span>
<a name="l30727"></a>30727   lastentry = (badface *) NULL;
<a name="l30728"></a>30728   <span class="comment">// Loop until pool &#39;badtetrahedrons&#39; is empty.</span>
<a name="l30729"></a>30729   <span class="keywordflow">while</span> (badtetrahedrons-&gt;items &gt; 0) {
<a name="l30730"></a>30730     badtetrahedrons-&gt;traversalinit();
<a name="l30731"></a>30731     remtet = badfacetraverse(badtetrahedrons);
<a name="l30732"></a>30732     <span class="keywordflow">while</span> (remtet != (badface *) NULL) {
<a name="l30733"></a>30733       <span class="comment">// Make sure that the tet is still the same one when it was tested.</span>
<a name="l30734"></a>30734       <span class="comment">//   Subsequent transformations may have made it a different tet.</span>
<a name="l30735"></a>30735       <span class="keywordflow">if</span> (!isdead(&amp;remtet-&gt;tt) &amp;&amp; org(remtet-&gt;tt) == remtet-&gt;forg &amp;&amp;
<a name="l30736"></a>30736           dest(remtet-&gt;tt) == remtet-&gt;fdest &amp;&amp;
<a name="l30737"></a>30737           apex(remtet-&gt;tt) == remtet-&gt;fapex &amp;&amp;
<a name="l30738"></a>30738           oppo(remtet-&gt;tt) == remtet-&gt;foppo) {
<a name="l30739"></a>30739         <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l30740"></a>30740           printf(<span class="stringliteral">&quot;    Repair tet (%d, %d, %d, %d) %g (degree).\n&quot;</span>,
<a name="l30741"></a>30741                  pointmark(remtet-&gt;forg), pointmark(remtet-&gt;fdest),
<a name="l30742"></a>30742                  pointmark(remtet-&gt;fapex), pointmark(remtet-&gt;foppo),
<a name="l30743"></a>30743                  acos(remtet-&gt;key) / PI * 180.0);
<a name="l30744"></a>30744         }
<a name="l30745"></a>30745         <span class="keywordflow">if</span> (!removeedge(remtet, optflag)) {
<a name="l30746"></a>30746           <span class="comment">// An unremoveable tet. Check if it forms a loop.</span>
<a name="l30747"></a>30747           <span class="keywordflow">if</span> (lastentry != (badface *) NULL) {
<a name="l30748"></a>30748             <span class="keywordflow">if</span> (remtet == lastentry) <span class="keywordflow">break</span>;
<a name="l30749"></a>30749           } <span class="keywordflow">else</span> {
<a name="l30750"></a>30750             <span class="comment">// Remember this tet as a breakpoint.</span>
<a name="l30751"></a>30751             lastentry = remtet;
<a name="l30752"></a>30752           }
<a name="l30753"></a>30753         } <span class="keywordflow">else</span> {
<a name="l30754"></a>30754           <span class="comment">// Clear the breakpoint.</span>
<a name="l30755"></a>30755           lastentry = (badface *) NULL;
<a name="l30756"></a>30756           <span class="comment">// Remove the entry from the queue.</span>
<a name="l30757"></a>30757           badfacedealloc(badtetrahedrons, remtet);
<a name="l30758"></a>30758         }
<a name="l30759"></a>30759       } <span class="keywordflow">else</span> {
<a name="l30760"></a>30760         <span class="comment">// Remove the entry from the queue.</span>
<a name="l30761"></a>30761         badfacedealloc(badtetrahedrons, remtet);
<a name="l30762"></a>30762       }
<a name="l30763"></a>30763       remtet = badfacetraverse(badtetrahedrons);
<a name="l30764"></a>30764     }
<a name="l30765"></a>30765     <span class="comment">// Stop if the above loop was out by force.</span>
<a name="l30766"></a>30766     <span class="keywordflow">if</span> (remtet != (badface *) NULL) <span class="keywordflow">break</span>;
<a name="l30767"></a>30767   }
<a name="l30768"></a>30768 
<a name="l30769"></a>30769   <span class="keywordflow">if</span> (b-&gt;verbose) {
<a name="l30770"></a>30770     <span class="keywordflow">if</span> (optcount[0] &gt; 0l) {
<a name="l30771"></a>30771       printf(<span class="stringliteral">&quot;  %ld tets are peeled off.\n&quot;</span>, optcount[0]);
<a name="l30772"></a>30772     }
<a name="l30773"></a>30773     <span class="keywordflow">if</span> (optcount[1] &gt; 0l) {
<a name="l30774"></a>30774       printf(<span class="stringliteral">&quot;  %ld faces are flipped.\n&quot;</span>, optcount[1]);
<a name="l30775"></a>30775     }
<a name="l30776"></a>30776     <span class="keywordflow">if</span> (optcount[3] + optcount[4] + optcount[5] + optcount[6] +
<a name="l30777"></a>30777         optcount[9] &gt; 0l) {
<a name="l30778"></a>30778       printf(<span class="stringliteral">&quot;  %ld edges are flipped.\n&quot;</span>, optcount[3] + optcount[4] +
<a name="l30779"></a>30779              optcount[5] + optcount[6] + optcount[9]);
<a name="l30780"></a>30780     }
<a name="l30781"></a>30781     <span class="comment">// if (badtetrahedrons-&gt;items &gt; 0l) {</span>
<a name="l30782"></a>30782     <span class="comment">//   printf(&quot;  %ld edges remain.\n&quot;, badtetrahedrons-&gt;items);</span>
<a name="l30783"></a>30783     <span class="comment">// }</span>
<a name="l30784"></a>30784   }
<a name="l30785"></a>30785 
<a name="l30786"></a>30786   <span class="keywordflow">if</span> ((badtetrahedrons-&gt;items &gt; 0l) &amp;&amp; optflag  &amp;&amp; (b-&gt;optlevel &gt; 2)) {
<a name="l30787"></a>30787     splittetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(badface), NULL, 256);
<a name="l30788"></a>30788     tetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l30789"></a>30789     ceillist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l30790"></a>30790     oldnum = points-&gt;items;
<a name="l30791"></a>30791     smoothsegverts = smoothvolverts = 0;
<a name="l30792"></a>30792     optcount[1] = 0l;
<a name="l30793"></a>30793     optcount[3] = optcount[4] = optcount[5] = optcount[6] = 0l; <span class="comment">// edge flips.</span>
<a name="l30794"></a>30794     optcount[9] = 0l;  <span class="comment">// combined flip count.</span>
<a name="l30795"></a>30795     iter = 0;
<a name="l30796"></a>30796 
<a name="l30797"></a>30797     <span class="keywordflow">do</span> {
<a name="l30798"></a>30798       <span class="comment">// Form a list of slivers to be split and clean the pool.</span>
<a name="l30799"></a>30799       badtetrahedrons-&gt;traversalinit();
<a name="l30800"></a>30800       remtet = badfacetraverse(badtetrahedrons);
<a name="l30801"></a>30801       <span class="keywordflow">while</span> (remtet != (badface *) NULL) {
<a name="l30802"></a>30802         splittetlist-&gt;append(remtet);
<a name="l30803"></a>30803         <span class="comment">// Remove the entry from the queue.</span>
<a name="l30804"></a>30804         badfacedealloc(badtetrahedrons, remtet);
<a name="l30805"></a>30805         remtet = badfacetraverse(badtetrahedrons);
<a name="l30806"></a>30806       }
<a name="l30807"></a>30807       <span class="keywordflow">for</span> (i = 0; i &lt; splittetlist-&gt;len(); i++) {
<a name="l30808"></a>30808         remtet = (badface *)(* splittetlist)[i];
<a name="l30809"></a>30809         <span class="comment">// Make sure that the tet is still the same one when it was tested.</span>
<a name="l30810"></a>30810         <span class="comment">//   Subsequent transformations may have made it a different tet.</span>
<a name="l30811"></a>30811         <span class="keywordflow">if</span> (!isdead(&amp;remtet-&gt;tt) &amp;&amp; org(remtet-&gt;tt) == remtet-&gt;forg &amp;&amp;
<a name="l30812"></a>30812             dest(remtet-&gt;tt) == remtet-&gt;fdest &amp;&amp;
<a name="l30813"></a>30813             apex(remtet-&gt;tt) == remtet-&gt;fapex &amp;&amp;
<a name="l30814"></a>30814             oppo(remtet-&gt;tt) == remtet-&gt;foppo) {
<a name="l30815"></a>30815           <span class="comment">// The sliver may get smoothed due to a neighboring tet.</span>
<a name="l30816"></a>30816           curdihed = facedihedral(remtet-&gt;forg, remtet-&gt;fdest, remtet-&gt;fapex,
<a name="l30817"></a>30817                                   remtet-&gt;foppo);
<a name="l30818"></a>30818           <span class="comment">// The dihedral angle of a tet must less than PI, correct it.</span>
<a name="l30819"></a>30819           <span class="keywordflow">if</span> (curdihed &gt; PI) curdihed = 2 * PI - curdihed;
<a name="l30820"></a>30820           <span class="comment">// Is it a large angle?</span>
<a name="l30821"></a>30821           <span class="keywordflow">if</span> (curdihed &gt; objdihed) {
<a name="l30822"></a>30822             remtet-&gt;key = cos(curdihed);
<a name="l30823"></a>30823             <span class="keywordflow">if</span> (b-&gt;verbose &gt; 1) {
<a name="l30824"></a>30824               printf(<span class="stringliteral">&quot;    Get sliver (%d, %d, %d, %d) %g (degree).\n&quot;</span>,
<a name="l30825"></a>30825                      pointmark(remtet-&gt;forg), pointmark(remtet-&gt;fdest),
<a name="l30826"></a>30826                      pointmark(remtet-&gt;fapex), pointmark(remtet-&gt;foppo),
<a name="l30827"></a>30827                      acos(remtet-&gt;key) / PI * 180.0);
<a name="l30828"></a>30828             }
<a name="l30829"></a>30829             <span class="keywordflow">if</span> (!removeedge(remtet, optflag)) {
<a name="l30830"></a>30830               <span class="keywordflow">if</span> (!smoothsliver(remtet, tetlist)) {
<a name="l30831"></a>30831                 splitsliver(remtet, tetlist, ceillist);
<a name="l30832"></a>30832               }
<a name="l30833"></a>30833             }
<a name="l30834"></a>30834           }
<a name="l30835"></a>30835         }
<a name="l30836"></a>30836       }
<a name="l30837"></a>30837       iter++;
<a name="l30838"></a>30838     } <span class="keywordflow">while</span> ((badtetrahedrons-&gt;items &gt; 0l) &amp;&amp; (iter &lt; b-&gt;optpasses));
<a name="l30839"></a>30839 
<a name="l30840"></a>30840     <span class="keywordflow">if</span> (b-&gt;verbose) {
<a name="l30841"></a>30841       printf(<span class="stringliteral">&quot;  %d passes.\n&quot;</span>, iter);
<a name="l30842"></a>30842       <span class="keywordflow">if</span> ((points-&gt;items - oldnum) &gt; 0l) {
<a name="l30843"></a>30843         printf(<span class="stringliteral">&quot;  %ld points are inserted (%d on segment).\n&quot;</span>,
<a name="l30844"></a>30844                points-&gt;items - oldnum, smoothsegverts);
<a name="l30845"></a>30845       }
<a name="l30846"></a>30846       <span class="keywordflow">if</span> (optcount[1] &gt; 0l) {
<a name="l30847"></a>30847         printf(<span class="stringliteral">&quot;  %ld faces are flipped.\n&quot;</span>, optcount[1]);
<a name="l30848"></a>30848       }
<a name="l30849"></a>30849       <span class="keywordflow">if</span> (optcount[3] + optcount[4] + optcount[5] + optcount[6] +
<a name="l30850"></a>30850           optcount[9] &gt; 0l) {
<a name="l30851"></a>30851         printf(<span class="stringliteral">&quot;  %ld edges are flipped.\n&quot;</span>, optcount[3] + optcount[4] +
<a name="l30852"></a>30852                optcount[5] + optcount[6] + optcount[9]);
<a name="l30853"></a>30853       }
<a name="l30854"></a>30854       <span class="comment">// if (badtetrahedrons-&gt;items &gt; 0l) {</span>
<a name="l30855"></a>30855       <span class="comment">//   printf(&quot;  %ld edges remain.\n&quot;, badtetrahedrons-&gt;items);</span>
<a name="l30856"></a>30856       <span class="comment">// }</span>
<a name="l30857"></a>30857     }
<a name="l30858"></a>30858     <span class="keyword">delete</span> tetlist;
<a name="l30859"></a>30859     <span class="keyword">delete</span> ceillist;
<a name="l30860"></a>30860     <span class="keyword">delete</span> splittetlist;
<a name="l30861"></a>30861   }
<a name="l30862"></a>30862 
<a name="l30863"></a>30863   <span class="keyword">delete</span> badtetrahedrons;
<a name="l30864"></a>30864   badtetrahedrons = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l30865"></a>30865 }
<a name="l30866"></a>30866 
<a name="l30867"></a>30867 <span class="comment">//</span>
<a name="l30868"></a>30868 <span class="comment">// End of mesh optimization routines</span>
<a name="l30869"></a>30869 <span class="comment">//</span>
<a name="l30870"></a>30870 
<a name="l30871"></a>30871 <span class="comment">//</span>
<a name="l30872"></a>30872 <span class="comment">// Begin of I/O rouitnes</span>
<a name="l30873"></a>30873 <span class="comment">//</span>
<a name="l30874"></a>30874 
<a name="l30876"></a>30876 <span class="comment">//                                                                           //</span>
<a name="l30877"></a>30877 <span class="comment">// transfernodes()    Transfer nodes from &#39;io-&gt;pointlist&#39; to &#39;this-&gt;points&#39;. //</span>
<a name="l30878"></a>30878 <span class="comment">//                                                                           //</span>
<a name="l30879"></a>30879 <span class="comment">// Initializing &#39;this-&gt;points&#39;.  Transferring all points from &#39;in-&gt;pointlist&#39;//</span>
<a name="l30880"></a>30880 <span class="comment">// into it. All points are indexed (start from in-&gt;firstnumber).  Each point //</span>
<a name="l30881"></a>30881 <span class="comment">// is initialized be UNUSEDVERTEX.  The bounding box (xmin, xmax, ymin, ymax,//</span>
<a name="l30882"></a>30882 <span class="comment">// zmin, zmax) and the diameter (longest) of the point set are calculated.   //</span>
<a name="l30883"></a>30883 <span class="comment">//                                                                           //</span>
<a name="l30885"></a>30885 <span class="comment"></span>
<a name="l30886"></a>30886 <span class="keywordtype">void</span> tetgenmesh::transfernodes()
<a name="l30887"></a>30887 {
<a name="l30888"></a>30888   point pointloop;
<a name="l30889"></a>30889   REAL x, y, z;
<a name="l30890"></a>30890   <span class="keywordtype">int</span> coordindex;
<a name="l30891"></a>30891   <span class="keywordtype">int</span> attribindex;
<a name="l30892"></a>30892   <span class="keywordtype">int</span> mtrindex;
<a name="l30893"></a>30893   <span class="keywordtype">int</span> i, j;
<a name="l30894"></a>30894 
<a name="l30895"></a>30895   <span class="comment">// Read the points.</span>
<a name="l30896"></a>30896   coordindex = 0;
<a name="l30897"></a>30897   attribindex = 0;
<a name="l30898"></a>30898   mtrindex = 0;
<a name="l30899"></a>30899   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofpoints; i++) {
<a name="l30900"></a>30900     makepoint(&amp;pointloop);
<a name="l30901"></a>30901     <span class="comment">// Read the point coordinates.</span>
<a name="l30902"></a>30902     x = pointloop[0] = in-&gt;pointlist[coordindex++];
<a name="l30903"></a>30903     y = pointloop[1] = in-&gt;pointlist[coordindex++];
<a name="l30904"></a>30904     z = pointloop[2] = in-&gt;pointlist[coordindex++];
<a name="l30905"></a>30905     <span class="comment">// Read the point attributes.</span>
<a name="l30906"></a>30906     <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberofpointattributes; j++) {
<a name="l30907"></a>30907       pointloop[3 + j] = in-&gt;pointattributelist[attribindex++];
<a name="l30908"></a>30908     }
<a name="l30909"></a>30909     <span class="comment">// Read the point metric tensor.</span>
<a name="l30910"></a>30910     <span class="keywordflow">for</span> (j = 0; j &lt; in-&gt;numberofpointmtrs; j++) {
<a name="l30911"></a>30911       pointloop[pointmtrindex + j] = in-&gt;pointmtrlist[mtrindex++];
<a name="l30912"></a>30912     }
<a name="l30913"></a>30913     <span class="comment">// Determine the smallest and largests x, y and z coordinates.</span>
<a name="l30914"></a>30914     <span class="keywordflow">if</span> (i == 0) {
<a name="l30915"></a>30915       xmin = xmax = x;
<a name="l30916"></a>30916       ymin = ymax = y;
<a name="l30917"></a>30917       zmin = zmax = z;
<a name="l30918"></a>30918     } <span class="keywordflow">else</span> {
<a name="l30919"></a>30919       xmin = (x &lt; xmin) ? x : xmin;
<a name="l30920"></a>30920       xmax = (x &gt; xmax) ? x : xmax;
<a name="l30921"></a>30921       ymin = (y &lt; ymin) ? y : ymin;
<a name="l30922"></a>30922       ymax = (y &gt; ymax) ? y : ymax;
<a name="l30923"></a>30923       zmin = (z &lt; zmin) ? z : zmin;
<a name="l30924"></a>30924       zmax = (z &gt; zmax) ? z : zmax;
<a name="l30925"></a>30925     }
<a name="l30926"></a>30926   }
<a name="l30927"></a>30927   <span class="comment">// &#39;longest&#39; is the largest possible edge length formed by input vertices.</span>
<a name="l30928"></a>30928   x = xmax - xmin;
<a name="l30929"></a>30929   y = ymax - ymin;
<a name="l30930"></a>30930   z = zmax - zmin;
<a name="l30931"></a>30931   longest = sqrt(x * x + y * y + z * z);
<a name="l30932"></a>30932   <span class="keywordflow">if</span> (longest == 0.0) {
<a name="l30933"></a>30933     printf(<span class="stringliteral">&quot;Error:  The point set is trivial.\n&quot;</span>);
<a name="l30934"></a>30934     terminatetetgen(1);
<a name="l30935"></a>30935   }
<a name="l30936"></a>30936   <span class="comment">// Two identical points are distinguished by &#39;lengthlimit&#39;.</span>
<a name="l30937"></a>30937   lengthlimit = longest * b-&gt;epsilon * 1e+2;
<a name="l30938"></a>30938 }
<a name="l30939"></a>30939 
<a name="l30941"></a>30941 <span class="comment">//                                                                           //</span>
<a name="l30942"></a>30942 <span class="comment">// jettisonnodes()    Jettison unused or duplicated vertices.                //</span>
<a name="l30943"></a>30943 <span class="comment">//                                                                           //</span>
<a name="l30944"></a>30944 <span class="comment">// Unused points are those input points which are outside the mesh domain or //</span>
<a name="l30945"></a>30945 <span class="comment">// have no connection (isolated) to the mesh.  Duplicated points exist for   //</span>
<a name="l30946"></a>30946 <span class="comment">// example if the input PLC is read from a .stl mesh file (marked during the //</span>
<a name="l30947"></a>30947 <span class="comment">// Delaunay tetrahedralization step. This routine remove these points from   //</span>
<a name="l30948"></a>30948 <span class="comment">// points list. All existing points are reindexed.                           //</span>
<a name="l30949"></a>30949 <span class="comment">//                                                                           //</span>
<a name="l30951"></a>30951 <span class="comment"></span>
<a name="l30952"></a>30952 <span class="keywordtype">void</span> tetgenmesh::jettisonnodes()
<a name="l30953"></a>30953 {
<a name="l30954"></a>30954   point pointloop;
<a name="l30955"></a>30955   <span class="keywordtype">bool</span> jetflag;
<a name="l30956"></a>30956   <span class="keywordtype">int</span> oldidx, newidx;
<a name="l30957"></a>30957   <span class="keywordtype">int</span> remcount;
<a name="l30958"></a>30958 
<a name="l30959"></a>30959   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l30960"></a>30960     printf(<span class="stringliteral">&quot;Jettisoning redundants points.\n&quot;</span>);
<a name="l30961"></a>30961   }
<a name="l30962"></a>30962 
<a name="l30963"></a>30963   points-&gt;traversalinit();
<a name="l30964"></a>30964   pointloop = pointtraverse();
<a name="l30965"></a>30965   oldidx = newidx = 0; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l30966"></a>30966   remcount = 0;
<a name="l30967"></a>30967   <span class="keywordflow">while</span> (pointloop != (point) NULL) {
<a name="l30968"></a>30968     jetflag = (pointtype(pointloop) == DUPLICATEDVERTEX) ||
<a name="l30969"></a>30969       (pointtype(pointloop) == UNUSEDVERTEX);
<a name="l30970"></a>30970     <span class="keywordflow">if</span> (jetflag) {
<a name="l30971"></a>30971       <span class="comment">// It is a duplicated point, delete it.</span>
<a name="l30972"></a>30972       pointdealloc(pointloop);
<a name="l30973"></a>30973       remcount++;
<a name="l30974"></a>30974     } <span class="keywordflow">else</span> {
<a name="l30975"></a>30975       <span class="comment">// Re-index it.</span>
<a name="l30976"></a>30976       setpointmark(pointloop, newidx + in-&gt;firstnumber);
<a name="l30977"></a>30977       <span class="keywordflow">if</span> (in-&gt;pointmarkerlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l30978"></a>30978         <span class="keywordflow">if</span> (oldidx &lt; in-&gt;numberofpoints) {
<a name="l30979"></a>30979           <span class="comment">// Re-index the point marker as well.</span>
<a name="l30980"></a>30980           in-&gt;pointmarkerlist[newidx] = in-&gt;pointmarkerlist[oldidx];
<a name="l30981"></a>30981         }
<a name="l30982"></a>30982       }
<a name="l30983"></a>30983       newidx++;
<a name="l30984"></a>30984     }
<a name="l30985"></a>30985     oldidx++;
<a name="l30986"></a>30986     <span class="keywordflow">if</span> (oldidx == in-&gt;numberofpoints) {
<a name="l30987"></a>30987       <span class="comment">// Update the numbe of input points (Because some were removed).</span>
<a name="l30988"></a>30988       in-&gt;numberofpoints -= remcount;
<a name="l30989"></a>30989       <span class="comment">// Remember this number for output original input nodes.</span>
<a name="l30990"></a>30990       jettisoninverts = remcount;
<a name="l30991"></a>30991     }
<a name="l30992"></a>30992     pointloop = pointtraverse();
<a name="l30993"></a>30993   }
<a name="l30994"></a>30994   <span class="keywordflow">if</span> (b-&gt;verbose) {
<a name="l30995"></a>30995     printf(<span class="stringliteral">&quot;  %d duplicated vertices have been removed.\n&quot;</span>, dupverts);
<a name="l30996"></a>30996     printf(<span class="stringliteral">&quot;  %d unused vertices have been removed.\n&quot;</span>, unuverts);
<a name="l30997"></a>30997   }
<a name="l30998"></a>30998   dupverts = 0;
<a name="l30999"></a>30999   unuverts = 0;
<a name="l31000"></a>31000 
<a name="l31001"></a>31001   <span class="comment">// The following line ensures that dead items in the pool of nodes cannot</span>
<a name="l31002"></a>31002   <span class="comment">//   be allocated for the new created nodes. This ensures that the input</span>
<a name="l31003"></a>31003   <span class="comment">//   nodes will occur earlier in the output files, and have lower indices.</span>
<a name="l31004"></a>31004   points-&gt;deaditemstack = (<span class="keywordtype">void</span> *) NULL;
<a name="l31005"></a>31005 }
<a name="l31006"></a>31006 
<a name="l31008"></a>31008 <span class="comment">//                                                                           //</span>
<a name="l31009"></a>31009 <span class="comment">// highorder()   Create extra nodes for quadratic subparametric elements.    //</span>
<a name="l31010"></a>31010 <span class="comment">//                                                                           //</span>
<a name="l31011"></a>31011 <span class="comment">// &#39;highordertable&#39; is an array (size = numberoftetrahedra * 6) for storing  //</span>
<a name="l31012"></a>31012 <span class="comment">// high-order nodes of each tetrahedron.  This routine is used only when -o2 //</span>
<a name="l31013"></a>31013 <span class="comment">// switch is used.                                                           //</span>
<a name="l31014"></a>31014 <span class="comment">//                                                                           //</span>
<a name="l31016"></a>31016 <span class="comment"></span>
<a name="l31017"></a>31017 <span class="keywordtype">void</span> tetgenmesh::highorder()
<a name="l31018"></a>31018 {
<a name="l31019"></a>31019   triface tetloop, worktet;
<a name="l31020"></a>31020   triface spintet, adjtet;
<a name="l31021"></a>31021   point torg, tdest, tapex;
<a name="l31022"></a>31022   point *extralist, *adjextralist;
<a name="l31023"></a>31023   point newpoint;
<a name="l31024"></a>31024   <span class="keywordtype">int</span> hitbdry, ptmark;
<a name="l31025"></a>31025   <span class="keywordtype">int</span> i, j;
<a name="l31026"></a>31026 
<a name="l31027"></a>31027   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l31028"></a>31028     printf(<span class="stringliteral">&quot;Adding vertices for second-order tetrahedra.\n&quot;</span>);
<a name="l31029"></a>31029   }
<a name="l31030"></a>31030 
<a name="l31031"></a>31031   <span class="comment">// Initialize the &#39;highordertable&#39;.</span>
<a name="l31032"></a>31032   highordertable = <span class="keyword">new</span> point[tetrahedrons-&gt;items * 6];
<a name="l31033"></a>31033   <span class="keywordflow">if</span> (highordertable == (point *) NULL) {
<a name="l31034"></a>31034     printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31035"></a>31035     terminatetetgen(1);
<a name="l31036"></a>31036   }
<a name="l31037"></a>31037 
<a name="l31038"></a>31038   <span class="comment">// The following line ensures that dead items in the pool of nodes cannot</span>
<a name="l31039"></a>31039   <span class="comment">//   be allocated for the extra nodes associated with high order elements.</span>
<a name="l31040"></a>31040   <span class="comment">//   This ensures that the primary nodes (at the corners of elements) will</span>
<a name="l31041"></a>31041   <span class="comment">//   occur earlier in the output files, and have lower indices, than the</span>
<a name="l31042"></a>31042   <span class="comment">//   extra nodes.</span>
<a name="l31043"></a>31043   points-&gt;deaditemstack = (<span class="keywordtype">void</span> *) NULL;
<a name="l31044"></a>31044 
<a name="l31045"></a>31045   <span class="comment">// Assign an entry for each tetrahedron to find its extra nodes. At the</span>
<a name="l31046"></a>31046   <span class="comment">//   mean while, initialize all extra nodes be NULL.</span>
<a name="l31047"></a>31047   i = 0;
<a name="l31048"></a>31048   tetrahedrons-&gt;traversalinit();
<a name="l31049"></a>31049   tetloop.tet = tetrahedrontraverse();
<a name="l31050"></a>31050   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l31051"></a>31051     tetloop.tet[highorderindex] = (tetrahedron) &amp;highordertable[i];
<a name="l31052"></a>31052     <span class="keywordflow">for</span> (j = 0; j &lt; 6; j++) {
<a name="l31053"></a>31053       highordertable[i + j] = (point) NULL;
<a name="l31054"></a>31054     }
<a name="l31055"></a>31055     i += 6;
<a name="l31056"></a>31056     tetloop.tet = tetrahedrontraverse();
<a name="l31057"></a>31057   }
<a name="l31058"></a>31058 
<a name="l31059"></a>31059   <span class="comment">// To create a unique node on each edge. Loop over all tetrahedra, and</span>
<a name="l31060"></a>31060   <span class="comment">//   look at the six edges of each tetrahedron.  If the extra node in</span>
<a name="l31061"></a>31061   <span class="comment">//   the tetrahedron corresponding to this edge is NULL, create a node</span>
<a name="l31062"></a>31062   <span class="comment">//   for this edge, at the same time, set the new node into the extra</span>
<a name="l31063"></a>31063   <span class="comment">//   node lists of all other tetrahedra sharing this edge.</span>
<a name="l31064"></a>31064   tetrahedrons-&gt;traversalinit();
<a name="l31065"></a>31065   tetloop.tet = tetrahedrontraverse();
<a name="l31066"></a>31066   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l31067"></a>31067     <span class="comment">// Get the list of extra nodes.</span>
<a name="l31068"></a>31068     extralist = (point *) tetloop.tet[highorderindex];
<a name="l31069"></a>31069     worktet.tet = tetloop.tet;
<a name="l31070"></a>31070     for (i = 0; i &lt; 6; i++) {
<a name="l31071"></a>31071       <span class="keywordflow">if</span> (extralist[i] == (point) NULL) {
<a name="l31072"></a>31072         <span class="comment">// Operate on this edge.</span>
<a name="l31073"></a>31073         worktet.loc = edge2locver[i][0];
<a name="l31074"></a>31074         worktet.ver = edge2locver[i][1];
<a name="l31075"></a>31075         <span class="comment">// Create a new node on this edge.</span>
<a name="l31076"></a>31076         torg = org(worktet);
<a name="l31077"></a>31077         tdest = dest(worktet);
<a name="l31078"></a>31078         <span class="comment">// Create a new node in the middle of the edge.</span>
<a name="l31079"></a>31079         newpoint = (point) points-&gt;alloc();
<a name="l31080"></a>31080         <span class="comment">// Interpolate its attributes.</span>
<a name="l31081"></a>31081         <span class="keywordflow">for</span> (j = 0; j &lt; 3 + in-&gt;numberofpointattributes; j++) {
<a name="l31082"></a>31082           newpoint[j] = 0.5 * (torg[j] + tdest[j]);
<a name="l31083"></a>31083         }
<a name="l31084"></a>31084         ptmark = (int) points-&gt;items - (in-&gt;firstnumber == 1 ? 0 : 1);
<a name="l31085"></a>31085         setpointmark(newpoint, ptmark);
<a name="l31086"></a>31086         <span class="comment">// Add this node to its extra node list.</span>
<a name="l31087"></a>31087         extralist[i] = newpoint;
<a name="l31088"></a>31088         <span class="comment">// Set &#39;newpoint&#39; into extra node lists of other tetrahedra</span>
<a name="l31089"></a>31089         <span class="comment">//   sharing this edge.</span>
<a name="l31090"></a>31090         tapex = apex(worktet);
<a name="l31091"></a>31091         spintet = worktet;
<a name="l31092"></a>31092         hitbdry = 0;
<a name="l31093"></a>31093         <span class="keywordflow">while</span> (hitbdry &lt; 2) {
<a name="l31094"></a>31094           <span class="keywordflow">if</span> (fnextself(spintet)) {
<a name="l31095"></a>31095             <span class="comment">// Get the extra node list of &#39;spintet&#39;.</span>
<a name="l31096"></a>31096             adjextralist = (point *) spintet.tet[highorderindex];
<a name="l31097"></a>31097             <span class="comment">// Find the index of its extra node list.</span>
<a name="l31098"></a>31098             j = locver2edge[spintet.loc][spintet.ver];
<a name="l31099"></a>31099             <span class="comment">// Only set &#39;newpoint&#39; into &#39;adjextralist&#39; if it is a NULL.</span>
<a name="l31100"></a>31100             <span class="comment">//   Because two faces can belong to the same tetrahedron.</span>
<a name="l31101"></a>31101             if (adjextralist[j] == (point) NULL) {
<a name="l31102"></a>31102               adjextralist[j] = newpoint;
<a name="l31103"></a>31103             }
<a name="l31104"></a>31104             <span class="keywordflow">if</span> (apex(spintet) == tapex) {
<a name="l31105"></a>31105               <span class="keywordflow">break</span>;
<a name="l31106"></a>31106             }
<a name="l31107"></a>31107           } <span class="keywordflow">else</span> {
<a name="l31108"></a>31108             hitbdry++;
<a name="l31109"></a>31109             <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l31110"></a>31110               esym(worktet, spintet);
<a name="l31111"></a>31111         }
<a name="l31112"></a>31112           }
<a name="l31113"></a>31113         }
<a name="l31114"></a>31114       }
<a name="l31115"></a>31115     }
<a name="l31116"></a>31116     tetloop.tet = tetrahedrontraverse();
<a name="l31117"></a>31117   }
<a name="l31118"></a>31118 }
<a name="l31119"></a>31119 
<a name="l31121"></a>31121 <span class="comment">//                                                                           //</span>
<a name="l31122"></a>31122 <span class="comment">// outnodes()    Output the points to a .node file or a tetgenio structure.  //</span>
<a name="l31123"></a>31123 <span class="comment">//                                                                           //</span>
<a name="l31124"></a>31124 <span class="comment">// Note: each point has already been numbered on input (the first index is   //</span>
<a name="l31125"></a>31125 <span class="comment">// &#39;in-&gt;firstnumber&#39;).                                                       //</span>
<a name="l31126"></a>31126 <span class="comment">//                                                                           //</span>
<a name="l31128"></a>31128 <span class="comment"></span>
<a name="l31129"></a>31129 <span class="keywordtype">void</span> tetgenmesh::outnodes(tetgenio* out)
<a name="l31130"></a>31130 {
<a name="l31131"></a>31131   FILE *outfile;
<a name="l31132"></a>31132   <span class="keywordtype">char</span> outnodefilename[FILENAMESIZE];
<a name="l31133"></a>31133   shellface subptr;
<a name="l31134"></a>31134   triface adjtet;
<a name="l31135"></a>31135   face subloop;
<a name="l31136"></a>31136   point pointloop;
<a name="l31137"></a>31137   point *extralist, ep[3];
<a name="l31138"></a>31138   <span class="keywordtype">int</span> nextras, bmark, shmark, marker;
<a name="l31139"></a>31139   <span class="keywordtype">int</span> coordindex, attribindex;
<a name="l31140"></a>31140   <span class="keywordtype">int</span> pointnumber, firstindex;
<a name="l31141"></a>31141   <span class="keywordtype">int</span> index, i;
<a name="l31142"></a>31142 
<a name="l31143"></a>31143   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31144"></a>31144     strcpy(outnodefilename, b-&gt;outfilename);
<a name="l31145"></a>31145     strcat(outnodefilename, <span class="stringliteral">&quot;.node&quot;</span>);
<a name="l31146"></a>31146   }
<a name="l31147"></a>31147 
<a name="l31148"></a>31148   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l31149"></a>31149     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31150"></a>31150       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, outnodefilename);
<a name="l31151"></a>31151     } <span class="keywordflow">else</span> {
<a name="l31152"></a>31152       printf(<span class="stringliteral">&quot;Writing nodes.\n&quot;</span>);
<a name="l31153"></a>31153     }
<a name="l31154"></a>31154   }
<a name="l31155"></a>31155 
<a name="l31156"></a>31156   nextras = in-&gt;numberofpointattributes;
<a name="l31157"></a>31157   bmark = !b-&gt;nobound &amp;&amp; in-&gt;pointmarkerlist;
<a name="l31158"></a>31158 
<a name="l31159"></a>31159   <span class="comment">// Avoid compile warnings.</span>
<a name="l31160"></a>31160   outfile = (FILE *) NULL;
<a name="l31161"></a>31161   marker = coordindex = 0;
<a name="l31162"></a>31162 
<a name="l31163"></a>31163   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31164"></a>31164     outfile = fopen(outnodefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l31165"></a>31165     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l31166"></a>31166       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, outnodefilename);
<a name="l31167"></a>31167       terminatetetgen(1);
<a name="l31168"></a>31168     }
<a name="l31169"></a>31169     <span class="comment">// Number of points, number of dimensions, number of point attributes,</span>
<a name="l31170"></a>31170     <span class="comment">//   and number of boundary markers (zero or one).</span>
<a name="l31171"></a>31171     fprintf(outfile, <span class="stringliteral">&quot;%ld  %d  %d  %d\n&quot;</span>, points-&gt;items, 3, nextras, bmark);
<a name="l31172"></a>31172   } <span class="keywordflow">else</span> {
<a name="l31173"></a>31173     <span class="comment">// Allocate space for &#39;pointlist&#39;;</span>
<a name="l31174"></a>31174     out-&gt;pointlist = <span class="keyword">new</span> REAL[points-&gt;items * 3];
<a name="l31175"></a>31175     <span class="keywordflow">if</span> (out-&gt;pointlist == (REAL *) NULL) {
<a name="l31176"></a>31176       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31177"></a>31177       terminatetetgen(1);
<a name="l31178"></a>31178     }
<a name="l31179"></a>31179     <span class="comment">// Allocate space for &#39;pointattributelist&#39; if necessary;</span>
<a name="l31180"></a>31180     <span class="keywordflow">if</span> (nextras &gt; 0) {
<a name="l31181"></a>31181       out-&gt;pointattributelist = <span class="keyword">new</span> REAL[points-&gt;items * nextras];
<a name="l31182"></a>31182       <span class="keywordflow">if</span> (out-&gt;pointattributelist == (REAL *) NULL) {
<a name="l31183"></a>31183         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31184"></a>31184         terminatetetgen(1);
<a name="l31185"></a>31185       }
<a name="l31186"></a>31186     }
<a name="l31187"></a>31187     <span class="comment">// Allocate space for &#39;pointmarkerlist&#39; if necessary;</span>
<a name="l31188"></a>31188     <span class="keywordflow">if</span> (bmark) {
<a name="l31189"></a>31189       out-&gt;pointmarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items];
<a name="l31190"></a>31190       <span class="keywordflow">if</span> (out-&gt;pointmarkerlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31191"></a>31191         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31192"></a>31192         terminatetetgen(1);
<a name="l31193"></a>31193       }
<a name="l31194"></a>31194     }
<a name="l31195"></a>31195     out-&gt;numberofpoints = points-&gt;items;
<a name="l31196"></a>31196     out-&gt;numberofpointattributes = nextras;
<a name="l31197"></a>31197     coordindex = 0;
<a name="l31198"></a>31198     attribindex = 0;
<a name="l31199"></a>31199   }
<a name="l31200"></a>31200 
<a name="l31201"></a>31201   <span class="keywordflow">if</span> (bmark &amp;&amp; (b-&gt;plc || b-&gt;refine)) {
<a name="l31202"></a>31202     <span class="comment">// Initialize the point2tet field of each point.</span>
<a name="l31203"></a>31203     points-&gt;traversalinit();
<a name="l31204"></a>31204     pointloop = pointtraverse();
<a name="l31205"></a>31205     <span class="keywordflow">while</span> (pointloop != (point) NULL) {
<a name="l31206"></a>31206       setpoint2tet(pointloop, (tetrahedron) NULL);
<a name="l31207"></a>31207       pointloop = pointtraverse();
<a name="l31208"></a>31208     }
<a name="l31209"></a>31209     <span class="comment">// Make a map point-to-subface. Hence a boundary point will get the</span>
<a name="l31210"></a>31210     <span class="comment">//   facet marker from that facet where it lies on.</span>
<a name="l31211"></a>31211     subfaces-&gt;traversalinit();
<a name="l31212"></a>31212     subloop.sh = shellfacetraverse(subfaces);
<a name="l31213"></a>31213     <span class="keywordflow">while</span> (subloop.sh != (shellface *) NULL) {
<a name="l31214"></a>31214       subloop.shver = 0;
<a name="l31215"></a>31215       <span class="comment">// Check all three points of the subface.</span>
<a name="l31216"></a>31216       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l31217"></a>31217         pointloop = (point) subloop.sh[3 + i];
<a name="l31218"></a>31218         setpoint2tet(pointloop, (tetrahedron) sencode(subloop));
<a name="l31219"></a>31219       }
<a name="l31220"></a>31220       <span class="keywordflow">if</span> (b-&gt;order == 2) {
<a name="l31221"></a>31221         <span class="comment">// &#39;-o2&#39; switch. Set markers for quadratic nodes of this subface.</span>
<a name="l31222"></a>31222         stpivot(subloop, adjtet);
<a name="l31223"></a>31223         <span class="keywordflow">if</span> (adjtet.tet == dummytet) {
<a name="l31224"></a>31224           sesymself(subloop);
<a name="l31225"></a>31225           stpivot(subloop, adjtet);
<a name="l31226"></a>31226         }
<a name="l31227"></a>31227         assert(adjtet.tet != dummytet);
<a name="l31228"></a>31228         extralist = (point *) adjtet.tet[highorderindex];
<a name="l31229"></a>31229         switch (adjtet.loc) {
<a name="l31230"></a>31230         <span class="keywordflow">case</span> 0:
<a name="l31231"></a>31231           ep[0] = extralist[0];
<a name="l31232"></a>31232           ep[1] = extralist[1];
<a name="l31233"></a>31233           ep[2] = extralist[2];
<a name="l31234"></a>31234           <span class="keywordflow">break</span>;
<a name="l31235"></a>31235         <span class="keywordflow">case</span> 1:
<a name="l31236"></a>31236           ep[0] = extralist[0];
<a name="l31237"></a>31237           ep[1] = extralist[4];
<a name="l31238"></a>31238           ep[2] = extralist[3];
<a name="l31239"></a>31239           <span class="keywordflow">break</span>;
<a name="l31240"></a>31240         <span class="keywordflow">case</span> 2:
<a name="l31241"></a>31241           ep[0] = extralist[1];
<a name="l31242"></a>31242           ep[1] = extralist[5];
<a name="l31243"></a>31243           ep[2] = extralist[4];
<a name="l31244"></a>31244           <span class="keywordflow">break</span>;
<a name="l31245"></a>31245         <span class="keywordflow">case</span> 3:
<a name="l31246"></a>31246           ep[0] = extralist[2];
<a name="l31247"></a>31247           ep[1] = extralist[3];
<a name="l31248"></a>31248           ep[2] = extralist[5];
<a name="l31249"></a>31249           <span class="keywordflow">break</span>;
<a name="l31250"></a>31250         <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
<a name="l31251"></a>31251         }
<a name="l31252"></a>31252         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l31253"></a>31253           setpoint2tet(ep[i], (tetrahedron) sencode(subloop));
<a name="l31254"></a>31254         }
<a name="l31255"></a>31255       }
<a name="l31256"></a>31256       subloop.sh = shellfacetraverse(subfaces);
<a name="l31257"></a>31257     }
<a name="l31258"></a>31258   }
<a name="l31259"></a>31259 
<a name="l31260"></a>31260   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l31261"></a>31261   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l31262"></a>31262 
<a name="l31263"></a>31263   points-&gt;traversalinit();
<a name="l31264"></a>31264   pointloop = pointtraverse();
<a name="l31265"></a>31265   pointnumber = firstindex; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l31266"></a>31266   index = 0;
<a name="l31267"></a>31267   <span class="keywordflow">while</span> (pointloop != (point) NULL) {
<a name="l31268"></a>31268     <span class="keywordflow">if</span> (bmark) {
<a name="l31269"></a>31269       <span class="comment">// Default the vertex has a zero marker.</span>
<a name="l31270"></a>31270       marker = 0;
<a name="l31271"></a>31271       <span class="comment">// Is it an input vertex?</span>
<a name="l31272"></a>31272       <span class="keywordflow">if</span> (index &lt; in-&gt;numberofpoints) {
<a name="l31273"></a>31273         <span class="comment">// Input point&#39;s marker is directly copied to output.</span>
<a name="l31274"></a>31274         marker = in-&gt;pointmarkerlist[index];
<a name="l31275"></a>31275       }
<a name="l31276"></a>31276       <span class="comment">// Is it a boundary vertex has marker zero?</span>
<a name="l31277"></a>31277       <span class="keywordflow">if</span> ((marker == 0) &amp;&amp; (b-&gt;plc || b-&gt;refine)) {
<a name="l31278"></a>31278         subptr = (shellface) point2tet(pointloop);
<a name="l31279"></a>31279         <span class="keywordflow">if</span> (subptr != (shellface) NULL) {
<a name="l31280"></a>31280           <span class="comment">// Default a boundary vertex has marker 1.</span>
<a name="l31281"></a>31281           marker = 1;
<a name="l31282"></a>31282           <span class="keywordflow">if</span> (in-&gt;facetmarkerlist != (<span class="keywordtype">int</span> *) NULL) {
<a name="l31283"></a>31283             <span class="comment">// The vertex gets the marker from the facet it lies on.</span>
<a name="l31284"></a>31284             sdecode(subptr, subloop);
<a name="l31285"></a>31285             shmark = shellmark(subloop);
<a name="l31286"></a>31286             marker = in-&gt;facetmarkerlist[shmark - 1];
<a name="l31287"></a>31287           }
<a name="l31288"></a>31288         }
<a name="l31289"></a>31289       }
<a name="l31290"></a>31290     }
<a name="l31291"></a>31291     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31292"></a>31292       <span class="comment">// Point number, x, y and z coordinates.</span>
<a name="l31293"></a>31293       fprintf(outfile, <span class="stringliteral">&quot;%4d    %.17g  %.17g  %.17g&quot;</span>, pointnumber,
<a name="l31294"></a>31294               pointloop[0], pointloop[1], pointloop[2]);
<a name="l31295"></a>31295       <span class="keywordflow">for</span> (i = 0; i &lt; nextras; i++) {
<a name="l31296"></a>31296         <span class="comment">// Write an attribute.</span>
<a name="l31297"></a>31297         fprintf(outfile, <span class="stringliteral">&quot;  %.17g&quot;</span>, pointloop[3 + i]);
<a name="l31298"></a>31298       }
<a name="l31299"></a>31299       <span class="keywordflow">if</span> (bmark) {
<a name="l31300"></a>31300         <span class="comment">// Write the boundary marker.</span>
<a name="l31301"></a>31301         fprintf(outfile, <span class="stringliteral">&quot;    %d&quot;</span>, marker);
<a name="l31302"></a>31302       }
<a name="l31303"></a>31303       fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l31304"></a>31304     } <span class="keywordflow">else</span> {
<a name="l31305"></a>31305       <span class="comment">// X, y, and z coordinates.</span>
<a name="l31306"></a>31306       out-&gt;pointlist[coordindex++] = pointloop[0];
<a name="l31307"></a>31307       out-&gt;pointlist[coordindex++] = pointloop[1];
<a name="l31308"></a>31308       out-&gt;pointlist[coordindex++] = pointloop[2];
<a name="l31309"></a>31309       <span class="comment">// Point attributes.</span>
<a name="l31310"></a>31310       <span class="keywordflow">for</span> (i = 0; i &lt; nextras; i++) {
<a name="l31311"></a>31311         <span class="comment">// Output an attribute.</span>
<a name="l31312"></a>31312         out-&gt;pointattributelist[attribindex++] = pointloop[3 + i];
<a name="l31313"></a>31313       }
<a name="l31314"></a>31314       <span class="keywordflow">if</span> (bmark) {
<a name="l31315"></a>31315         <span class="comment">// Output the boundary marker.</span>
<a name="l31316"></a>31316         out-&gt;pointmarkerlist[index] = marker;
<a name="l31317"></a>31317       }
<a name="l31318"></a>31318     }
<a name="l31319"></a>31319     pointloop = pointtraverse();
<a name="l31320"></a>31320     pointnumber++;
<a name="l31321"></a>31321     index++;
<a name="l31322"></a>31322   }
<a name="l31323"></a>31323 
<a name="l31324"></a>31324   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31325"></a>31325     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l31326"></a>31326     fclose(outfile);
<a name="l31327"></a>31327   }
<a name="l31328"></a>31328 }
<a name="l31329"></a>31329 
<a name="l31331"></a>31331 <span class="comment">//                                                                           //</span>
<a name="l31332"></a>31332 <span class="comment">// outmetrics()    Output the metric to a file (*.mtr) or a tetgenio obj.    //</span>
<a name="l31333"></a>31333 <span class="comment">//                                                                           //</span>
<a name="l31335"></a>31335 <span class="comment"></span>
<a name="l31336"></a>31336 <span class="keywordtype">void</span> tetgenmesh::outmetrics(tetgenio* out)
<a name="l31337"></a>31337 {
<a name="l31338"></a>31338   FILE *outfile;
<a name="l31339"></a>31339   <span class="keywordtype">char</span> outmtrfilename[FILENAMESIZE];
<a name="l31340"></a>31340   list *tetlist, *ptlist;
<a name="l31341"></a>31341   triface tetloop;
<a name="l31342"></a>31342   point ptloop, neipt;
<a name="l31343"></a>31343   REAL lave, len; <span class="comment">// lmin, lmax,</span>
<a name="l31344"></a>31344   <span class="keywordtype">int</span> mtrindex;
<a name="l31345"></a>31345   <span class="keywordtype">int</span> i;
<a name="l31346"></a>31346 
<a name="l31347"></a>31347   lave = 0.0;
<a name="l31348"></a>31348 
<a name="l31349"></a>31349   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31350"></a>31350     strcpy(outmtrfilename, b-&gt;outfilename);
<a name="l31351"></a>31351     strcat(outmtrfilename, <span class="stringliteral">&quot;.mtr&quot;</span>);
<a name="l31352"></a>31352   }
<a name="l31353"></a>31353 
<a name="l31354"></a>31354   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l31355"></a>31355     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31356"></a>31356       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, outmtrfilename);
<a name="l31357"></a>31357     } <span class="keywordflow">else</span> {
<a name="l31358"></a>31358       printf(<span class="stringliteral">&quot;Writing metrics.\n&quot;</span>);
<a name="l31359"></a>31359     }
<a name="l31360"></a>31360   }
<a name="l31361"></a>31361 
<a name="l31362"></a>31362   <span class="comment">// Avoid compile warnings.</span>
<a name="l31363"></a>31363   outfile = (FILE *) NULL;
<a name="l31364"></a>31364   mtrindex = 0;
<a name="l31365"></a>31365 
<a name="l31366"></a>31366   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31367"></a>31367     outfile = fopen(outmtrfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l31368"></a>31368     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l31369"></a>31369       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, outmtrfilename);
<a name="l31370"></a>31370       terminatetetgen(1);
<a name="l31371"></a>31371     }
<a name="l31372"></a>31372     <span class="comment">// Number of points, number of point metrices,</span>
<a name="l31373"></a>31373     <span class="comment">// fprintf(outfile, &quot;%ld  %d\n&quot;, points-&gt;items, sizeoftensor + 3);</span>
<a name="l31374"></a>31374     fprintf(outfile, <span class="stringliteral">&quot;%ld  %d\n&quot;</span>, points-&gt;items, 1);
<a name="l31375"></a>31375   } <span class="keywordflow">else</span> {
<a name="l31376"></a>31376     <span class="comment">// Allocate space for &#39;pointmtrlist&#39; if necessary;</span>
<a name="l31377"></a>31377     <span class="comment">// out-&gt;pointmtrlist = new REAL[points-&gt;items * (sizeoftensor + 3)];</span>
<a name="l31378"></a>31378     out-&gt;pointmtrlist = <span class="keyword">new</span> REAL[points-&gt;items];
<a name="l31379"></a>31379     <span class="keywordflow">if</span> (out-&gt;pointmtrlist == (REAL *) NULL) {
<a name="l31380"></a>31380       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31381"></a>31381       terminatetetgen(1);
<a name="l31382"></a>31382     }
<a name="l31383"></a>31383     out-&gt;numberofpointmtrs = 1; <span class="comment">// (sizeoftensor + 3);</span>
<a name="l31384"></a>31384     mtrindex = 0;
<a name="l31385"></a>31385   }
<a name="l31386"></a>31386 
<a name="l31387"></a>31387   <span class="comment">// Initialize the point2tet field of each point.</span>
<a name="l31388"></a>31388   points-&gt;traversalinit();
<a name="l31389"></a>31389   ptloop = pointtraverse();
<a name="l31390"></a>31390   <span class="keywordflow">while</span> (ptloop != (point) NULL) {
<a name="l31391"></a>31391     setpoint2tet(ptloop, (tetrahedron) NULL);
<a name="l31392"></a>31392     ptloop = pointtraverse();
<a name="l31393"></a>31393   }
<a name="l31394"></a>31394   <span class="comment">// Create the point-to-tet map.</span>
<a name="l31395"></a>31395   tetrahedrons-&gt;traversalinit();
<a name="l31396"></a>31396   tetloop.tet = tetrahedrontraverse();
<a name="l31397"></a>31397   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l31398"></a>31398     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l31399"></a>31399       ptloop = (point) tetloop.tet[4 + i];
<a name="l31400"></a>31400       setpoint2tet(ptloop, encode(tetloop));
<a name="l31401"></a>31401     }
<a name="l31402"></a>31402     tetloop.tet = tetrahedrontraverse();
<a name="l31403"></a>31403   }
<a name="l31404"></a>31404 
<a name="l31405"></a>31405   tetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l31406"></a>31406   ptlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL, 256);
<a name="l31407"></a>31407 
<a name="l31408"></a>31408   points-&gt;traversalinit();
<a name="l31409"></a>31409   ptloop = pointtraverse();
<a name="l31410"></a>31410   <span class="keywordflow">while</span> (ptloop != (point) NULL) {
<a name="l31411"></a>31411     decode(point2tet(ptloop), tetloop);
<a name="l31412"></a>31412     <span class="keywordflow">if</span> (!isdead(&amp;tetloop)) {
<a name="l31413"></a>31413       <span class="comment">// Form the star of p.</span>
<a name="l31414"></a>31414       tetlist-&gt;append(&amp;tetloop);
<a name="l31415"></a>31415       formstarpolyhedron(ptloop, tetlist, ptlist, <span class="keyword">true</span>);
<a name="l31416"></a>31416       <span class="comment">// lmin = longest;</span>
<a name="l31417"></a>31417       <span class="comment">// lmax = 0.0;</span>
<a name="l31418"></a>31418       lave = 0.0;
<a name="l31419"></a>31419       <span class="keywordflow">for</span> (i = 0; i &lt; ptlist-&gt;len(); i++) {
<a name="l31420"></a>31420         neipt = * (point *)(* ptlist)[i];
<a name="l31421"></a>31421         len = distance(ptloop, neipt);
<a name="l31422"></a>31422         <span class="comment">// lmin = lmin &lt; len ? lmin : len;</span>
<a name="l31423"></a>31423         <span class="comment">// lmax = lmax &gt; len ? lmax : len;</span>
<a name="l31424"></a>31424         lave += len;
<a name="l31425"></a>31425       }
<a name="l31426"></a>31426       lave /= ptlist-&gt;len();
<a name="l31427"></a>31427     }
<a name="l31428"></a>31428     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31429"></a>31429       <span class="comment">// for (i = 0; i &lt; sizeoftensor; i++) {</span>
<a name="l31430"></a>31430       <span class="comment">//   fprintf(outfile, &quot;%-16.8e &quot;, ptloop[pointmtrindex + i]);</span>
<a name="l31431"></a>31431       <span class="comment">// }</span>
<a name="l31432"></a>31432       <span class="keywordflow">if</span> (ptlist-&gt;len() &gt; 0) {
<a name="l31433"></a>31433         <span class="comment">// fprintf(outfile, &quot;%-16.8e %-16.8e %-16.8e&quot;, lmin, lmax, lave);</span>
<a name="l31434"></a>31434         fprintf(outfile, <span class="stringliteral">&quot;%-16.8e &quot;</span>, lave);
<a name="l31435"></a>31435       } <span class="keywordflow">else</span> {
<a name="l31436"></a>31436         fprintf(outfile, <span class="stringliteral">&quot;0.0 &quot;</span>); <span class="comment">// fprintf(outfile, &quot;0.0  0.0  0.0&quot;);</span>
<a name="l31437"></a>31437       }
<a name="l31438"></a>31438       fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l31439"></a>31439     } <span class="keywordflow">else</span> {
<a name="l31440"></a>31440       <span class="comment">// for (i = 0; i &lt; sizeoftensor; i++) {</span>
<a name="l31441"></a>31441       <span class="comment">//   out-&gt;pointmtrlist[mtrindex++] = ptloop[pointmtrindex + i];</span>
<a name="l31442"></a>31442       <span class="comment">// }</span>
<a name="l31443"></a>31443       <span class="keywordflow">if</span> (ptlist-&gt;len() &gt; 0) {
<a name="l31444"></a>31444         <span class="comment">// out-&gt;pointmtrlist[mtrindex++] = lmin;</span>
<a name="l31445"></a>31445         <span class="comment">// out-&gt;pointmtrlist[mtrindex++] = lmax;</span>
<a name="l31446"></a>31446         out-&gt;pointmtrlist[mtrindex++] = lave;
<a name="l31447"></a>31447       } <span class="keywordflow">else</span> {
<a name="l31448"></a>31448         <span class="comment">// out-&gt;pointmtrlist[mtrindex++] = 0.0;</span>
<a name="l31449"></a>31449         <span class="comment">// out-&gt;pointmtrlist[mtrindex++] = 0.0;</span>
<a name="l31450"></a>31450         out-&gt;pointmtrlist[mtrindex++] = 0.0;
<a name="l31451"></a>31451       }
<a name="l31452"></a>31452     }
<a name="l31453"></a>31453     tetlist-&gt;clear();
<a name="l31454"></a>31454     ptlist-&gt;clear();
<a name="l31455"></a>31455     ptloop = pointtraverse();
<a name="l31456"></a>31456   }
<a name="l31457"></a>31457 
<a name="l31458"></a>31458   <span class="keyword">delete</span> tetlist;
<a name="l31459"></a>31459   <span class="keyword">delete</span> ptlist;
<a name="l31460"></a>31460 
<a name="l31461"></a>31461   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31462"></a>31462     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l31463"></a>31463     fclose(outfile);
<a name="l31464"></a>31464   }
<a name="l31465"></a>31465 }
<a name="l31466"></a>31466 
<a name="l31468"></a>31468 <span class="comment">//                                                                           //</span>
<a name="l31469"></a>31469 <span class="comment">// outelements()    Output the tetrahedra to an .ele file or a tetgenio      //</span>
<a name="l31470"></a>31470 <span class="comment">//                  structure.                                               //</span>
<a name="l31471"></a>31471 <span class="comment">//                                                                           //</span>
<a name="l31473"></a>31473 <span class="comment"></span>
<a name="l31474"></a>31474 <span class="keywordtype">void</span> tetgenmesh::outelements(tetgenio* out)
<a name="l31475"></a>31475 {
<a name="l31476"></a>31476   FILE *outfile;
<a name="l31477"></a>31477   <span class="keywordtype">char</span> outelefilename[FILENAMESIZE];
<a name="l31478"></a>31478   tetrahedron* tptr;
<a name="l31479"></a>31479   <span class="keywordtype">int</span> *tlist;
<a name="l31480"></a>31480   REAL *talist;
<a name="l31481"></a>31481   <span class="keywordtype">int</span> firstindex, shift;
<a name="l31482"></a>31482   <span class="keywordtype">int</span> pointindex;
<a name="l31483"></a>31483   <span class="keywordtype">int</span> attribindex;
<a name="l31484"></a>31484   point p1, p2, p3, p4;
<a name="l31485"></a>31485   point *extralist;
<a name="l31486"></a>31486   <span class="keywordtype">int</span> elementnumber;
<a name="l31487"></a>31487   <span class="keywordtype">int</span> eextras;
<a name="l31488"></a>31488   <span class="keywordtype">int</span> i;
<a name="l31489"></a>31489 
<a name="l31490"></a>31490   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31491"></a>31491     strcpy(outelefilename, b-&gt;outfilename);
<a name="l31492"></a>31492     strcat(outelefilename, <span class="stringliteral">&quot;.ele&quot;</span>);
<a name="l31493"></a>31493   }
<a name="l31494"></a>31494 
<a name="l31495"></a>31495   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l31496"></a>31496     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31497"></a>31497       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, outelefilename);
<a name="l31498"></a>31498     } <span class="keywordflow">else</span> {
<a name="l31499"></a>31499       printf(<span class="stringliteral">&quot;Writing elements.\n&quot;</span>);
<a name="l31500"></a>31500     }
<a name="l31501"></a>31501   }
<a name="l31502"></a>31502 
<a name="l31503"></a>31503   <span class="comment">// Avoid compile warnings.</span>
<a name="l31504"></a>31504   outfile = (FILE *) NULL;
<a name="l31505"></a>31505   tlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l31506"></a>31506   talist = (<span class="keywordtype">double</span> *) NULL;
<a name="l31507"></a>31507   pointindex = attribindex = 0;
<a name="l31508"></a>31508 
<a name="l31509"></a>31509   eextras = in-&gt;numberoftetrahedronattributes;
<a name="l31510"></a>31510   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31511"></a>31511     outfile = fopen(outelefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l31512"></a>31512     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l31513"></a>31513       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, outelefilename);
<a name="l31514"></a>31514       terminatetetgen(1);
<a name="l31515"></a>31515     }
<a name="l31516"></a>31516     <span class="comment">// Number of tetras, points per tetra, attributes per tetra.</span>
<a name="l31517"></a>31517     fprintf(outfile, <span class="stringliteral">&quot;%ld  %d  %d\n&quot;</span>, tetrahedrons-&gt;items,
<a name="l31518"></a>31518             b-&gt;order == 1 ? 4 : 10, eextras);
<a name="l31519"></a>31519   } <span class="keywordflow">else</span> {
<a name="l31520"></a>31520     <span class="comment">// Allocate memory for output tetrahedra.</span>
<a name="l31521"></a>31521     out-&gt;tetrahedronlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[tetrahedrons-&gt;items *
<a name="l31522"></a>31522                                    (b-&gt;order == 1 ? 4 : 10)];
<a name="l31523"></a>31523     <span class="keywordflow">if</span> (out-&gt;tetrahedronlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31524"></a>31524       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31525"></a>31525       terminatetetgen(1);
<a name="l31526"></a>31526     }
<a name="l31527"></a>31527     <span class="comment">// Allocate memory for output tetrahedron attributes if necessary.</span>
<a name="l31528"></a>31528     <span class="keywordflow">if</span> (eextras &gt; 0) {
<a name="l31529"></a>31529       out-&gt;tetrahedronattributelist = <span class="keyword">new</span> REAL[tetrahedrons-&gt;items * eextras];
<a name="l31530"></a>31530       <span class="keywordflow">if</span> (out-&gt;tetrahedronattributelist == (REAL *) NULL) {
<a name="l31531"></a>31531         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31532"></a>31532         terminatetetgen(1);
<a name="l31533"></a>31533       }
<a name="l31534"></a>31534     }
<a name="l31535"></a>31535     out-&gt;numberoftetrahedra = tetrahedrons-&gt;items;
<a name="l31536"></a>31536     out-&gt;numberofcorners = b-&gt;order == 1 ? 4 : 10;
<a name="l31537"></a>31537     out-&gt;numberoftetrahedronattributes = eextras;
<a name="l31538"></a>31538     tlist = out-&gt;tetrahedronlist;
<a name="l31539"></a>31539     talist = out-&gt;tetrahedronattributelist;
<a name="l31540"></a>31540     pointindex = 0;
<a name="l31541"></a>31541     attribindex = 0;
<a name="l31542"></a>31542   }
<a name="l31543"></a>31543 
<a name="l31544"></a>31544   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l31545"></a>31545   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l31546"></a>31546   shift = 0; <span class="comment">// Default no shiftment.</span>
<a name="l31547"></a>31547   <span class="keywordflow">if</span> ((in-&gt;firstnumber == 1) &amp;&amp; (firstindex == 0)) {
<a name="l31548"></a>31548     shift = 1; <span class="comment">// Shift the output indices by 1.</span>
<a name="l31549"></a>31549   }
<a name="l31550"></a>31550 
<a name="l31551"></a>31551   tetrahedrons-&gt;traversalinit();
<a name="l31552"></a>31552   tptr = tetrahedrontraverse();
<a name="l31553"></a>31553   elementnumber = firstindex; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l31554"></a>31554   <span class="keywordflow">while</span> (tptr != (tetrahedron *) NULL) {
<a name="l31555"></a>31555     p1 = (point) tptr[4];
<a name="l31556"></a>31556     p2 = (point) tptr[5];
<a name="l31557"></a>31557     p3 = (point) tptr[6];
<a name="l31558"></a>31558     p4 = (point) tptr[7];
<a name="l31559"></a>31559     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31560"></a>31560       <span class="comment">// Tetrahedron number, indices for four points.</span>
<a name="l31561"></a>31561       fprintf(outfile, <span class="stringliteral">&quot;%5d   %5d %5d %5d %5d&quot;</span>, elementnumber,
<a name="l31562"></a>31562               pointmark(p1) - shift, pointmark(p2) - shift,
<a name="l31563"></a>31563               pointmark(p3) - shift, pointmark(p4) - shift);
<a name="l31564"></a>31564       <span class="keywordflow">if</span> (b-&gt;order == 2) {
<a name="l31565"></a>31565         extralist = (point *) tptr[highorderindex];
<a name="l31566"></a>31566         <span class="comment">// Tetrahedron number, indices for four points plus six extra points.</span>
<a name="l31567"></a>31567         fprintf(outfile, <span class="stringliteral">&quot;  %5d %5d %5d %5d %5d %5d&quot;</span>,
<a name="l31568"></a>31568           pointmark(extralist[0]) - shift, pointmark(extralist[1]) - shift,
<a name="l31569"></a>31569           pointmark(extralist[2]) - shift, pointmark(extralist[3]) - shift,
<a name="l31570"></a>31570           pointmark(extralist[4]) - shift, pointmark(extralist[5]) - shift);
<a name="l31571"></a>31571       }
<a name="l31572"></a>31572       <span class="keywordflow">for</span> (i = 0; i &lt; eextras; i++) {
<a name="l31573"></a>31573         fprintf(outfile, <span class="stringliteral">&quot;    %.17g&quot;</span>, elemattribute(tptr, i));
<a name="l31574"></a>31574       }
<a name="l31575"></a>31575       fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l31576"></a>31576     } <span class="keywordflow">else</span> {
<a name="l31577"></a>31577       tlist[pointindex++] = pointmark(p1) - shift;
<a name="l31578"></a>31578       tlist[pointindex++] = pointmark(p2) - shift;
<a name="l31579"></a>31579       tlist[pointindex++] = pointmark(p3) - shift;
<a name="l31580"></a>31580       tlist[pointindex++] = pointmark(p4) - shift;
<a name="l31581"></a>31581       <span class="keywordflow">if</span> (b-&gt;order == 2) {
<a name="l31582"></a>31582         extralist = (point *) tptr[highorderindex];
<a name="l31583"></a>31583         tlist[pointindex++] = pointmark(extralist[0]) - shift;
<a name="l31584"></a>31584         tlist[pointindex++] = pointmark(extralist[1]) - shift;
<a name="l31585"></a>31585         tlist[pointindex++] = pointmark(extralist[2]) - shift;
<a name="l31586"></a>31586         tlist[pointindex++] = pointmark(extralist[3]) - shift;
<a name="l31587"></a>31587         tlist[pointindex++] = pointmark(extralist[4]) - shift;
<a name="l31588"></a>31588         tlist[pointindex++] = pointmark(extralist[5]) - shift;
<a name="l31589"></a>31589       }
<a name="l31590"></a>31590       <span class="keywordflow">for</span> (i = 0; i &lt; eextras; i++) {
<a name="l31591"></a>31591         talist[attribindex++] = elemattribute(tptr, i);
<a name="l31592"></a>31592       }
<a name="l31593"></a>31593     }
<a name="l31594"></a>31594     <span class="keywordflow">if</span> (b-&gt;neighout) {
<a name="l31595"></a>31595       <span class="comment">// Remember the index of this element.</span>
<a name="l31596"></a>31596       * (<span class="keywordtype">int</span> *) (tptr + elemmarkerindex) = elementnumber;
<a name="l31597"></a>31597     }
<a name="l31598"></a>31598     tptr = tetrahedrontraverse();
<a name="l31599"></a>31599     elementnumber++;
<a name="l31600"></a>31600   }
<a name="l31601"></a>31601   <span class="keywordflow">if</span> (b-&gt;neighout) {
<a name="l31602"></a>31602     <span class="comment">// Set the outside element marker.</span>
<a name="l31603"></a>31603     * (<span class="keywordtype">int</span> *) (dummytet + elemmarkerindex) = -1;
<a name="l31604"></a>31604   }
<a name="l31605"></a>31605 
<a name="l31606"></a>31606   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31607"></a>31607     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l31608"></a>31608     fclose(outfile);
<a name="l31609"></a>31609   }
<a name="l31610"></a>31610 }
<a name="l31611"></a>31611 
<a name="l31613"></a>31613 <span class="comment">//                                                                           //</span>
<a name="l31614"></a>31614 <span class="comment">// outfaces()    Output all faces to a .face file or a tetgenio structure.   //</span>
<a name="l31615"></a>31615 <span class="comment">//                                                                           //</span>
<a name="l31616"></a>31616 <span class="comment">// This routines outputs all triangular faces (including outer boundary      //</span>
<a name="l31617"></a>31617 <span class="comment">// faces and inner faces) of this mesh.                                      //</span>
<a name="l31618"></a>31618 <span class="comment">//                                                                           //</span>
<a name="l31620"></a>31620 <span class="comment"></span>
<a name="l31621"></a>31621 <span class="keywordtype">void</span> tetgenmesh::outfaces(tetgenio* out)
<a name="l31622"></a>31622 {
<a name="l31623"></a>31623   FILE *outfile;
<a name="l31624"></a>31624   <span class="keywordtype">char</span> facefilename[FILENAMESIZE];
<a name="l31625"></a>31625   <span class="keywordtype">int</span> *elist;
<a name="l31626"></a>31626   <span class="keywordtype">int</span> *emlist;
<a name="l31627"></a>31627   <span class="keywordtype">int</span> neigh1, neigh2;
<a name="l31628"></a>31628   <span class="keywordtype">int</span> index;
<a name="l31629"></a>31629   triface tface, tsymface;
<a name="l31630"></a>31630   face checkmark;
<a name="l31631"></a>31631   point torg, tdest, tapex;
<a name="l31632"></a>31632   <span class="keywordtype">long</span> faces;
<a name="l31633"></a>31633   <span class="keywordtype">int</span> bmark, faceid, marker;
<a name="l31634"></a>31634   <span class="keywordtype">int</span> firstindex, shift;
<a name="l31635"></a>31635   <span class="keywordtype">int</span> facenumber;
<a name="l31636"></a>31636 
<a name="l31637"></a>31637   neigh1 = 0;
<a name="l31638"></a>31638   neigh2 = 0;
<a name="l31639"></a>31639 
<a name="l31640"></a>31640   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31641"></a>31641     strcpy(facefilename, b-&gt;outfilename);
<a name="l31642"></a>31642     strcat(facefilename, <span class="stringliteral">&quot;.face&quot;</span>);
<a name="l31643"></a>31643   }
<a name="l31644"></a>31644 
<a name="l31645"></a>31645   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l31646"></a>31646     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31647"></a>31647       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, facefilename);
<a name="l31648"></a>31648     } <span class="keywordflow">else</span> {
<a name="l31649"></a>31649       printf(<span class="stringliteral">&quot;Writing faces.\n&quot;</span>);
<a name="l31650"></a>31650     }
<a name="l31651"></a>31651   }
<a name="l31652"></a>31652 
<a name="l31653"></a>31653   <span class="comment">// Avoid compile warnings.</span>
<a name="l31654"></a>31654   outfile = (FILE *) NULL;
<a name="l31655"></a>31655   elist = (<span class="keywordtype">int</span> *) NULL;
<a name="l31656"></a>31656   emlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l31657"></a>31657   index =  marker = 0;
<a name="l31658"></a>31658 
<a name="l31659"></a>31659   faces = (4l * tetrahedrons-&gt;items + hullsize) / 2l;
<a name="l31660"></a>31660   bmark = !b-&gt;nobound &amp;&amp; in-&gt;facetmarkerlist;
<a name="l31661"></a>31661 
<a name="l31662"></a>31662   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31663"></a>31663     outfile = fopen(facefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l31664"></a>31664     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l31665"></a>31665       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, facefilename);
<a name="l31666"></a>31666       terminatetetgen(1);
<a name="l31667"></a>31667     }
<a name="l31668"></a>31668     fprintf(outfile, <span class="stringliteral">&quot;%ld  %d\n&quot;</span>, faces, bmark);
<a name="l31669"></a>31669   } <span class="keywordflow">else</span> {
<a name="l31670"></a>31670     <span class="comment">// Allocate memory for &#39;trifacelist&#39;.</span>
<a name="l31671"></a>31671     out-&gt;trifacelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[faces * 3];
<a name="l31672"></a>31672     <span class="keywordflow">if</span> (out-&gt;trifacelist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31673"></a>31673       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31674"></a>31674       terminatetetgen(1);
<a name="l31675"></a>31675     }
<a name="l31676"></a>31676     <span class="comment">// Allocate memory for &#39;trifacemarkerlist&#39; if necessary.</span>
<a name="l31677"></a>31677     <span class="keywordflow">if</span> (bmark) {
<a name="l31678"></a>31678       out-&gt;trifacemarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[faces];
<a name="l31679"></a>31679       <span class="keywordflow">if</span> (out-&gt;trifacemarkerlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31680"></a>31680         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31681"></a>31681         terminatetetgen(1);
<a name="l31682"></a>31682       }
<a name="l31683"></a>31683     }
<a name="l31684"></a>31684     <span class="keywordflow">if</span> (b-&gt;neighout &gt; 1) {
<a name="l31685"></a>31685       <span class="comment">// &#39;-nn&#39; switch.</span>
<a name="l31686"></a>31686       out-&gt;adjtetlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[subfaces-&gt;items * 2];
<a name="l31687"></a>31687       <span class="keywordflow">if</span> (out-&gt;adjtetlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31688"></a>31688         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31689"></a>31689         terminatetetgen(1);
<a name="l31690"></a>31690       }
<a name="l31691"></a>31691     }
<a name="l31692"></a>31692     out-&gt;numberoftrifaces = faces;
<a name="l31693"></a>31693     elist = out-&gt;trifacelist;
<a name="l31694"></a>31694     emlist = out-&gt;trifacemarkerlist;
<a name="l31695"></a>31695     index = 0;
<a name="l31696"></a>31696   }
<a name="l31697"></a>31697 
<a name="l31698"></a>31698   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l31699"></a>31699   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l31700"></a>31700   shift = 0; <span class="comment">// Default no shiftment.</span>
<a name="l31701"></a>31701   <span class="keywordflow">if</span> ((in-&gt;firstnumber == 1) &amp;&amp; (firstindex == 0)) {
<a name="l31702"></a>31702     shift = 1; <span class="comment">// Shift the output indices by 1.</span>
<a name="l31703"></a>31703   }
<a name="l31704"></a>31704 
<a name="l31705"></a>31705   tetrahedrons-&gt;traversalinit();
<a name="l31706"></a>31706   tface.tet = tetrahedrontraverse();
<a name="l31707"></a>31707   facenumber = firstindex; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l31708"></a>31708   <span class="comment">// To loop over the set of faces, loop over all tetrahedra, and look at</span>
<a name="l31709"></a>31709   <span class="comment">//   the four faces of each one. If there isn&#39;t another tetrahedron</span>
<a name="l31710"></a>31710   <span class="comment">//   adjacent to this face, operate on the face.  If there is another</span>
<a name="l31711"></a>31711   <span class="comment">//   adjacent tetrahedron, operate on the face only if the current</span>
<a name="l31712"></a>31712   <span class="comment">//   tetrahedron has a smaller pointer than its neighbor.  This way, each</span>
<a name="l31713"></a>31713   <span class="comment">//   face is considered only once.</span>
<a name="l31714"></a>31714   <span class="keywordflow">while</span> (tface.tet != (tetrahedron *) NULL) {
<a name="l31715"></a>31715     <span class="keywordflow">for</span> (tface.loc = 0; tface.loc &lt; 4; tface.loc ++) {
<a name="l31716"></a>31716       sym(tface, tsymface);
<a name="l31717"></a>31717       <span class="keywordflow">if</span> ((tsymface.tet == dummytet) || (tface.tet &lt; tsymface.tet)) {
<a name="l31718"></a>31718         torg = org(tface);
<a name="l31719"></a>31719         tdest = dest(tface);
<a name="l31720"></a>31720         tapex = apex(tface);
<a name="l31721"></a>31721         <span class="keywordflow">if</span> (bmark) {
<a name="l31722"></a>31722           <span class="comment">// Get the boundary marker of this face. If it is an inner face,</span>
<a name="l31723"></a>31723           <span class="comment">//   it has no boundary marker, set it be zero.</span>
<a name="l31724"></a>31724           <span class="keywordflow">if</span> (b-&gt;useshelles) {
<a name="l31725"></a>31725             <span class="comment">// Shell face is used.</span>
<a name="l31726"></a>31726             tspivot(tface, checkmark);
<a name="l31727"></a>31727             <span class="keywordflow">if</span> (checkmark.sh == dummysh) {
<a name="l31728"></a>31728               marker = 0;  <span class="comment">// It is an inner face.</span>
<a name="l31729"></a>31729             } <span class="keywordflow">else</span> {
<a name="l31730"></a>31730               faceid = shellmark(checkmark) - 1;
<a name="l31731"></a>31731               marker = in-&gt;facetmarkerlist[faceid];
<a name="l31732"></a>31732             }
<a name="l31733"></a>31733           } <span class="keywordflow">else</span> {
<a name="l31734"></a>31734             <span class="comment">// Shell face is not used, only distinguish outer and inner face.</span>
<a name="l31735"></a>31735             marker = tsymface.tet != dummytet ? 1 : 0;
<a name="l31736"></a>31736           }
<a name="l31737"></a>31737         }
<a name="l31738"></a>31738         <span class="keywordflow">if</span> (b-&gt;neighout &gt; 1) {
<a name="l31739"></a>31739           <span class="comment">// &#39;-nn&#39; switch. Output adjacent tets indices.</span>
<a name="l31740"></a>31740           neigh1 = * (<span class="keywordtype">int</span> *)(tface.tet + elemmarkerindex);
<a name="l31741"></a>31741           <span class="keywordflow">if</span> (tsymface.tet != dummytet) {
<a name="l31742"></a>31742             neigh2 = * (<span class="keywordtype">int</span> *)(tsymface.tet + elemmarkerindex);
<a name="l31743"></a>31743           } <span class="keywordflow">else</span> {
<a name="l31744"></a>31744             neigh2 = -1;
<a name="l31745"></a>31745           }
<a name="l31746"></a>31746         }
<a name="l31747"></a>31747         <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31748"></a>31748           <span class="comment">// Face number, indices of three vertices.</span>
<a name="l31749"></a>31749           fprintf(outfile, <span class="stringliteral">&quot;%5d   %4d  %4d  %4d&quot;</span>, facenumber,
<a name="l31750"></a>31750                   pointmark(torg) - shift, pointmark(tdest) - shift,
<a name="l31751"></a>31751                   pointmark(tapex) - shift);
<a name="l31752"></a>31752           <span class="keywordflow">if</span> (bmark) {
<a name="l31753"></a>31753             <span class="comment">// Output a boundary marker.</span>
<a name="l31754"></a>31754             fprintf(outfile, <span class="stringliteral">&quot;  %d&quot;</span>, marker);
<a name="l31755"></a>31755           }
<a name="l31756"></a>31756           <span class="keywordflow">if</span> (b-&gt;neighout &gt; 1) {
<a name="l31757"></a>31757             fprintf(outfile, <span class="stringliteral">&quot;    %5d  %5d&quot;</span>, neigh1, neigh2);
<a name="l31758"></a>31758           }
<a name="l31759"></a>31759           fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l31760"></a>31760         } <span class="keywordflow">else</span> {
<a name="l31761"></a>31761           <span class="comment">// Output indices of three vertices.</span>
<a name="l31762"></a>31762           elist[index++] = pointmark(torg) - shift;
<a name="l31763"></a>31763           elist[index++] = pointmark(tdest) - shift;
<a name="l31764"></a>31764           elist[index++] = pointmark(tapex) - shift;
<a name="l31765"></a>31765           <span class="keywordflow">if</span> (bmark) {
<a name="l31766"></a>31766             emlist[facenumber - in-&gt;firstnumber] = marker;
<a name="l31767"></a>31767           }
<a name="l31768"></a>31768           <span class="keywordflow">if</span> (b-&gt;neighout &gt; 1) {
<a name="l31769"></a>31769             out-&gt;adjtetlist[(facenumber - in-&gt;firstnumber) * 2]     = neigh1;
<a name="l31770"></a>31770             out-&gt;adjtetlist[(facenumber - in-&gt;firstnumber) * 2 + 1] = neigh2;
<a name="l31771"></a>31771           }
<a name="l31772"></a>31772         }
<a name="l31773"></a>31773         facenumber++;
<a name="l31774"></a>31774       }
<a name="l31775"></a>31775     }
<a name="l31776"></a>31776     tface.tet = tetrahedrontraverse();
<a name="l31777"></a>31777   }
<a name="l31778"></a>31778 
<a name="l31779"></a>31779   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31780"></a>31780     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l31781"></a>31781     fclose(outfile);
<a name="l31782"></a>31782   }
<a name="l31783"></a>31783 }
<a name="l31784"></a>31784 
<a name="l31786"></a>31786 <span class="comment">//                                                                           //</span>
<a name="l31787"></a>31787 <span class="comment">// outhullfaces()    Output outer boundary faces to a .face file or a        //</span>
<a name="l31788"></a>31788 <span class="comment">//                   tetgenio structure.                                     //</span>
<a name="l31789"></a>31789 <span class="comment">//                                                                           //</span>
<a name="l31790"></a>31790 <span class="comment">// The normal of each face is arranged to point inside of the domain (use    //</span>
<a name="l31791"></a>31791 <span class="comment">// right-hand rule).  This routines will outputs convex hull faces if the    //</span>
<a name="l31792"></a>31792 <span class="comment">// mesh is a Delaunay tetrahedralization.                                    //</span>
<a name="l31793"></a>31793 <span class="comment">//                                                                           //</span>
<a name="l31795"></a>31795 <span class="comment"></span>
<a name="l31796"></a>31796 <span class="keywordtype">void</span> tetgenmesh::outhullfaces(tetgenio* out)
<a name="l31797"></a>31797 {
<a name="l31798"></a>31798   FILE *outfile;
<a name="l31799"></a>31799   <span class="keywordtype">char</span> facefilename[FILENAMESIZE];
<a name="l31800"></a>31800   <span class="keywordtype">int</span> *elist;
<a name="l31801"></a>31801   <span class="keywordtype">int</span> index;
<a name="l31802"></a>31802   triface tface, tsymface;
<a name="l31803"></a>31803   face checkmark;
<a name="l31804"></a>31804   point torg, tdest, tapex;
<a name="l31805"></a>31805   <span class="keywordtype">int</span> firstindex, shift;
<a name="l31806"></a>31806   <span class="keywordtype">int</span> facenumber;
<a name="l31807"></a>31807 
<a name="l31808"></a>31808   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31809"></a>31809     strcpy(facefilename, b-&gt;outfilename);
<a name="l31810"></a>31810     strcat(facefilename, <span class="stringliteral">&quot;.face&quot;</span>);
<a name="l31811"></a>31811   }
<a name="l31812"></a>31812 
<a name="l31813"></a>31813   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l31814"></a>31814     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31815"></a>31815       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, facefilename);
<a name="l31816"></a>31816     } <span class="keywordflow">else</span> {
<a name="l31817"></a>31817       printf(<span class="stringliteral">&quot;Writing faces.\n&quot;</span>);
<a name="l31818"></a>31818     }
<a name="l31819"></a>31819   }
<a name="l31820"></a>31820 
<a name="l31821"></a>31821   <span class="comment">// Avoid compile warnings.</span>
<a name="l31822"></a>31822   outfile = (FILE *) NULL;
<a name="l31823"></a>31823   elist = (<span class="keywordtype">int</span> *) NULL;
<a name="l31824"></a>31824   index = 0;
<a name="l31825"></a>31825 
<a name="l31826"></a>31826   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31827"></a>31827     outfile = fopen(facefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l31828"></a>31828     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l31829"></a>31829       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, facefilename);
<a name="l31830"></a>31830       terminatetetgen(1);
<a name="l31831"></a>31831     }
<a name="l31832"></a>31832     fprintf(outfile, <span class="stringliteral">&quot;%ld  0\n&quot;</span>, hullsize);
<a name="l31833"></a>31833   } <span class="keywordflow">else</span> {
<a name="l31834"></a>31834     <span class="comment">// Allocate memory for &#39;trifacelist&#39;.</span>
<a name="l31835"></a>31835     out-&gt;trifacelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[hullsize * 3];
<a name="l31836"></a>31836     <span class="keywordflow">if</span> (out-&gt;trifacelist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31837"></a>31837       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31838"></a>31838       terminatetetgen(1);
<a name="l31839"></a>31839     }
<a name="l31840"></a>31840     out-&gt;numberoftrifaces = hullsize;
<a name="l31841"></a>31841     elist = out-&gt;trifacelist;
<a name="l31842"></a>31842     index = 0;
<a name="l31843"></a>31843   }
<a name="l31844"></a>31844 
<a name="l31845"></a>31845   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l31846"></a>31846   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l31847"></a>31847   shift = 0; <span class="comment">// Default no shiftment.</span>
<a name="l31848"></a>31848   <span class="keywordflow">if</span> ((in-&gt;firstnumber == 1) &amp;&amp; (firstindex == 0)) {
<a name="l31849"></a>31849     shift = 1; <span class="comment">// Shift the output indices by 1.</span>
<a name="l31850"></a>31850   }
<a name="l31851"></a>31851 
<a name="l31852"></a>31852   tetrahedrons-&gt;traversalinit();
<a name="l31853"></a>31853   tface.tet = tetrahedrontraverse();
<a name="l31854"></a>31854   facenumber = firstindex; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l31855"></a>31855   <span class="comment">// To loop over the set of hull faces, loop over all tetrahedra, and look</span>
<a name="l31856"></a>31856   <span class="comment">//   at the four faces of each one. If there isn&#39;t another tetrahedron</span>
<a name="l31857"></a>31857   <span class="comment">//   adjacent to this face, operate on the face.</span>
<a name="l31858"></a>31858   <span class="keywordflow">while</span> (tface.tet != (tetrahedron *) NULL) {
<a name="l31859"></a>31859     <span class="keywordflow">for</span> (tface.loc = 0; tface.loc &lt; 4; tface.loc ++) {
<a name="l31860"></a>31860       sym(tface, tsymface);
<a name="l31861"></a>31861       <span class="keywordflow">if</span> (tsymface.tet == dummytet) {
<a name="l31862"></a>31862         torg = org(tface);
<a name="l31863"></a>31863         tdest = dest(tface);
<a name="l31864"></a>31864         tapex = apex(tface);
<a name="l31865"></a>31865         <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31866"></a>31866           <span class="comment">// Face number, indices of three vertices.</span>
<a name="l31867"></a>31867           fprintf(outfile, <span class="stringliteral">&quot;%5d   %4d  %4d  %4d&quot;</span>, facenumber,
<a name="l31868"></a>31868                   pointmark(torg) - shift, pointmark(tdest) - shift,
<a name="l31869"></a>31869                   pointmark(tapex) - shift);
<a name="l31870"></a>31870           fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l31871"></a>31871         } <span class="keywordflow">else</span> {
<a name="l31872"></a>31872           <span class="comment">// Output indices of three vertices.</span>
<a name="l31873"></a>31873           elist[index++] = pointmark(torg) - shift;
<a name="l31874"></a>31874           elist[index++] = pointmark(tdest) - shift;
<a name="l31875"></a>31875           elist[index++] = pointmark(tapex) - shift;
<a name="l31876"></a>31876         }
<a name="l31877"></a>31877         facenumber++;
<a name="l31878"></a>31878       }
<a name="l31879"></a>31879     }
<a name="l31880"></a>31880     tface.tet = tetrahedrontraverse();
<a name="l31881"></a>31881   }
<a name="l31882"></a>31882 
<a name="l31883"></a>31883   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31884"></a>31884     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l31885"></a>31885     fclose(outfile);
<a name="l31886"></a>31886   }
<a name="l31887"></a>31887 }
<a name="l31888"></a>31888 
<a name="l31890"></a>31890 <span class="comment">//                                                                           //</span>
<a name="l31891"></a>31891 <span class="comment">// outsubfaces()    Output subfaces (i.e. boundary faces) to a .face file or //</span>
<a name="l31892"></a>31892 <span class="comment">//                  a tetgenio structure.                                    //</span>
<a name="l31893"></a>31893 <span class="comment">//                                                                           //</span>
<a name="l31894"></a>31894 <span class="comment">// The boundary faces are exist in &#39;subfaces&#39;. For listing triangle vertices //</span>
<a name="l31895"></a>31895 <span class="comment">// in the same sense for all triangles in the mesh, the direction determined //</span>
<a name="l31896"></a>31896 <span class="comment">// by right-hand rule is pointer to the inside of the volume.                //</span>
<a name="l31897"></a>31897 <span class="comment">//                                                                           //</span>
<a name="l31899"></a>31899 <span class="comment"></span>
<a name="l31900"></a>31900 <span class="keywordtype">void</span> tetgenmesh::outsubfaces(tetgenio* out)
<a name="l31901"></a>31901 {
<a name="l31902"></a>31902   FILE *outfile;
<a name="l31903"></a>31903   <span class="keywordtype">char</span> facefilename[FILENAMESIZE];
<a name="l31904"></a>31904   <span class="keywordtype">int</span> *elist;
<a name="l31905"></a>31905   <span class="keywordtype">int</span> *emlist;
<a name="l31906"></a>31906   <span class="keywordtype">int</span> index, index1, index2;
<a name="l31907"></a>31907   triface abuttingtet;
<a name="l31908"></a>31908   face faceloop;
<a name="l31909"></a>31909   point torg, tdest, tapex;
<a name="l31910"></a>31910   <span class="keywordtype">int</span> bmark, faceid, marker;
<a name="l31911"></a>31911   <span class="keywordtype">int</span> firstindex, shift;
<a name="l31912"></a>31912   <span class="keywordtype">int</span> neigh1, neigh2;
<a name="l31913"></a>31913   <span class="keywordtype">int</span> facenumber;
<a name="l31914"></a>31914 
<a name="l31915"></a>31915   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31916"></a>31916     strcpy(facefilename, b-&gt;outfilename);
<a name="l31917"></a>31917     strcat(facefilename, <span class="stringliteral">&quot;.face&quot;</span>);
<a name="l31918"></a>31918   }
<a name="l31919"></a>31919 
<a name="l31920"></a>31920   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l31921"></a>31921     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31922"></a>31922       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, facefilename);
<a name="l31923"></a>31923     } <span class="keywordflow">else</span> {
<a name="l31924"></a>31924       printf(<span class="stringliteral">&quot;Writing faces.\n&quot;</span>);
<a name="l31925"></a>31925     }
<a name="l31926"></a>31926   }
<a name="l31927"></a>31927 
<a name="l31928"></a>31928   <span class="comment">// Avoid compile warnings.</span>
<a name="l31929"></a>31929   outfile = (FILE *) NULL;
<a name="l31930"></a>31930   elist = (<span class="keywordtype">int</span> *) NULL;
<a name="l31931"></a>31931   emlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l31932"></a>31932   index = index1 = index2 = 0;
<a name="l31933"></a>31933   faceid = marker = 0;
<a name="l31934"></a>31934   neigh1 = neigh2 = 0;
<a name="l31935"></a>31935 
<a name="l31936"></a>31936   bmark = !b-&gt;nobound &amp;&amp; in-&gt;facetmarkerlist;
<a name="l31937"></a>31937 
<a name="l31938"></a>31938   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l31939"></a>31939     outfile = fopen(facefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l31940"></a>31940     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l31941"></a>31941       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, facefilename);
<a name="l31942"></a>31942       terminatetetgen(1);
<a name="l31943"></a>31943     }
<a name="l31944"></a>31944     <span class="comment">// Number of subfaces.</span>
<a name="l31945"></a>31945     fprintf(outfile, <span class="stringliteral">&quot;%ld  %d\n&quot;</span>, subfaces-&gt;items, bmark);
<a name="l31946"></a>31946   } <span class="keywordflow">else</span> {
<a name="l31947"></a>31947     <span class="comment">// Allocate memory for &#39;trifacelist&#39;.</span>
<a name="l31948"></a>31948     out-&gt;trifacelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[subfaces-&gt;items * 3];
<a name="l31949"></a>31949     <span class="keywordflow">if</span> (out-&gt;trifacelist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31950"></a>31950       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31951"></a>31951       terminatetetgen(1);
<a name="l31952"></a>31952     }
<a name="l31953"></a>31953     <span class="keywordflow">if</span> (bmark) {
<a name="l31954"></a>31954       <span class="comment">// Allocate memory for &#39;trifacemarkerlist&#39;.</span>
<a name="l31955"></a>31955       out-&gt;trifacemarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[subfaces-&gt;items];
<a name="l31956"></a>31956       <span class="keywordflow">if</span> (out-&gt;trifacemarkerlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31957"></a>31957         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31958"></a>31958         terminatetetgen(1);
<a name="l31959"></a>31959       }
<a name="l31960"></a>31960     }
<a name="l31961"></a>31961     <span class="keywordflow">if</span> (b-&gt;neighout &gt; 1) {
<a name="l31962"></a>31962       <span class="comment">// &#39;-nn&#39; switch.</span>
<a name="l31963"></a>31963       out-&gt;adjtetlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[subfaces-&gt;items * 2];
<a name="l31964"></a>31964       <span class="keywordflow">if</span> (out-&gt;adjtetlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l31965"></a>31965         printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l31966"></a>31966         terminatetetgen(1);
<a name="l31967"></a>31967       }
<a name="l31968"></a>31968     }
<a name="l31969"></a>31969     out-&gt;numberoftrifaces = subfaces-&gt;items;
<a name="l31970"></a>31970     elist = out-&gt;trifacelist;
<a name="l31971"></a>31971     emlist = out-&gt;trifacemarkerlist;
<a name="l31972"></a>31972   }
<a name="l31973"></a>31973 
<a name="l31974"></a>31974   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l31975"></a>31975   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l31976"></a>31976   shift = 0; <span class="comment">// Default no shiftment.</span>
<a name="l31977"></a>31977   <span class="keywordflow">if</span> ((in-&gt;firstnumber == 1) &amp;&amp; (firstindex == 0)) {
<a name="l31978"></a>31978     shift = 1; <span class="comment">// Shift the output indices by 1.</span>
<a name="l31979"></a>31979   }
<a name="l31980"></a>31980 
<a name="l31981"></a>31981   subfaces-&gt;traversalinit();
<a name="l31982"></a>31982   faceloop.sh = shellfacetraverse(subfaces);
<a name="l31983"></a>31983   facenumber = firstindex; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l31984"></a>31984   <span class="keywordflow">while</span> (faceloop.sh != (shellface *) NULL) {
<a name="l31985"></a>31985     stpivot(faceloop, abuttingtet);
<a name="l31986"></a>31986     <span class="keywordflow">if</span> (abuttingtet.tet == dummytet) {
<a name="l31987"></a>31987       sesymself(faceloop);
<a name="l31988"></a>31988       stpivot(faceloop, abuttingtet);
<a name="l31989"></a>31989     }
<a name="l31990"></a>31990     <span class="keywordflow">if</span> (abuttingtet.tet != dummytet) {
<a name="l31991"></a>31991       <span class="comment">// If there is a tetrahedron containing this subface, orient it so</span>
<a name="l31992"></a>31992       <span class="comment">//   that the normal of this face points to inside of the volume by</span>
<a name="l31993"></a>31993       <span class="comment">//   right-hand rule.</span>
<a name="l31994"></a>31994       adjustedgering(abuttingtet, CCW);
<a name="l31995"></a>31995       torg = org(abuttingtet);
<a name="l31996"></a>31996       tdest = dest(abuttingtet);
<a name="l31997"></a>31997       tapex = apex(abuttingtet);
<a name="l31998"></a>31998     } <span class="keywordflow">else</span> {
<a name="l31999"></a>31999       <span class="comment">// This may happen when only a surface mesh be generated.</span>
<a name="l32000"></a>32000       torg = sorg(faceloop);
<a name="l32001"></a>32001       tdest = sdest(faceloop);
<a name="l32002"></a>32002       tapex = sapex(faceloop);
<a name="l32003"></a>32003     }
<a name="l32004"></a>32004     <span class="keywordflow">if</span> (bmark) {
<a name="l32005"></a>32005       faceid = shellmark(faceloop) - 1;
<a name="l32006"></a>32006       marker = in-&gt;facetmarkerlist[faceid];
<a name="l32007"></a>32007     }
<a name="l32008"></a>32008     <span class="keywordflow">if</span> (b-&gt;neighout &gt; 1) {
<a name="l32009"></a>32009       <span class="comment">// &#39;-nn&#39; switch. Output adjacent tets indices.</span>
<a name="l32010"></a>32010       neigh1 = -1;
<a name="l32011"></a>32011       stpivot(faceloop, abuttingtet);
<a name="l32012"></a>32012       <span class="keywordflow">if</span> (abuttingtet.tet != dummytet) {
<a name="l32013"></a>32013         neigh1 = * (<span class="keywordtype">int</span> *)(abuttingtet.tet + elemmarkerindex);
<a name="l32014"></a>32014       }
<a name="l32015"></a>32015       neigh2 = -1;
<a name="l32016"></a>32016       sesymself(faceloop);
<a name="l32017"></a>32017       stpivot(faceloop, abuttingtet);
<a name="l32018"></a>32018       <span class="keywordflow">if</span> (abuttingtet.tet != dummytet) {
<a name="l32019"></a>32019         neigh2 = * (<span class="keywordtype">int</span> *)(abuttingtet.tet + elemmarkerindex);
<a name="l32020"></a>32020       }
<a name="l32021"></a>32021     }
<a name="l32022"></a>32022     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32023"></a>32023       fprintf(outfile, <span class="stringliteral">&quot;%5d   %4d  %4d  %4d&quot;</span>, facenumber,
<a name="l32024"></a>32024               pointmark(torg) - shift, pointmark(tdest) - shift,
<a name="l32025"></a>32025               pointmark(tapex) - shift);
<a name="l32026"></a>32026       <span class="keywordflow">if</span> (bmark) {
<a name="l32027"></a>32027         fprintf(outfile, <span class="stringliteral">&quot;    %d&quot;</span>, marker);
<a name="l32028"></a>32028       }
<a name="l32029"></a>32029       <span class="keywordflow">if</span> (b-&gt;neighout &gt; 1) {
<a name="l32030"></a>32030         fprintf(outfile, <span class="stringliteral">&quot;    %5d  %5d&quot;</span>, neigh1, neigh2);
<a name="l32031"></a>32031       }
<a name="l32032"></a>32032       fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l32033"></a>32033     } <span class="keywordflow">else</span> {
<a name="l32034"></a>32034       <span class="comment">// Output three vertices of this face;</span>
<a name="l32035"></a>32035       elist[index++] = pointmark(torg) - shift;
<a name="l32036"></a>32036       elist[index++] = pointmark(tdest) - shift;
<a name="l32037"></a>32037       elist[index++] = pointmark(tapex) - shift;
<a name="l32038"></a>32038       <span class="keywordflow">if</span> (bmark) {
<a name="l32039"></a>32039         emlist[index1++] = marker;
<a name="l32040"></a>32040       }
<a name="l32041"></a>32041       <span class="keywordflow">if</span> (b-&gt;neighout &gt; 1) {
<a name="l32042"></a>32042         out-&gt;adjtetlist[index2++] = neigh1;
<a name="l32043"></a>32043         out-&gt;adjtetlist[index2++] = neigh2;
<a name="l32044"></a>32044       }
<a name="l32045"></a>32045     }
<a name="l32046"></a>32046     facenumber++;
<a name="l32047"></a>32047     faceloop.sh = shellfacetraverse(subfaces);
<a name="l32048"></a>32048   }
<a name="l32049"></a>32049 
<a name="l32050"></a>32050   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32051"></a>32051     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l32052"></a>32052     fclose(outfile);
<a name="l32053"></a>32053   }
<a name="l32054"></a>32054 }
<a name="l32055"></a>32055 
<a name="l32057"></a>32057 <span class="comment">//                                                                           //</span>
<a name="l32058"></a>32058 <span class="comment">// outedges()    Output all edges to a .edge file or a structure.            //</span>
<a name="l32059"></a>32059 <span class="comment">//                                                                           //</span>
<a name="l32061"></a>32061 <span class="comment"></span>
<a name="l32062"></a>32062 <span class="keywordtype">void</span> tetgenmesh::outedges(tetgenio* out)
<a name="l32063"></a>32063 {
<a name="l32064"></a>32064   FILE *outfile;
<a name="l32065"></a>32065   <span class="keywordtype">char</span> edgefilename[FILENAMESIZE];
<a name="l32066"></a>32066   <span class="keywordtype">int</span> *elist, *emlist;
<a name="l32067"></a>32067   <span class="keywordtype">int</span> index, index1;
<a name="l32068"></a>32068   triface tetloop, worktet, spintet;
<a name="l32069"></a>32069   face checksh;
<a name="l32070"></a>32070   point torg, tdest;
<a name="l32071"></a>32071   <span class="keywordtype">long</span> faces, edges;
<a name="l32072"></a>32072   <span class="keywordtype">int</span> firstindex, shift;
<a name="l32073"></a>32073   <span class="keywordtype">int</span> edgenumber, faceid, marker;
<a name="l32074"></a>32074   <span class="keywordtype">int</span> hitbdry, i;
<a name="l32075"></a>32075 
<a name="l32076"></a>32076   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32077"></a>32077     strcpy(edgefilename, b-&gt;outfilename);
<a name="l32078"></a>32078     strcat(edgefilename, <span class="stringliteral">&quot;.edge&quot;</span>);
<a name="l32079"></a>32079   }
<a name="l32080"></a>32080 
<a name="l32081"></a>32081   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l32082"></a>32082     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32083"></a>32083       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, edgefilename);
<a name="l32084"></a>32084     } <span class="keywordflow">else</span> {
<a name="l32085"></a>32085       printf(<span class="stringliteral">&quot;Writing edges.\n&quot;</span>);
<a name="l32086"></a>32086     }
<a name="l32087"></a>32087   }
<a name="l32088"></a>32088 
<a name="l32089"></a>32089   <span class="comment">// Avoid compile warnings.</span>
<a name="l32090"></a>32090   outfile = (FILE *) NULL;
<a name="l32091"></a>32091   elist = (<span class="keywordtype">int</span> *) NULL;
<a name="l32092"></a>32092   emlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l32093"></a>32093   index = index1 = 0;
<a name="l32094"></a>32094   faceid = marker = 0;
<a name="l32095"></a>32095 
<a name="l32096"></a>32096   <span class="comment">// Using the Euler formula (V-E+F-T=1) to get the total number of edges.</span>
<a name="l32097"></a>32097   faces = (4l * tetrahedrons-&gt;items + hullsize) / 2l;
<a name="l32098"></a>32098   edges = points-&gt;items + faces - tetrahedrons-&gt;items - 1l;
<a name="l32099"></a>32099 
<a name="l32100"></a>32100   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32101"></a>32101     outfile = fopen(edgefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l32102"></a>32102     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l32103"></a>32103       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, edgefilename);
<a name="l32104"></a>32104       terminatetetgen(1);
<a name="l32105"></a>32105     }
<a name="l32106"></a>32106     <span class="comment">// Write the number of edges, boundary markers (0 or 1).</span>
<a name="l32107"></a>32107     fprintf(outfile, <span class="stringliteral">&quot;%ld  %d\n&quot;</span>, edges, !b-&gt;nobound);
<a name="l32108"></a>32108   } <span class="keywordflow">else</span> {
<a name="l32109"></a>32109     <span class="comment">// Allocate memory for &#39;edgelist&#39;.</span>
<a name="l32110"></a>32110     out-&gt;edgelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[edges * 2];
<a name="l32111"></a>32111     <span class="keywordflow">if</span> (out-&gt;edgelist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l32112"></a>32112       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l32113"></a>32113       terminatetetgen(1);
<a name="l32114"></a>32114     }
<a name="l32115"></a>32115     <span class="keywordflow">if</span> (!b-&gt;nobound) {
<a name="l32116"></a>32116       out-&gt;edgemarkerlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[edges];
<a name="l32117"></a>32117     }
<a name="l32118"></a>32118     out-&gt;numberofedges = edges;
<a name="l32119"></a>32119     elist = out-&gt;edgelist;
<a name="l32120"></a>32120     emlist = out-&gt;edgemarkerlist;
<a name="l32121"></a>32121   }
<a name="l32122"></a>32122 
<a name="l32123"></a>32123   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l32124"></a>32124   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l32125"></a>32125   shift = 0; <span class="comment">// Default no shiftment.</span>
<a name="l32126"></a>32126   <span class="keywordflow">if</span> ((in-&gt;firstnumber == 1) &amp;&amp; (firstindex == 0)) {
<a name="l32127"></a>32127     shift = 1; <span class="comment">// Shift (reduce) the output indices by 1.</span>
<a name="l32128"></a>32128   }
<a name="l32129"></a>32129 
<a name="l32130"></a>32130   tetrahedrons-&gt;traversalinit();
<a name="l32131"></a>32131   tetloop.tet = tetrahedrontraverse();
<a name="l32132"></a>32132   edgenumber = firstindex; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l32133"></a>32133   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l32134"></a>32134     <span class="comment">// Count the number of Voronoi faces. Look at the six edges of each</span>
<a name="l32135"></a>32135     <span class="comment">//   tetrahedron. Count the edge only if the tetrahedron&#39;s pointer is</span>
<a name="l32136"></a>32136     <span class="comment">//   smaller than those of all other tetrahedra that share the edge.</span>
<a name="l32137"></a>32137     worktet.tet = tetloop.tet;
<a name="l32138"></a>32138     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l32139"></a>32139       worktet.loc = edge2locver[i][0];
<a name="l32140"></a>32140       worktet.ver = edge2locver[i][1];
<a name="l32141"></a>32141       adjustedgering(worktet, CW);
<a name="l32142"></a>32142       spintet = worktet;
<a name="l32143"></a>32143       hitbdry = 0;
<a name="l32144"></a>32144       <span class="keywordflow">while</span> (hitbdry &lt; 2) {
<a name="l32145"></a>32145         <span class="keywordflow">if</span> (fnextself(spintet)) {
<a name="l32146"></a>32146           <span class="keywordflow">if</span> (apex(spintet) == apex(worktet)) <span class="keywordflow">break</span>;
<a name="l32147"></a>32147           <span class="keywordflow">if</span> (spintet.tet &lt; worktet.tet) <span class="keywordflow">break</span>;
<a name="l32148"></a>32148         } <span class="keywordflow">else</span> {
<a name="l32149"></a>32149           hitbdry++;
<a name="l32150"></a>32150           <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l32151"></a>32151             esym(worktet, spintet);
<a name="l32152"></a>32152             fnextself(spintet); <span class="comment">// In the same tet.</span>
<a name="l32153"></a>32153       }
<a name="l32154"></a>32154         }
<a name="l32155"></a>32155       }
<a name="l32156"></a>32156       <span class="comment">// Count this edge if no adjacent tets are smaller than this tet.</span>
<a name="l32157"></a>32157       <span class="keywordflow">if</span> (spintet.tet &gt;= worktet.tet) {
<a name="l32158"></a>32158         torg = org(worktet);
<a name="l32159"></a>32159         tdest = dest(worktet);
<a name="l32160"></a>32160         <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32161"></a>32161           fprintf(outfile, <span class="stringliteral">&quot;%5d   %4d  %4d&quot;</span>, edgenumber,
<a name="l32162"></a>32162                   pointmark(torg) - shift, pointmark(tdest) - shift);
<a name="l32163"></a>32163         } <span class="keywordflow">else</span> {
<a name="l32164"></a>32164           <span class="comment">// Output three vertices of this face;</span>
<a name="l32165"></a>32165           elist[index++] = pointmark(torg) - shift;
<a name="l32166"></a>32166           elist[index++] = pointmark(tdest) - shift;
<a name="l32167"></a>32167         }
<a name="l32168"></a>32168         <span class="keywordflow">if</span> (!b-&gt;nobound) {
<a name="l32169"></a>32169           <span class="keywordflow">if</span> (hitbdry &gt; 0) {
<a name="l32170"></a>32170             <span class="comment">// It is a boundary edge. Get the boundary marker of the facet</span>
<a name="l32171"></a>32171             <span class="comment">//   containing this edge. Note there may have more than one</span>
<a name="l32172"></a>32172             <span class="comment">//   facet, choose one arbitrarily.</span>
<a name="l32173"></a>32173             <span class="keywordflow">if</span> ((b-&gt;plc || b-&gt;refine) &amp;&amp; in-&gt;facetmarkerlist) {
<a name="l32174"></a>32174               tspivot(spintet, checksh);
<a name="l32175"></a>32175               faceid = shellmark(checksh) - 1;
<a name="l32176"></a>32176               marker = in-&gt;facetmarkerlist[faceid];
<a name="l32177"></a>32177             } <span class="keywordflow">else</span> {
<a name="l32178"></a>32178               marker = 1;  <span class="comment">// Indicate it&#39;s a boundary edge.</span>
<a name="l32179"></a>32179             }
<a name="l32180"></a>32180           } <span class="keywordflow">else</span> {
<a name="l32181"></a>32181             marker = 0;
<a name="l32182"></a>32182           }
<a name="l32183"></a>32183           <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32184"></a>32184             fprintf(outfile, <span class="stringliteral">&quot;  %d&quot;</span>, marker);
<a name="l32185"></a>32185           } <span class="keywordflow">else</span> {
<a name="l32186"></a>32186             emlist[index1++] = marker;
<a name="l32187"></a>32187           }
<a name="l32188"></a>32188         }
<a name="l32189"></a>32189         <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32190"></a>32190           fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l32191"></a>32191         }
<a name="l32192"></a>32192         edgenumber++;
<a name="l32193"></a>32193       }
<a name="l32194"></a>32194     }
<a name="l32195"></a>32195     tetloop.tet = tetrahedrontraverse();
<a name="l32196"></a>32196   }
<a name="l32197"></a>32197 
<a name="l32198"></a>32198   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32199"></a>32199     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l32200"></a>32200     fclose(outfile);
<a name="l32201"></a>32201   }
<a name="l32202"></a>32202 }
<a name="l32203"></a>32203 
<a name="l32205"></a>32205 <span class="comment">//                                                                           //</span>
<a name="l32206"></a>32206 <span class="comment">// outsubsegments()    Output segments to a .edge file or a structure.       //</span>
<a name="l32207"></a>32207 <span class="comment">//                                                                           //</span>
<a name="l32209"></a>32209 <span class="comment"></span>
<a name="l32210"></a>32210 <span class="keywordtype">void</span> tetgenmesh::outsubsegments(tetgenio* out)
<a name="l32211"></a>32211 {
<a name="l32212"></a>32212   FILE *outfile;
<a name="l32213"></a>32213   <span class="keywordtype">char</span> edgefilename[FILENAMESIZE];
<a name="l32214"></a>32214   <span class="keywordtype">int</span> *elist;
<a name="l32215"></a>32215   <span class="keywordtype">int</span> index;
<a name="l32216"></a>32216   face edgeloop;
<a name="l32217"></a>32217   point torg, tdest;
<a name="l32218"></a>32218   <span class="keywordtype">int</span> firstindex, shift;
<a name="l32219"></a>32219   <span class="keywordtype">int</span> edgenumber;
<a name="l32220"></a>32220 
<a name="l32221"></a>32221   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32222"></a>32222     strcpy(edgefilename, b-&gt;outfilename);
<a name="l32223"></a>32223     strcat(edgefilename, <span class="stringliteral">&quot;.edge&quot;</span>);
<a name="l32224"></a>32224   }
<a name="l32225"></a>32225 
<a name="l32226"></a>32226   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l32227"></a>32227     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32228"></a>32228       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, edgefilename);
<a name="l32229"></a>32229     } <span class="keywordflow">else</span> {
<a name="l32230"></a>32230       printf(<span class="stringliteral">&quot;Writing edges.\n&quot;</span>);
<a name="l32231"></a>32231     }
<a name="l32232"></a>32232   }
<a name="l32233"></a>32233 
<a name="l32234"></a>32234   <span class="comment">// Avoid compile warnings.</span>
<a name="l32235"></a>32235   outfile = (FILE *) NULL;
<a name="l32236"></a>32236   elist = (<span class="keywordtype">int</span> *) NULL;
<a name="l32237"></a>32237   index = 0;
<a name="l32238"></a>32238 
<a name="l32239"></a>32239   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32240"></a>32240     outfile = fopen(edgefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l32241"></a>32241     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l32242"></a>32242       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, edgefilename);
<a name="l32243"></a>32243       terminatetetgen(1);
<a name="l32244"></a>32244     }
<a name="l32245"></a>32245     <span class="comment">// Number of subsegments.</span>
<a name="l32246"></a>32246     fprintf(outfile, <span class="stringliteral">&quot;%ld\n&quot;</span>, subsegs-&gt;items);
<a name="l32247"></a>32247   } <span class="keywordflow">else</span> {
<a name="l32248"></a>32248     <span class="comment">// Allocate memory for &#39;edgelist&#39;.</span>
<a name="l32249"></a>32249     out-&gt;edgelist = <span class="keyword">new</span> <span class="keywordtype">int</span>[subsegs-&gt;items * 2];
<a name="l32250"></a>32250     <span class="keywordflow">if</span> (out-&gt;edgelist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l32251"></a>32251       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l32252"></a>32252       terminatetetgen(1);
<a name="l32253"></a>32253     }
<a name="l32254"></a>32254     out-&gt;numberofedges = subsegs-&gt;items;
<a name="l32255"></a>32255     elist = out-&gt;edgelist;
<a name="l32256"></a>32256   }
<a name="l32257"></a>32257 
<a name="l32258"></a>32258   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l32259"></a>32259   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l32260"></a>32260   shift = 0; <span class="comment">// Default no shiftment.</span>
<a name="l32261"></a>32261   <span class="keywordflow">if</span> ((in-&gt;firstnumber == 1) &amp;&amp; (firstindex == 0)) {
<a name="l32262"></a>32262     shift = 1; <span class="comment">// Shift the output indices by 1.</span>
<a name="l32263"></a>32263   }
<a name="l32264"></a>32264 
<a name="l32265"></a>32265   subsegs-&gt;traversalinit();
<a name="l32266"></a>32266   edgeloop.sh = shellfacetraverse(subsegs);
<a name="l32267"></a>32267   edgenumber = firstindex; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l32268"></a>32268   <span class="keywordflow">while</span> (edgeloop.sh != (shellface *) NULL) {
<a name="l32269"></a>32269     torg = sorg(edgeloop);
<a name="l32270"></a>32270     tdest = sdest(edgeloop);
<a name="l32271"></a>32271     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32272"></a>32272       fprintf(outfile, <span class="stringliteral">&quot;%5d   %4d  %4d\n&quot;</span>, edgenumber,
<a name="l32273"></a>32273               pointmark(torg) - shift, pointmark(tdest) - shift);
<a name="l32274"></a>32274     } <span class="keywordflow">else</span> {
<a name="l32275"></a>32275       <span class="comment">// Output three vertices of this face;</span>
<a name="l32276"></a>32276       elist[index++] = pointmark(torg) - shift;
<a name="l32277"></a>32277       elist[index++] = pointmark(tdest) - shift;
<a name="l32278"></a>32278     }
<a name="l32279"></a>32279     edgenumber++;
<a name="l32280"></a>32280     edgeloop.sh = shellfacetraverse(subsegs);
<a name="l32281"></a>32281   }
<a name="l32282"></a>32282 
<a name="l32283"></a>32283   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32284"></a>32284     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l32285"></a>32285     fclose(outfile);
<a name="l32286"></a>32286   }
<a name="l32287"></a>32287 }
<a name="l32288"></a>32288 
<a name="l32290"></a>32290 <span class="comment">//                                                                           //</span>
<a name="l32291"></a>32291 <span class="comment">// outneighbors()    Output tet neighbors to a .neigh file or a structure.   //</span>
<a name="l32292"></a>32292 <span class="comment">//                                                                           //</span>
<a name="l32294"></a>32294 <span class="comment"></span>
<a name="l32295"></a>32295 <span class="keywordtype">void</span> tetgenmesh::outneighbors(tetgenio* out)
<a name="l32296"></a>32296 {
<a name="l32297"></a>32297   FILE *outfile;
<a name="l32298"></a>32298   <span class="keywordtype">char</span> neighborfilename[FILENAMESIZE];
<a name="l32299"></a>32299   <span class="keywordtype">int</span> *nlist;
<a name="l32300"></a>32300   <span class="keywordtype">int</span> index;
<a name="l32301"></a>32301   triface tetloop, tetsym;
<a name="l32302"></a>32302   <span class="keywordtype">int</span> neighbor1, neighbor2, neighbor3, neighbor4;
<a name="l32303"></a>32303   <span class="keywordtype">int</span> firstindex;
<a name="l32304"></a>32304   <span class="keywordtype">int</span> elementnumber;
<a name="l32305"></a>32305 
<a name="l32306"></a>32306   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32307"></a>32307     strcpy(neighborfilename, b-&gt;outfilename);
<a name="l32308"></a>32308     strcat(neighborfilename, <span class="stringliteral">&quot;.neigh&quot;</span>);
<a name="l32309"></a>32309   }
<a name="l32310"></a>32310 
<a name="l32311"></a>32311   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l32312"></a>32312     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32313"></a>32313       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, neighborfilename);
<a name="l32314"></a>32314     } <span class="keywordflow">else</span> {
<a name="l32315"></a>32315       printf(<span class="stringliteral">&quot;Writing neighbors.\n&quot;</span>);
<a name="l32316"></a>32316     }
<a name="l32317"></a>32317   }
<a name="l32318"></a>32318 
<a name="l32319"></a>32319   <span class="comment">// Avoid compile warnings.</span>
<a name="l32320"></a>32320   outfile = (FILE *) NULL;
<a name="l32321"></a>32321   nlist = (<span class="keywordtype">int</span> *) NULL;
<a name="l32322"></a>32322   index = 0;
<a name="l32323"></a>32323 
<a name="l32324"></a>32324   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32325"></a>32325     outfile = fopen(neighborfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l32326"></a>32326     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l32327"></a>32327       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, neighborfilename);
<a name="l32328"></a>32328       terminatetetgen(1);
<a name="l32329"></a>32329     }
<a name="l32330"></a>32330     <span class="comment">// Number of tetrahedra, four faces per tetrahedron.</span>
<a name="l32331"></a>32331     fprintf(outfile, <span class="stringliteral">&quot;%ld  %d\n&quot;</span>, tetrahedrons-&gt;items, 4);
<a name="l32332"></a>32332   } <span class="keywordflow">else</span> {
<a name="l32333"></a>32333     <span class="comment">// Allocate memory for &#39;neighborlist&#39;.</span>
<a name="l32334"></a>32334     out-&gt;neighborlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[tetrahedrons-&gt;items * 4];
<a name="l32335"></a>32335     <span class="keywordflow">if</span> (out-&gt;neighborlist == (<span class="keywordtype">int</span> *) NULL) {
<a name="l32336"></a>32336       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l32337"></a>32337       terminatetetgen(1);
<a name="l32338"></a>32338     }
<a name="l32339"></a>32339     nlist = out-&gt;neighborlist;
<a name="l32340"></a>32340   }
<a name="l32341"></a>32341 
<a name="l32342"></a>32342   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l32343"></a>32343   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l32344"></a>32344 
<a name="l32345"></a>32345   tetrahedrons-&gt;traversalinit();
<a name="l32346"></a>32346   tetloop.tet = tetrahedrontraverse();
<a name="l32347"></a>32347   elementnumber = firstindex; <span class="comment">// in-&gt;firstnumber;</span>
<a name="l32348"></a>32348   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l32349"></a>32349     tetloop.loc = 2;
<a name="l32350"></a>32350     sym(tetloop, tetsym);
<a name="l32351"></a>32351     neighbor1 = * (<span class="keywordtype">int</span> *) (tetsym.tet + elemmarkerindex);
<a name="l32352"></a>32352     tetloop.loc = 3;
<a name="l32353"></a>32353     sym(tetloop, tetsym);
<a name="l32354"></a>32354     neighbor2 = * (<span class="keywordtype">int</span> *) (tetsym.tet + elemmarkerindex);
<a name="l32355"></a>32355     tetloop.loc = 1;
<a name="l32356"></a>32356     sym(tetloop, tetsym);
<a name="l32357"></a>32357     neighbor3 = * (<span class="keywordtype">int</span> *) (tetsym.tet + elemmarkerindex);
<a name="l32358"></a>32358     tetloop.loc = 0;
<a name="l32359"></a>32359     sym(tetloop, tetsym);
<a name="l32360"></a>32360     neighbor4 = * (<span class="keywordtype">int</span> *) (tetsym.tet + elemmarkerindex);
<a name="l32361"></a>32361     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32362"></a>32362       <span class="comment">// Tetrahedra number, neighboring tetrahedron numbers.</span>
<a name="l32363"></a>32363       fprintf(outfile, <span class="stringliteral">&quot;%4d    %4d  %4d  %4d  %4d\n&quot;</span>, elementnumber,
<a name="l32364"></a>32364               neighbor1, neighbor2, neighbor3, neighbor4);
<a name="l32365"></a>32365     } <span class="keywordflow">else</span> {
<a name="l32366"></a>32366       nlist[index++] = neighbor1;
<a name="l32367"></a>32367       nlist[index++] = neighbor2;
<a name="l32368"></a>32368       nlist[index++] = neighbor3;
<a name="l32369"></a>32369       nlist[index++] = neighbor4;
<a name="l32370"></a>32370     }
<a name="l32371"></a>32371     tetloop.tet = tetrahedrontraverse();
<a name="l32372"></a>32372     elementnumber++;
<a name="l32373"></a>32373   }
<a name="l32374"></a>32374 
<a name="l32375"></a>32375   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32376"></a>32376     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l32377"></a>32377     fclose(outfile);
<a name="l32378"></a>32378   }
<a name="l32379"></a>32379 }
<a name="l32380"></a>32380 
<a name="l32382"></a>32382 <span class="comment">//                                                                           //</span>
<a name="l32383"></a>32383 <span class="comment">// outvoronoi()    Output the Voronoi diagram to .v.node, .v.edge, v.face,   //</span>
<a name="l32384"></a>32384 <span class="comment">//                 and .v.cell.                                              //</span>
<a name="l32385"></a>32385 <span class="comment">//                                                                           //</span>
<a name="l32386"></a>32386 <span class="comment">// The Voronoi diagram is the geometric dual of the Delaunay triangulation.  //</span>
<a name="l32387"></a>32387 <span class="comment">// The Voronoi vertices are the circumcenters of Delaunay tetrahedra.  Each  //</span>
<a name="l32388"></a>32388 <span class="comment">// Voronoi edge connects two Voronoi vertices at two sides of a common Dela- //</span>
<a name="l32389"></a>32389 <span class="comment">// unay face. At a face of convex hull, it becomes a ray (goto the infinity).//</span>
<a name="l32390"></a>32390 <span class="comment">// A Voronoi face is the convex hull of all Voronoi vertices around a common //</span>
<a name="l32391"></a>32391 <span class="comment">// Delaunay edge. It is a closed polygon for any interal Delaunay edge. At a //</span>
<a name="l32392"></a>32392 <span class="comment">// ridge, it is unbounded.  Each Voronoi cell is the convex hull of all Vor- //</span>
<a name="l32393"></a>32393 <span class="comment">// onoi vertices around a common Delaunay vertex. It is a polytope for any   //</span>
<a name="l32394"></a>32394 <span class="comment">// internal Delaunay vertex. It is an unbounded polyhedron for a Delaunay    //</span>
<a name="l32395"></a>32395 <span class="comment">// vertex belonging to the convex hull.                                      //</span>
<a name="l32396"></a>32396 <span class="comment">//                                                                           //</span>
<a name="l32398"></a>32398 <span class="comment"></span>
<a name="l32399"></a>32399 <span class="keywordtype">void</span> tetgenmesh::outvoronoi(tetgenio* out)
<a name="l32400"></a>32400 {
<a name="l32401"></a>32401   FILE *outfile;
<a name="l32402"></a>32402   <span class="keywordtype">char</span> outfilename[FILENAMESIZE];
<a name="l32403"></a>32403   tetgenio::voroedge *vedge;
<a name="l32404"></a>32404   tetgenio::vorofacet *vfacet;
<a name="l32405"></a>32405   list *tetlist, *ptlist;
<a name="l32406"></a>32406   triface tetloop, worktet, spintet;
<a name="l32407"></a>32407   point pt[4], ptloop, neipt;
<a name="l32408"></a>32408   REAL ccent[3], infvec[3], vec1[3], vec2[3], L;
<a name="l32409"></a>32409   <span class="keywordtype">long</span> faces, edges;
<a name="l32410"></a>32410   <span class="keywordtype">int</span> *tetfaceindexarray, *tetedgeindexarray;
<a name="l32411"></a>32411   <span class="keywordtype">int</span> arraysize, *vertarray;
<a name="l32412"></a>32412   <span class="keywordtype">int</span> vpointcount, vedgecount, vfacecount, tcount;
<a name="l32413"></a>32413   <span class="keywordtype">int</span> index, shift;
<a name="l32414"></a>32414   <span class="keywordtype">int</span> end1, end2;
<a name="l32415"></a>32415   <span class="keywordtype">int</span> hitbdry, i, j, k;
<a name="l32416"></a>32416 
<a name="l32417"></a>32417   vedge = NULL;
<a name="l32418"></a>32418   vertarray = NULL;
<a name="l32419"></a>32419   vfacet = NULL;
<a name="l32420"></a>32420   k = 0;
<a name="l32421"></a>32421 
<a name="l32422"></a>32422   <span class="comment">// Output Voronoi vertices to .v.node file.</span>
<a name="l32423"></a>32423   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32424"></a>32424     strcpy(outfilename, b-&gt;outfilename);
<a name="l32425"></a>32425     strcat(outfilename, <span class="stringliteral">&quot;.v.node&quot;</span>);
<a name="l32426"></a>32426   }
<a name="l32427"></a>32427 
<a name="l32428"></a>32428   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l32429"></a>32429     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32430"></a>32430       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, outfilename);
<a name="l32431"></a>32431     } <span class="keywordflow">else</span> {
<a name="l32432"></a>32432       printf(<span class="stringliteral">&quot;Writing Voronoi vertices.\n&quot;</span>);
<a name="l32433"></a>32433     }
<a name="l32434"></a>32434   }
<a name="l32435"></a>32435 
<a name="l32436"></a>32436   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l32437"></a>32437   shift = (b-&gt;zeroindex ? 0 : in-&gt;firstnumber);
<a name="l32438"></a>32438   <span class="comment">// The number of Delaunay faces (= the number of Voronoi edges).</span>
<a name="l32439"></a>32439   faces = (4l * tetrahedrons-&gt;items + hullsize) / 2l;
<a name="l32440"></a>32440   <span class="comment">// The number of Delaunay edges (= the number of Voronoi faces).</span>
<a name="l32441"></a>32441   edges = points-&gt;items + faces - tetrahedrons-&gt;items - 1;
<a name="l32442"></a>32442   outfile = (FILE *) NULL; <span class="comment">// Avoid compile warnings.</span>
<a name="l32443"></a>32443 
<a name="l32444"></a>32444   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32445"></a>32445     outfile = fopen(outfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l32446"></a>32446     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l32447"></a>32447       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, outfilename);
<a name="l32448"></a>32448       terminatetetgen(1);
<a name="l32449"></a>32449     }
<a name="l32450"></a>32450     <span class="comment">// Number of voronoi points, 3 dim, no attributes, no marker.</span>
<a name="l32451"></a>32451     fprintf(outfile, <span class="stringliteral">&quot;%ld  3  0  0\n&quot;</span>, tetrahedrons-&gt;items);
<a name="l32452"></a>32452   } <span class="keywordflow">else</span> {
<a name="l32453"></a>32453     <span class="comment">// Allocate space for &#39;vpointlist&#39;.</span>
<a name="l32454"></a>32454     out-&gt;numberofvpoints = (int) tetrahedrons-&gt;items;
<a name="l32455"></a>32455     out-&gt;vpointlist = <span class="keyword">new</span> REAL[out-&gt;numberofvpoints * 3];
<a name="l32456"></a>32456     if (out-&gt;vpointlist == (REAL *) NULL) {
<a name="l32457"></a>32457       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l32458"></a>32458       terminatetetgen(1);
<a name="l32459"></a>32459     }
<a name="l32460"></a>32460   }
<a name="l32461"></a>32461 
<a name="l32462"></a>32462   <span class="comment">// Loop the tetrahedronlist once, do the following:</span>
<a name="l32463"></a>32463   <span class="comment">//   (1) Output Voronoi vertices (the circumcenter of the tetrahedron).</span>
<a name="l32464"></a>32464   <span class="comment">//   (2) Make a map from points-to-tetrahedra (for Voronoi cells).</span>
<a name="l32465"></a>32465   tetrahedrons-&gt;traversalinit();
<a name="l32466"></a>32466   tetloop.tet = tetrahedrontraverse();
<a name="l32467"></a>32467   vpointcount = 0;
<a name="l32468"></a>32468   index = 0;
<a name="l32469"></a>32469   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l32470"></a>32470     <span class="comment">// Calculate the circumcenter.</span>
<a name="l32471"></a>32471     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l32472"></a>32472       pt[i] = (point) tetloop.tet[4 + i];
<a name="l32473"></a>32473       setpoint2tet(pt[i], encode(tetloop));
<a name="l32474"></a>32474     }
<a name="l32475"></a>32475     circumsphere(pt[0], pt[1], pt[2], pt[3], ccent, NULL);
<a name="l32476"></a>32476     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32477"></a>32477       fprintf(outfile, <span class="stringliteral">&quot;%4d  %16.8e %16.8e %16.8e\n&quot;</span>, vpointcount + shift,
<a name="l32478"></a>32478               ccent[0], ccent[1], ccent[2]);
<a name="l32479"></a>32479     } <span class="keywordflow">else</span> {
<a name="l32480"></a>32480       out-&gt;vpointlist[index++] = ccent[0];
<a name="l32481"></a>32481       out-&gt;vpointlist[index++] = ccent[1];
<a name="l32482"></a>32482       out-&gt;vpointlist[index++] = ccent[2];
<a name="l32483"></a>32483     }
<a name="l32484"></a>32484     <span class="comment">// Remember the index of this element.</span>
<a name="l32485"></a>32485     * (<span class="keywordtype">int</span> *) (tetloop.tet + elemmarkerindex) = vpointcount;
<a name="l32486"></a>32486     vpointcount++;
<a name="l32487"></a>32487     tetloop.tet = tetrahedrontraverse();
<a name="l32488"></a>32488   }
<a name="l32489"></a>32489   <span class="comment">// Set the outside element marker.</span>
<a name="l32490"></a>32490   * (<span class="keywordtype">int</span> *) (dummytet + elemmarkerindex) = -1;
<a name="l32491"></a>32491 
<a name="l32492"></a>32492   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32493"></a>32493     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l32494"></a>32494     fclose(outfile);
<a name="l32495"></a>32495   }
<a name="l32496"></a>32496 
<a name="l32497"></a>32497   <span class="comment">// Output Voronoi edges to .v.edge file.</span>
<a name="l32498"></a>32498   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32499"></a>32499     strcpy(outfilename, b-&gt;outfilename);
<a name="l32500"></a>32500     strcat(outfilename, <span class="stringliteral">&quot;.v.edge&quot;</span>);
<a name="l32501"></a>32501   }
<a name="l32502"></a>32502 
<a name="l32503"></a>32503   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l32504"></a>32504     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32505"></a>32505       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, outfilename);
<a name="l32506"></a>32506     } <span class="keywordflow">else</span> {
<a name="l32507"></a>32507       printf(<span class="stringliteral">&quot;Writing Voronoi edges.\n&quot;</span>);
<a name="l32508"></a>32508     }
<a name="l32509"></a>32509   }
<a name="l32510"></a>32510 
<a name="l32511"></a>32511   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32512"></a>32512     outfile = fopen(outfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l32513"></a>32513     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l32514"></a>32514       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, outfilename);
<a name="l32515"></a>32515       terminatetetgen(1);
<a name="l32516"></a>32516     }
<a name="l32517"></a>32517     <span class="comment">// Number of Voronoi edges, no marker.</span>
<a name="l32518"></a>32518     fprintf(outfile, <span class="stringliteral">&quot;%ld  0\n&quot;</span>, faces);
<a name="l32519"></a>32519   } <span class="keywordflow">else</span> {
<a name="l32520"></a>32520     <span class="comment">// Allocate space for &#39;vpointlist&#39;.</span>
<a name="l32521"></a>32521     out-&gt;numberofedges = (int) faces;
<a name="l32522"></a>32522     out-&gt;vedgelist = <span class="keyword">new</span> tetgenio::voroedge[out-&gt;numberofvedges];
<a name="l32523"></a>32523   }
<a name="l32524"></a>32524 
<a name="l32525"></a>32525   <span class="comment">// Loop the tetrahedronlist once, output the Voronoi edges. The index of</span>
<a name="l32526"></a>32526   <span class="comment">//   each Voronoi edge corresponding to the index of the Delaunay face.</span>
<a name="l32527"></a>32527   <span class="comment">//   The four faces&#39; indices of each tetrahedron are saved in the list</span>
<a name="l32528"></a>32528   <span class="comment">//   &#39;tetfaceindexarray&#39;, in the entry of i,  where i (0-based) is the</span>
<a name="l32529"></a>32529   <span class="comment">//   index of this tetrahedron (= vpointcount).</span>
<a name="l32530"></a>32530   tetfaceindexarray = <span class="keyword">new</span> <span class="keywordtype">int</span>[tetrahedrons-&gt;items * 4];
<a name="l32531"></a>32531   tetrahedrons-&gt;traversalinit();
<a name="l32532"></a>32532   tetloop.tet = tetrahedrontraverse();
<a name="l32533"></a>32533   vedgecount = 0;
<a name="l32534"></a>32534   index = 0;
<a name="l32535"></a>32535   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l32536"></a>32536     <span class="comment">// Count the number of Voronoi edges. Look at the four faces of each</span>
<a name="l32537"></a>32537     <span class="comment">//   tetrahedron. Count the face if the tetrahedron&#39;s pointer is</span>
<a name="l32538"></a>32538     <span class="comment">//   smaller than its neighbor&#39;s or the neighbor is outside.</span>
<a name="l32539"></a>32539     end1 = * (<span class="keywordtype">int</span> *) (tetloop.tet + elemmarkerindex);
<a name="l32540"></a>32540     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l32541"></a>32541       decode(tetloop.tet[i], worktet);
<a name="l32542"></a>32542       <span class="keywordflow">if</span> ((worktet.tet == dummytet) || (tetloop.tet &lt; worktet.tet)) {
<a name="l32543"></a>32543         <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32544"></a>32544           fprintf(outfile, <span class="stringliteral">&quot;%4d  %4d&quot;</span>, vedgecount + shift, end1 + shift);
<a name="l32545"></a>32545         } <span class="keywordflow">else</span> {
<a name="l32546"></a>32546           vedge = &amp;(out-&gt;vedgelist[index++]);
<a name="l32547"></a>32547           vedge-&gt;v1 = end1 + shift;
<a name="l32548"></a>32548         }
<a name="l32549"></a>32549         end2 = * (<span class="keywordtype">int</span> *) (worktet.tet + elemmarkerindex);
<a name="l32550"></a>32550         <span class="comment">// Note that end2 may be -1 (worktet.tet is outside).</span>
<a name="l32551"></a>32551         <span class="keywordflow">if</span> (end2 == -1) {
<a name="l32552"></a>32552           <span class="comment">// Calculate the out normal of this hull face.</span>
<a name="l32553"></a>32553           worktet.tet = tetloop.tet;
<a name="l32554"></a>32554           worktet.loc = i;
<a name="l32555"></a>32555           worktet.ver = 1; <span class="comment">// The CW edge ring.</span>
<a name="l32556"></a>32556           pt[0] = org(worktet);
<a name="l32557"></a>32557           pt[1] = dest(worktet);
<a name="l32558"></a>32558           pt[2] = apex(worktet);
<a name="l32559"></a>32559           <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) vec1[j] = pt[1][j] - pt[0][j];
<a name="l32560"></a>32560           <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) vec2[j] = pt[2][j] - pt[0][j];
<a name="l32561"></a>32561           cross(vec1, vec2, infvec);
<a name="l32562"></a>32562           <span class="comment">// Normalize it.</span>
<a name="l32563"></a>32563           L = sqrt(infvec[0] * infvec[0] + infvec[1] * infvec[1]
<a name="l32564"></a>32564                    + infvec[2] * infvec[2]);
<a name="l32565"></a>32565           <span class="keywordflow">if</span> (L &gt; 0) <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) infvec[j] /= L;
<a name="l32566"></a>32566           <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32567"></a>32567             fprintf(outfile, <span class="stringliteral">&quot; -1&quot;</span>);
<a name="l32568"></a>32568             fprintf(outfile, <span class="stringliteral">&quot; %g %g %g\n&quot;</span>, infvec[0], infvec[1], infvec[2]);
<a name="l32569"></a>32569           } <span class="keywordflow">else</span> {
<a name="l32570"></a>32570             vedge-&gt;v2 = -1;
<a name="l32571"></a>32571             vedge-&gt;vnormal[0] = infvec[0];
<a name="l32572"></a>32572             vedge-&gt;vnormal[1] = infvec[1];
<a name="l32573"></a>32573             vedge-&gt;vnormal[2] = infvec[2];
<a name="l32574"></a>32574           }
<a name="l32575"></a>32575         } <span class="keywordflow">else</span> {
<a name="l32576"></a>32576           <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32577"></a>32577             fprintf(outfile, <span class="stringliteral">&quot; %4d\n&quot;</span>, end2 + shift);
<a name="l32578"></a>32578           } <span class="keywordflow">else</span> {
<a name="l32579"></a>32579             vedge-&gt;v2 = end2 + shift;
<a name="l32580"></a>32580             vedge-&gt;vnormal[0] = 0.0;
<a name="l32581"></a>32581             vedge-&gt;vnormal[1] = 0.0;
<a name="l32582"></a>32582             vedge-&gt;vnormal[2] = 0.0;
<a name="l32583"></a>32583           }
<a name="l32584"></a>32584         }
<a name="l32585"></a>32585         <span class="comment">// Save the face index in this tet and its neighbor if exists.</span>
<a name="l32586"></a>32586         tetfaceindexarray[end1 * 4 + i] = vedgecount;
<a name="l32587"></a>32587         <span class="keywordflow">if</span> (end2 != -1) {
<a name="l32588"></a>32588           tetfaceindexarray[end2 * 4 + worktet.loc] = vedgecount;
<a name="l32589"></a>32589         }
<a name="l32590"></a>32590         vedgecount++;
<a name="l32591"></a>32591       }
<a name="l32592"></a>32592     }
<a name="l32593"></a>32593     tetloop.tet = tetrahedrontraverse();
<a name="l32594"></a>32594   }
<a name="l32595"></a>32595 
<a name="l32596"></a>32596   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32597"></a>32597     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l32598"></a>32598     fclose(outfile);
<a name="l32599"></a>32599   }
<a name="l32600"></a>32600 
<a name="l32601"></a>32601   <span class="comment">// Output Voronoi faces to .v.face file.</span>
<a name="l32602"></a>32602   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32603"></a>32603     strcpy(outfilename, b-&gt;outfilename);
<a name="l32604"></a>32604     strcat(outfilename, <span class="stringliteral">&quot;.v.face&quot;</span>);
<a name="l32605"></a>32605   }
<a name="l32606"></a>32606 
<a name="l32607"></a>32607   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l32608"></a>32608     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32609"></a>32609       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, outfilename);
<a name="l32610"></a>32610     } <span class="keywordflow">else</span> {
<a name="l32611"></a>32611       printf(<span class="stringliteral">&quot;Writing Voronoi faces.\n&quot;</span>);
<a name="l32612"></a>32612     }
<a name="l32613"></a>32613   }
<a name="l32614"></a>32614 
<a name="l32615"></a>32615   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32616"></a>32616     outfile = fopen(outfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l32617"></a>32617     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l32618"></a>32618       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, outfilename);
<a name="l32619"></a>32619       terminatetetgen(1);
<a name="l32620"></a>32620     }
<a name="l32621"></a>32621     <span class="comment">// Number of Voronoi faces.</span>
<a name="l32622"></a>32622     fprintf(outfile, <span class="stringliteral">&quot;%ld  0\n&quot;</span>, edges);
<a name="l32623"></a>32623   } <span class="keywordflow">else</span> {
<a name="l32624"></a>32624     out-&gt;numberofvfacets = edges;
<a name="l32625"></a>32625     out-&gt;vfacetlist = <span class="keyword">new</span> tetgenio::vorofacet[out-&gt;numberofvfacets];
<a name="l32626"></a>32626     <span class="keywordflow">if</span> (out-&gt;vfacetlist == (tetgenio::vorofacet *) NULL) {
<a name="l32627"></a>32627       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l32628"></a>32628       terminatetetgen(1);
<a name="l32629"></a>32629     }
<a name="l32630"></a>32630   }
<a name="l32631"></a>32631 
<a name="l32632"></a>32632   <span class="comment">// Loop the tetrahedronlist once, Output Voronoi facets. The index of each</span>
<a name="l32633"></a>32633   <span class="comment">//   Voronoi facet corresponding to the index of the Delaunay edge.  The</span>
<a name="l32634"></a>32634   <span class="comment">//   six edges&#39; indices of each tetrahedron are saved in the list &#39;tetedge-</span>
<a name="l32635"></a>32635   <span class="comment">//   indexarray&#39;, in the entry of i,  where i (0-based) is the index of</span>
<a name="l32636"></a>32636   <span class="comment">//   this tetrahedron (= vpointcount).</span>
<a name="l32637"></a>32637   tetedgeindexarray = <span class="keyword">new</span> <span class="keywordtype">int</span>[tetrahedrons-&gt;items * 6];
<a name="l32638"></a>32638   tetrahedrons-&gt;traversalinit();
<a name="l32639"></a>32639   tetloop.tet = tetrahedrontraverse();
<a name="l32640"></a>32640   vfacecount = 0;
<a name="l32641"></a>32641   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l32642"></a>32642     <span class="comment">// Count the number of Voronoi faces. Look at the six edges of each</span>
<a name="l32643"></a>32643     <span class="comment">//   tetrahedron. Count the edge only if the tetrahedron&#39;s pointer is</span>
<a name="l32644"></a>32644     <span class="comment">//   smaller than those of all other tetrahedra that share the edge.</span>
<a name="l32645"></a>32645     worktet = tetloop;
<a name="l32646"></a>32646     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l32647"></a>32647       worktet.loc = edge2locver[i][0];
<a name="l32648"></a>32648       worktet.ver = edge2locver[i][1];
<a name="l32649"></a>32649       <span class="comment">// Now count the number of tets surrounding this edge.</span>
<a name="l32650"></a>32650       tcount = 1;
<a name="l32651"></a>32651       adjustedgering(worktet, CW);
<a name="l32652"></a>32652       spintet = worktet;
<a name="l32653"></a>32653       hitbdry = 0;
<a name="l32654"></a>32654       <span class="keywordflow">while</span> (hitbdry &lt; 2) {
<a name="l32655"></a>32655         <span class="keywordflow">if</span> (fnextself(spintet)) {
<a name="l32656"></a>32656           <span class="keywordflow">if</span> (apex(spintet) == apex(worktet)) <span class="keywordflow">break</span>;
<a name="l32657"></a>32657           <span class="keywordflow">if</span> (spintet.tet &lt; worktet.tet) <span class="keywordflow">break</span>;
<a name="l32658"></a>32658           tcount++;
<a name="l32659"></a>32659         } <span class="keywordflow">else</span> {
<a name="l32660"></a>32660           hitbdry++;
<a name="l32661"></a>32661           <span class="keywordflow">if</span> (hitbdry &lt; 2) {
<a name="l32662"></a>32662             esym(worktet, spintet);
<a name="l32663"></a>32663             fnextself(spintet); <span class="comment">// In the same tet.</span>
<a name="l32664"></a>32664       }
<a name="l32665"></a>32665         }
<a name="l32666"></a>32666       }
<a name="l32667"></a>32667       <span class="comment">// Count this edge if no adjacent tets are smaller than this tet.</span>
<a name="l32668"></a>32668       <span class="keywordflow">if</span> (spintet.tet &gt;= worktet.tet) {
<a name="l32669"></a>32669         <span class="comment">// Get the two endpoints of this edge.</span>
<a name="l32670"></a>32670         pt[0] = org(worktet);
<a name="l32671"></a>32671         pt[1] = dest(worktet);
<a name="l32672"></a>32672         end1 = pointmark(pt[0]) - in-&gt;firstnumber;
<a name="l32673"></a>32673         end2 = pointmark(pt[1]) - in-&gt;firstnumber;
<a name="l32674"></a>32674         <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32675"></a>32675           fprintf(outfile, <span class="stringliteral">&quot;%4d  %4d %4d  %-2d &quot;</span>, vfacecount + shift,
<a name="l32676"></a>32676                   end1 + shift, end2 + shift, tcount + (hitbdry &gt; 0));
<a name="l32677"></a>32677         } <span class="keywordflow">else</span> {
<a name="l32678"></a>32678           vfacet = &amp;(out-&gt;vfacetlist[vfacecount]);
<a name="l32679"></a>32679           vfacet-&gt;c1 = end1 + shift;
<a name="l32680"></a>32680           vfacet-&gt;c2 = end2 + shift;
<a name="l32681"></a>32681           vfacet-&gt;elist = <span class="keyword">new</span> <span class="keywordtype">int</span>[tcount + (hitbdry &gt; 0) + 1];
<a name="l32682"></a>32682           vfacet-&gt;elist[0] = tcount + (hitbdry &gt; 0);
<a name="l32683"></a>32683           index = 1;
<a name="l32684"></a>32684         }
<a name="l32685"></a>32685         <span class="comment">// If hitbdry &gt; 0, then spintet is a hull face.</span>
<a name="l32686"></a>32686         <span class="keywordflow">if</span> (hitbdry &gt; 0) {
<a name="l32687"></a>32687           <span class="comment">// The edge list starts with a ray.</span>
<a name="l32688"></a>32688           vpointcount = * (<span class="keywordtype">int</span> *) (spintet.tet + elemmarkerindex);
<a name="l32689"></a>32689           vedgecount = tetfaceindexarray[vpointcount * 4 + spintet.loc];
<a name="l32690"></a>32690           <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32691"></a>32691             fprintf(outfile, <span class="stringliteral">&quot; %d&quot;</span>, vedgecount + shift);
<a name="l32692"></a>32692           } <span class="keywordflow">else</span> {
<a name="l32693"></a>32693             vfacet-&gt;elist[index++] = vedgecount + shift;
<a name="l32694"></a>32694           }
<a name="l32695"></a>32695           <span class="comment">// Save this facet number in tet.</span>
<a name="l32696"></a>32696           tetedgeindexarray[vpointcount * 6 +
<a name="l32697"></a>32697             locver2edge[spintet.loc][spintet.ver]] = vfacecount;
<a name="l32698"></a>32698           esymself(spintet);
<a name="l32699"></a>32699           fnextself(spintet); <span class="comment">// In the same tet.</span>
<a name="l32700"></a>32700         }
<a name="l32701"></a>32701         <span class="comment">// Output internal Voronoi edges.</span>
<a name="l32702"></a>32702         <span class="keywordflow">for</span> (j = 0; j &lt; tcount; j++) {
<a name="l32703"></a>32703           vpointcount = * (<span class="keywordtype">int</span> *) (spintet.tet + elemmarkerindex);
<a name="l32704"></a>32704           vedgecount = tetfaceindexarray[vpointcount * 4 + spintet.loc];
<a name="l32705"></a>32705           <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32706"></a>32706             fprintf(outfile, <span class="stringliteral">&quot; %d&quot;</span>, vedgecount + shift);
<a name="l32707"></a>32707           } <span class="keywordflow">else</span> {
<a name="l32708"></a>32708             vfacet-&gt;elist[index++] = vedgecount + shift;
<a name="l32709"></a>32709           }
<a name="l32710"></a>32710           <span class="comment">// Save this facet number in tet.</span>
<a name="l32711"></a>32711           tetedgeindexarray[vpointcount * 6 +
<a name="l32712"></a>32712             locver2edge[spintet.loc][spintet.ver]] = vfacecount;
<a name="l32713"></a>32713           fnextself(spintet);
<a name="l32714"></a>32714         }
<a name="l32715"></a>32715         <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32716"></a>32716           fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l32717"></a>32717         }
<a name="l32718"></a>32718         vfacecount++;
<a name="l32719"></a>32719       }
<a name="l32720"></a>32720     } <span class="comment">// if (i = 0; i &lt; 6; i++)</span>
<a name="l32721"></a>32721     tetloop.tet = tetrahedrontraverse();
<a name="l32722"></a>32722   }
<a name="l32723"></a>32723 
<a name="l32724"></a>32724   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32725"></a>32725     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l32726"></a>32726     fclose(outfile);
<a name="l32727"></a>32727   }
<a name="l32728"></a>32728 
<a name="l32729"></a>32729   <span class="comment">// Output Voronoi cells to .v.cell file.</span>
<a name="l32730"></a>32730   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32731"></a>32731     strcpy(outfilename, b-&gt;outfilename);
<a name="l32732"></a>32732     strcat(outfilename, <span class="stringliteral">&quot;.v.cell&quot;</span>);
<a name="l32733"></a>32733   }
<a name="l32734"></a>32734 
<a name="l32735"></a>32735   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l32736"></a>32736     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32737"></a>32737       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, outfilename);
<a name="l32738"></a>32738     } <span class="keywordflow">else</span> {
<a name="l32739"></a>32739       printf(<span class="stringliteral">&quot;Writing Voronoi cells.\n&quot;</span>);
<a name="l32740"></a>32740     }
<a name="l32741"></a>32741   }
<a name="l32742"></a>32742 
<a name="l32743"></a>32743   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32744"></a>32744     outfile = fopen(outfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l32745"></a>32745     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l32746"></a>32746       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, outfilename);
<a name="l32747"></a>32747       terminatetetgen(1);
<a name="l32748"></a>32748     }
<a name="l32749"></a>32749     <span class="comment">// Number of Voronoi cells.</span>
<a name="l32750"></a>32750     fprintf(outfile, <span class="stringliteral">&quot;%ld\n&quot;</span>, points-&gt;items);
<a name="l32751"></a>32751   } <span class="keywordflow">else</span> {
<a name="l32752"></a>32752     out-&gt;numberofvcells = points-&gt;items;
<a name="l32753"></a>32753     out-&gt;vcelllist = <span class="keyword">new</span> <span class="keywordtype">int</span>*[out-&gt;numberofvcells];
<a name="l32754"></a>32754     <span class="keywordflow">if</span> (out-&gt;vcelllist == (<span class="keywordtype">int</span> **) NULL) {
<a name="l32755"></a>32755       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l32756"></a>32756       terminatetetgen(1);
<a name="l32757"></a>32757     }
<a name="l32758"></a>32758   }
<a name="l32759"></a>32759 
<a name="l32760"></a>32760   <span class="comment">// Loop through point list, for each point, output a Voronoi cell.</span>
<a name="l32761"></a>32761   tetlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(triface), NULL, 256);
<a name="l32762"></a>32762   ptlist = <span class="keyword">new</span> list(<span class="keyword">sizeof</span>(point *), NULL, 256);
<a name="l32763"></a>32763   points-&gt;traversalinit();
<a name="l32764"></a>32764   ptloop = pointtraverse();
<a name="l32765"></a>32765   vpointcount = 0;
<a name="l32766"></a>32766   <span class="keywordflow">while</span> (ptloop != (point) NULL) {
<a name="l32767"></a>32767     decode(point2tet(ptloop), tetloop);
<a name="l32768"></a>32768     <span class="comment">// assert(!isdead(&amp;tetloop));</span>
<a name="l32769"></a>32769     <span class="keywordflow">if</span> (!isdead(&amp;tetloop)) {
<a name="l32770"></a>32770       <span class="comment">// Form the star of p.</span>
<a name="l32771"></a>32771       tetlist-&gt;append(&amp;tetloop);
<a name="l32772"></a>32772       formstarpolyhedron(ptloop, tetlist, ptlist, <span class="keyword">true</span>);
<a name="l32773"></a>32773       tcount = ptlist-&gt;len();
<a name="l32774"></a>32774       <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32775"></a>32775         fprintf(outfile, <span class="stringliteral">&quot;%4d  %-2d &quot;</span>, vpointcount + shift, tcount);
<a name="l32776"></a>32776       } <span class="keywordflow">else</span> {
<a name="l32777"></a>32777         arraysize = tcount;
<a name="l32778"></a>32778         vertarray = out-&gt;vcelllist[vpointcount];
<a name="l32779"></a>32779         vertarray = <span class="keyword">new</span> <span class="keywordtype">int</span>[arraysize + 1];
<a name="l32780"></a>32780         vertarray[0] = arraysize;
<a name="l32781"></a>32781         index = 1;
<a name="l32782"></a>32782       }
<a name="l32783"></a>32783       <span class="comment">// List Voronoi facets bounding this cell.</span>
<a name="l32784"></a>32784       <span class="keywordflow">for</span> (i = 0; i &lt; ptlist-&gt;len(); i++) {
<a name="l32785"></a>32785         neipt =  * (point *)(* ptlist)[i];
<a name="l32786"></a>32786         <span class="comment">// Find a tet in tetlist having edge (ptloop, neipt) -- Very Slow.</span>
<a name="l32787"></a>32787         <span class="keywordflow">for</span> (j = 0; j &lt; tetlist-&gt;len(); j++) {
<a name="l32788"></a>32788           tetloop = * (triface *)(* tetlist)[j];
<a name="l32789"></a>32789           <span class="keywordflow">for</span> (k = 0; k &lt; 6; k++) {
<a name="l32790"></a>32790             tetloop.loc = edge2locver[k][0];
<a name="l32791"></a>32791             tetloop.ver = edge2locver[k][1];
<a name="l32792"></a>32792             <span class="keywordflow">if</span> (org(tetloop) == ptloop) {
<a name="l32793"></a>32793               <span class="keywordflow">if</span> (dest(tetloop) == neipt) <span class="keywordflow">break</span>;
<a name="l32794"></a>32794             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (org(tetloop) == neipt) {
<a name="l32795"></a>32795               <span class="keywordflow">if</span> (dest(tetloop) == ptloop) <span class="keywordflow">break</span>;
<a name="l32796"></a>32796             }
<a name="l32797"></a>32797           }
<a name="l32798"></a>32798           <span class="keywordflow">if</span> (k &lt; 6) <span class="keywordflow">break</span>; <span class="comment">// Found this edge.</span>
<a name="l32799"></a>32799         }
<a name="l32800"></a>32800         assert(j &lt; tetlist-&gt;len());
<a name="l32801"></a>32801         <span class="comment">// k is the right edge number.</span>
<a name="l32802"></a>32802         end1 = * (<span class="keywordtype">int</span> *) (tetloop.tet + elemmarkerindex);
<a name="l32803"></a>32803         vfacecount = tetedgeindexarray[end1 * 6 + k];
<a name="l32804"></a>32804         <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32805"></a>32805           fprintf(outfile, <span class="stringliteral">&quot; %d&quot;</span>, vfacecount + shift);
<a name="l32806"></a>32806         } <span class="keywordflow">else</span> {
<a name="l32807"></a>32807           vertarray[index++] = vfacecount + shift;
<a name="l32808"></a>32808         }
<a name="l32809"></a>32809       } <span class="comment">// for (i = 0; i &lt; ptlist-&gt;len(); i++) {</span>
<a name="l32810"></a>32810       <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32811"></a>32811         fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l32812"></a>32812       }
<a name="l32813"></a>32813       vpointcount++;
<a name="l32814"></a>32814     }
<a name="l32815"></a>32815     tetlist-&gt;clear();
<a name="l32816"></a>32816     ptlist-&gt;clear();
<a name="l32817"></a>32817     ptloop = pointtraverse();
<a name="l32818"></a>32818   }
<a name="l32819"></a>32819   <span class="keyword">delete</span> tetlist;
<a name="l32820"></a>32820   <span class="keyword">delete</span> ptlist;
<a name="l32821"></a>32821   <span class="keyword">delete</span> [] tetfaceindexarray;
<a name="l32822"></a>32822   <span class="keyword">delete</span> [] tetedgeindexarray;
<a name="l32823"></a>32823 
<a name="l32824"></a>32824   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32825"></a>32825     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l32826"></a>32826     fclose(outfile);
<a name="l32827"></a>32827   }
<a name="l32828"></a>32828 }
<a name="l32829"></a>32829 
<a name="l32831"></a>32831 <span class="comment">//                                                                           //</span>
<a name="l32832"></a>32832 <span class="comment">// outpbcnodes()    Output pbc node pairs to a .pbc file or a structure.     //</span>
<a name="l32833"></a>32833 <span class="comment">//                                                                           //</span>
<a name="l32835"></a>32835 <span class="comment"></span>
<a name="l32836"></a>32836 <span class="keywordtype">void</span> tetgenmesh::outpbcnodes(tetgenio* out)
<a name="l32837"></a>32837 {
<a name="l32838"></a>32838   FILE *outfile;
<a name="l32839"></a>32839   <span class="keywordtype">char</span> pbcfilename[FILENAMESIZE];
<a name="l32840"></a>32840   list *ptpairlist;
<a name="l32841"></a>32841   tetgenio::pbcgroup *pgi, *pgo;
<a name="l32842"></a>32842   pbcdata *pd;
<a name="l32843"></a>32843   face faceloop;
<a name="l32844"></a>32844   face checkseg, symseg;
<a name="l32845"></a>32845   point *ptpair, pa, pb;
<a name="l32846"></a>32846   <span class="keyword">enum</span> locateresult loc;
<a name="l32847"></a>32847   REAL sympt[3], d1, d2;
<a name="l32848"></a>32848   <span class="keywordtype">int</span> *worklist;
<a name="l32849"></a>32849   <span class="keywordtype">int</span> firstindex, shift;
<a name="l32850"></a>32850   <span class="keywordtype">int</span> index, idx;
<a name="l32851"></a>32851   <span class="keywordtype">int</span> i, j, k, l;
<a name="l32852"></a>32852 
<a name="l32853"></a>32853   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32854"></a>32854     strcpy(pbcfilename, b-&gt;outfilename);
<a name="l32855"></a>32855     strcat(pbcfilename, <span class="stringliteral">&quot;.pbc&quot;</span>);
<a name="l32856"></a>32856   }
<a name="l32857"></a>32857 
<a name="l32858"></a>32858   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l32859"></a>32859     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32860"></a>32860       printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, pbcfilename);
<a name="l32861"></a>32861     } <span class="keywordflow">else</span> {
<a name="l32862"></a>32862       printf(<span class="stringliteral">&quot;Writing pbc nodes.\n&quot;</span>);
<a name="l32863"></a>32863     }
<a name="l32864"></a>32864   }
<a name="l32865"></a>32865 
<a name="l32866"></a>32866   <span class="comment">// Avoid compilation warnings.</span>
<a name="l32867"></a>32867   outfile = (FILE *) NULL;
<a name="l32868"></a>32868   pgo = (tetgenio::pbcgroup *) NULL;
<a name="l32869"></a>32869   index = 0;
<a name="l32870"></a>32870 
<a name="l32871"></a>32871   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32872"></a>32872     outfile = fopen(pbcfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l32873"></a>32873     <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l32874"></a>32874       printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, pbcfilename);
<a name="l32875"></a>32875       terminatetetgen(1);
<a name="l32876"></a>32876     }
<a name="l32877"></a>32877     <span class="comment">// Number of pbc groups.</span>
<a name="l32878"></a>32878     fprintf(outfile, <span class="stringliteral">&quot;# number of PBCs.\n&quot;</span>);
<a name="l32879"></a>32879     fprintf(outfile, <span class="stringliteral">&quot;%d\n\n&quot;</span>, in-&gt;numberofpbcgroups);
<a name="l32880"></a>32880   } <span class="keywordflow">else</span> {
<a name="l32881"></a>32881     out-&gt;numberofpbcgroups = in-&gt;numberofpbcgroups;
<a name="l32882"></a>32882     <span class="comment">// Allocate memory for &#39;out-&gt;pbcgrouplist&#39;.</span>
<a name="l32883"></a>32883     out-&gt;pbcgrouplist = <span class="keyword">new</span> tetgenio::pbcgroup[in-&gt;numberofpbcgroups];
<a name="l32884"></a>32884     <span class="comment">// (Next line was a bug, reported by Murry Nigel).</span>
<a name="l32885"></a>32885     <span class="keywordflow">if</span> (out-&gt;pbcgrouplist == (tetgenio::pbcgroup *) NULL) {
<a name="l32886"></a>32886       printf(<span class="stringliteral">&quot;Error:  Out of memory.\n&quot;</span>);
<a name="l32887"></a>32887       terminatetetgen(1);
<a name="l32888"></a>32888     }
<a name="l32889"></a>32889   }
<a name="l32890"></a>32890 
<a name="l32891"></a>32891   ptpairlist = <span class="keyword">new</span> list(2 * <span class="keyword">sizeof</span>(point *), NULL, 256);
<a name="l32892"></a>32892   worklist = <span class="keyword">new</span> <span class="keywordtype">int</span>[points-&gt;items + 1];
<a name="l32893"></a>32893   <span class="keywordflow">for</span> (i = 0; i &lt; points-&gt;items + 1; i++) worklist[i] = 0;
<a name="l32894"></a>32894 
<a name="l32895"></a>32895   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l32896"></a>32896   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l32897"></a>32897   shift = 0; <span class="comment">// Default no shiftment.</span>
<a name="l32898"></a>32898   <span class="keywordflow">if</span> ((in-&gt;firstnumber == 1) &amp;&amp; (firstindex == 0)) {
<a name="l32899"></a>32899     shift = 1; <span class="comment">// Shift the output indices by 1.</span>
<a name="l32900"></a>32900   }
<a name="l32901"></a>32901 
<a name="l32902"></a>32902   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofpbcgroups; i++) {
<a name="l32903"></a>32903     <span class="comment">// Group i.</span>
<a name="l32904"></a>32904     pgi = &amp;(in-&gt;pbcgrouplist[i]);
<a name="l32905"></a>32905     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32906"></a>32906       fprintf(outfile, <span class="stringliteral">&quot;# PBC %d\n&quot;</span>, in-&gt;firstnumber + i);
<a name="l32907"></a>32907       <span class="comment">// Output facet markers.</span>
<a name="l32908"></a>32908       fprintf(outfile, <span class="stringliteral">&quot;%d  %d\n&quot;</span>, pgi-&gt;fmark1, pgi-&gt;fmark2);
<a name="l32909"></a>32909       <span class="comment">// Output transformation matrix.</span>
<a name="l32910"></a>32910       fprintf(outfile, <span class="stringliteral">&quot;[\n&quot;</span>);
<a name="l32911"></a>32911       <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l32912"></a>32912         fprintf(outfile, <span class="stringliteral">&quot;  %.12g %.12g %.12g %.12g\n&quot;</span>, pgi-&gt;transmat[j][0],
<a name="l32913"></a>32913                 pgi-&gt;transmat[j][1], pgi-&gt;transmat[j][2], pgi-&gt;transmat[j][3]);
<a name="l32914"></a>32914       }
<a name="l32915"></a>32915       fprintf(outfile, <span class="stringliteral">&quot;]\n&quot;</span>);
<a name="l32916"></a>32916     } <span class="keywordflow">else</span> {
<a name="l32917"></a>32917       pgo = &amp;(out-&gt;pbcgrouplist[i]);
<a name="l32918"></a>32918       <span class="comment">// Copy data from pgi to pgo.</span>
<a name="l32919"></a>32919       pgo-&gt;fmark1 = pgi-&gt;fmark1;
<a name="l32920"></a>32920       pgo-&gt;fmark2 = pgi-&gt;fmark2;
<a name="l32921"></a>32921       <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++) {
<a name="l32922"></a>32922         <span class="keywordflow">for</span> (k = 0; k &lt; 4; k++) pgo-&gt;transmat[j][k] = pgi-&gt;transmat[j][k];
<a name="l32923"></a>32923       }
<a name="l32924"></a>32924     }
<a name="l32925"></a>32925 
<a name="l32926"></a>32926     <span class="comment">// Find the point pairs of group i.</span>
<a name="l32927"></a>32927     subfaces-&gt;traversalinit();
<a name="l32928"></a>32928     faceloop.sh = shellfacetraverse(subfaces);
<a name="l32929"></a>32929     <span class="keywordflow">while</span> (faceloop.sh != (shellface *) NULL) {
<a name="l32930"></a>32930       <span class="keywordflow">if</span> (shellpbcgroup(faceloop) == i) {
<a name="l32931"></a>32931         <span class="comment">// It is in group i. Operate on it if it has pgi-&gt;fmark1.</span>
<a name="l32932"></a>32932         idx = shellmark(faceloop) - 1;
<a name="l32933"></a>32933         <span class="keywordflow">if</span> (in-&gt;facetmarkerlist[idx] == pgi-&gt;fmark1) {
<a name="l32934"></a>32934           <span class="comment">// Loop three edges of the subface.</span>
<a name="l32935"></a>32935           <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l32936"></a>32936             sspivot(faceloop, checkseg);
<a name="l32937"></a>32937             <span class="comment">// Loop two vertices of the edge.</span>
<a name="l32938"></a>32938             <span class="keywordflow">for</span> (k = 0; k &lt; 2; k++) {
<a name="l32939"></a>32939               <span class="keywordflow">if</span> (k == 0) pa = sorg(faceloop);
<a name="l32940"></a>32940               <span class="keywordflow">else</span> pa = sdest(faceloop);
<a name="l32941"></a>32941               <span class="keywordflow">if</span> (worklist[pointmark(pa)] == 0) {
<a name="l32942"></a>32942                 pb = (point) NULL;
<a name="l32943"></a>32943                 <span class="keywordflow">if</span> (checkseg.sh != dummysh) {
<a name="l32944"></a>32944                   <span class="comment">// pa is on a segment. Find pb.</span>
<a name="l32945"></a>32945                   <span class="comment">// Find the incident pbcgroup of checkseg.</span>
<a name="l32946"></a>32946                   idx = shellmark(checkseg) - 1;
<a name="l32947"></a>32947                   <span class="keywordflow">for</span> (l = idx2segpglist[idx]; l &lt; idx2segpglist[idx + 1];
<a name="l32948"></a>32948                        l++) {
<a name="l32949"></a>32949                     pd = (pbcdata *)(* segpbcgrouptable)[segpglist[l]];
<a name="l32950"></a>32950                     <span class="keywordflow">if</span> (((pd-&gt;fmark[0] == pgi-&gt;fmark1) &amp;&amp;
<a name="l32951"></a>32951                          (pd-&gt;fmark[1] == pgi-&gt;fmark2)) ||
<a name="l32952"></a>32952                         ((pd-&gt;fmark[0] == pgi-&gt;fmark2) &amp;&amp;
<a name="l32953"></a>32953                          (pd-&gt;fmark[1] == pgi-&gt;fmark1))) <span class="keywordflow">break</span>;
<a name="l32954"></a>32954                   }
<a name="l32955"></a>32955 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l32956"></a>32956 <span class="preprocessor"></span>                  assert(l &lt; idx2segpglist[idx + 1]);
<a name="l32957"></a>32957 <span class="preprocessor">#endif</span>
<a name="l32958"></a>32958 <span class="preprocessor"></span>                  loc = getsegpbcsympoint(pa, &amp;checkseg, sympt, &amp;symseg,
<a name="l32959"></a>32959                                           segpglist[l]);
<a name="l32960"></a>32960                   <span class="keywordflow">if</span> (loc != ONVERTEX) {
<a name="l32961"></a>32961                     <span class="comment">// Not found a match point! It may be caused by the</span>
<a name="l32962"></a>32962                     <span class="comment">//   pair of input vertices don&#39;t have enough digits.</span>
<a name="l32963"></a>32963                     <span class="comment">//   Choose a near vertex.</span>
<a name="l32964"></a>32964                     d1 = distance(sympt, sorg(symseg));
<a name="l32965"></a>32965                     d2 = distance(sympt, sdest(symseg));
<a name="l32966"></a>32966                     <span class="keywordflow">if</span> (d1 &gt; d2) sesymself(symseg);
<a name="l32967"></a>32967                   }
<a name="l32968"></a>32968                   pb = sorg(symseg);
<a name="l32969"></a>32969                 } <span class="keywordflow">else</span> {
<a name="l32970"></a>32970                   <span class="comment">// Operate on pa if it is inside the facet.</span>
<a name="l32971"></a>32971                   <span class="keywordflow">if</span> (pointtype(pa) == FREESUBVERTEX) {
<a name="l32972"></a>32972                     pb = point2pbcpt(pa);
<a name="l32973"></a>32973                   }
<a name="l32974"></a>32974                 }
<a name="l32975"></a>32975                 <span class="keywordflow">if</span> (pb != (point) NULL) {
<a name="l32976"></a>32976                   <span class="comment">// Add the pair (pa, pb) into list.</span>
<a name="l32977"></a>32977                   ptpair = (point *) ptpairlist-&gt;append(NULL);
<a name="l32978"></a>32978                   ptpair[0] = pa;
<a name="l32979"></a>32979                   ptpair[1] = pb;
<a name="l32980"></a>32980                   <span class="comment">// Mark pa (avoid to operate on it later).</span>
<a name="l32981"></a>32981                   worklist[pointmark(pa)] = 1;
<a name="l32982"></a>32982                 }
<a name="l32983"></a>32983               }
<a name="l32984"></a>32984             }
<a name="l32985"></a>32985             <span class="comment">// Get the next edge.</span>
<a name="l32986"></a>32986             senextself(faceloop);
<a name="l32987"></a>32987           }
<a name="l32988"></a>32988         }
<a name="l32989"></a>32989       }
<a name="l32990"></a>32990       faceloop.sh = shellfacetraverse(subfaces);
<a name="l32991"></a>32991     }
<a name="l32992"></a>32992 
<a name="l32993"></a>32993     <span class="comment">// Output the list of pbc points.</span>
<a name="l32994"></a>32994     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l32995"></a>32995       fprintf(outfile, <span class="stringliteral">&quot;%d\n&quot;</span>, ptpairlist-&gt;len());
<a name="l32996"></a>32996     } <span class="keywordflow">else</span> {
<a name="l32997"></a>32997       pgo-&gt;numberofpointpairs = ptpairlist-&gt;len();
<a name="l32998"></a>32998       pgo-&gt;pointpairlist = <span class="keyword">new</span> <span class="keywordtype">int</span>[pgo-&gt;numberofpointpairs * 2];
<a name="l32999"></a>32999       index = 0;
<a name="l33000"></a>33000     }
<a name="l33001"></a>33001     <span class="keywordflow">for</span> (j = 0; j &lt; ptpairlist-&gt;len(); j++) {
<a name="l33002"></a>33002       ptpair = (point *)(* ptpairlist)[j];
<a name="l33003"></a>33003       pa = ptpair[0];
<a name="l33004"></a>33004       pb = ptpair[1];
<a name="l33005"></a>33005       <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l33006"></a>33006         fprintf(outfile, <span class="stringliteral">&quot;  %4d %4d\n&quot;</span>, pointmark(pa) - shift,
<a name="l33007"></a>33007                 pointmark(pb) - shift);
<a name="l33008"></a>33008       } <span class="keywordflow">else</span> {
<a name="l33009"></a>33009         pgo-&gt;pointpairlist[index++] = pointmark(pa) - shift;
<a name="l33010"></a>33010         pgo-&gt;pointpairlist[index++] = pointmark(pb) - shift;
<a name="l33011"></a>33011       }
<a name="l33012"></a>33012       <span class="comment">// Unmark pa.</span>
<a name="l33013"></a>33013       worklist[pointmark(pa)] = 0;
<a name="l33014"></a>33014     }
<a name="l33015"></a>33015     <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l33016"></a>33016       fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33017"></a>33017     }
<a name="l33018"></a>33018     ptpairlist-&gt;clear();
<a name="l33019"></a>33019   }
<a name="l33020"></a>33020 
<a name="l33021"></a>33021   <span class="keyword">delete</span> [] worklist;
<a name="l33022"></a>33022   <span class="keyword">delete</span> ptpairlist;
<a name="l33023"></a>33023 
<a name="l33024"></a>33024   <span class="keywordflow">if</span> (out == (tetgenio *) NULL) {
<a name="l33025"></a>33025     fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l33026"></a>33026     fclose(outfile);
<a name="l33027"></a>33027   }
<a name="l33028"></a>33028 }
<a name="l33029"></a>33029 
<a name="l33031"></a>33031 <span class="comment">//                                                                           //</span>
<a name="l33032"></a>33032 <span class="comment">// outsmesh()    Write surface mesh to a .smesh file, which can be read and  //</span>
<a name="l33033"></a>33033 <span class="comment">//               tetrahedralized by TetGen.                                  //</span>
<a name="l33034"></a>33034 <span class="comment">//                                                                           //</span>
<a name="l33035"></a>33035 <span class="comment">// You can specify a filename (without suffix) in &#39;smfilename&#39;. If you don&#39;t //</span>
<a name="l33036"></a>33036 <span class="comment">// supply a filename (let smfilename be NULL), the default name stored in    //</span>
<a name="l33037"></a>33037 <span class="comment">// &#39;tetgenbehavior&#39; will be used.                                            //</span>
<a name="l33038"></a>33038 <span class="comment">//                                                                           //</span>
<a name="l33040"></a>33040 <span class="comment"></span>
<a name="l33041"></a>33041 <span class="keywordtype">void</span> tetgenmesh::outsmesh(<span class="keywordtype">char</span>* smfilename)
<a name="l33042"></a>33042 {
<a name="l33043"></a>33043   FILE *outfile;
<a name="l33044"></a>33044   <span class="keywordtype">char</span> nodfilename[FILENAMESIZE];
<a name="l33045"></a>33045   <span class="keywordtype">char</span> smefilename[FILENAMESIZE];
<a name="l33046"></a>33046   face faceloop;
<a name="l33047"></a>33047   point p1, p2, p3;
<a name="l33048"></a>33048   <span class="keywordtype">int</span> firstindex, shift;
<a name="l33049"></a>33049   <span class="keywordtype">int</span> bmark;
<a name="l33050"></a>33050   <span class="keywordtype">int</span> faceid, marker;
<a name="l33051"></a>33051   <span class="keywordtype">int</span> i;
<a name="l33052"></a>33052 
<a name="l33053"></a>33053   <span class="keywordflow">if</span> (smfilename != (<span class="keywordtype">char</span> *) NULL &amp;&amp; smfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33054"></a>33054     strcpy(smefilename, smfilename);
<a name="l33055"></a>33055   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;outfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33056"></a>33056     strcpy(smefilename, b-&gt;outfilename);
<a name="l33057"></a>33057   } <span class="keywordflow">else</span> {
<a name="l33058"></a>33058     strcpy(smefilename, <span class="stringliteral">&quot;unnamed&quot;</span>);
<a name="l33059"></a>33059   }
<a name="l33060"></a>33060   strcpy(nodfilename, smefilename);
<a name="l33061"></a>33061   strcat(smefilename, <span class="stringliteral">&quot;.smesh&quot;</span>);
<a name="l33062"></a>33062   strcat(nodfilename, <span class="stringliteral">&quot;.node&quot;</span>);
<a name="l33063"></a>33063 
<a name="l33064"></a>33064   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33065"></a>33065     printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, smefilename);
<a name="l33066"></a>33066   }
<a name="l33067"></a>33067   outfile = fopen(smefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l33068"></a>33068   <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l33069"></a>33069     printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, smefilename);
<a name="l33070"></a>33070     <span class="keywordflow">return</span>;
<a name="l33071"></a>33071   }
<a name="l33072"></a>33072 
<a name="l33073"></a>33073   <span class="comment">// Determine the first index (0 or 1).</span>
<a name="l33074"></a>33074   firstindex = b-&gt;zeroindex ? 0 : in-&gt;firstnumber;
<a name="l33075"></a>33075   shift = 0; <span class="comment">// Default no shiftment.</span>
<a name="l33076"></a>33076   <span class="keywordflow">if</span> ((in-&gt;firstnumber == 1) &amp;&amp; (firstindex == 0)) {
<a name="l33077"></a>33077     shift = 1; <span class="comment">// Shift the output indices by 1.</span>
<a name="l33078"></a>33078   }
<a name="l33079"></a>33079 
<a name="l33080"></a>33080   fprintf(outfile, <span class="stringliteral">&quot;# %s.  TetGen&#39;s input file.\n&quot;</span>, smefilename);
<a name="l33081"></a>33081   fprintf(outfile, <span class="stringliteral">&quot;\n# part 1: node list.\n&quot;</span>);
<a name="l33082"></a>33082   fprintf(outfile, <span class="stringliteral">&quot;0  3  0  0  # nodes are found in %s.\n&quot;</span>, nodfilename);
<a name="l33083"></a>33083 
<a name="l33084"></a>33084   marker = 0; <span class="comment">// avoid compile warning.</span>
<a name="l33085"></a>33085   bmark = !b-&gt;nobound &amp;&amp; in-&gt;facetmarkerlist;
<a name="l33086"></a>33086 
<a name="l33087"></a>33087   fprintf(outfile, <span class="stringliteral">&quot;\n# part 2: facet list.\n&quot;</span>);
<a name="l33088"></a>33088   <span class="comment">// Number of facets, boundary marker.</span>
<a name="l33089"></a>33089   fprintf(outfile, <span class="stringliteral">&quot;%ld  %d\n&quot;</span>, subfaces-&gt;items, bmark);
<a name="l33090"></a>33090 
<a name="l33091"></a>33091   subfaces-&gt;traversalinit();
<a name="l33092"></a>33092   faceloop.sh = shellfacetraverse(subfaces);
<a name="l33093"></a>33093   <span class="keywordflow">while</span> (faceloop.sh != (shellface *) NULL) {
<a name="l33094"></a>33094     p1 = sorg(faceloop);
<a name="l33095"></a>33095     p2 = sdest(faceloop);
<a name="l33096"></a>33096     p3 = sapex(faceloop);
<a name="l33097"></a>33097     <span class="keywordflow">if</span> (bmark) {
<a name="l33098"></a>33098       faceid = shellmark(faceloop) - 1;
<a name="l33099"></a>33099       <span class="keywordflow">if</span> (faceid &gt;= 0) {
<a name="l33100"></a>33100         marker = in-&gt;facetmarkerlist[faceid];
<a name="l33101"></a>33101       } <span class="keywordflow">else</span> {
<a name="l33102"></a>33102         marker = 0; <span class="comment">// This subface must be added manually later.</span>
<a name="l33103"></a>33103       }
<a name="l33104"></a>33104     }
<a name="l33105"></a>33105     fprintf(outfile, <span class="stringliteral">&quot;3    %4d  %4d  %4d&quot;</span>, pointmark(p1) - shift,
<a name="l33106"></a>33106             pointmark(p2) - shift, pointmark(p3) - shift);
<a name="l33107"></a>33107     <span class="keywordflow">if</span> (bmark) {
<a name="l33108"></a>33108       fprintf(outfile, <span class="stringliteral">&quot;    %d&quot;</span>, marker);
<a name="l33109"></a>33109     }
<a name="l33110"></a>33110     fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33111"></a>33111     faceloop.sh = shellfacetraverse(subfaces);
<a name="l33112"></a>33112   }
<a name="l33113"></a>33113 
<a name="l33114"></a>33114   <span class="comment">// Copy input holelist.</span>
<a name="l33115"></a>33115   fprintf(outfile, <span class="stringliteral">&quot;\n# part 3: hole list.\n&quot;</span>);
<a name="l33116"></a>33116   fprintf(outfile, <span class="stringliteral">&quot;%d\n&quot;</span>, in-&gt;numberofholes);
<a name="l33117"></a>33117   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofholes; i++) {
<a name="l33118"></a>33118     fprintf(outfile, <span class="stringliteral">&quot;%d  %g  %g  %g\n&quot;</span>, i + in-&gt;firstnumber,
<a name="l33119"></a>33119             in-&gt;holelist[i * 3], in-&gt;holelist[i * 3 + 1],
<a name="l33120"></a>33120             in-&gt;holelist[i * 3 + 2]);
<a name="l33121"></a>33121   }
<a name="l33122"></a>33122 
<a name="l33123"></a>33123   <span class="comment">// Copy input regionlist.</span>
<a name="l33124"></a>33124   fprintf(outfile, <span class="stringliteral">&quot;\n# part 4: region list.\n&quot;</span>);
<a name="l33125"></a>33125   fprintf(outfile, <span class="stringliteral">&quot;%d\n&quot;</span>, in-&gt;numberofregions);
<a name="l33126"></a>33126   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofregions; i++) {
<a name="l33127"></a>33127     fprintf(outfile, <span class="stringliteral">&quot;%d  %g  %g  %g  %d  %g\n&quot;</span>, i + in-&gt;firstnumber,
<a name="l33128"></a>33128             in-&gt;regionlist[i * 5], in-&gt;regionlist[i * 5 + 1],
<a name="l33129"></a>33129             in-&gt;regionlist[i * 5 + 2], (<span class="keywordtype">int</span>) in-&gt;regionlist[i * 5 + 3],
<a name="l33130"></a>33130             in-&gt;regionlist[i * 5 + 4]);
<a name="l33131"></a>33131   }
<a name="l33132"></a>33132 
<a name="l33133"></a>33133   fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l33134"></a>33134   fclose(outfile);
<a name="l33135"></a>33135 }
<a name="l33136"></a>33136 
<a name="l33138"></a>33138 <span class="comment">//                                                                           //</span>
<a name="l33139"></a>33139 <span class="comment">// outmesh2medit()    Write mesh to a .mesh file, which can be read and      //</span>
<a name="l33140"></a>33140 <span class="comment">//                    rendered by Medit (a free mesh viewer from INRIA).     //</span>
<a name="l33141"></a>33141 <span class="comment">//                                                                           //</span>
<a name="l33142"></a>33142 <span class="comment">// You can specify a filename (without suffix) in &#39;mfilename&#39;.  If you don&#39;t //</span>
<a name="l33143"></a>33143 <span class="comment">// supply a filename (let mfilename be NULL), the default name stored in     //</span>
<a name="l33144"></a>33144 <span class="comment">// &#39;tetgenbehavior&#39; will be used. The output file will have the suffix .mesh.//</span>
<a name="l33145"></a>33145 <span class="comment">//                                                                           //</span>
<a name="l33147"></a>33147 <span class="comment"></span>
<a name="l33148"></a>33148 <span class="keywordtype">void</span> tetgenmesh::outmesh2medit(<span class="keywordtype">char</span>* mfilename)
<a name="l33149"></a>33149 {
<a name="l33150"></a>33150   FILE *outfile;
<a name="l33151"></a>33151   <span class="keywordtype">char</span> mefilename[FILENAMESIZE];
<a name="l33152"></a>33152   tetrahedron* tetptr;
<a name="l33153"></a>33153   triface tface, tsymface;
<a name="l33154"></a>33154   face segloop, checkmark;
<a name="l33155"></a>33155   point ptloop, p1, p2, p3, p4;
<a name="l33156"></a>33156   <span class="keywordtype">long</span> faces;
<a name="l33157"></a>33157   <span class="keywordtype">int</span> pointnumber;
<a name="l33158"></a>33158   <span class="keywordtype">int</span> i;
<a name="l33159"></a>33159 
<a name="l33160"></a>33160   <span class="keywordflow">if</span> (mfilename != (<span class="keywordtype">char</span> *) NULL &amp;&amp; mfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33161"></a>33161     strcpy(mefilename, mfilename);
<a name="l33162"></a>33162   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;outfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33163"></a>33163     strcpy(mefilename, b-&gt;outfilename);
<a name="l33164"></a>33164   } <span class="keywordflow">else</span> {
<a name="l33165"></a>33165     strcpy(mefilename, <span class="stringliteral">&quot;unnamed&quot;</span>);
<a name="l33166"></a>33166   }
<a name="l33167"></a>33167   strcat(mefilename, <span class="stringliteral">&quot;.mesh&quot;</span>);
<a name="l33168"></a>33168 
<a name="l33169"></a>33169   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33170"></a>33170     printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, mefilename);
<a name="l33171"></a>33171   }
<a name="l33172"></a>33172   outfile = fopen(mefilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l33173"></a>33173   <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l33174"></a>33174     printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, mefilename);
<a name="l33175"></a>33175     <span class="keywordflow">return</span>;
<a name="l33176"></a>33176   }
<a name="l33177"></a>33177 
<a name="l33178"></a>33178   fprintf(outfile, <span class="stringliteral">&quot;MeshVersionFormatted 1\n&quot;</span>);
<a name="l33179"></a>33179   fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33180"></a>33180   fprintf(outfile, <span class="stringliteral">&quot;Dimension\n&quot;</span>);
<a name="l33181"></a>33181   fprintf(outfile, <span class="stringliteral">&quot;3\n&quot;</span>);
<a name="l33182"></a>33182   fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33183"></a>33183 
<a name="l33184"></a>33184   fprintf(outfile, <span class="stringliteral">&quot;\n# Set of mesh vertices\n&quot;</span>);
<a name="l33185"></a>33185   fprintf(outfile, <span class="stringliteral">&quot;Vertices\n&quot;</span>);
<a name="l33186"></a>33186   fprintf(outfile, <span class="stringliteral">&quot;%ld\n&quot;</span>, points-&gt;items);
<a name="l33187"></a>33187 
<a name="l33188"></a>33188   points-&gt;traversalinit();
<a name="l33189"></a>33189   ptloop = pointtraverse();
<a name="l33190"></a>33190   pointnumber = 1;                        <span class="comment">// Medit need start number form 1.</span>
<a name="l33191"></a>33191   <span class="keywordflow">while</span> (ptloop != (point) NULL) {
<a name="l33192"></a>33192     <span class="comment">// Point coordinates.</span>
<a name="l33193"></a>33193     fprintf(outfile, <span class="stringliteral">&quot;%.17g  %.17g  %.17g&quot;</span>, ptloop[0], ptloop[1], ptloop[2]);
<a name="l33194"></a>33194     <span class="keywordflow">if</span> (in-&gt;numberofpointattributes &gt; 0) {
<a name="l33195"></a>33195       <span class="comment">// Write an attribute, ignore others if more than one.</span>
<a name="l33196"></a>33196       fprintf(outfile, <span class="stringliteral">&quot;  %.17g\n&quot;</span>, ptloop[3]);
<a name="l33197"></a>33197     } <span class="keywordflow">else</span> {
<a name="l33198"></a>33198       fprintf(outfile, <span class="stringliteral">&quot;    0\n&quot;</span>);
<a name="l33199"></a>33199     }
<a name="l33200"></a>33200     setpointmark(ptloop, pointnumber);
<a name="l33201"></a>33201     ptloop = pointtraverse();
<a name="l33202"></a>33202     pointnumber++;
<a name="l33203"></a>33203   }
<a name="l33204"></a>33204 
<a name="l33205"></a>33205   <span class="comment">// Compute the number of edges.</span>
<a name="l33206"></a>33206   faces = (4l * tetrahedrons-&gt;items + hullsize) / 2l;
<a name="l33207"></a>33207 
<a name="l33208"></a>33208   fprintf(outfile, <span class="stringliteral">&quot;\n# Set of Triangles\n&quot;</span>);
<a name="l33209"></a>33209   fprintf(outfile, <span class="stringliteral">&quot;Triangles\n&quot;</span>);
<a name="l33210"></a>33210   fprintf(outfile, <span class="stringliteral">&quot;%ld\n&quot;</span>, faces);
<a name="l33211"></a>33211 
<a name="l33212"></a>33212   tetrahedrons-&gt;traversalinit();
<a name="l33213"></a>33213   tface.tet = tetrahedrontraverse();
<a name="l33214"></a>33214   <span class="comment">// To loop over the set of faces, loop over all tetrahedra, and look at</span>
<a name="l33215"></a>33215   <span class="comment">//   the four faces of each tetrahedron. If there isn&#39;t another tetrahedron</span>
<a name="l33216"></a>33216   <span class="comment">//   adjacent to the face, operate on the face.  If there is another adj-</span>
<a name="l33217"></a>33217   <span class="comment">//   acent tetrahedron, operate on the face only if the current tetrahedron</span>
<a name="l33218"></a>33218   <span class="comment">//   has a smaller pointer than its neighbor.  This way, each face is</span>
<a name="l33219"></a>33219   <span class="comment">//   considered only once.</span>
<a name="l33220"></a>33220   <span class="keywordflow">while</span> (tface.tet != (tetrahedron *) NULL) {
<a name="l33221"></a>33221     <span class="keywordflow">for</span> (tface.loc = 0; tface.loc &lt; 4; tface.loc ++) {
<a name="l33222"></a>33222       sym(tface, tsymface);
<a name="l33223"></a>33223       <span class="keywordflow">if</span> (tface.tet &lt; tsymface.tet || tsymface.tet == dummytet) {
<a name="l33224"></a>33224         p1 = org (tface);
<a name="l33225"></a>33225         p2 = dest(tface);
<a name="l33226"></a>33226         p3 = apex(tface);
<a name="l33227"></a>33227         fprintf(outfile, <span class="stringliteral">&quot;%5d  %5d  %5d&quot;</span>,
<a name="l33228"></a>33228                 pointmark(p1), pointmark(p2), pointmark(p3));
<a name="l33229"></a>33229         fprintf(outfile, <span class="stringliteral">&quot;    0\n&quot;</span>);
<a name="l33230"></a>33230       }
<a name="l33231"></a>33231     }
<a name="l33232"></a>33232     tface.tet = tetrahedrontraverse();
<a name="l33233"></a>33233   }
<a name="l33234"></a>33234 
<a name="l33235"></a>33235   fprintf(outfile, <span class="stringliteral">&quot;\n# Set of Tetrahedra\n&quot;</span>);
<a name="l33236"></a>33236   fprintf(outfile, <span class="stringliteral">&quot;Tetrahedra\n&quot;</span>);
<a name="l33237"></a>33237   fprintf(outfile, <span class="stringliteral">&quot;%ld\n&quot;</span>, tetrahedrons-&gt;items);
<a name="l33238"></a>33238 
<a name="l33239"></a>33239   tetrahedrons-&gt;traversalinit();
<a name="l33240"></a>33240   tetptr = tetrahedrontraverse();
<a name="l33241"></a>33241   <span class="keywordflow">while</span> (tetptr != (tetrahedron *) NULL) {
<a name="l33242"></a>33242     p1 = (point) tetptr[4];
<a name="l33243"></a>33243     p2 = (point) tetptr[5];
<a name="l33244"></a>33244     p3 = (point) tetptr[6];
<a name="l33245"></a>33245     p4 = (point) tetptr[7];
<a name="l33246"></a>33246     fprintf(outfile, <span class="stringliteral">&quot;%5d  %5d  %5d  %5d&quot;</span>,
<a name="l33247"></a>33247             pointmark(p1), pointmark(p2), pointmark(p3), pointmark(p4));
<a name="l33248"></a>33248     <span class="keywordflow">if</span> (in-&gt;numberoftetrahedronattributes &gt; 0) {
<a name="l33249"></a>33249       fprintf(outfile, <span class="stringliteral">&quot;  %.17g&quot;</span>, elemattribute(tetptr, 0));
<a name="l33250"></a>33250     } <span class="keywordflow">else</span> {
<a name="l33251"></a>33251       fprintf(outfile, <span class="stringliteral">&quot;  0&quot;</span>);
<a name="l33252"></a>33252     }
<a name="l33253"></a>33253     fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33254"></a>33254     tetptr = tetrahedrontraverse();
<a name="l33255"></a>33255   }
<a name="l33256"></a>33256 
<a name="l33257"></a>33257   fprintf(outfile, <span class="stringliteral">&quot;\nCorners\n&quot;</span>);
<a name="l33258"></a>33258   fprintf(outfile, <span class="stringliteral">&quot;%d\n&quot;</span>, in-&gt;numberofpoints);
<a name="l33259"></a>33259 
<a name="l33260"></a>33260   <span class="keywordflow">for</span> (i = 0; i &lt; in-&gt;numberofpoints; i++) {
<a name="l33261"></a>33261     fprintf(outfile, <span class="stringliteral">&quot;%4d\n&quot;</span>, i + 1);
<a name="l33262"></a>33262   }
<a name="l33263"></a>33263 
<a name="l33264"></a>33264   <span class="keywordflow">if</span> (b-&gt;useshelles) {
<a name="l33265"></a>33265     fprintf(outfile, <span class="stringliteral">&quot;\nEdges\n&quot;</span>);
<a name="l33266"></a>33266     fprintf(outfile, <span class="stringliteral">&quot;%ld\n&quot;</span>, subsegs-&gt;items);
<a name="l33267"></a>33267 
<a name="l33268"></a>33268     subsegs-&gt;traversalinit();
<a name="l33269"></a>33269     segloop.sh = shellfacetraverse(subsegs);
<a name="l33270"></a>33270     <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l33271"></a>33271       p1 = sorg(segloop);
<a name="l33272"></a>33272       p2 = sdest(segloop);
<a name="l33273"></a>33273       fprintf(outfile, <span class="stringliteral">&quot;%5d  %5d&quot;</span>, pointmark(p1), pointmark(p2));
<a name="l33274"></a>33274       fprintf(outfile, <span class="stringliteral">&quot;    0\n&quot;</span>);
<a name="l33275"></a>33275       segloop.sh = shellfacetraverse(subsegs);
<a name="l33276"></a>33276     }
<a name="l33277"></a>33277   }
<a name="l33278"></a>33278 
<a name="l33279"></a>33279   fprintf(outfile, <span class="stringliteral">&quot;\nEnd\n&quot;</span>);
<a name="l33280"></a>33280   fclose(outfile);
<a name="l33281"></a>33281 }
<a name="l33282"></a>33282 
<a name="l33284"></a>33284 <span class="comment">//                                                                           //</span>
<a name="l33285"></a>33285 <span class="comment">// outmesh2gid()    Write mesh to a .ele.msh file and a .face.msh file,      //</span>
<a name="l33286"></a>33286 <span class="comment">//                  which can be imported and rendered by Gid.               //</span>
<a name="l33287"></a>33287 <span class="comment">//                                                                           //</span>
<a name="l33288"></a>33288 <span class="comment">// You can specify a filename (without suffix) in &#39;gfilename&#39;.  If you don&#39;t //</span>
<a name="l33289"></a>33289 <span class="comment">// supply a filename (let gfilename be NULL), the default name stored in     //</span>
<a name="l33290"></a>33290 <span class="comment">// &#39;tetgenbehavior&#39; will be used. The suffixes (.ele.msh and .face.msh) will //</span>
<a name="l33291"></a>33291 <span class="comment">// be automatically added.                                                   //</span>
<a name="l33292"></a>33292 <span class="comment">//                                                                           //</span>
<a name="l33294"></a>33294 <span class="comment"></span>
<a name="l33295"></a>33295 <span class="keywordtype">void</span> tetgenmesh::outmesh2gid(<span class="keywordtype">char</span>* gfilename)
<a name="l33296"></a>33296 {
<a name="l33297"></a>33297   FILE *outfile;
<a name="l33298"></a>33298   <span class="keywordtype">char</span> gidfilename[FILENAMESIZE];
<a name="l33299"></a>33299   tetrahedron* tetptr;
<a name="l33300"></a>33300   triface tface, tsymface;
<a name="l33301"></a>33301   face sface;
<a name="l33302"></a>33302   point ptloop, p1, p2, p3, p4;
<a name="l33303"></a>33303   <span class="keywordtype">int</span> pointnumber;
<a name="l33304"></a>33304   <span class="keywordtype">int</span> elementnumber;
<a name="l33305"></a>33305 
<a name="l33306"></a>33306   <span class="keywordflow">if</span> (gfilename != (<span class="keywordtype">char</span> *) NULL &amp;&amp; gfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33307"></a>33307     strcpy(gidfilename, gfilename);
<a name="l33308"></a>33308   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;outfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33309"></a>33309     strcpy(gidfilename, b-&gt;outfilename);
<a name="l33310"></a>33310   } <span class="keywordflow">else</span> {
<a name="l33311"></a>33311     strcpy(gidfilename, <span class="stringliteral">&quot;unnamed&quot;</span>);
<a name="l33312"></a>33312   }
<a name="l33313"></a>33313   strcat(gidfilename, <span class="stringliteral">&quot;.ele.msh&quot;</span>);
<a name="l33314"></a>33314 
<a name="l33315"></a>33315   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33316"></a>33316     printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, gidfilename);
<a name="l33317"></a>33317   }
<a name="l33318"></a>33318   outfile = fopen(gidfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l33319"></a>33319   <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l33320"></a>33320     printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, gidfilename);
<a name="l33321"></a>33321     <span class="keywordflow">return</span>;
<a name="l33322"></a>33322   }
<a name="l33323"></a>33323 
<a name="l33324"></a>33324   fprintf(outfile, <span class="stringliteral">&quot;mesh dimension = 3 elemtype tetrahedron nnode = 4\n&quot;</span>);
<a name="l33325"></a>33325   fprintf(outfile, <span class="stringliteral">&quot;coordinates\n&quot;</span>);
<a name="l33326"></a>33326 
<a name="l33327"></a>33327   points-&gt;traversalinit();
<a name="l33328"></a>33328   ptloop = pointtraverse();
<a name="l33329"></a>33329   pointnumber = 1;                        <span class="comment">// Gid need start number form 1.</span>
<a name="l33330"></a>33330   <span class="keywordflow">while</span> (ptloop != (point) NULL) {
<a name="l33331"></a>33331     <span class="comment">// Point coordinates.</span>
<a name="l33332"></a>33332     fprintf(outfile, <span class="stringliteral">&quot;%4d  %.17g %.17g %.17g&quot;</span>, pointnumber,
<a name="l33333"></a>33333             ptloop[0], ptloop[1], ptloop[2]);
<a name="l33334"></a>33334     <span class="keywordflow">if</span> (in-&gt;numberofpointattributes &gt; 0) {
<a name="l33335"></a>33335       <span class="comment">// Write an attribute, ignore others if more than one.</span>
<a name="l33336"></a>33336       fprintf(outfile, <span class="stringliteral">&quot;  %.17g&quot;</span>, ptloop[3]);
<a name="l33337"></a>33337     }
<a name="l33338"></a>33338     fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33339"></a>33339     setpointmark(ptloop, pointnumber);
<a name="l33340"></a>33340     ptloop = pointtraverse();
<a name="l33341"></a>33341     pointnumber++;
<a name="l33342"></a>33342   }
<a name="l33343"></a>33343 
<a name="l33344"></a>33344   fprintf(outfile, <span class="stringliteral">&quot;end coordinates\n&quot;</span>);
<a name="l33345"></a>33345   fprintf(outfile, <span class="stringliteral">&quot;elements\n&quot;</span>);
<a name="l33346"></a>33346 
<a name="l33347"></a>33347   tetrahedrons-&gt;traversalinit();
<a name="l33348"></a>33348   tetptr = tetrahedrontraverse();
<a name="l33349"></a>33349   elementnumber = 1;
<a name="l33350"></a>33350   <span class="keywordflow">while</span> (tetptr != (tetrahedron *) NULL) {
<a name="l33351"></a>33351     p1 = (point) tetptr[4];
<a name="l33352"></a>33352     p2 = (point) tetptr[5];
<a name="l33353"></a>33353     p3 = (point) tetptr[6];
<a name="l33354"></a>33354     p4 = (point) tetptr[7];
<a name="l33355"></a>33355     fprintf(outfile, <span class="stringliteral">&quot;%5d  %5d %5d %5d %5d&quot;</span>, elementnumber,
<a name="l33356"></a>33356             pointmark(p1), pointmark(p2), pointmark(p3), pointmark(p4));
<a name="l33357"></a>33357     <span class="keywordflow">if</span> (in-&gt;numberoftetrahedronattributes &gt; 0) {
<a name="l33358"></a>33358       fprintf(outfile, <span class="stringliteral">&quot;  %.17g&quot;</span>, elemattribute(tetptr, 0));
<a name="l33359"></a>33359     }
<a name="l33360"></a>33360     fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33361"></a>33361     tetptr = tetrahedrontraverse();
<a name="l33362"></a>33362     elementnumber++;
<a name="l33363"></a>33363   }
<a name="l33364"></a>33364 
<a name="l33365"></a>33365   fprintf(outfile, <span class="stringliteral">&quot;end elements\n&quot;</span>);
<a name="l33366"></a>33366   fclose(outfile);
<a name="l33367"></a>33367 
<a name="l33368"></a>33368   <span class="keywordflow">if</span> (gfilename != (<span class="keywordtype">char</span> *) NULL &amp;&amp; gfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33369"></a>33369     strcpy(gidfilename, gfilename);
<a name="l33370"></a>33370   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;outfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33371"></a>33371     strcpy(gidfilename, b-&gt;outfilename);
<a name="l33372"></a>33372   } <span class="keywordflow">else</span> {
<a name="l33373"></a>33373     strcpy(gidfilename, <span class="stringliteral">&quot;unnamed&quot;</span>);
<a name="l33374"></a>33374   }
<a name="l33375"></a>33375   strcat(gidfilename, <span class="stringliteral">&quot;.face.msh&quot;</span>);
<a name="l33376"></a>33376 
<a name="l33377"></a>33377   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33378"></a>33378     printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, gidfilename);
<a name="l33379"></a>33379   }
<a name="l33380"></a>33380   outfile = fopen(gidfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l33381"></a>33381   <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l33382"></a>33382     printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, gidfilename);
<a name="l33383"></a>33383     <span class="keywordflow">return</span>;
<a name="l33384"></a>33384   }
<a name="l33385"></a>33385 
<a name="l33386"></a>33386   fprintf(outfile, <span class="stringliteral">&quot;mesh dimension = 3 elemtype triangle nnode = 3\n&quot;</span>);
<a name="l33387"></a>33387   fprintf(outfile, <span class="stringliteral">&quot;coordinates\n&quot;</span>);
<a name="l33388"></a>33388 
<a name="l33389"></a>33389   points-&gt;traversalinit();
<a name="l33390"></a>33390   ptloop = pointtraverse();
<a name="l33391"></a>33391   pointnumber = 1;                        <span class="comment">// Gid need start number form 1.</span>
<a name="l33392"></a>33392   <span class="keywordflow">while</span> (ptloop != (point) NULL) {
<a name="l33393"></a>33393     <span class="comment">// Point coordinates.</span>
<a name="l33394"></a>33394     fprintf(outfile, <span class="stringliteral">&quot;%4d  %.17g %.17g %.17g&quot;</span>, pointnumber,
<a name="l33395"></a>33395             ptloop[0], ptloop[1], ptloop[2]);
<a name="l33396"></a>33396     <span class="keywordflow">if</span> (in-&gt;numberofpointattributes &gt; 0) {
<a name="l33397"></a>33397       <span class="comment">// Write an attribute, ignore others if more than one.</span>
<a name="l33398"></a>33398       fprintf(outfile, <span class="stringliteral">&quot;  %.17g&quot;</span>, ptloop[3]);
<a name="l33399"></a>33399     }
<a name="l33400"></a>33400     fprintf(outfile, <span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33401"></a>33401     setpointmark(ptloop, pointnumber);
<a name="l33402"></a>33402     ptloop = pointtraverse();
<a name="l33403"></a>33403     pointnumber++;
<a name="l33404"></a>33404   }
<a name="l33405"></a>33405 
<a name="l33406"></a>33406   fprintf(outfile, <span class="stringliteral">&quot;end coordinates\n&quot;</span>);
<a name="l33407"></a>33407   fprintf(outfile, <span class="stringliteral">&quot;elements\n&quot;</span>);
<a name="l33408"></a>33408 
<a name="l33409"></a>33409   tetrahedrons-&gt;traversalinit();
<a name="l33410"></a>33410   tface.tet = tetrahedrontraverse();
<a name="l33411"></a>33411   elementnumber = 1;
<a name="l33412"></a>33412   <span class="keywordflow">while</span> (tface.tet != (tetrahedron *) NULL) {
<a name="l33413"></a>33413     <span class="keywordflow">for</span> (tface.loc = 0; tface.loc &lt; 4; tface.loc ++) {
<a name="l33414"></a>33414       sym(tface, tsymface);
<a name="l33415"></a>33415       <span class="keywordflow">if</span> ((tface.tet &lt; tsymface.tet) || (tsymface.tet == dummytet)) {
<a name="l33416"></a>33416         p1 = org(tface);
<a name="l33417"></a>33417         p2 = dest(tface);
<a name="l33418"></a>33418         p3 = apex(tface);
<a name="l33419"></a>33419         <span class="keywordflow">if</span> (tsymface.tet == dummytet) {
<a name="l33420"></a>33420           <span class="comment">// It&#39;s a hull face, output it.</span>
<a name="l33421"></a>33421           fprintf(outfile, <span class="stringliteral">&quot;%5d   %d  %d  %d\n&quot;</span>, elementnumber,
<a name="l33422"></a>33422                   pointmark(p1), pointmark(p2), pointmark(p3));
<a name="l33423"></a>33423           elementnumber++;
<a name="l33424"></a>33424         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;useshelles) {
<a name="l33425"></a>33425           <span class="comment">// Only output it if it&#39;s a subface.</span>
<a name="l33426"></a>33426           tspivot(tface, sface);
<a name="l33427"></a>33427           <span class="keywordflow">if</span> (sface.sh != dummysh) {
<a name="l33428"></a>33428             fprintf(outfile, <span class="stringliteral">&quot;%5d   %d  %d  %d\n&quot;</span>, elementnumber,
<a name="l33429"></a>33429                     pointmark(p1), pointmark(p2), pointmark(p3));
<a name="l33430"></a>33430             elementnumber++;
<a name="l33431"></a>33431           }
<a name="l33432"></a>33432         }
<a name="l33433"></a>33433       }
<a name="l33434"></a>33434     }
<a name="l33435"></a>33435     tface.tet = tetrahedrontraverse();
<a name="l33436"></a>33436   }
<a name="l33437"></a>33437 
<a name="l33438"></a>33438   fprintf(outfile, <span class="stringliteral">&quot;end elements\n&quot;</span>);
<a name="l33439"></a>33439   fclose(outfile);
<a name="l33440"></a>33440 }
<a name="l33441"></a>33441 
<a name="l33443"></a>33443 <span class="comment">//                                                                           //</span>
<a name="l33444"></a>33444 <span class="comment">// outmesh2off()    Write the mesh to an .off file.                          //</span>
<a name="l33445"></a>33445 <span class="comment">//                                                                           //</span>
<a name="l33446"></a>33446 <span class="comment">// .off, the Object File Format, is one of the popular file formats from the //</span>
<a name="l33447"></a>33447 <span class="comment">// Geometry Center&#39;s Geomview package (http://www.geomview.org).             //</span>
<a name="l33448"></a>33448 <span class="comment">//                                                                           //</span>
<a name="l33450"></a>33450 <span class="comment"></span>
<a name="l33451"></a>33451 <span class="keywordtype">void</span> tetgenmesh::outmesh2off(<span class="keywordtype">char</span>* ofilename)
<a name="l33452"></a>33452 {
<a name="l33453"></a>33453   FILE *outfile;
<a name="l33454"></a>33454   <span class="keywordtype">char</span> offfilename[FILENAMESIZE];
<a name="l33455"></a>33455   triface tface, tsymface;
<a name="l33456"></a>33456   point ptloop, p1, p2, p3;
<a name="l33457"></a>33457   <span class="keywordtype">long</span> faces;
<a name="l33458"></a>33458   <span class="keywordtype">int</span> shift;
<a name="l33459"></a>33459 
<a name="l33460"></a>33460   <span class="keywordflow">if</span> (ofilename != (<span class="keywordtype">char</span> *) NULL &amp;&amp; ofilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33461"></a>33461     strcpy(offfilename, ofilename);
<a name="l33462"></a>33462   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;outfilename[0] != <span class="charliteral">&#39;\0&#39;</span>) {
<a name="l33463"></a>33463     strcpy(offfilename, b-&gt;outfilename);
<a name="l33464"></a>33464   } <span class="keywordflow">else</span> {
<a name="l33465"></a>33465     strcpy(offfilename, <span class="stringliteral">&quot;unnamed&quot;</span>);
<a name="l33466"></a>33466   }
<a name="l33467"></a>33467   strcat(offfilename, <span class="stringliteral">&quot;.off&quot;</span>);
<a name="l33468"></a>33468 
<a name="l33469"></a>33469   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33470"></a>33470     printf(<span class="stringliteral">&quot;Writing %s.\n&quot;</span>, offfilename);
<a name="l33471"></a>33471   }
<a name="l33472"></a>33472   outfile = fopen(offfilename, <span class="stringliteral">&quot;w&quot;</span>);
<a name="l33473"></a>33473   <span class="keywordflow">if</span> (outfile == (FILE *) NULL) {
<a name="l33474"></a>33474     printf(<span class="stringliteral">&quot;File I/O Error:  Cannot create file %s.\n&quot;</span>, offfilename);
<a name="l33475"></a>33475     <span class="keywordflow">return</span>;
<a name="l33476"></a>33476   }
<a name="l33477"></a>33477 
<a name="l33478"></a>33478   <span class="comment">// Calculate the number of triangular faces in the tetrahedral mesh.</span>
<a name="l33479"></a>33479   faces = (4l * tetrahedrons-&gt;items + hullsize) / 2l;
<a name="l33480"></a>33480 
<a name="l33481"></a>33481   <span class="comment">// Number of points, faces, and edges(not used, here show hullsize).</span>
<a name="l33482"></a>33482   fprintf(outfile, <span class="stringliteral">&quot;OFF\n%ld  %ld  %ld\n&quot;</span>, points-&gt;items, faces, hullsize);
<a name="l33483"></a>33483 
<a name="l33484"></a>33484   <span class="comment">// Write the points.</span>
<a name="l33485"></a>33485   points-&gt;traversalinit();
<a name="l33486"></a>33486   ptloop = pointtraverse();
<a name="l33487"></a>33487   <span class="keywordflow">while</span> (ptloop != (point) NULL) {
<a name="l33488"></a>33488     fprintf(outfile, <span class="stringliteral">&quot; %.17g  %.17g  %.17g\n&quot;</span>,ptloop[0], ptloop[1], ptloop[2]);
<a name="l33489"></a>33489     ptloop = pointtraverse();
<a name="l33490"></a>33490   }
<a name="l33491"></a>33491 
<a name="l33492"></a>33492   <span class="comment">// OFF always use zero as the first index.</span>
<a name="l33493"></a>33493   shift = in-&gt;firstnumber == 1 ? 1 : 0;
<a name="l33494"></a>33494 
<a name="l33495"></a>33495   tetrahedrons-&gt;traversalinit();
<a name="l33496"></a>33496   tface.tet = tetrahedrontraverse();
<a name="l33497"></a>33497   <span class="comment">// To loop over the set of faces, loop over all tetrahedra, and look at</span>
<a name="l33498"></a>33498   <span class="comment">//   the four faces of each tetrahedron. If there isn&#39;t another tetrahedron</span>
<a name="l33499"></a>33499   <span class="comment">//   adjacent to the face, operate on the face.  If there is another adj-</span>
<a name="l33500"></a>33500   <span class="comment">//   acent tetrahedron, operate on the face only if the current tetrahedron</span>
<a name="l33501"></a>33501   <span class="comment">//   has a smaller pointer than its neighbor.  This way, each face is</span>
<a name="l33502"></a>33502   <span class="comment">//   considered only once.</span>
<a name="l33503"></a>33503   <span class="keywordflow">while</span> (tface.tet != (tetrahedron *) NULL) {
<a name="l33504"></a>33504     <span class="keywordflow">for</span> (tface.loc = 0; tface.loc &lt; 4; tface.loc ++) {
<a name="l33505"></a>33505       sym(tface, tsymface);
<a name="l33506"></a>33506       <span class="keywordflow">if</span> ((tface.tet &lt; tsymface.tet) || (tsymface.tet == dummytet)) {
<a name="l33507"></a>33507         p1 = org(tface);
<a name="l33508"></a>33508         p2 = dest(tface);
<a name="l33509"></a>33509         p3 = apex(tface);
<a name="l33510"></a>33510         <span class="comment">// Face number, indices of three vertexs.</span>
<a name="l33511"></a>33511         fprintf(outfile, <span class="stringliteral">&quot;3   %4d  %4d  %4d\n&quot;</span>, pointmark(p1) - shift,
<a name="l33512"></a>33512                 pointmark(p2) - shift, pointmark(p3) - shift);
<a name="l33513"></a>33513       }
<a name="l33514"></a>33514     }
<a name="l33515"></a>33515     tface.tet = tetrahedrontraverse();
<a name="l33516"></a>33516   }
<a name="l33517"></a>33517 
<a name="l33518"></a>33518   fprintf(outfile, <span class="stringliteral">&quot;# Generated by %s\n&quot;</span>, b-&gt;commandline);
<a name="l33519"></a>33519   fclose(outfile);
<a name="l33520"></a>33520 }
<a name="l33521"></a>33521 
<a name="l33522"></a>33522 <span class="comment">//</span>
<a name="l33523"></a>33523 <span class="comment">// End of I/O rouitnes</span>
<a name="l33524"></a>33524 <span class="comment">//</span>
<a name="l33525"></a>33525 
<a name="l33526"></a>33526 <span class="comment">//</span>
<a name="l33527"></a>33527 <span class="comment">// Begin of user interaction routines</span>
<a name="l33528"></a>33528 <span class="comment">//</span>
<a name="l33529"></a>33529 
<a name="l33531"></a>33531 <span class="comment">//                                                                           //</span>
<a name="l33532"></a>33532 <span class="comment">// internalerror()    Ask the user to send me the defective product.  Exit.  //</span>
<a name="l33533"></a>33533 <span class="comment">//                                                                           //</span>
<a name="l33535"></a>33535 <span class="comment"></span>
<a name="l33536"></a>33536 <span class="keywordtype">void</span> tetgenmesh::internalerror()
<a name="l33537"></a>33537 {
<a name="l33538"></a>33538   printf(<span class="stringliteral">&quot;  Please report this bug to sihang@mail.berlios.de. Include the\n&quot;</span>);
<a name="l33539"></a>33539   printf(<span class="stringliteral">&quot;    message above, your input data set, and the exact command\n&quot;</span>);
<a name="l33540"></a>33540   printf(<span class="stringliteral">&quot;    line you used to run this program, thank you.\n&quot;</span>);
<a name="l33541"></a>33541   terminatetetgen(2);
<a name="l33542"></a>33542 }
<a name="l33543"></a>33543 
<a name="l33545"></a>33545 <span class="comment">//                                                                           //</span>
<a name="l33546"></a>33546 <span class="comment">// checkmesh()    Test the mesh for topological consistency.                 //</span>
<a name="l33547"></a>33547 <span class="comment">//                                                                           //</span>
<a name="l33549"></a>33549 <span class="comment"></span>
<a name="l33550"></a>33550 <span class="keywordtype">void</span> tetgenmesh::checkmesh()
<a name="l33551"></a>33551 {
<a name="l33552"></a>33552   triface tetraloop;
<a name="l33553"></a>33553   triface oppotet, oppooppotet;
<a name="l33554"></a>33554   point tetorg, tetdest, tetapex, tetoppo;
<a name="l33555"></a>33555   REAL oritest;
<a name="l33556"></a>33556   <span class="keywordtype">int</span> horrors;
<a name="l33557"></a>33557 
<a name="l33558"></a>33558   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33559"></a>33559     printf(<span class="stringliteral">&quot;  Checking consistency of mesh...\n&quot;</span>);
<a name="l33560"></a>33560   }
<a name="l33561"></a>33561 
<a name="l33562"></a>33562   horrors = 0;
<a name="l33563"></a>33563   <span class="comment">// Run through the list of tetrahedra, checking each one.</span>
<a name="l33564"></a>33564   tetrahedrons-&gt;traversalinit();
<a name="l33565"></a>33565   tetraloop.tet = tetrahedrontraverse();
<a name="l33566"></a>33566   <span class="keywordflow">while</span> (tetraloop.tet != (tetrahedron *) NULL) {
<a name="l33567"></a>33567     <span class="comment">// Check all four faces of the tetrahedron.</span>
<a name="l33568"></a>33568     <span class="keywordflow">for</span> (tetraloop.loc = 0; tetraloop.loc &lt; 4; tetraloop.loc++) {
<a name="l33569"></a>33569       tetorg = org(tetraloop);
<a name="l33570"></a>33570       tetdest = dest(tetraloop);
<a name="l33571"></a>33571       tetapex = apex(tetraloop);
<a name="l33572"></a>33572       tetoppo = oppo(tetraloop);
<a name="l33573"></a>33573       <span class="keywordflow">if</span> (tetraloop.loc == 0) {             <span class="comment">// Only test for inversion once.</span>
<a name="l33574"></a>33574         oritest = orient3d(tetorg, tetdest, tetapex, tetoppo);
<a name="l33575"></a>33575         <span class="keywordflow">if</span> (oritest &gt;= 0.0) {
<a name="l33576"></a>33576           printf(<span class="stringliteral">&quot;  !! !! %s &quot;</span>, oritest &gt; 0.0 ? <span class="stringliteral">&quot;Inverted&quot;</span> : <span class="stringliteral">&quot;Degenerated&quot;</span>);
<a name="l33577"></a>33577           printtet(&amp;tetraloop);
<a name="l33578"></a>33578           printf(<span class="stringliteral">&quot;  orient3d = %.17g.\n&quot;</span>, oritest);
<a name="l33579"></a>33579           horrors++;
<a name="l33580"></a>33580         }
<a name="l33581"></a>33581       }
<a name="l33582"></a>33582       <span class="comment">// Find the neighboring tetrahedron on this face.</span>
<a name="l33583"></a>33583       sym(tetraloop, oppotet);
<a name="l33584"></a>33584       <span class="keywordflow">if</span> (oppotet.tet != dummytet) {
<a name="l33585"></a>33585         <span class="comment">// Check that the tetrahedron&#39;s neighbor knows it&#39;s a neighbor.</span>
<a name="l33586"></a>33586         sym(oppotet, oppooppotet);
<a name="l33587"></a>33587         <span class="keywordflow">if</span> ((tetraloop.tet != oppooppotet.tet)
<a name="l33588"></a>33588             || (tetraloop.loc != oppooppotet.loc)) {
<a name="l33589"></a>33589           printf(<span class="stringliteral">&quot;  !! !! Asymmetric tetra-tetra bond:\n&quot;</span>);
<a name="l33590"></a>33590           <span class="keywordflow">if</span> (tetraloop.tet == oppooppotet.tet) {
<a name="l33591"></a>33591             printf(<span class="stringliteral">&quot;   (Right tetrahedron, wrong orientation)\n&quot;</span>);
<a name="l33592"></a>33592           }
<a name="l33593"></a>33593           printf(<span class="stringliteral">&quot;    First &quot;</span>);
<a name="l33594"></a>33594           printtet(&amp;tetraloop);
<a name="l33595"></a>33595           printf(<span class="stringliteral">&quot;    Second (nonreciprocating) &quot;</span>);
<a name="l33596"></a>33596           printtet(&amp;oppotet);
<a name="l33597"></a>33597           horrors++;
<a name="l33598"></a>33598         }
<a name="l33599"></a>33599       }
<a name="l33600"></a>33600     }
<a name="l33601"></a>33601     tetraloop.tet = tetrahedrontraverse();
<a name="l33602"></a>33602   }
<a name="l33603"></a>33603   <span class="keywordflow">if</span> (horrors == 0) {
<a name="l33604"></a>33604     <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33605"></a>33605       printf(<span class="stringliteral">&quot;  In my studied opinion, the mesh appears to be consistent.\n&quot;</span>);
<a name="l33606"></a>33606     }
<a name="l33607"></a>33607   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (horrors == 1) {
<a name="l33608"></a>33608     printf(<span class="stringliteral">&quot;  !! !! !! !! Precisely one festering wound discovered.\n&quot;</span>);
<a name="l33609"></a>33609   } <span class="keywordflow">else</span> {
<a name="l33610"></a>33610     printf(<span class="stringliteral">&quot;  !! !! !! !! %d abominations witnessed.\n&quot;</span>, horrors);
<a name="l33611"></a>33611   }
<a name="l33612"></a>33612 }
<a name="l33613"></a>33613 
<a name="l33615"></a>33615 <span class="comment">//                                                                           //</span>
<a name="l33616"></a>33616 <span class="comment">// checkshells()       Test the boundary mesh for topological consistency.   //</span>
<a name="l33617"></a>33617 <span class="comment">//                                                                           //</span>
<a name="l33619"></a>33619 <span class="comment"></span>
<a name="l33620"></a>33620 <span class="keywordtype">void</span> tetgenmesh::checkshells()
<a name="l33621"></a>33621 {
<a name="l33622"></a>33622   triface oppotet, oppooppotet, testtet;
<a name="l33623"></a>33623   face shloop, segloop, spin;
<a name="l33624"></a>33624   face testsh, testseg, testshsh;
<a name="l33625"></a>33625   point shorg, shdest, segorg, segdest;
<a name="l33626"></a>33626   REAL checksign;
<a name="l33627"></a>33627   <span class="keywordtype">bool</span> same;
<a name="l33628"></a>33628   <span class="keywordtype">int</span> horrors;
<a name="l33629"></a>33629   <span class="keywordtype">int</span> i;
<a name="l33630"></a>33630 
<a name="l33631"></a>33631   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33632"></a>33632     printf(<span class="stringliteral">&quot;  Checking consistency of the mesh boundary...\n&quot;</span>);
<a name="l33633"></a>33633   }
<a name="l33634"></a>33634   horrors = 0;
<a name="l33635"></a>33635 
<a name="l33636"></a>33636   <span class="comment">// Run through the list of subfaces, checking each one.</span>
<a name="l33637"></a>33637   subfaces-&gt;traversalinit();
<a name="l33638"></a>33638   shloop.sh = shellfacetraverse(subfaces);
<a name="l33639"></a>33639   <span class="keywordflow">while</span> (shloop.sh != (shellface *) NULL) {
<a name="l33640"></a>33640     <span class="comment">// Check two connected tetrahedra if they exist.</span>
<a name="l33641"></a>33641     shloop.shver = 0;
<a name="l33642"></a>33642     stpivot(shloop, oppotet);
<a name="l33643"></a>33643     <span class="keywordflow">if</span> (oppotet.tet != dummytet) {
<a name="l33644"></a>33644       tspivot(oppotet, testsh);
<a name="l33645"></a>33645       <span class="keywordflow">if</span> (testsh.sh != shloop.sh) {
<a name="l33646"></a>33646         printf(<span class="stringliteral">&quot;  !! !! Wrong tetra-subface connection.\n&quot;</span>);
<a name="l33647"></a>33647         printf(<span class="stringliteral">&quot;    Tetra: &quot;</span>);
<a name="l33648"></a>33648         printtet(&amp;oppotet);
<a name="l33649"></a>33649         printf(<span class="stringliteral">&quot;    Subface: &quot;</span>);
<a name="l33650"></a>33650         printsh(&amp;shloop);
<a name="l33651"></a>33651         horrors++;
<a name="l33652"></a>33652       }
<a name="l33653"></a>33653       <span class="keywordflow">if</span> (oppo(oppotet) != (point) NULL) {
<a name="l33654"></a>33654         adjustedgering(oppotet, CCW);
<a name="l33655"></a>33655         checksign = orient3d(sorg(shloop), sdest(shloop), sapex(shloop),
<a name="l33656"></a>33656                              oppo(oppotet));
<a name="l33657"></a>33657         <span class="keywordflow">if</span> (checksign &gt;= 0.0) {
<a name="l33658"></a>33658           printf(<span class="stringliteral">&quot;  !! !! Wrong subface orientation.\n&quot;</span>);
<a name="l33659"></a>33659           printf(<span class="stringliteral">&quot;    Subface: &quot;</span>);
<a name="l33660"></a>33660           printsh(&amp;shloop);
<a name="l33661"></a>33661           horrors++;
<a name="l33662"></a>33662         }
<a name="l33663"></a>33663       }
<a name="l33664"></a>33664     }
<a name="l33665"></a>33665     sesymself(shloop);
<a name="l33666"></a>33666     stpivot(shloop, oppooppotet);
<a name="l33667"></a>33667     <span class="keywordflow">if</span> (oppooppotet.tet != dummytet) {
<a name="l33668"></a>33668       tspivot(oppooppotet, testsh);
<a name="l33669"></a>33669       <span class="keywordflow">if</span> (testsh.sh != shloop.sh) {
<a name="l33670"></a>33670         printf(<span class="stringliteral">&quot;  !! !! Wrong tetra-subface connection.\n&quot;</span>);
<a name="l33671"></a>33671         printf(<span class="stringliteral">&quot;    Tetra: &quot;</span>);
<a name="l33672"></a>33672         printtet(&amp;oppooppotet);
<a name="l33673"></a>33673         printf(<span class="stringliteral">&quot;    Subface: &quot;</span>);
<a name="l33674"></a>33674         printsh(&amp;shloop);
<a name="l33675"></a>33675         horrors++;
<a name="l33676"></a>33676       }
<a name="l33677"></a>33677       <span class="keywordflow">if</span> (oppotet.tet != dummytet) {
<a name="l33678"></a>33678         sym(oppotet, testtet);
<a name="l33679"></a>33679         <span class="keywordflow">if</span> (testtet.tet != oppooppotet.tet) {
<a name="l33680"></a>33680           printf(<span class="stringliteral">&quot;  !! !! Wrong tetra-subface-tetra connection.\n&quot;</span>);
<a name="l33681"></a>33681           printf(<span class="stringliteral">&quot;    Tetra 1: &quot;</span>);
<a name="l33682"></a>33682           printtet(&amp;oppotet);
<a name="l33683"></a>33683           printf(<span class="stringliteral">&quot;    Subface: &quot;</span>);
<a name="l33684"></a>33684           printsh(&amp;shloop);
<a name="l33685"></a>33685           printf(<span class="stringliteral">&quot;    Tetra 2: &quot;</span>);
<a name="l33686"></a>33686           printtet(&amp;oppooppotet);
<a name="l33687"></a>33687           horrors++;
<a name="l33688"></a>33688         }
<a name="l33689"></a>33689       }
<a name="l33690"></a>33690       <span class="keywordflow">if</span> (oppo(oppooppotet) != (point) NULL) {
<a name="l33691"></a>33691         adjustedgering(oppooppotet, CCW);
<a name="l33692"></a>33692         checksign = orient3d(sorg(shloop), sdest(shloop), sapex(shloop),
<a name="l33693"></a>33693                              oppo(oppooppotet));
<a name="l33694"></a>33694         <span class="keywordflow">if</span> (checksign &gt;= 0.0) {
<a name="l33695"></a>33695           printf(<span class="stringliteral">&quot;  !! !! Wrong subface orientation.\n&quot;</span>);
<a name="l33696"></a>33696           printf(<span class="stringliteral">&quot;    Subface: &quot;</span>);
<a name="l33697"></a>33697           printsh(&amp;shloop);
<a name="l33698"></a>33698           horrors++;
<a name="l33699"></a>33699         }
<a name="l33700"></a>33700       }
<a name="l33701"></a>33701     }
<a name="l33702"></a>33702     <span class="comment">// Check connection between subfaces.</span>
<a name="l33703"></a>33703     shloop.shver = 0;
<a name="l33704"></a>33704     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l33705"></a>33705       shorg = sorg(shloop);
<a name="l33706"></a>33706       shdest = sdest(shloop);
<a name="l33707"></a>33707       sspivot(shloop, testseg);
<a name="l33708"></a>33708       <span class="keywordflow">if</span> (testseg.sh != dummysh) {
<a name="l33709"></a>33709         segorg = sorg(testseg);
<a name="l33710"></a>33710         segdest = sdest(testseg);
<a name="l33711"></a>33711         same = ((shorg == segorg) &amp;&amp; (shdest == segdest))
<a name="l33712"></a>33712         || ((shorg == segdest) &amp;&amp; (shdest == segorg));
<a name="l33713"></a>33713         <span class="keywordflow">if</span> (!same) {
<a name="l33714"></a>33714           printf(<span class="stringliteral">&quot;  !! !! Wrong subface-subsegment connection.\n&quot;</span>);
<a name="l33715"></a>33715           printf(<span class="stringliteral">&quot;    Subface: &quot;</span>);
<a name="l33716"></a>33716           printsh(&amp;shloop);
<a name="l33717"></a>33717           printf(<span class="stringliteral">&quot;    Subsegment: &quot;</span>);
<a name="l33718"></a>33718           printsh(&amp;testseg);
<a name="l33719"></a>33719           horrors++;
<a name="l33720"></a>33720         }
<a name="l33721"></a>33721       }
<a name="l33722"></a>33722       spivot(shloop, testsh);
<a name="l33723"></a>33723       <span class="keywordflow">if</span> (testsh.sh != dummysh) {
<a name="l33724"></a>33724         segorg = sorg(testsh);
<a name="l33725"></a>33725         segdest = sdest(testsh);
<a name="l33726"></a>33726         same = ((shorg == segorg) &amp;&amp; (shdest == segdest))
<a name="l33727"></a>33727         || ((shorg == segdest) &amp;&amp; (shdest == segorg));
<a name="l33728"></a>33728         <span class="keywordflow">if</span> (!same) {
<a name="l33729"></a>33729           printf(<span class="stringliteral">&quot;  !! !! Wrong subface-subface connection.\n&quot;</span>);
<a name="l33730"></a>33730           printf(<span class="stringliteral">&quot;    Subface 1: &quot;</span>);
<a name="l33731"></a>33731           printsh(&amp;shloop);
<a name="l33732"></a>33732           printf(<span class="stringliteral">&quot;    Subface 2: &quot;</span>);
<a name="l33733"></a>33733           printsh(&amp;testsh);
<a name="l33734"></a>33734           horrors++;
<a name="l33735"></a>33735         }
<a name="l33736"></a>33736         spivot(testsh, testshsh);
<a name="l33737"></a>33737         shorg = sorg(testshsh);
<a name="l33738"></a>33738         shdest = sdest(testshsh);
<a name="l33739"></a>33739         same = ((shorg == segorg) &amp;&amp; (shdest == segdest))
<a name="l33740"></a>33740         || ((shorg == segdest) &amp;&amp; (shdest == segorg));
<a name="l33741"></a>33741         <span class="keywordflow">if</span> (!same) {
<a name="l33742"></a>33742           printf(<span class="stringliteral">&quot;  !! !! Wrong subface-subface connection.\n&quot;</span>);
<a name="l33743"></a>33743           printf(<span class="stringliteral">&quot;    Subface 1: &quot;</span>);
<a name="l33744"></a>33744           printsh(&amp;testsh);
<a name="l33745"></a>33745           printf(<span class="stringliteral">&quot;    Subface 2: &quot;</span>);
<a name="l33746"></a>33746           printsh(&amp;testshsh);
<a name="l33747"></a>33747           horrors++;
<a name="l33748"></a>33748         }
<a name="l33749"></a>33749         <span class="keywordflow">if</span> (testseg.sh == dummysh) {
<a name="l33750"></a>33750           <span class="keywordflow">if</span> (testshsh.sh != shloop.sh) {
<a name="l33751"></a>33751             printf(<span class="stringliteral">&quot;  !! !! Wrong subface-subface connection.\n&quot;</span>);
<a name="l33752"></a>33752             printf(<span class="stringliteral">&quot;    Subface 1: &quot;</span>);
<a name="l33753"></a>33753             printsh(&amp;shloop);
<a name="l33754"></a>33754             printf(<span class="stringliteral">&quot;    Subface 2: &quot;</span>);
<a name="l33755"></a>33755             printsh(&amp;testsh);
<a name="l33756"></a>33756             horrors++;
<a name="l33757"></a>33757           }
<a name="l33758"></a>33758         }
<a name="l33759"></a>33759       }
<a name="l33760"></a>33760       senextself(shloop);
<a name="l33761"></a>33761     }
<a name="l33762"></a>33762     shloop.sh = shellfacetraverse(subfaces);
<a name="l33763"></a>33763   }
<a name="l33764"></a>33764 
<a name="l33765"></a>33765   <span class="comment">// Run through the list of subsegs, checking each one.</span>
<a name="l33766"></a>33766   subsegs-&gt;traversalinit();
<a name="l33767"></a>33767   segloop.sh = shellfacetraverse(subsegs);
<a name="l33768"></a>33768   <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l33769"></a>33769     segorg = sorg(segloop);
<a name="l33770"></a>33770     segdest = sdest(segloop);
<a name="l33771"></a>33771     spivot(segloop, testsh);
<a name="l33772"></a>33772     <span class="keywordflow">if</span> (testsh.sh == dummysh) {
<a name="l33773"></a>33773       printf(<span class="stringliteral">&quot;  !! !! Wrong subsegment-subface connection.\n&quot;</span>);
<a name="l33774"></a>33774       printf(<span class="stringliteral">&quot;    Subsegment: &quot;</span>);
<a name="l33775"></a>33775       printsh(&amp;segloop);
<a name="l33776"></a>33776       horrors++;
<a name="l33777"></a>33777       segloop.sh = shellfacetraverse(subsegs);
<a name="l33778"></a>33778       <span class="keywordflow">continue</span>;
<a name="l33779"></a>33779     }
<a name="l33780"></a>33780     shorg = sorg(testsh);
<a name="l33781"></a>33781     shdest = sdest(testsh);
<a name="l33782"></a>33782     same = ((shorg == segorg) &amp;&amp; (shdest == segdest))
<a name="l33783"></a>33783         || ((shorg == segdest) &amp;&amp; (shdest == segorg));
<a name="l33784"></a>33784     <span class="keywordflow">if</span> (!same) {
<a name="l33785"></a>33785       printf(<span class="stringliteral">&quot;  !! !! Wrong subsegment-subface connection.\n&quot;</span>);
<a name="l33786"></a>33786       printf(<span class="stringliteral">&quot;    Subsegment : &quot;</span>);
<a name="l33787"></a>33787       printsh(&amp;segloop);
<a name="l33788"></a>33788       printf(<span class="stringliteral">&quot;    Subface : &quot;</span>);
<a name="l33789"></a>33789       printsh(&amp;testsh);
<a name="l33790"></a>33790       horrors++;
<a name="l33791"></a>33791       segloop.sh = shellfacetraverse(subsegs);
<a name="l33792"></a>33792       <span class="keywordflow">continue</span>;
<a name="l33793"></a>33793     }
<a name="l33794"></a>33794     <span class="comment">// Check the connection of face loop around this subsegment.</span>
<a name="l33795"></a>33795     spin = testsh;
<a name="l33796"></a>33796     i = 0;
<a name="l33797"></a>33797     <span class="keywordflow">do</span> {
<a name="l33798"></a>33798       spivotself(spin);
<a name="l33799"></a>33799       shorg = sorg(spin);
<a name="l33800"></a>33800       shdest = sdest(spin);
<a name="l33801"></a>33801       same = ((shorg == segorg) &amp;&amp; (shdest == segdest))
<a name="l33802"></a>33802           || ((shorg == segdest) &amp;&amp; (shdest == segorg));
<a name="l33803"></a>33803       <span class="keywordflow">if</span> (!same) {
<a name="l33804"></a>33804         printf(<span class="stringliteral">&quot;  !! !! Wrong subsegment-subface connection.\n&quot;</span>);
<a name="l33805"></a>33805         printf(<span class="stringliteral">&quot;    Subsegment : &quot;</span>);
<a name="l33806"></a>33806         printsh(&amp;segloop);
<a name="l33807"></a>33807         printf(<span class="stringliteral">&quot;    Subface : &quot;</span>);
<a name="l33808"></a>33808         printsh(&amp;testsh);
<a name="l33809"></a>33809         horrors++;
<a name="l33810"></a>33810         <span class="keywordflow">break</span>;
<a name="l33811"></a>33811       }
<a name="l33812"></a>33812       i++;
<a name="l33813"></a>33813     } <span class="keywordflow">while</span> (spin.sh != testsh.sh &amp;&amp; i &lt; 1000);
<a name="l33814"></a>33814     <span class="keywordflow">if</span> (i &gt;= 1000) {
<a name="l33815"></a>33815       printf(<span class="stringliteral">&quot;  !! !! Wrong subsegment-subface connection.\n&quot;</span>);
<a name="l33816"></a>33816       printf(<span class="stringliteral">&quot;    Subsegment : &quot;</span>);
<a name="l33817"></a>33817       printsh(&amp;segloop);
<a name="l33818"></a>33818       horrors++;
<a name="l33819"></a>33819     }
<a name="l33820"></a>33820     segloop.sh = shellfacetraverse(subsegs);
<a name="l33821"></a>33821   }
<a name="l33822"></a>33822   <span class="keywordflow">if</span> (horrors == 0) {
<a name="l33823"></a>33823     <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33824"></a>33824       printf(<span class="stringliteral">&quot;  Mesh boundaries connected correctly.\n&quot;</span>);
<a name="l33825"></a>33825     }
<a name="l33826"></a>33826   } <span class="keywordflow">else</span> {
<a name="l33827"></a>33827     printf(<span class="stringliteral">&quot;  !! !! !! !! %d boundary connection viewed with horror.\n&quot;</span>,
<a name="l33828"></a>33828            horrors);
<a name="l33829"></a>33829     <span class="keywordflow">return</span>;
<a name="l33830"></a>33830   }
<a name="l33831"></a>33831 }
<a name="l33832"></a>33832 
<a name="l33834"></a>33834 <span class="comment">//                                                                           //</span>
<a name="l33835"></a>33835 <span class="comment">// checkdelaunay()    Ensure that the mesh is constrained Delaunay.          //</span>
<a name="l33836"></a>33836 <span class="comment">//                                                                           //</span>
<a name="l33837"></a>33837 <span class="comment">// If &#39;flipqueue&#39; is not NULL, non-locally Delaunay faces are saved in it.   //</span>
<a name="l33838"></a>33838 <span class="comment">//                                                                           //</span>
<a name="l33840"></a>33840 <span class="comment"></span>
<a name="l33841"></a>33841 <span class="keywordtype">void</span> tetgenmesh::checkdelaunay(REAL eps, queue* flipqueue)
<a name="l33842"></a>33842 {
<a name="l33843"></a>33843   triface tetraloop;
<a name="l33844"></a>33844   triface oppotet;
<a name="l33845"></a>33845   face opposhelle;
<a name="l33846"></a>33846   point tetorg, tetdest, tetapex, tetoppo;
<a name="l33847"></a>33847   point oppooppo;
<a name="l33848"></a>33848   <span class="keyword">enum</span> fliptype fc;
<a name="l33849"></a>33849   REAL sign;
<a name="l33850"></a>33850   <span class="keywordtype">int</span> shouldbedelaunay;
<a name="l33851"></a>33851   <span class="keywordtype">int</span> horrors;
<a name="l33852"></a>33852 
<a name="l33853"></a>33853   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33854"></a>33854     printf(<span class="stringliteral">&quot;  Checking Delaunay property of the mesh...\n&quot;</span>);
<a name="l33855"></a>33855   }
<a name="l33856"></a>33856   horrors = 0;
<a name="l33857"></a>33857   <span class="comment">// Run through the list of triangles, checking each one.</span>
<a name="l33858"></a>33858   tetrahedrons-&gt;traversalinit();
<a name="l33859"></a>33859   tetraloop.tet = tetrahedrontraverse();
<a name="l33860"></a>33860   <span class="keywordflow">while</span> (tetraloop.tet != (tetrahedron *) NULL) {
<a name="l33861"></a>33861     <span class="comment">// Check all four faces of the tetrahedron.</span>
<a name="l33862"></a>33862     <span class="keywordflow">for</span> (tetraloop.loc = 0; tetraloop.loc &lt; 4; tetraloop.loc++) {
<a name="l33863"></a>33863       tetorg = org(tetraloop);
<a name="l33864"></a>33864       tetdest = dest(tetraloop);
<a name="l33865"></a>33865       tetapex = apex(tetraloop);
<a name="l33866"></a>33866       tetoppo = oppo(tetraloop);
<a name="l33867"></a>33867       sym(tetraloop, oppotet);
<a name="l33868"></a>33868       oppooppo = oppo(oppotet);
<a name="l33869"></a>33869       <span class="comment">// Only do testif there is an adjoining tetrahedron whose pointer is</span>
<a name="l33870"></a>33870       <span class="comment">//   larger (to ensure that each pair isn&#39;t tested twice).</span>
<a name="l33871"></a>33871       shouldbedelaunay = (oppotet.tet != dummytet)
<a name="l33872"></a>33872                           &amp;&amp; (tetoppo != (point) NULL)
<a name="l33873"></a>33873                           &amp;&amp; (oppooppo != (point) NULL)
<a name="l33874"></a>33874                           &amp;&amp; (tetraloop.tet &lt; oppotet.tet);
<a name="l33875"></a>33875       <span class="keywordflow">if</span> (checksubfaces &amp;&amp; shouldbedelaunay) {
<a name="l33876"></a>33876         <span class="comment">// If a shell face separates the tetrahedra, then the face is</span>
<a name="l33877"></a>33877         <span class="comment">//   constrained, so no local Delaunay test should be done.</span>
<a name="l33878"></a>33878         tspivot(tetraloop, opposhelle);
<a name="l33879"></a>33879         <span class="keywordflow">if</span> (opposhelle.sh != dummysh){
<a name="l33880"></a>33880           shouldbedelaunay = 0;
<a name="l33881"></a>33881         }
<a name="l33882"></a>33882       }
<a name="l33883"></a>33883       <span class="keywordflow">if</span> (shouldbedelaunay) {
<a name="l33884"></a>33884         sign = insphere(tetdest, tetorg, tetapex, tetoppo, oppooppo);
<a name="l33885"></a>33885         <span class="keywordflow">if</span> ((sign &gt; 0.0) &amp;&amp; (eps &gt; 0.0)) {
<a name="l33886"></a>33886           <span class="keywordflow">if</span> (iscospheric(tetdest, tetorg, tetapex, tetoppo, oppooppo, sign,
<a name="l33887"></a>33887                           eps)) sign = 0.0;
<a name="l33888"></a>33888         }
<a name="l33889"></a>33889         <span class="keywordflow">if</span> (sign &gt; 0.0) {
<a name="l33890"></a>33890           <span class="keywordflow">if</span> (flipqueue) {
<a name="l33891"></a>33891             enqueueflipface(tetraloop, flipqueue);
<a name="l33892"></a>33892           } <span class="keywordflow">else</span> {
<a name="l33893"></a>33893             printf(<span class="stringliteral">&quot;  !! Non-locally Delaunay face (%d, %d, %d) &quot;</span>,
<a name="l33894"></a>33894                    pointmark(tetorg), pointmark(tetdest), pointmark(tetapex));
<a name="l33895"></a>33895             fc = categorizeface(tetraloop);
<a name="l33896"></a>33896             <span class="keywordflow">switch</span> (fc) {
<a name="l33897"></a>33897             <span class="keywordflow">case</span> T23: printf(<span class="stringliteral">&quot;\&quot;T23\&quot;&quot;</span>); <span class="keywordflow">break</span>;
<a name="l33898"></a>33898             <span class="keywordflow">case</span> T32: printf(<span class="stringliteral">&quot;\&quot;T32\&quot;&quot;</span>); <span class="keywordflow">break</span>;
<a name="l33899"></a>33899             <span class="keywordflow">case</span> T22: printf(<span class="stringliteral">&quot;\&quot;T22\&quot;&quot;</span>); <span class="keywordflow">break</span>;
<a name="l33900"></a>33900             <span class="keywordflow">case</span> T44: printf(<span class="stringliteral">&quot;\&quot;T44\&quot;&quot;</span>); <span class="keywordflow">break</span>;
<a name="l33901"></a>33901             <span class="keywordflow">case</span> N32: printf(<span class="stringliteral">&quot;\&quot;N32\&quot;&quot;</span>); <span class="keywordflow">break</span>;
<a name="l33902"></a>33902             <span class="keywordflow">case</span> N40: printf(<span class="stringliteral">&quot;\&quot;N40\&quot;&quot;</span>); <span class="keywordflow">break</span>;
<a name="l33903"></a>33903             <span class="keywordflow">case</span> FORBIDDENFACE:printf(<span class="stringliteral">&quot;\&quot;FORBIDDENFACE\&quot;&quot;</span>); <span class="keywordflow">break</span>;
<a name="l33904"></a>33904             <span class="keywordflow">case</span> FORBIDDENEDGE:printf(<span class="stringliteral">&quot;\&quot;FORBIDDENEDGE\&quot;&quot;</span>); <span class="keywordflow">break</span>;
<a name="l33905"></a>33905             }
<a name="l33906"></a>33906             printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l33907"></a>33907           }
<a name="l33908"></a>33908           horrors++;
<a name="l33909"></a>33909         }
<a name="l33910"></a>33910       }
<a name="l33911"></a>33911     }
<a name="l33912"></a>33912     tetraloop.tet = tetrahedrontraverse();
<a name="l33913"></a>33913   }
<a name="l33914"></a>33914   <span class="keywordflow">if</span> (flipqueue == (queue *) NULL) {
<a name="l33915"></a>33915     <span class="keywordflow">if</span> (horrors == 0) {
<a name="l33916"></a>33916       <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33917"></a>33917         printf(<span class="stringliteral">&quot;  The mesh is %s.\n&quot;</span>,
<a name="l33918"></a>33918                checksubfaces ? <span class="stringliteral">&quot;constrained Delaunay&quot;</span> : <span class="stringliteral">&quot;Delaunay&quot;</span>);
<a name="l33919"></a>33919       }
<a name="l33920"></a>33920     } <span class="keywordflow">else</span> {
<a name="l33921"></a>33921       printf(<span class="stringliteral">&quot;  !! !! !! !! %d obscenities viewed with horror.\n&quot;</span>, horrors);
<a name="l33922"></a>33922     }
<a name="l33923"></a>33923   }
<a name="l33924"></a>33924 }
<a name="l33925"></a>33925 
<a name="l33927"></a>33927 <span class="comment">//                                                                           //</span>
<a name="l33928"></a>33928 <span class="comment">// checkconforming()    Ensure that the mesh is conforming Delaunay.         //</span>
<a name="l33929"></a>33929 <span class="comment">//                                                                           //</span>
<a name="l33931"></a>33931 <span class="comment"></span>
<a name="l33932"></a>33932 <span class="keywordtype">void</span> tetgenmesh::checkconforming()
<a name="l33933"></a>33933 {
<a name="l33934"></a>33934   face segloop, shloop;
<a name="l33935"></a>33935   <span class="keywordtype">int</span> encsubsegs, encsubfaces;
<a name="l33936"></a>33936 
<a name="l33937"></a>33937   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33938"></a>33938     printf(<span class="stringliteral">&quot;  Checking conforming Delaunay property of mesh...\n&quot;</span>);
<a name="l33939"></a>33939   }
<a name="l33940"></a>33940   encsubsegs = encsubfaces = 0;
<a name="l33941"></a>33941   <span class="comment">// Run through the list of subsegments, check each one.</span>
<a name="l33942"></a>33942   subsegs-&gt;traversalinit();
<a name="l33943"></a>33943   segloop.sh = shellfacetraverse(subsegs);
<a name="l33944"></a>33944   <span class="keywordflow">while</span> (segloop.sh != (shellface *) NULL) {
<a name="l33945"></a>33945     <span class="keywordflow">if</span> (checkseg4encroach(&amp;segloop, NULL, NULL, <span class="keyword">false</span>)) {
<a name="l33946"></a>33946       printf(<span class="stringliteral">&quot;  !! !! Non-conforming subsegment: (%d, %d)\n&quot;</span>,
<a name="l33947"></a>33947              pointmark(sorg(segloop)), pointmark(sdest(segloop)));
<a name="l33948"></a>33948       encsubsegs++;
<a name="l33949"></a>33949     }
<a name="l33950"></a>33950     segloop.sh = shellfacetraverse(subsegs);
<a name="l33951"></a>33951   }
<a name="l33952"></a>33952   <span class="comment">// Run through the list of subfaces, check each one.</span>
<a name="l33953"></a>33953   subfaces-&gt;traversalinit();
<a name="l33954"></a>33954   shloop.sh = shellfacetraverse(subfaces);
<a name="l33955"></a>33955   <span class="keywordflow">while</span> (shloop.sh != (shellface *) NULL) {
<a name="l33956"></a>33956     <span class="keywordflow">if</span> (checksub4encroach(&amp;shloop, NULL, <span class="keyword">false</span>)) {
<a name="l33957"></a>33957       printf(<span class="stringliteral">&quot;  !! !! Non-conforming subface: (%d, %d, %d)\n&quot;</span>,
<a name="l33958"></a>33958              pointmark(sorg(shloop)), pointmark(sdest(shloop)),
<a name="l33959"></a>33959              pointmark(sapex(shloop)));
<a name="l33960"></a>33960       encsubfaces++;
<a name="l33961"></a>33961     }
<a name="l33962"></a>33962     shloop.sh = shellfacetraverse(subfaces);
<a name="l33963"></a>33963   }
<a name="l33964"></a>33964   <span class="keywordflow">if</span> (encsubsegs == 0 &amp;&amp; encsubfaces == 0) {
<a name="l33965"></a>33965     <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l33966"></a>33966       printf(<span class="stringliteral">&quot;  The mesh is conforming Delaunay.\n&quot;</span>);
<a name="l33967"></a>33967     }
<a name="l33968"></a>33968   } <span class="keywordflow">else</span> {
<a name="l33969"></a>33969     <span class="keywordflow">if</span> (encsubsegs &gt; 0) {
<a name="l33970"></a>33970       printf(<span class="stringliteral">&quot;  !! !! %d subsegments are non-conforming.\n&quot;</span>, encsubsegs);
<a name="l33971"></a>33971     }
<a name="l33972"></a>33972     <span class="keywordflow">if</span> (encsubfaces &gt; 0) {
<a name="l33973"></a>33973       printf(<span class="stringliteral">&quot;  !! !! %d subfaces are non-conforming.\n&quot;</span>, encsubfaces);
<a name="l33974"></a>33974     }
<a name="l33975"></a>33975   }
<a name="l33976"></a>33976 }
<a name="l33977"></a>33977 
<a name="l33979"></a>33979 <span class="comment">//                                                                           //</span>
<a name="l33980"></a>33980 <span class="comment">// algorithmicstatistics()    Print statistics about the mesh algorithms.    //</span>
<a name="l33981"></a>33981 <span class="comment">//                                                                           //</span>
<a name="l33983"></a>33983 <span class="comment"></span>
<a name="l33984"></a>33984 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l33985"></a>33985 <span class="preprocessor"></span>
<a name="l33986"></a>33986 <span class="keywordtype">void</span> tetgenmesh::algorithmicstatistics()
<a name="l33987"></a>33987 {
<a name="l33988"></a>33988   <span class="comment">/*</span>
<a name="l33989"></a>33989 <span class="comment">  printf(&quot;Algorithmic statistics:\n\n&quot;);</span>
<a name="l33990"></a>33990 <span class="comment">  printf(&quot;  Point location millisecond:  %g\n&quot;, (REAL) tloctime * 1e+3);</span>
<a name="l33991"></a>33991 <span class="comment">  printf(&quot;  Flip millisecond:  %g\n&quot;, (REAL) tfliptime * 1e+3);</span>
<a name="l33992"></a>33992 <span class="comment">  if (b-&gt;plc || b-&gt;refine) {</span>
<a name="l33993"></a>33993 <span class="comment">    printf(&quot;  Number of facet above points calculations: %ld\n&quot;, abovecount);</span>
<a name="l33994"></a>33994 <span class="comment">  }</span>
<a name="l33995"></a>33995 <span class="comment">  if (b-&gt;plc) {</span>
<a name="l33996"></a>33996 <span class="comment">    printf(&quot;  Segment split rules: R1 %ld, R2 %ld, R3 %ld\n&quot;, r1count, r2count,</span>
<a name="l33997"></a>33997 <span class="comment">           r3count);</span>
<a name="l33998"></a>33998 <span class="comment">  }</span>
<a name="l33999"></a>33999 <span class="comment">  if (b-&gt;quality) {</span>
<a name="l34000"></a>34000 <span class="comment">    printf(&quot;  Bowyer-Watson insertions: seg %ld, sub %ld, vol %ld.\n&quot;,</span>
<a name="l34001"></a>34001 <span class="comment">           bowatsegcount, bowatsubcount, bowatvolcount);</span>
<a name="l34002"></a>34002 <span class="comment">    printf(&quot;  Bowyer-Watson corrections: seg %ld, sub %ld, vol %ld\n&quot;,</span>
<a name="l34003"></a>34003 <span class="comment">           updsegcount, updsubcount, updvolcount);</span>
<a name="l34004"></a>34004 <span class="comment">    printf(&quot;  Bowyer-Watson failures: seg %ld, sub %ld, vol %ld\n&quot;,</span>
<a name="l34005"></a>34005 <span class="comment">           failsegcount, failsubcount, failvolcount);</span>
<a name="l34006"></a>34006 <span class="comment">    printf(&quot;  Number of repair flips: %ld.\n&quot;, repairflipcount);</span>
<a name="l34007"></a>34007 <span class="comment">    printf(&quot;  Number of circumcenters outside Bowat-cav.: %ld.\n&quot;,</span>
<a name="l34008"></a>34008 <span class="comment">           outbowatcircumcount);</span>
<a name="l34009"></a>34009 <span class="comment">    if (b-&gt;conformdel) {</span>
<a name="l34010"></a>34010 <span class="comment">      printf(&quot;  Segment split rules: R2 %ld, R3 %ld\n&quot;, r2count, r3count);</span>
<a name="l34011"></a>34011 <span class="comment">      printf(&quot;  Number of CDT enforcement points: %ld.\n&quot;, cdtenforcesegpts);</span>
<a name="l34012"></a>34012 <span class="comment">    }</span>
<a name="l34013"></a>34013 <span class="comment">    printf(&quot;  Number of Rejections: seg %ld, sub %ld, tet %ld.\n&quot;, rejsegpts,</span>
<a name="l34014"></a>34014 <span class="comment">           rejsubpts, rejtetpts);</span>
<a name="l34015"></a>34015 <span class="comment">    if (b-&gt;optlevel) {</span>
<a name="l34016"></a>34016 <span class="comment">      printf(</span>
<a name="l34017"></a>34017 <span class="comment">      &quot;  Optimization flips: f32 %ld, f44 %ld, f56 %ld, f68 %ld, fnm %ld.\n&quot;,</span>
<a name="l34018"></a>34018 <span class="comment">             optcount[3], optcount[4], optcount[5], optcount[6], optcount[9]);</span>
<a name="l34019"></a>34019 <span class="comment">      printf(&quot;  Optimization segment deletions: %ld.\n&quot;, optcount[1]);</span>
<a name="l34020"></a>34020 <span class="comment">    }</span>
<a name="l34021"></a>34021 <span class="comment">  }</span>
<a name="l34022"></a>34022 <span class="comment">  printf(&quot;\n&quot;);</span>
<a name="l34023"></a>34023 <span class="comment">  */</span>
<a name="l34024"></a>34024 }
<a name="l34025"></a>34025 
<a name="l34026"></a>34026 <span class="preprocessor">#endif // #ifdef SELF_CHECK</span>
<a name="l34027"></a>34027 <span class="preprocessor"></span>
<a name="l34029"></a>34029 <span class="comment">//                                                                           //</span>
<a name="l34030"></a>34030 <span class="comment">// qualitystatistics()    Print statistics about the quality of the mesh.    //</span>
<a name="l34031"></a>34031 <span class="comment">//                                                                           //</span>
<a name="l34033"></a>34033 <span class="comment"></span>
<a name="l34034"></a>34034 <span class="keywordtype">void</span> tetgenmesh::qualitystatistics()
<a name="l34035"></a>34035 {
<a name="l34036"></a>34036   triface tetloop, neightet;
<a name="l34037"></a>34037   point p[4];
<a name="l34038"></a>34038   <span class="keywordtype">char</span> sbuf[128];
<a name="l34039"></a>34039   REAL radiusratiotable[12];
<a name="l34040"></a>34040   REAL aspectratiotable[12];
<a name="l34041"></a>34041   REAL A[4][4], rhs[4], D;
<a name="l34042"></a>34042   REAL V[6][3], N[4][3], H[4]; <span class="comment">// edge-vectors, face-normals, face-heights.</span>
<a name="l34043"></a>34043   REAL edgelength[6], alldihed[6], faceangle[3];
<a name="l34044"></a>34044   REAL shortest, longest;
<a name="l34045"></a>34045   REAL smallestvolume, biggestvolume;
<a name="l34046"></a>34046   REAL smallestdiangle, biggestdiangle;
<a name="l34047"></a>34047   REAL smallestfaangle, biggestfaangle;
<a name="l34048"></a>34048   REAL tetvol, minaltitude;
<a name="l34049"></a>34049   REAL cirradius, minheightinv; <span class="comment">// insradius;</span>
<a name="l34050"></a>34050   REAL shortlen, longlen;
<a name="l34051"></a>34051   REAL tetaspect, tetradius;
<a name="l34052"></a>34052   REAL smalldiangle, bigdiangle;
<a name="l34053"></a>34053   REAL smallfaangle, bigfaangle;
<a name="l34054"></a>34054   <span class="keywordtype">int</span> radiustable[12];
<a name="l34055"></a>34055   <span class="keywordtype">int</span> aspecttable[16];
<a name="l34056"></a>34056   <span class="keywordtype">int</span> dihedangletable[18];
<a name="l34057"></a>34057   <span class="keywordtype">int</span> faceangletable[18];
<a name="l34058"></a>34058   <span class="keywordtype">int</span> indx[4];
<a name="l34059"></a>34059   <span class="keywordtype">int</span> radiusindex;
<a name="l34060"></a>34060   <span class="keywordtype">int</span> aspectindex;
<a name="l34061"></a>34061   <span class="keywordtype">int</span> tendegree;
<a name="l34062"></a>34062   <span class="keywordtype">int</span> i, j;
<a name="l34063"></a>34063 
<a name="l34064"></a>34064   smallfaangle = 0.0;
<a name="l34065"></a>34065   bigfaangle = 0.0;
<a name="l34066"></a>34066 
<a name="l34067"></a>34067   printf(<span class="stringliteral">&quot;Mesh quality statistics:\n\n&quot;</span>);
<a name="l34068"></a>34068 
<a name="l34069"></a>34069   <span class="comment">// Avoid compile warnings.</span>
<a name="l34070"></a>34070   shortlen = longlen = 0.0;
<a name="l34071"></a>34071   smalldiangle = bigdiangle = 0.0;
<a name="l34072"></a>34072 
<a name="l34073"></a>34073   radiusratiotable[0]  =    0.707;    radiusratiotable[1]  =     1.0;
<a name="l34074"></a>34074   radiusratiotable[2]  =      1.1;    radiusratiotable[3]  =     1.2;
<a name="l34075"></a>34075   radiusratiotable[4]  =      1.4;    radiusratiotable[5]  =     1.6;
<a name="l34076"></a>34076   radiusratiotable[6]  =      1.8;    radiusratiotable[7]  =     2.0;
<a name="l34077"></a>34077   radiusratiotable[8]  =      2.5;    radiusratiotable[9]  =     3.0;
<a name="l34078"></a>34078   radiusratiotable[10] =     10.0;    radiusratiotable[11] =     0.0;
<a name="l34079"></a>34079 
<a name="l34080"></a>34080   aspectratiotable[0]  =      1.5;    aspectratiotable[1]  =     2.0;
<a name="l34081"></a>34081   aspectratiotable[2]  =      2.5;    aspectratiotable[3]  =     3.0;
<a name="l34082"></a>34082   aspectratiotable[4]  =      4.0;    aspectratiotable[5]  =     6.0;
<a name="l34083"></a>34083   aspectratiotable[6]  =     10.0;    aspectratiotable[7]  =    15.0;
<a name="l34084"></a>34084   aspectratiotable[8]  =     25.0;    aspectratiotable[9]  =    50.0;
<a name="l34085"></a>34085   aspectratiotable[10] =    100.0;    aspectratiotable[11] =     0.0;
<a name="l34086"></a>34086 
<a name="l34087"></a>34087   <span class="keywordflow">for</span> (i = 0; i &lt; 12; i++) radiustable[i] = 0;
<a name="l34088"></a>34088   <span class="keywordflow">for</span> (i = 0; i &lt; 12; i++) aspecttable[i] = 0;
<a name="l34089"></a>34089   <span class="keywordflow">for</span> (i = 0; i &lt; 18; i++) dihedangletable[i] = 0;
<a name="l34090"></a>34090   <span class="keywordflow">for</span> (i = 0; i &lt; 18; i++) faceangletable[i] = 0;
<a name="l34091"></a>34091 
<a name="l34092"></a>34092   minaltitude = xmax - xmin + ymax - ymin + zmax - zmin;
<a name="l34093"></a>34093   minaltitude = minaltitude * minaltitude;
<a name="l34094"></a>34094   shortest = minaltitude;
<a name="l34095"></a>34095   longest = 0.0;
<a name="l34096"></a>34096   smallestvolume = minaltitude;
<a name="l34097"></a>34097   biggestvolume = 0.0;
<a name="l34098"></a>34098   smallestdiangle = smallestfaangle = 180.0;
<a name="l34099"></a>34099   biggestdiangle = biggestfaangle = 0.0;
<a name="l34100"></a>34100 
<a name="l34101"></a>34101   <span class="comment">// Loop all elements, calculate quality parameters for each element.</span>
<a name="l34102"></a>34102   tetrahedrons-&gt;traversalinit();
<a name="l34103"></a>34103   tetloop.tet = tetrahedrontraverse();
<a name="l34104"></a>34104   <span class="keywordflow">while</span> (tetloop.tet != (tetrahedron *) NULL) {
<a name="l34105"></a>34105 
<a name="l34106"></a>34106     <span class="comment">// Get four vertices: p0, p1, p2, p3.</span>
<a name="l34107"></a>34107     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) p[i] = (point) tetloop.tet[4 + i];
<a name="l34108"></a>34108     <span class="comment">// Set the edge vectors: V[0], ..., V[5]</span>
<a name="l34109"></a>34109     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) V[0][i] = p[0][i] - p[3][i]; <span class="comment">// V[0]: p3-&gt;p0.</span>
<a name="l34110"></a>34110     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) V[1][i] = p[1][i] - p[3][i]; <span class="comment">// V[1]: p3-&gt;p1.</span>
<a name="l34111"></a>34111     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) V[2][i] = p[2][i] - p[3][i]; <span class="comment">// V[2]: p3-&gt;p2.</span>
<a name="l34112"></a>34112     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) V[3][i] = p[1][i] - p[0][i]; <span class="comment">// V[3]: p0-&gt;p1.</span>
<a name="l34113"></a>34113     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) V[4][i] = p[2][i] - p[1][i]; <span class="comment">// V[4]: p1-&gt;p2.</span>
<a name="l34114"></a>34114     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) V[5][i] = p[0][i] - p[2][i]; <span class="comment">// V[5]: p2-&gt;p0.</span>
<a name="l34115"></a>34115     <span class="comment">// Set the matrix A = [V[0], V[1], V[2]]^T.</span>
<a name="l34116"></a>34116     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l34117"></a>34117       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) A[j][i] = V[j][i];
<a name="l34118"></a>34118     }
<a name="l34119"></a>34119     <span class="comment">// Decompose A just once.</span>
<a name="l34120"></a>34120     lu_decmp(A, 3, indx, &amp;D, 0);
<a name="l34121"></a>34121     <span class="comment">// Get the tet volume.</span>
<a name="l34122"></a>34122     tetvol = fabs(A[indx[0]][0] * A[indx[1]][1] * A[indx[2]][2]) / 6.0;
<a name="l34123"></a>34123     <span class="comment">// Get the three faces normals.</span>
<a name="l34124"></a>34124     <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) {
<a name="l34125"></a>34125       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) rhs[i] = 0.0;
<a name="l34126"></a>34126       rhs[j] = 1.0;  <span class="comment">// Positive means the inside direction</span>
<a name="l34127"></a>34127       lu_solve(A, 3, indx, rhs, 0);
<a name="l34128"></a>34128       <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) N[j][i] = rhs[i];
<a name="l34129"></a>34129     }
<a name="l34130"></a>34130     <span class="comment">// Get the fourth face normal by summing up the first three.</span>
<a name="l34131"></a>34131     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) N[3][i] = - N[0][i] - N[1][i] - N[2][i];
<a name="l34132"></a>34132     <span class="comment">// Get the radius of the circumsphere.</span>
<a name="l34133"></a>34133     <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) rhs[i] = 0.5 * dot(V[i], V[i]);
<a name="l34134"></a>34134     lu_solve(A, 3, indx, rhs, 0);
<a name="l34135"></a>34135     cirradius = sqrt(dot(rhs, rhs));
<a name="l34136"></a>34136     <span class="comment">// Normalize the face normals.</span>
<a name="l34137"></a>34137     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
<a name="l34138"></a>34138       <span class="comment">// H[i] is the inverse of height of its corresponding face.</span>
<a name="l34139"></a>34139       H[i] = sqrt(dot(N[i], N[i]));
<a name="l34140"></a>34140       <span class="keywordflow">for</span> (j = 0; j &lt; 3; j++) N[i][j] /= H[i];
<a name="l34141"></a>34141     }
<a name="l34142"></a>34142     <span class="comment">// Get the radius of the inscribed sphere.</span>
<a name="l34143"></a>34143     <span class="comment">// insradius = 1.0 / (H[0] + H[1] + H[2] + H[3]);</span>
<a name="l34144"></a>34144     <span class="comment">// Get the biggest H[i] (corresponding to the smallest height).</span>
<a name="l34145"></a>34145     minheightinv = H[0];
<a name="l34146"></a>34146     <span class="keywordflow">for</span> (i = 1; i &lt; 3; i++) {
<a name="l34147"></a>34147       <span class="keywordflow">if</span> (H[i] &gt; minheightinv) minheightinv = H[i];
<a name="l34148"></a>34148     }
<a name="l34149"></a>34149     <span class="comment">// Get the squares of the edge lengthes.</span>
<a name="l34150"></a>34150     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) edgelength[i] = dot(V[i], V[i]);
<a name="l34151"></a>34151     <span class="comment">// Get the dihedrals (in degree) at each edges.</span>
<a name="l34152"></a>34152     j = 0;
<a name="l34153"></a>34153     <span class="keywordflow">for</span> (i = 1; i &lt; 4; i++) {
<a name="l34154"></a>34154       alldihed[j] = -dot(N[0], N[i]); <span class="comment">// Edge cd, bd, bc.</span>
<a name="l34155"></a>34155       <span class="keywordflow">if</span> (alldihed[j] &lt; -1.0) alldihed[j] = -1; <span class="comment">// Rounding.</span>
<a name="l34156"></a>34156       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alldihed[j] &gt; 1.0) alldihed[j] = 1;
<a name="l34157"></a>34157       alldihed[j] = acos(alldihed[j]) / PI * 180.0;
<a name="l34158"></a>34158       j++;
<a name="l34159"></a>34159     }
<a name="l34160"></a>34160     <span class="keywordflow">for</span> (i = 2; i &lt; 4; i++) {
<a name="l34161"></a>34161       alldihed[j] = -dot(N[1], N[i]); <span class="comment">// Edge ad, ac.</span>
<a name="l34162"></a>34162       <span class="keywordflow">if</span> (alldihed[j] &lt; -1.0) alldihed[j] = -1; <span class="comment">// Rounding.</span>
<a name="l34163"></a>34163       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alldihed[j] &gt; 1.0) alldihed[j] = 1;
<a name="l34164"></a>34164       alldihed[j] = acos(alldihed[j]) / PI * 180.0;
<a name="l34165"></a>34165       j++;
<a name="l34166"></a>34166     }
<a name="l34167"></a>34167     alldihed[j] = -dot(N[2], N[3]); <span class="comment">// Edge ab.</span>
<a name="l34168"></a>34168     <span class="keywordflow">if</span> (alldihed[j] &lt; -1.0) alldihed[j] = -1; <span class="comment">// Rounding.</span>
<a name="l34169"></a>34169     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (alldihed[j] &gt; 1.0) alldihed[j] = 1;
<a name="l34170"></a>34170     alldihed[j] = acos(alldihed[j]) / PI * 180.0;
<a name="l34171"></a>34171 
<a name="l34172"></a>34172     <span class="comment">// Calculate the longest and shortest edge length.</span>
<a name="l34173"></a>34173     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l34174"></a>34174       <span class="keywordflow">if</span> (i == 0) {
<a name="l34175"></a>34175         shortlen = longlen = edgelength[i];
<a name="l34176"></a>34176       } <span class="keywordflow">else</span> {
<a name="l34177"></a>34177         shortlen = edgelength[i] &lt; shortlen ? edgelength[i] : shortlen;
<a name="l34178"></a>34178         longlen  = edgelength[i] &gt; longlen  ? edgelength[i] : longlen;
<a name="l34179"></a>34179       }
<a name="l34180"></a>34180       <span class="keywordflow">if</span> (edgelength[i] &gt; longest) {
<a name="l34181"></a>34181         longest = edgelength[i];
<a name="l34182"></a>34182       }
<a name="l34183"></a>34183       <span class="keywordflow">if</span> (edgelength[i] &lt; shortest) {
<a name="l34184"></a>34184         shortest = edgelength[i];
<a name="l34185"></a>34185       }
<a name="l34186"></a>34186     }
<a name="l34187"></a>34187 
<a name="l34188"></a>34188     <span class="comment">// Calculate the largest and smallest volume.</span>
<a name="l34189"></a>34189     <span class="keywordflow">if</span> (tetvol &lt; smallestvolume) {
<a name="l34190"></a>34190       smallestvolume = tetvol;
<a name="l34191"></a>34191     }
<a name="l34192"></a>34192     <span class="keywordflow">if</span> (tetvol &gt; biggestvolume) {
<a name="l34193"></a>34193       biggestvolume = tetvol;
<a name="l34194"></a>34194     }
<a name="l34195"></a>34195 
<a name="l34196"></a>34196     <span class="comment">// Calculate the largest and smallest dihedral angles.</span>
<a name="l34197"></a>34197     <span class="keywordflow">for</span> (i = 0; i &lt; 6; i++) {
<a name="l34198"></a>34198       <span class="keywordflow">if</span> (i == 0) {
<a name="l34199"></a>34199         smalldiangle = bigdiangle = alldihed[i];
<a name="l34200"></a>34200       } <span class="keywordflow">else</span> {
<a name="l34201"></a>34201         smalldiangle = alldihed[i] &lt; smalldiangle ? alldihed[i] : smalldiangle;
<a name="l34202"></a>34202         bigdiangle = alldihed[i] &gt; bigdiangle ? alldihed[i] : bigdiangle;
<a name="l34203"></a>34203       }
<a name="l34204"></a>34204       <span class="keywordflow">if</span> (alldihed[i] &lt; smallestdiangle) {
<a name="l34205"></a>34205         smallestdiangle = alldihed[i];
<a name="l34206"></a>34206       }
<a name="l34207"></a>34207       <span class="keywordflow">if</span> (alldihed[i] &gt; biggestdiangle) {
<a name="l34208"></a>34208         biggestdiangle = alldihed[i];
<a name="l34209"></a>34209       }
<a name="l34210"></a>34210     }
<a name="l34211"></a>34211     <span class="comment">// Accumulate the corresponding number in the dihedral angle histogram.</span>
<a name="l34212"></a>34212     <span class="keywordflow">if</span> (smalldiangle &lt; 5.0) {
<a name="l34213"></a>34213       tendegree = 0;
<a name="l34214"></a>34214     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (smalldiangle &gt;= 5.0 &amp;&amp; smalldiangle &lt; 10.0) {
<a name="l34215"></a>34215       tendegree = 1;
<a name="l34216"></a>34216     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (smalldiangle &gt;= 80.0 &amp;&amp; smalldiangle &lt; 110.0) {
<a name="l34217"></a>34217       tendegree = 9; <span class="comment">// Angles between 80 to 110 degree are in one entry.</span>
<a name="l34218"></a>34218     } <span class="keywordflow">else</span> {
<a name="l34219"></a>34219       tendegree = (int) (smalldiangle / 10.);
<a name="l34220"></a>34220       <span class="keywordflow">if</span> (smalldiangle &lt; 80.0) {
<a name="l34221"></a>34221         tendegree++;  <span class="comment">// In the left column.</span>
<a name="l34222"></a>34222       } <span class="keywordflow">else</span> {
<a name="l34223"></a>34223         tendegree--;  <span class="comment">// In the right column.</span>
<a name="l34224"></a>34224       }
<a name="l34225"></a>34225     }
<a name="l34226"></a>34226     dihedangletable[tendegree]++;
<a name="l34227"></a>34227     <span class="keywordflow">if</span> (bigdiangle &gt;= 80.0 &amp;&amp; bigdiangle &lt; 110.0) {
<a name="l34228"></a>34228       tendegree = 9; <span class="comment">// Angles between 80 to 110 degree are in one entry.</span>
<a name="l34229"></a>34229     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bigdiangle &gt;= 170.0 &amp;&amp; bigdiangle &lt; 175.0) {
<a name="l34230"></a>34230       tendegree = 16;
<a name="l34231"></a>34231     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (bigdiangle &gt;= 175.0) {
<a name="l34232"></a>34232       tendegree = 17;
<a name="l34233"></a>34233     } <span class="keywordflow">else</span> {
<a name="l34234"></a>34234       tendegree = (int) (bigdiangle / 10.);
<a name="l34235"></a>34235       <span class="keywordflow">if</span> (bigdiangle &lt; 80.0) {
<a name="l34236"></a>34236         tendegree++;  <span class="comment">// In the left column.</span>
<a name="l34237"></a>34237       } <span class="keywordflow">else</span> {
<a name="l34238"></a>34238         tendegree--;  <span class="comment">// In the right column.</span>
<a name="l34239"></a>34239       }
<a name="l34240"></a>34240     }
<a name="l34241"></a>34241     dihedangletable[tendegree]++;
<a name="l34242"></a>34242 
<a name="l34243"></a>34243     <span class="comment">// Calulate the largest and smallest face angles.</span>
<a name="l34244"></a>34244     tetloop.ver = 0;
<a name="l34245"></a>34245     <span class="keywordflow">for</span> (tetloop.loc = 0; tetloop.loc &lt; 4; tetloop.loc++) {
<a name="l34246"></a>34246       sym(tetloop, neightet);
<a name="l34247"></a>34247       <span class="comment">// Only do the calulation once for a face.</span>
<a name="l34248"></a>34248       <span class="keywordflow">if</span> ((neightet.tet == dummytet) || (tetloop.tet &lt; neightet.tet)) {
<a name="l34249"></a>34249         p[0] = org(tetloop);
<a name="l34250"></a>34250         p[1] = dest(tetloop);
<a name="l34251"></a>34251         p[2] = apex(tetloop);
<a name="l34252"></a>34252         faceangle[0] = interiorangle(p[0], p[1], p[2], NULL);
<a name="l34253"></a>34253         faceangle[1] = interiorangle(p[1], p[2], p[0], NULL);
<a name="l34254"></a>34254         faceangle[2] = PI - (faceangle[0] + faceangle[1]);
<a name="l34255"></a>34255         <span class="comment">// Translate angles into degrees.</span>
<a name="l34256"></a>34256         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l34257"></a>34257           faceangle[i] = (faceangle[i] * 180.0) / PI;
<a name="l34258"></a>34258         }
<a name="l34259"></a>34259         <span class="comment">// Calculate the largest and smallest face angles.</span>
<a name="l34260"></a>34260         <span class="keywordflow">for</span> (i = 0; i &lt; 3; i++) {
<a name="l34261"></a>34261           <span class="keywordflow">if</span> (i == 0) {
<a name="l34262"></a>34262             smallfaangle = bigfaangle = faceangle[i];
<a name="l34263"></a>34263           } <span class="keywordflow">else</span> {
<a name="l34264"></a>34264             smallfaangle = faceangle[i] &lt; smallfaangle ?
<a name="l34265"></a>34265               faceangle[i] : smallfaangle;
<a name="l34266"></a>34266             bigfaangle = faceangle[i] &gt; bigfaangle ? faceangle[i] : bigfaangle;
<a name="l34267"></a>34267           }
<a name="l34268"></a>34268           <span class="keywordflow">if</span> (faceangle[i] &lt; smallestfaangle) {
<a name="l34269"></a>34269             smallestfaangle = faceangle[i];
<a name="l34270"></a>34270           }
<a name="l34271"></a>34271           <span class="keywordflow">if</span> (faceangle[i] &gt; biggestfaangle) {
<a name="l34272"></a>34272             biggestfaangle = faceangle[i];
<a name="l34273"></a>34273           }
<a name="l34274"></a>34274         }
<a name="l34275"></a>34275         tendegree = (int) (smallfaangle / 10.);
<a name="l34276"></a>34276         faceangletable[tendegree]++;
<a name="l34277"></a>34277         tendegree = (int) (bigfaangle / 10.);
<a name="l34278"></a>34278         faceangletable[tendegree]++;
<a name="l34279"></a>34279       }
<a name="l34280"></a>34280     }
<a name="l34281"></a>34281 
<a name="l34282"></a>34282     <span class="comment">// Calculate aspect ratio and radius-edge ratio for this element.</span>
<a name="l34283"></a>34283     tetradius = cirradius / sqrt(shortlen);
<a name="l34284"></a>34284     <span class="comment">// tetaspect = sqrt(longlen) / (2.0 * insradius);</span>
<a name="l34285"></a>34285     tetaspect = sqrt(longlen) * minheightinv;
<a name="l34286"></a>34286     aspectindex = 0;
<a name="l34287"></a>34287     <span class="keywordflow">while</span> ((tetaspect &gt; aspectratiotable[aspectindex]) &amp;&amp; (aspectindex &lt; 11)) {
<a name="l34288"></a>34288       aspectindex++;
<a name="l34289"></a>34289     }
<a name="l34290"></a>34290     aspecttable[aspectindex]++;
<a name="l34291"></a>34291     radiusindex = 0;
<a name="l34292"></a>34292     <span class="keywordflow">while</span> ((tetradius &gt; radiusratiotable[radiusindex]) &amp;&amp; (radiusindex &lt; 11)) {
<a name="l34293"></a>34293       radiusindex++;
<a name="l34294"></a>34294     }
<a name="l34295"></a>34295     radiustable[radiusindex]++;
<a name="l34296"></a>34296 
<a name="l34297"></a>34297     tetloop.tet = tetrahedrontraverse();
<a name="l34298"></a>34298   }
<a name="l34299"></a>34299 
<a name="l34300"></a>34300   shortest = sqrt(shortest);
<a name="l34301"></a>34301   longest = sqrt(longest);
<a name="l34302"></a>34302   minaltitude = sqrt(minaltitude);
<a name="l34303"></a>34303 
<a name="l34304"></a>34304   printf(<span class="stringliteral">&quot;  Smallest volume: %16.5g   |  Largest volume: %16.5g\n&quot;</span>,
<a name="l34305"></a>34305          smallestvolume, biggestvolume);
<a name="l34306"></a>34306   printf(<span class="stringliteral">&quot;  Shortest edge:   %16.5g   |  Longest edge:   %16.5g\n&quot;</span>,
<a name="l34307"></a>34307          shortest, longest);
<a name="l34308"></a>34308   sprintf(sbuf, <span class="stringliteral">&quot;%.17g&quot;</span>, biggestfaangle);
<a name="l34309"></a>34309   <span class="keywordflow">if</span> (strlen(sbuf) &gt; 8) {
<a name="l34310"></a>34310     sbuf[8] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l34311"></a>34311   }
<a name="l34312"></a>34312   printf(<span class="stringliteral">&quot;  Smallest facangle: %14.5g   |  Largest facangle:       %s\n&quot;</span>,
<a name="l34313"></a>34313          smallestfaangle, sbuf);
<a name="l34314"></a>34314   sprintf(sbuf, <span class="stringliteral">&quot;%.17g&quot;</span>, biggestdiangle);
<a name="l34315"></a>34315   <span class="keywordflow">if</span> (strlen(sbuf) &gt; 8) {
<a name="l34316"></a>34316     sbuf[8] = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l34317"></a>34317   }
<a name="l34318"></a>34318   printf(<span class="stringliteral">&quot;  Smallest dihedral: %14.5g   |  Largest dihedral:       %s\n\n&quot;</span>,
<a name="l34319"></a>34319          smallestdiangle, sbuf);
<a name="l34320"></a>34320 
<a name="l34321"></a>34321   <span class="comment">/*</span>
<a name="l34322"></a>34322 <span class="comment">  printf(&quot;  Radius-edge ratio histogram:\n&quot;);</span>
<a name="l34323"></a>34323 <span class="comment">  printf(&quot;         &lt; %-6.6g    :  %8d      | %6.6g - %-6.6g     :  %8d\n&quot;,</span>
<a name="l34324"></a>34324 <span class="comment">         radiusratiotable[0], radiustable[0], radiusratiotable[5],</span>
<a name="l34325"></a>34325 <span class="comment">         radiusratiotable[6], radiustable[6]);</span>
<a name="l34326"></a>34326 <span class="comment">  for (i = 1; i &lt; 5; i++) {</span>
<a name="l34327"></a>34327 <span class="comment">    printf(&quot;  %6.6g - %-6.6g    :  %8d      | %6.6g - %-6.6g     :  %8d\n&quot;,</span>
<a name="l34328"></a>34328 <span class="comment">           radiusratiotable[i - 1], radiusratiotable[i], radiustable[i],</span>
<a name="l34329"></a>34329 <span class="comment">           radiusratiotable[i + 5], radiusratiotable[i + 6],</span>
<a name="l34330"></a>34330 <span class="comment">           radiustable[i + 6]);</span>
<a name="l34331"></a>34331 <span class="comment">  }</span>
<a name="l34332"></a>34332 <span class="comment">  printf(&quot;  %6.6g - %-6.6g    :  %8d      | %6.6g -            :  %8d\n&quot;,</span>
<a name="l34333"></a>34333 <span class="comment">         radiusratiotable[4], radiusratiotable[5], radiustable[5],</span>
<a name="l34334"></a>34334 <span class="comment">         radiusratiotable[10], radiustable[11]);</span>
<a name="l34335"></a>34335 <span class="comment">  printf(&quot;  (A tetrahedron&#39;s radius-edge ratio is its radius of &quot;);</span>
<a name="l34336"></a>34336 <span class="comment">  printf(&quot;circumsphere divided\n&quot;);</span>
<a name="l34337"></a>34337 <span class="comment">  printf(&quot;    by its shortest edge length)\n\n&quot;);</span>
<a name="l34338"></a>34338 <span class="comment">  */</span>
<a name="l34339"></a>34339 
<a name="l34340"></a>34340   printf(<span class="stringliteral">&quot;  Aspect ratio histogram:\n&quot;</span>);
<a name="l34341"></a>34341   printf(<span class="stringliteral">&quot;         &lt; %-6.6g    :  %8d      | %6.6g - %-6.6g     :  %8d\n&quot;</span>,
<a name="l34342"></a>34342          aspectratiotable[0], aspecttable[0], aspectratiotable[5],
<a name="l34343"></a>34343          aspectratiotable[6], aspecttable[6]);
<a name="l34344"></a>34344   <span class="keywordflow">for</span> (i = 1; i &lt; 5; i++) {
<a name="l34345"></a>34345     printf(<span class="stringliteral">&quot;  %6.6g - %-6.6g    :  %8d      | %6.6g - %-6.6g     :  %8d\n&quot;</span>,
<a name="l34346"></a>34346            aspectratiotable[i - 1], aspectratiotable[i], aspecttable[i],
<a name="l34347"></a>34347            aspectratiotable[i + 5], aspectratiotable[i + 6],
<a name="l34348"></a>34348            aspecttable[i + 6]);
<a name="l34349"></a>34349   }
<a name="l34350"></a>34350   printf(<span class="stringliteral">&quot;  %6.6g - %-6.6g    :  %8d      | %6.6g -            :  %8d\n&quot;</span>,
<a name="l34351"></a>34351          aspectratiotable[4], aspectratiotable[5], aspecttable[5],
<a name="l34352"></a>34352          aspectratiotable[10], aspecttable[11]);
<a name="l34353"></a>34353   printf(<span class="stringliteral">&quot;  (A tetrahedron&#39;s aspect ratio is its longest edge length&quot;</span>);
<a name="l34354"></a>34354   printf(<span class="stringliteral">&quot; divided by its\n&quot;</span>);
<a name="l34355"></a>34355   printf(<span class="stringliteral">&quot;    smallest side height)\n\n&quot;</span>);
<a name="l34356"></a>34356 
<a name="l34357"></a>34357   printf(<span class="stringliteral">&quot;  Face angle histogram:\n&quot;</span>);
<a name="l34358"></a>34358   <span class="keywordflow">for</span> (i = 0; i &lt; 9; i++) {
<a name="l34359"></a>34359     printf(<span class="stringliteral">&quot;    %3d - %3d degrees:  %8d      |    %3d - %3d degrees:  %8d\n&quot;</span>,
<a name="l34360"></a>34360            i * 10, i * 10 + 10, faceangletable[i],
<a name="l34361"></a>34361            i * 10 + 90, i * 10 + 100, faceangletable[i + 9]);
<a name="l34362"></a>34362   }
<a name="l34363"></a>34363   <span class="keywordflow">if</span> (minfaceang != PI) {
<a name="l34364"></a>34364     printf(<span class="stringliteral">&quot;  Minimum input face angle is %g (degree).\n&quot;</span>,
<a name="l34365"></a>34365            minfaceang / PI * 180.0);
<a name="l34366"></a>34366   }
<a name="l34367"></a>34367   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l34368"></a>34368 
<a name="l34369"></a>34369   printf(<span class="stringliteral">&quot;  Dihedral angle histogram:\n&quot;</span>);
<a name="l34370"></a>34370   <span class="comment">// Print the three two rows:</span>
<a name="l34371"></a>34371   printf(<span class="stringliteral">&quot;     %3d - %2d degrees:  %8d      |    %3d - %3d degrees:  %8d\n&quot;</span>,
<a name="l34372"></a>34372          0, 5, dihedangletable[0], 80, 110, dihedangletable[9]);
<a name="l34373"></a>34373   printf(<span class="stringliteral">&quot;     %3d - %2d degrees:  %8d      |    %3d - %3d degrees:  %8d\n&quot;</span>,
<a name="l34374"></a>34374          5, 10, dihedangletable[1], 110, 120, dihedangletable[10]);
<a name="l34375"></a>34375   <span class="comment">// Print the third to seventh rows.</span>
<a name="l34376"></a>34376   <span class="keywordflow">for</span> (i = 2; i &lt; 7; i++) {
<a name="l34377"></a>34377     printf(<span class="stringliteral">&quot;     %3d - %2d degrees:  %8d      |    %3d - %3d degrees:  %8d\n&quot;</span>,
<a name="l34378"></a>34378            (i - 1) * 10, (i - 1) * 10 + 10, dihedangletable[i],
<a name="l34379"></a>34379            (i - 1) * 10 + 110, (i - 1) * 10 + 120, dihedangletable[i + 9]);
<a name="l34380"></a>34380   }
<a name="l34381"></a>34381   <span class="comment">// Print the last two rows.</span>
<a name="l34382"></a>34382   printf(<span class="stringliteral">&quot;     %3d - %2d degrees:  %8d      |    %3d - %3d degrees:  %8d\n&quot;</span>,
<a name="l34383"></a>34383          60, 70, dihedangletable[7], 170, 175, dihedangletable[16]);
<a name="l34384"></a>34384   printf(<span class="stringliteral">&quot;     %3d - %2d degrees:  %8d      |    %3d - %3d degrees:  %8d\n&quot;</span>,
<a name="l34385"></a>34385          70, 80, dihedangletable[8], 175, 180, dihedangletable[17]);
<a name="l34386"></a>34386   <span class="keywordflow">if</span> (minfacetdihed != PI) {
<a name="l34387"></a>34387     printf(<span class="stringliteral">&quot;  Minimum input facet dihedral angle is %g (degree).\n&quot;</span>,
<a name="l34388"></a>34388            minfacetdihed / PI * 180.0);
<a name="l34389"></a>34389   }
<a name="l34390"></a>34390   printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l34391"></a>34391 }
<a name="l34392"></a>34392 
<a name="l34394"></a>34394 <span class="comment">//                                                                           //</span>
<a name="l34395"></a>34395 <span class="comment">// statistics()    Print all sorts of cool facts.                            //</span>
<a name="l34396"></a>34396 <span class="comment">//                                                                           //</span>
<a name="l34398"></a>34398 <span class="comment"></span>
<a name="l34399"></a>34399 <span class="keywordtype">void</span> tetgenmesh::statistics()
<a name="l34400"></a>34400 {
<a name="l34401"></a>34401   printf(<span class="stringliteral">&quot;\nStatistics:\n\n&quot;</span>);
<a name="l34402"></a>34402   printf(<span class="stringliteral">&quot;  Input points: %d\n&quot;</span>, in-&gt;numberofpoints + jettisoninverts);
<a name="l34403"></a>34403   <span class="keywordflow">if</span> (b-&gt;refine) {
<a name="l34404"></a>34404     printf(<span class="stringliteral">&quot;  Input tetrahedra: %d\n&quot;</span>, in-&gt;numberoftetrahedra);
<a name="l34405"></a>34405   }
<a name="l34406"></a>34406   <span class="keywordflow">if</span> (b-&gt;plc) {
<a name="l34407"></a>34407     printf(<span class="stringliteral">&quot;  Input facets: %d\n&quot;</span>, in-&gt;numberoffacets);
<a name="l34408"></a>34408     printf(<span class="stringliteral">&quot;  Input segments: %ld\n&quot;</span>, insegments);
<a name="l34409"></a>34409     printf(<span class="stringliteral">&quot;  Input holes: %d\n&quot;</span>, in-&gt;numberofholes);
<a name="l34410"></a>34410     printf(<span class="stringliteral">&quot;  Input regions: %d\n&quot;</span>, in-&gt;numberofregions);
<a name="l34411"></a>34411   }
<a name="l34412"></a>34412 
<a name="l34413"></a>34413   printf(<span class="stringliteral">&quot;\n  Mesh points: %ld\n&quot;</span>, points-&gt;items);
<a name="l34414"></a>34414   printf(<span class="stringliteral">&quot;  Mesh tetrahedra: %ld\n&quot;</span>, tetrahedrons-&gt;items);
<a name="l34415"></a>34415   <span class="keywordflow">if</span> (b-&gt;plc || b-&gt;refine) {
<a name="l34416"></a>34416     printf(<span class="stringliteral">&quot;  Mesh triangles: %ld\n&quot;</span>, (4l*tetrahedrons-&gt;items+hullsize)/2l);
<a name="l34417"></a>34417   }
<a name="l34418"></a>34418   <span class="keywordflow">if</span> (b-&gt;plc || b-&gt;refine) {
<a name="l34419"></a>34419     printf(<span class="stringliteral">&quot;  Mesh subfaces: %ld\n&quot;</span>, subfaces-&gt;items);
<a name="l34420"></a>34420     printf(<span class="stringliteral">&quot;  Mesh subsegments: %ld\n\n&quot;</span>, subsegs-&gt;items);
<a name="l34421"></a>34421   } <span class="keywordflow">else</span> {
<a name="l34422"></a>34422     printf(<span class="stringliteral">&quot;  Convex hull triangles: %ld\n\n&quot;</span>, hullsize);
<a name="l34423"></a>34423   }
<a name="l34424"></a>34424   <span class="keywordflow">if</span> (b-&gt;verbose &gt; 0) {
<a name="l34425"></a>34425     qualitystatistics();
<a name="l34426"></a>34426     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> totalmeshbytes;
<a name="l34427"></a>34427     printf(<span class="stringliteral">&quot;Memory allocation statistics:\n\n&quot;</span>);
<a name="l34428"></a>34428     printf(<span class="stringliteral">&quot;  Maximum number of vertices: %ld\n&quot;</span>, points-&gt;maxitems);
<a name="l34429"></a>34429     totalmeshbytes = points-&gt;maxitems * points-&gt;itembytes;
<a name="l34430"></a>34430     printf(<span class="stringliteral">&quot;  Maximum number of tetrahedra: %ld\n&quot;</span>, tetrahedrons-&gt;maxitems);
<a name="l34431"></a>34431     totalmeshbytes += tetrahedrons-&gt;maxitems * tetrahedrons-&gt;itembytes;
<a name="l34432"></a>34432     <span class="keywordflow">if</span> (subfaces != (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL) {
<a name="l34433"></a>34433       printf(<span class="stringliteral">&quot;  Maximum number of subfaces: %ld\n&quot;</span>, subfaces-&gt;maxitems);
<a name="l34434"></a>34434       totalmeshbytes += subfaces-&gt;maxitems * subfaces-&gt;itembytes;
<a name="l34435"></a>34435     }
<a name="l34436"></a>34436     <span class="keywordflow">if</span> (subsegs != (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL) {
<a name="l34437"></a>34437       printf(<span class="stringliteral">&quot;  Maximum number of segments: %ld\n&quot;</span>, subsegs-&gt;maxitems);
<a name="l34438"></a>34438       totalmeshbytes += subsegs-&gt;maxitems * subsegs-&gt;itembytes;
<a name="l34439"></a>34439     }
<a name="l34440"></a>34440     printf(<span class="stringliteral">&quot;  Approximate heap memory used by the mesh (K bytes): %g\n\n&quot;</span>,
<a name="l34441"></a>34441            (<span class="keywordtype">double</span>) totalmeshbytes / 1024.0);
<a name="l34442"></a>34442 <span class="preprocessor">#ifdef SELF_CHECK</span>
<a name="l34443"></a>34443 <span class="preprocessor"></span>    algorithmicstatistics();
<a name="l34444"></a>34444 <span class="preprocessor">#endif</span>
<a name="l34445"></a>34445 <span class="preprocessor"></span>  }
<a name="l34446"></a>34446 }
<a name="l34447"></a>34447 
<a name="l34448"></a>34448 <span class="comment">//</span>
<a name="l34449"></a>34449 <span class="comment">// End of user interaction routines</span>
<a name="l34450"></a>34450 <span class="comment">//</span>
<a name="l34451"></a>34451 
<a name="l34452"></a>34452 <span class="comment">//</span>
<a name="l34453"></a>34453 <span class="comment">// Begin of constructor and destructor of tetgenmesh</span>
<a name="l34454"></a>34454 <span class="comment">//</span>
<a name="l34455"></a>34455 
<a name="l34457"></a>34457 <span class="comment">//                                                                           //</span>
<a name="l34458"></a>34458 <span class="comment">// ~tetgenmesh()    Deallocte memory occupied by a tetgenmesh object.        //</span>
<a name="l34459"></a>34459 <span class="comment">//                                                                           //</span>
<a name="l34461"></a>34461 <span class="comment"></span>
<a name="l34462"></a>34462 tetgenmesh::~tetgenmesh()
<a name="l34463"></a>34463 {
<a name="l34464"></a>34464   bgm = (tetgenmesh *) NULL;
<a name="l34465"></a>34465   in = (tetgenio *) NULL;
<a name="l34466"></a>34466   b = (tetgenbehavior *) NULL;
<a name="l34467"></a>34467 
<a name="l34468"></a>34468   <span class="keywordflow">if</span> (tetrahedrons != (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL) {
<a name="l34469"></a>34469     <span class="keyword">delete</span> tetrahedrons;
<a name="l34470"></a>34470   }
<a name="l34471"></a>34471   <span class="keywordflow">if</span> (subfaces != (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL) {
<a name="l34472"></a>34472     <span class="keyword">delete</span> subfaces;
<a name="l34473"></a>34473   }
<a name="l34474"></a>34474   <span class="keywordflow">if</span> (subsegs != (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL) {
<a name="l34475"></a>34475     <span class="keyword">delete</span> subsegs;
<a name="l34476"></a>34476   }
<a name="l34477"></a>34477   <span class="keywordflow">if</span> (points != (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL) {
<a name="l34478"></a>34478     <span class="keyword">delete</span> points;
<a name="l34479"></a>34479   }
<a name="l34480"></a>34480   <span class="keywordflow">if</span> (dummytetbase != (tetrahedron *) NULL) {
<a name="l34481"></a>34481     <span class="keyword">delete</span> [] dummytetbase;
<a name="l34482"></a>34482   }
<a name="l34483"></a>34483   <span class="keywordflow">if</span> (dummyshbase != (shellface *) NULL) {
<a name="l34484"></a>34484     <span class="keyword">delete</span> [] dummyshbase;
<a name="l34485"></a>34485   }
<a name="l34486"></a>34486   <span class="keywordflow">if</span> (facetabovepointarray != (point *) NULL) {
<a name="l34487"></a>34487     <span class="keyword">delete</span> [] facetabovepointarray;
<a name="l34488"></a>34488   }
<a name="l34489"></a>34489   <span class="keywordflow">if</span> (highordertable != (point *) NULL) {
<a name="l34490"></a>34490     <span class="keyword">delete</span> [] highordertable;
<a name="l34491"></a>34491   }
<a name="l34492"></a>34492   <span class="keywordflow">if</span> (subpbcgrouptable != (pbcdata *) NULL) {
<a name="l34493"></a>34493     <span class="keyword">delete</span> [] subpbcgrouptable;
<a name="l34494"></a>34494   }
<a name="l34495"></a>34495   <span class="keywordflow">if</span> (segpbcgrouptable != (list *) NULL) {
<a name="l34496"></a>34496     <span class="keyword">delete</span> segpbcgrouptable;
<a name="l34497"></a>34497     <span class="keyword">delete</span> [] idx2segpglist;
<a name="l34498"></a>34498     <span class="keyword">delete</span> [] segpglist;
<a name="l34499"></a>34499   }
<a name="l34500"></a>34500 }
<a name="l34501"></a>34501 
<a name="l34503"></a>34503 <span class="comment">//                                                                           //</span>
<a name="l34504"></a>34504 <span class="comment">// tetgenmesh()    Initialize a tetgenmesh object.                           //</span>
<a name="l34505"></a>34505 <span class="comment">//                                                                           //</span>
<a name="l34507"></a>34507 <span class="comment"></span>
<a name="l34508"></a>34508 tetgenmesh::tetgenmesh()
<a name="l34509"></a>34509 {
<a name="l34510"></a>34510   bgm = (tetgenmesh *) NULL;
<a name="l34511"></a>34511   in = (tetgenio *) NULL;
<a name="l34512"></a>34512   b = (tetgenbehavior *) NULL;
<a name="l34513"></a>34513 
<a name="l34514"></a>34514   tetrahedrons = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l34515"></a>34515   subfaces = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l34516"></a>34516   subsegs = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l34517"></a>34517   points = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l34518"></a>34518   badsubsegs = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l34519"></a>34519   badsubfaces = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l34520"></a>34520   badtetrahedrons = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l34521"></a>34521   flipstackers = (<a class="code" href="structmemorypool.html">memorypool</a> *) NULL;
<a name="l34522"></a>34522 
<a name="l34523"></a>34523   dummytet = (tetrahedron *) NULL;
<a name="l34524"></a>34524   dummytetbase = (tetrahedron *) NULL;
<a name="l34525"></a>34525   dummysh = (shellface *) NULL;
<a name="l34526"></a>34526   dummyshbase = (shellface *) NULL;
<a name="l34527"></a>34527 
<a name="l34528"></a>34528   facetabovepointarray = (point *) NULL;
<a name="l34529"></a>34529   abovepoint = (point) NULL;
<a name="l34530"></a>34530   highordertable = (point *) NULL;
<a name="l34531"></a>34531   subpbcgrouptable = (pbcdata *) NULL;
<a name="l34532"></a>34532   segpbcgrouptable = (list *) NULL;
<a name="l34533"></a>34533   idx2segpglist = (<span class="keywordtype">int</span> *) NULL;
<a name="l34534"></a>34534   segpglist = (<span class="keywordtype">int</span> *) NULL;
<a name="l34535"></a>34535 
<a name="l34536"></a>34536   xmax = xmin = ymax = ymin = zmax = zmin = 0.0;
<a name="l34537"></a>34537   longest = 0.0;
<a name="l34538"></a>34538   hullsize = 0l;
<a name="l34539"></a>34539   insegments = 0l;
<a name="l34540"></a>34540   pointmtrindex = 0;
<a name="l34541"></a>34541   pointmarkindex = 0;
<a name="l34542"></a>34542   point2simindex = 0;
<a name="l34543"></a>34543   point2pbcptindex = 0;
<a name="l34544"></a>34544   highorderindex = 0;
<a name="l34545"></a>34545   elemattribindex = 0;
<a name="l34546"></a>34546   volumeboundindex = 0;
<a name="l34547"></a>34547   shmarkindex = 0;
<a name="l34548"></a>34548   areaboundindex = 0;
<a name="l34549"></a>34549   checksubfaces = 0;
<a name="l34550"></a>34550   checksubsegs = 0;
<a name="l34551"></a>34551   checkpbcs = 0;
<a name="l34552"></a>34552   varconstraint = 0;
<a name="l34553"></a>34553   nonconvex = 0;
<a name="l34554"></a>34554   dupverts = 0;
<a name="l34555"></a>34555   unuverts = 0;
<a name="l34556"></a>34556   relverts = 0;
<a name="l34557"></a>34557   suprelverts = 0;
<a name="l34558"></a>34558   collapverts = 0;
<a name="l34559"></a>34559   unsupverts = 0;
<a name="l34560"></a>34560   jettisoninverts = 0;
<a name="l34561"></a>34561   symbolic = 1;
<a name="l34562"></a>34562   samples = 0l;
<a name="l34563"></a>34563   randomseed = 1l;
<a name="l34564"></a>34564   macheps = 0.0;
<a name="l34565"></a>34565   minfaceang = minfacetdihed = PI;
<a name="l34566"></a>34566   maxcavfaces = maxcavverts = 0;
<a name="l34567"></a>34567   expcavcount = 0;
<a name="l34568"></a>34568   abovecount = 0l;
<a name="l34569"></a>34569   bowatvolcount = bowatsubcount = bowatsegcount = 0l;
<a name="l34570"></a>34570   updvolcount = updsubcount = updsegcount = 0l;
<a name="l34571"></a>34571   repairflipcount = 0l;
<a name="l34572"></a>34572   outbowatcircumcount = 0l;
<a name="l34573"></a>34573   failvolcount = failsubcount = failsegcount = 0l;
<a name="l34574"></a>34574   r1count = r2count = r3count = 0l;
<a name="l34575"></a>34575   cdtenforcesegpts = 0l;
<a name="l34576"></a>34576   rejsegpts = rejsubpts = rejtetpts = 0l;
<a name="l34577"></a>34577   flip23s = flip32s = flip22s = flip44s = 0l;
<a name="l34578"></a>34578   tloctime = tfliptime = 0.0;
<a name="l34579"></a>34579 }
<a name="l34580"></a>34580 
<a name="l34581"></a>34581 <span class="comment">//</span>
<a name="l34582"></a>34582 <span class="comment">// End of constructor and destructor of tetgenmesh</span>
<a name="l34583"></a>34583 <span class="comment">//</span>
<a name="l34584"></a>34584 
<a name="l34585"></a>34585 <span class="comment">//</span>
<a name="l34586"></a>34586 <span class="comment">// End of class &#39;tetgenmesh&#39; implementation.</span>
<a name="l34587"></a>34587 <span class="comment">//</span>
<a name="l34588"></a>34588 
<a name="l34590"></a>34590 <span class="comment">//                                                                           //</span>
<a name="l34591"></a>34591 <span class="comment">// tetrahedralize()    The interface for users using TetGen library to       //</span>
<a name="l34592"></a>34592 <span class="comment">//                     generate tetrahedral meshes with all features.        //</span>
<a name="l34593"></a>34593 <span class="comment">//                                                                           //</span>
<a name="l34594"></a>34594 <span class="comment">// The sequence is roughly as follows.  Many of these steps can be skipped,  //</span>
<a name="l34595"></a>34595 <span class="comment">// depending on the command line switches.                                   //</span>
<a name="l34596"></a>34596 <span class="comment">//                                                                           //</span>
<a name="l34597"></a>34597 <span class="comment">// - Initialize constants and parse the command line.                        //</span>
<a name="l34598"></a>34598 <span class="comment">// - Read the vertices from a file and either                                //</span>
<a name="l34599"></a>34599 <span class="comment">//   - tetrahedralize them (no -r), or                                       //</span>
<a name="l34600"></a>34600 <span class="comment">//   - read an old mesh from files and reconstruct it (-r).                  //</span>
<a name="l34601"></a>34601 <span class="comment">// - Insert the PLC segments and facets (-p).                                //</span>
<a name="l34602"></a>34602 <span class="comment">// - Read the holes (-p), regional attributes (-pA), and regional volume     //</span>
<a name="l34603"></a>34603 <span class="comment">//   constraints (-pa).  Carve the holes and concavities, and spread the     //</span>
<a name="l34604"></a>34604 <span class="comment">//   regional attributes and volume constraints.                             //</span>
<a name="l34605"></a>34605 <span class="comment">// - Enforce the constraints on minimum quality bound (-q) and maximum       //</span>
<a name="l34606"></a>34606 <span class="comment">//   volume (-a). Also enforce the conforming Delaunay property (-q and -a). //</span>
<a name="l34607"></a>34607 <span class="comment">// - Promote the mesh&#39;s linear tetrahedra to higher order elements (-o).     //</span>
<a name="l34608"></a>34608 <span class="comment">// - Write the output files and print the statistics.                        //</span>
<a name="l34609"></a>34609 <span class="comment">// - Check the consistency and Delaunay property of the mesh (-C).           //</span>
<a name="l34610"></a>34610 <span class="comment">//                                                                           //</span>
<a name="l34612"></a>34612 <span class="comment"></span>
<a name="l34613"></a>34613 <span class="keywordtype">void</span> tetrahedralize(tetgenbehavior *b, tetgenio *in, tetgenio *out,
<a name="l34614"></a>34614   tetgenio *addin, tetgenio *bgmin)
<a name="l34615"></a>34615 {
<a name="l34616"></a>34616   tetgenmesh m;
<a name="l34617"></a>34617   <span class="comment">// Variables for timing the performance of TetGen (defined in time.h).</span>
<a name="l34618"></a>34618   clock_t tv[14];
<a name="l34619"></a>34619 
<a name="l34620"></a>34620   tv[0] = clock();
<a name="l34621"></a>34621 
<a name="l34622"></a>34622   m.b = b;
<a name="l34623"></a>34623   m.in = in;
<a name="l34624"></a>34624   m.macheps = exactinit();
<a name="l34625"></a>34625   m.steinerleft = b-&gt;steiner;
<a name="l34626"></a>34626   <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l34627"></a>34627     m.bgm = <span class="keyword">new</span> tetgenmesh();
<a name="l34628"></a>34628     m.bgm-&gt;b = b;
<a name="l34629"></a>34629     m.bgm-&gt;in = bgmin;
<a name="l34630"></a>34630     m.bgm-&gt;macheps = exactinit();
<a name="l34631"></a>34631   }
<a name="l34632"></a>34632   m.initializepools();
<a name="l34633"></a>34633   m.transfernodes();
<a name="l34634"></a>34634 
<a name="l34635"></a>34635   tv[1] = clock();
<a name="l34636"></a>34636 
<a name="l34637"></a>34637   <span class="keywordflow">if</span> (b-&gt;refine) {
<a name="l34638"></a>34638     m.reconstructmesh();
<a name="l34639"></a>34639   } <span class="keywordflow">else</span> {
<a name="l34640"></a>34640     m.delaunizevertices();
<a name="l34641"></a>34641   }
<a name="l34642"></a>34642 
<a name="l34643"></a>34643   tv[2] = clock();
<a name="l34644"></a>34644 
<a name="l34645"></a>34645   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34646"></a>34646     <span class="keywordflow">if</span> (b-&gt;refine) {
<a name="l34647"></a>34647       printf(<span class="stringliteral">&quot;Mesh reconstruction seconds:&quot;</span>);
<a name="l34648"></a>34648     } <span class="keywordflow">else</span> {
<a name="l34649"></a>34649       printf(<span class="stringliteral">&quot;Delaunay seconds:&quot;</span>);
<a name="l34650"></a>34650     }
<a name="l34651"></a>34651     printf(<span class="stringliteral">&quot;  %g\n&quot;</span>, (tv[2] - tv[1]) / (REAL) CLOCKS_PER_SEC);
<a name="l34652"></a>34652   }
<a name="l34653"></a>34653 
<a name="l34654"></a>34654   <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l34655"></a>34655     <span class="keywordflow">if</span> (bgmin != (tetgenio *) NULL) {
<a name="l34656"></a>34656       m.bgm-&gt;initializepools();
<a name="l34657"></a>34657       m.bgm-&gt;transfernodes();
<a name="l34658"></a>34658       m.bgm-&gt;reconstructmesh();
<a name="l34659"></a>34659     } <span class="keywordflow">else</span> {
<a name="l34660"></a>34660       m.bgm-&gt;in = in;
<a name="l34661"></a>34661       m.bgm-&gt;initializepools();
<a name="l34662"></a>34662       m.duplicatebgmesh();
<a name="l34663"></a>34663     }
<a name="l34664"></a>34664   }
<a name="l34665"></a>34665 
<a name="l34666"></a>34666   tv[3] = clock();
<a name="l34667"></a>34667 
<a name="l34668"></a>34668   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34669"></a>34669     <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l34670"></a>34670       printf(<span class="stringliteral">&quot;Background mesh reconstruct seconds:  %g\n&quot;</span>,
<a name="l34671"></a>34671              (tv[3] - tv[2]) / (REAL) CLOCKS_PER_SEC);
<a name="l34672"></a>34672     }
<a name="l34673"></a>34673   }
<a name="l34674"></a>34674 
<a name="l34675"></a>34675   <span class="keywordflow">if</span> (b-&gt;useshelles &amp;&amp; !b-&gt;refine) {
<a name="l34676"></a>34676     m.meshsurface();
<a name="l34677"></a>34677     <span class="keywordflow">if</span> (b-&gt;diagnose != 1) {
<a name="l34678"></a>34678       m.markacutevertices(89.0);
<a name="l34679"></a>34679       m.incrperturbvertices(b-&gt;epsilon);
<a name="l34680"></a>34680       m.delaunizesegments();
<a name="l34681"></a>34681       <span class="keywordflow">if</span> (m.checkpbcs) {
<a name="l34682"></a>34682         <span class="keywordtype">long</span> oldnum;
<a name="l34683"></a>34683         <span class="keywordflow">do</span> {
<a name="l34684"></a>34684           oldnum = m.points-&gt;items;
<a name="l34685"></a>34685           m.incrperturbvertices(b-&gt;epsilon);
<a name="l34686"></a>34686           <span class="keywordflow">if</span> (m.points-&gt;items &gt; oldnum) {
<a name="l34687"></a>34687             oldnum = m.points-&gt;items;
<a name="l34688"></a>34688             m.delaunizesegments();
<a name="l34689"></a>34689           }
<a name="l34690"></a>34690         } <span class="keywordflow">while</span> (oldnum &lt; m.points-&gt;items);
<a name="l34691"></a>34691       }
<a name="l34692"></a>34692       m.constrainedfacets();
<a name="l34693"></a>34693     } <span class="keywordflow">else</span> {
<a name="l34694"></a>34694       m.detectinterfaces();
<a name="l34695"></a>34695     }
<a name="l34696"></a>34696   }
<a name="l34697"></a>34697 
<a name="l34698"></a>34698   tv[4] = clock();
<a name="l34699"></a>34699 
<a name="l34700"></a>34700   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34701"></a>34701     <span class="keywordflow">if</span> (b-&gt;useshelles &amp;&amp; !b-&gt;refine) {
<a name="l34702"></a>34702       <span class="keywordflow">if</span> (b-&gt;diagnose != 1) {
<a name="l34703"></a>34703         printf(<span class="stringliteral">&quot;Segment and facet &quot;</span>);
<a name="l34704"></a>34704       } <span class="keywordflow">else</span> {
<a name="l34705"></a>34705         printf(<span class="stringliteral">&quot;Intersection &quot;</span>);
<a name="l34706"></a>34706       }
<a name="l34707"></a>34707       printf(<span class="stringliteral">&quot;seconds:  %g\n&quot;</span>, (tv[4] - tv[3]) / (REAL) CLOCKS_PER_SEC);
<a name="l34708"></a>34708     }
<a name="l34709"></a>34709   }
<a name="l34710"></a>34710 
<a name="l34711"></a>34711   <span class="keywordflow">if</span> (b-&gt;plc &amp;&amp; !(b-&gt;diagnose == 1)) {
<a name="l34712"></a>34712     m.carveholes();
<a name="l34713"></a>34713   }
<a name="l34714"></a>34714 
<a name="l34715"></a>34715   tv[5] = clock();
<a name="l34716"></a>34716 
<a name="l34717"></a>34717   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34718"></a>34718     <span class="keywordflow">if</span> (b-&gt;plc &amp;&amp; !(b-&gt;diagnose == 1)) {
<a name="l34719"></a>34719       printf(<span class="stringliteral">&quot;Hole seconds:  %g\n&quot;</span>, (tv[5] - tv[4]) / (REAL) CLOCKS_PER_SEC);
<a name="l34720"></a>34720     }
<a name="l34721"></a>34721   }
<a name="l34722"></a>34722 
<a name="l34723"></a>34723   <span class="keywordflow">if</span> ((b-&gt;plc || b-&gt;refine) &amp;&amp; !(b-&gt;diagnose == 1)) {
<a name="l34724"></a>34724     m.optimizemesh(<span class="keyword">false</span>);
<a name="l34725"></a>34725   }
<a name="l34726"></a>34726 
<a name="l34727"></a>34727   tv[6] = clock();
<a name="l34728"></a>34728 
<a name="l34729"></a>34729   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34730"></a>34730     <span class="keywordflow">if</span> ((b-&gt;plc || b-&gt;refine) &amp;&amp; !(b-&gt;diagnose == 1)) {
<a name="l34731"></a>34731       printf(<span class="stringliteral">&quot;Repair seconds:  %g\n&quot;</span>, (tv[6] - tv[5]) / (REAL) CLOCKS_PER_SEC);
<a name="l34732"></a>34732     }
<a name="l34733"></a>34733   }
<a name="l34734"></a>34734 
<a name="l34735"></a>34735   <span class="keywordflow">if</span> ((b-&gt;plc &amp;&amp; b-&gt;nobisect) &amp;&amp; !(b-&gt;diagnose == 1)) {
<a name="l34736"></a>34736     m.removesteiners(<span class="keyword">false</span>);
<a name="l34737"></a>34737   }
<a name="l34738"></a>34738 
<a name="l34739"></a>34739   tv[7] = clock();
<a name="l34740"></a>34740 
<a name="l34741"></a>34741   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34742"></a>34742     <span class="keywordflow">if</span> ((b-&gt;plc &amp;&amp; b-&gt;nobisect) &amp;&amp; !(b-&gt;diagnose == 1)) {
<a name="l34743"></a>34743       printf(<span class="stringliteral">&quot;Steiner removal seconds:  %g\n&quot;</span>,
<a name="l34744"></a>34744              (tv[7] - tv[6]) / (REAL) CLOCKS_PER_SEC);
<a name="l34745"></a>34745     }
<a name="l34746"></a>34746   }
<a name="l34747"></a>34747 
<a name="l34748"></a>34748   <span class="keywordflow">if</span> (b-&gt;insertaddpoints &amp;&amp; (addin != (tetgenio *) NULL)) {
<a name="l34749"></a>34749     <span class="keywordflow">if</span> (addin-&gt;numberofpoints &gt; 0) {
<a name="l34750"></a>34750       m.insertconstrainedpoints(addin);
<a name="l34751"></a>34751     }
<a name="l34752"></a>34752   }
<a name="l34753"></a>34753 
<a name="l34754"></a>34754   tv[8] = clock();
<a name="l34755"></a>34755 
<a name="l34756"></a>34756   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34757"></a>34757     <span class="keywordflow">if</span> ((b-&gt;plc || b-&gt;refine) &amp;&amp; (b-&gt;insertaddpoints)) {
<a name="l34758"></a>34758       printf(<span class="stringliteral">&quot;Constrained points seconds:  %g\n&quot;</span>,
<a name="l34759"></a>34759              (tv[8] - tv[7]) / (REAL) CLOCKS_PER_SEC);
<a name="l34760"></a>34760     }
<a name="l34761"></a>34761   }
<a name="l34762"></a>34762 
<a name="l34763"></a>34763   <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l34764"></a>34764     m.interpolatesizemap();
<a name="l34765"></a>34765   }
<a name="l34766"></a>34766 
<a name="l34767"></a>34767   tv[9] = clock();
<a name="l34768"></a>34768 
<a name="l34769"></a>34769   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34770"></a>34770     <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l34771"></a>34771       printf(<span class="stringliteral">&quot;Size interpolating seconds:  %g\n&quot;</span>,
<a name="l34772"></a>34772              (tv[9] - tv[8]) / (REAL) CLOCKS_PER_SEC);
<a name="l34773"></a>34773     }
<a name="l34774"></a>34774   }
<a name="l34775"></a>34775 
<a name="l34776"></a>34776   <span class="keywordflow">if</span> (b-&gt;coarse) {
<a name="l34777"></a>34777     m.removesteiners(<span class="keyword">true</span>);
<a name="l34778"></a>34778   }
<a name="l34779"></a>34779 
<a name="l34780"></a>34780   tv[10] = clock();
<a name="l34781"></a>34781 
<a name="l34782"></a>34782   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34783"></a>34783     <span class="keywordflow">if</span> (b-&gt;coarse) {
<a name="l34784"></a>34784       printf(<span class="stringliteral">&quot;Mesh coarsening seconds:  %g\n&quot;</span>,
<a name="l34785"></a>34785              (tv[10] - tv[9]) / (REAL) CLOCKS_PER_SEC);
<a name="l34786"></a>34786     }
<a name="l34787"></a>34787   }
<a name="l34788"></a>34788 
<a name="l34789"></a>34789   <span class="keywordflow">if</span> (b-&gt;quality) {
<a name="l34790"></a>34790     m.enforcequality();
<a name="l34791"></a>34791   }
<a name="l34792"></a>34792 
<a name="l34793"></a>34793   tv[11] = clock();
<a name="l34794"></a>34794 
<a name="l34795"></a>34795   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34796"></a>34796     <span class="keywordflow">if</span> (b-&gt;quality) {
<a name="l34797"></a>34797       printf(<span class="stringliteral">&quot;Quality seconds:  %g\n&quot;</span>,
<a name="l34798"></a>34798              (tv[11] - tv[10]) / (REAL) CLOCKS_PER_SEC);
<a name="l34799"></a>34799     }
<a name="l34800"></a>34800   }
<a name="l34801"></a>34801 
<a name="l34802"></a>34802   <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; (b-&gt;optlevel &gt; 0)) {
<a name="l34803"></a>34803     m.optimizemesh(<span class="keyword">true</span>);
<a name="l34804"></a>34804   }
<a name="l34805"></a>34805 
<a name="l34806"></a>34806   tv[12] = clock();
<a name="l34807"></a>34807 
<a name="l34808"></a>34808   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34809"></a>34809     <span class="keywordflow">if</span> (b-&gt;quality &amp;&amp; (b-&gt;optlevel &gt; 0)) {
<a name="l34810"></a>34810       printf(<span class="stringliteral">&quot;Optimize seconds:  %g\n&quot;</span>,
<a name="l34811"></a>34811              (tv[12] - tv[11]) / (REAL) CLOCKS_PER_SEC);
<a name="l34812"></a>34812     }
<a name="l34813"></a>34813   }
<a name="l34814"></a>34814 
<a name="l34815"></a>34815   <span class="keywordflow">if</span> (!b-&gt;nojettison &amp;&amp; ((m.dupverts &gt; 0) || (m.unuverts &gt; 0)
<a name="l34816"></a>34816       || (b-&gt;refine &amp;&amp; (in-&gt;numberofcorners == 10)))) {
<a name="l34817"></a>34817     m.jettisonnodes();
<a name="l34818"></a>34818   }
<a name="l34819"></a>34819 
<a name="l34820"></a>34820   <span class="keywordflow">if</span> (b-&gt;order &gt; 1) {
<a name="l34821"></a>34821     m.highorder();
<a name="l34822"></a>34822   }
<a name="l34823"></a>34823 
<a name="l34824"></a>34824   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34825"></a>34825     printf(<span class="stringliteral">&quot;\n&quot;</span>);
<a name="l34826"></a>34826   }
<a name="l34827"></a>34827 
<a name="l34828"></a>34828   <span class="keywordflow">if</span> (out != (tetgenio *) NULL) {
<a name="l34829"></a>34829     out-&gt;firstnumber = in-&gt;firstnumber;
<a name="l34830"></a>34830     out-&gt;mesh_dim = in-&gt;mesh_dim;
<a name="l34831"></a>34831   }
<a name="l34832"></a>34832 
<a name="l34833"></a>34833   <span class="keywordflow">if</span> (b-&gt;nonodewritten || b-&gt;noiterationnum) {
<a name="l34834"></a>34834     <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34835"></a>34835       printf(<span class="stringliteral">&quot;NOT writing a .node file.\n&quot;</span>);
<a name="l34836"></a>34836     }
<a name="l34837"></a>34837   } <span class="keywordflow">else</span> {
<a name="l34838"></a>34838     <span class="keywordflow">if</span> (b-&gt;diagnose == 1) {
<a name="l34839"></a>34839       <span class="keywordflow">if</span> (m.subfaces-&gt;items &gt; 0l) {
<a name="l34840"></a>34840         m.outnodes(out);  <span class="comment">// Only output when self-intersecting faces exist.</span>
<a name="l34841"></a>34841       }
<a name="l34842"></a>34842     } <span class="keywordflow">else</span> {
<a name="l34843"></a>34843       m.outnodes(out);
<a name="l34844"></a>34844       <span class="keywordflow">if</span> (b-&gt;quality || b-&gt;metric) {
<a name="l34845"></a>34845         <span class="comment">// m.outmetrics(out);</span>
<a name="l34846"></a>34846       }
<a name="l34847"></a>34847     }
<a name="l34848"></a>34848   }
<a name="l34849"></a>34849 
<a name="l34850"></a>34850   <span class="keywordflow">if</span> (b-&gt;noelewritten) {
<a name="l34851"></a>34851     <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34852"></a>34852       printf(<span class="stringliteral">&quot;NOT writing an .ele file.\n&quot;</span>);
<a name="l34853"></a>34853     }
<a name="l34854"></a>34854   } <span class="keywordflow">else</span> {
<a name="l34855"></a>34855     <span class="keywordflow">if</span> (!(b-&gt;diagnose == 1)) {
<a name="l34856"></a>34856       <span class="keywordflow">if</span> (m.tetrahedrons-&gt;items &gt; 0l) {
<a name="l34857"></a>34857         m.outelements(out);
<a name="l34858"></a>34858       }
<a name="l34859"></a>34859     }
<a name="l34860"></a>34860   }
<a name="l34861"></a>34861 
<a name="l34862"></a>34862   <span class="keywordflow">if</span> (b-&gt;nofacewritten) {
<a name="l34863"></a>34863     <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34864"></a>34864       printf(<span class="stringliteral">&quot;NOT writing an .face file.\n&quot;</span>);
<a name="l34865"></a>34865     }
<a name="l34866"></a>34866   } <span class="keywordflow">else</span> {
<a name="l34867"></a>34867     <span class="keywordflow">if</span> (b-&gt;facesout) {
<a name="l34868"></a>34868       <span class="keywordflow">if</span> (m.tetrahedrons-&gt;items &gt; 0l) {
<a name="l34869"></a>34869         m.outfaces(out);  <span class="comment">// Output all faces.</span>
<a name="l34870"></a>34870       }
<a name="l34871"></a>34871     } <span class="keywordflow">else</span> {
<a name="l34872"></a>34872       <span class="keywordflow">if</span> (b-&gt;diagnose == 1) {
<a name="l34873"></a>34873         <span class="keywordflow">if</span> (m.subfaces-&gt;items &gt; 0l) {
<a name="l34874"></a>34874           m.outsubfaces(out); <span class="comment">// Only output self-intersecting faces.</span>
<a name="l34875"></a>34875         }
<a name="l34876"></a>34876       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (b-&gt;plc || b-&gt;refine) {
<a name="l34877"></a>34877         <span class="keywordflow">if</span> (m.subfaces-&gt;items &gt; 0l) {
<a name="l34878"></a>34878           m.outsubfaces(out); <span class="comment">// Output boundary faces.</span>
<a name="l34879"></a>34879         }
<a name="l34880"></a>34880       } <span class="keywordflow">else</span> {
<a name="l34881"></a>34881         <span class="keywordflow">if</span> (m.tetrahedrons-&gt;items &gt; 0l) {
<a name="l34882"></a>34882           m.outhullfaces(out); <span class="comment">// Output convex hull faces.</span>
<a name="l34883"></a>34883         }
<a name="l34884"></a>34884       }
<a name="l34885"></a>34885     }
<a name="l34886"></a>34886   }
<a name="l34887"></a>34887 
<a name="l34888"></a>34888   <span class="keywordflow">if</span> (m.checkpbcs) {
<a name="l34889"></a>34889     m.outpbcnodes(out);
<a name="l34890"></a>34890   }
<a name="l34891"></a>34891 
<a name="l34892"></a>34892   <span class="keywordflow">if</span> (b-&gt;edgesout) {
<a name="l34893"></a>34893     <span class="keywordflow">if</span> (b-&gt;edgesout &gt; 1) {
<a name="l34894"></a>34894       m.outedges(out); <span class="comment">// -ee, output all mesh edges.</span>
<a name="l34895"></a>34895     } <span class="keywordflow">else</span> {
<a name="l34896"></a>34896       m.outsubsegments(out); <span class="comment">// -e, only output subsegments.</span>
<a name="l34897"></a>34897     }
<a name="l34898"></a>34898   }
<a name="l34899"></a>34899 
<a name="l34900"></a>34900   <span class="keywordflow">if</span> (!out &amp;&amp; b-&gt;plc &amp;&amp;
<a name="l34901"></a>34901       ((b-&gt;object == tetgenbehavior::OFF) ||
<a name="l34902"></a>34902        (b-&gt;object == tetgenbehavior::PLY) ||
<a name="l34903"></a>34903        (b-&gt;object == tetgenbehavior::STL))) {
<a name="l34904"></a>34904     m.outsmesh(b-&gt;outfilename);
<a name="l34905"></a>34905   }
<a name="l34906"></a>34906 
<a name="l34907"></a>34907   <span class="keywordflow">if</span> (!out &amp;&amp; b-&gt;meditview) {
<a name="l34908"></a>34908     m.outmesh2medit(b-&gt;outfilename);
<a name="l34909"></a>34909   }
<a name="l34910"></a>34910 
<a name="l34911"></a>34911   <span class="keywordflow">if</span> (!out &amp;&amp; b-&gt;gidview) {
<a name="l34912"></a>34912     m.outmesh2gid(b-&gt;outfilename);
<a name="l34913"></a>34913   }
<a name="l34914"></a>34914 
<a name="l34915"></a>34915   <span class="keywordflow">if</span> (!out &amp;&amp; b-&gt;geomview) {
<a name="l34916"></a>34916     m.outmesh2off(b-&gt;outfilename);
<a name="l34917"></a>34917   }
<a name="l34918"></a>34918 
<a name="l34919"></a>34919   <span class="keywordflow">if</span> (b-&gt;neighout) {
<a name="l34920"></a>34920     m.outneighbors(out);
<a name="l34921"></a>34921   }
<a name="l34922"></a>34922 
<a name="l34923"></a>34923   <span class="keywordflow">if</span> (b-&gt;voroout) {
<a name="l34924"></a>34924     m.outvoronoi(out);
<a name="l34925"></a>34925   }
<a name="l34926"></a>34926 
<a name="l34927"></a>34927   tv[13] = clock();
<a name="l34928"></a>34928 
<a name="l34929"></a>34929   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34930"></a>34930     printf(<span class="stringliteral">&quot;\nOutput seconds:  %g\n&quot;</span>,
<a name="l34931"></a>34931            (tv[13] - tv[12]) / (REAL) CLOCKS_PER_SEC);
<a name="l34932"></a>34932     printf(<span class="stringliteral">&quot;Total running seconds:  %g\n&quot;</span>,
<a name="l34933"></a>34933            (tv[13] - tv[0]) / (REAL) CLOCKS_PER_SEC);
<a name="l34934"></a>34934   }
<a name="l34935"></a>34935 
<a name="l34936"></a>34936   <span class="keywordflow">if</span> (b-&gt;docheck) {
<a name="l34937"></a>34937     m.checkmesh();
<a name="l34938"></a>34938     <span class="keywordflow">if</span> (m.checksubfaces) {
<a name="l34939"></a>34939       m.checkshells();
<a name="l34940"></a>34940     }
<a name="l34941"></a>34941     <span class="keywordflow">if</span> (b-&gt;docheck &gt; 1) {
<a name="l34942"></a>34942       m.checkdelaunay(0.0, NULL);
<a name="l34943"></a>34943       <span class="keywordflow">if</span> (b-&gt;docheck &gt; 2) {
<a name="l34944"></a>34944         <span class="keywordflow">if</span> (b-&gt;quality || b-&gt;refine) {
<a name="l34945"></a>34945           m.checkconforming();
<a name="l34946"></a>34946         }
<a name="l34947"></a>34947       }
<a name="l34948"></a>34948     }
<a name="l34949"></a>34949   }
<a name="l34950"></a>34950 
<a name="l34951"></a>34951   <span class="keywordflow">if</span> (!b-&gt;quiet) {
<a name="l34952"></a>34952     m.statistics();
<a name="l34953"></a>34953   }
<a name="l34954"></a>34954 
<a name="l34955"></a>34955   <span class="keywordflow">if</span> (b-&gt;metric) {
<a name="l34956"></a>34956     <span class="keyword">delete</span> m.bgm;
<a name="l34957"></a>34957   }
<a name="l34958"></a>34958 }
<a name="l34959"></a>34959 
<a name="l34960"></a>34960 <span class="preprocessor">#ifndef TETLIBRARY</span>
<a name="l34961"></a>34961 <span class="preprocessor"></span>
<a name="l34963"></a>34963 <span class="comment">//                                                                           //</span>
<a name="l34964"></a>34964 <span class="comment">// main()    The entrance for running TetGen from command line.              //</span>
<a name="l34965"></a>34965 <span class="comment">//                                                                           //</span>
<a name="l34967"></a>34967 <span class="comment"></span>
<a name="l34968"></a>34968 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
<a name="l34969"></a>34969 
<a name="l34970"></a>34970 <span class="preprocessor">#else // with TETLIBRARY</span>
<a name="l34971"></a>34971 <span class="preprocessor"></span>
<a name="l34973"></a>34973 <span class="comment">//                                                                           //</span>
<a name="l34974"></a>34974 <span class="comment">// tetrahedralize()    The entrance for calling TetGen from another program. //</span>
<a name="l34975"></a>34975 <span class="comment">//                                                                           //</span>
<a name="l34977"></a>34977 <span class="comment"></span>
<a name="l34978"></a>34978 <span class="keywordtype">void</span> tetrahedralize(<span class="keywordtype">char</span> *switches, tetgenio *in, tetgenio *out,
<a name="l34979"></a>34979   tetgenio *addin, tetgenio *bgmin)
<a name="l34980"></a>34980 
<a name="l34981"></a>34981 <span class="preprocessor">#endif // not TETLIBRARY</span>
<a name="l34982"></a>34982 <span class="preprocessor"></span>
<a name="l34983"></a>34983 {
<a name="l34984"></a>34984   tetgenbehavior b;
<a name="l34985"></a>34985 
<a name="l34986"></a>34986 <span class="preprocessor">#ifndef TETLIBRARY</span>
<a name="l34987"></a>34987 <span class="preprocessor"></span>
<a name="l34988"></a>34988   tetgenio in, addin, bgmin;
<a name="l34989"></a>34989 
<a name="l34990"></a>34990   <span class="keywordflow">if</span> (!b.parse_commandline(argc, argv)) {
<a name="l34991"></a>34991     terminatetetgen(1);
<a name="l34992"></a>34992   }
<a name="l34993"></a>34993   <span class="keywordflow">if</span> (b.refine) {
<a name="l34994"></a>34994     <span class="keywordflow">if</span> (!in.load_tetmesh(b.infilename)) {
<a name="l34995"></a>34995       terminatetetgen(1);
<a name="l34996"></a>34996     }
<a name="l34997"></a>34997   } <span class="keywordflow">else</span> {
<a name="l34998"></a>34998     <span class="keywordflow">if</span> (!in.load_plc(b.infilename, (<span class="keywordtype">int</span>) b.object)) {
<a name="l34999"></a>34999       terminatetetgen(1);
<a name="l35000"></a>35000     }
<a name="l35001"></a>35001   }
<a name="l35002"></a>35002   <span class="keywordflow">if</span> (b.insertaddpoints) {
<a name="l35003"></a>35003     <span class="keywordflow">if</span> (!addin.load_node(b.addinfilename)) {
<a name="l35004"></a>35004       addin.numberofpoints = 0l;
<a name="l35005"></a>35005     }
<a name="l35006"></a>35006   }
<a name="l35007"></a>35007   <span class="keywordflow">if</span> (b.metric) {
<a name="l35008"></a>35008     <span class="keywordflow">if</span> (!bgmin.load_tetmesh(b.bgmeshfilename)) {
<a name="l35009"></a>35009       bgmin.numberoftetrahedra = 0l;
<a name="l35010"></a>35010     }
<a name="l35011"></a>35011   }
<a name="l35012"></a>35012 
<a name="l35013"></a>35013   <span class="keywordflow">if</span> (bgmin.numberoftetrahedra &gt; 0l) {
<a name="l35014"></a>35014     tetrahedralize(&amp;b, &amp;in, NULL, &amp;addin, &amp;bgmin);
<a name="l35015"></a>35015   } <span class="keywordflow">else</span> {
<a name="l35016"></a>35016     tetrahedralize(&amp;b, &amp;in, NULL, &amp;addin, NULL);
<a name="l35017"></a>35017   }
<a name="l35018"></a>35018 
<a name="l35019"></a>35019   <span class="keywordflow">return</span> 0;
<a name="l35020"></a>35020 
<a name="l35021"></a>35021 <span class="preprocessor">#else // with TETLIBRARY</span>
<a name="l35022"></a>35022 <span class="preprocessor"></span>
<a name="l35023"></a>35023   <span class="keywordflow">if</span> (!b.parse_commandline(switches)) {
<a name="l35024"></a>35024     terminatetetgen(1);
<a name="l35025"></a>35025   }
<a name="l35026"></a>35026   tetrahedralize(&amp;b, in, out, addin, bgmin);
<a name="l35027"></a>35027 
<a name="l35028"></a>35028 <span class="preprocessor">#endif // not TETLIBRARY</span>
<a name="l35029"></a>35029 <span class="preprocessor"></span>}
<a name="l35030"></a>35030 
<a name="l35031"></a>35031 } <span class="comment">//Added namespace to avoid clash with triangle</span>
<a name="l35032"></a>35032 
<a name="l35033"></a>35033 <span class="preprocessor">#ifndef TETLIBRARY</span>
<a name="l35034"></a>35034 <span class="preprocessor"></span><span class="comment">// Shim for entry point to main inside the namespace.  This is just in case we want to compile up a binary from this</span>
<a name="l35035"></a>35035 <span class="comment">// source code.</span>
<a name="l35036"></a>35036 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
<a name="l35037"></a>35037 {
<a name="l35038"></a>35038     tetgen::main(argc, argv);
<a name="l35039"></a>35039 }
<a name="l35040"></a>35040 <span class="preprocessor">#endif // not TETLIBRARY</span>
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="tetgen_8cpp.html">tetgen.cpp</a>      </li>
      <li class="footer">Generated on Mon Nov 5 2012 12:47:31 for Chaste by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </li>
    </ul>
  </div>

</body>
</html>
