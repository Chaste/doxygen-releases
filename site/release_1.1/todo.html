<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>Chaste: Todo List</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="classes.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="todo">Todo List </a></h1><a class="anchor" name="_todo000147"></a> <dl>
<dt>Member <a class="el" href="classAbstractBoundaryConditionsContainer.html#98e842db80a358c83142d31fe13d34d1">AbstractBoundaryConditionsContainer::HasDirichletBoundaryCondition</a> (const Node&lt; SPACE_DIM &gt; *pNode, unsigned indexOfUnknown=0) </dt>
<dd>Perhaps have flag in node object for efficiency?<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000014"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#b3d410251141549358c65068dffd4189">AbstractCardiacPde::mDoOneCacheReplication</a>  </dt>
<dd>maybe we don't want the conventional assembly even in the first time step. </dd>
</dl>
<p>
<a class="anchor" name="_todo000013"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#39dfbb68a40779f4d7f50bcea1bce67a">AbstractCardiacPde::serialize</a> (Archive &amp;archive, const unsigned int version) </dt>
<dd>#98 Check that mpIntracellularConductivityTensors is archived properly here. </dd>
</dl>
<p>
<a class="anchor" name="_todo000015"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#3da9067042945829fb0ac5dd5b9a1e0a">AbstractCardiacPde::AbstractCardiacPde</a> (AbstractCardiacCellFactory&lt; ELEM_DIM, SPACE_DIM &gt; *pCellFactory, const unsigned stride=1) </dt>
<dd>tidy up using extract method refactoring<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000009"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#3da9067042945829fb0ac5dd5b9a1e0a">AbstractCardiacPde::AbstractCardiacPde</a> (AbstractCardiacCellFactory&lt; ELEM_DIM, SPACE_DIM &gt; *pCellFactory, const unsigned stride=1) </dt>
<dd>Create a class defining constant tensors to be used when no fibre orientation is provided. </dd>
</dl>
<p>
<a class="anchor" name="_todo000011"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#4490629bc56452d6107dd3695d14a804">AbstractCardiacPde::AbstractCardiacPde</a> (std::vector&lt; AbstractCardiacCell * &gt; &amp;rCellsDistributed, const unsigned stride=1) </dt>
<dd>: #98: The state of the object is inconsistent since mpIntracellularConductivityTensors has not been set. </dd>
</dl>
<p>
<a class="anchor" name="_todo000012"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacPde.html#5bf51ab40bff8a969d93f18d831e81b9">AbstractCardiacPde::~AbstractCardiacPde</a> () </dt>
<dd>: #98 once the archiving constructor is creating the conductivity tensors properly we won't need this if statement </dd>
</dl>
<p>
<a class="anchor" name="_todo000029"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#05d48f02b8cccdc8917ba74aeba20c0d">AbstractCardiacProblem::mpWriter</a>  </dt>
<dd><a class="el" href="classCardiacElectroMechanicsProblem.html">CardiacElectroMechanicsProblem</a> should be a friend, but not sure how to get friends to work when both friends are templated and abstract. </dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#97b823df0769e85894bcfd831c640d60">AbstractCardiacProblem::Initialise</a> () </dt>
<dd>: Only considering &lt;LoadMesh/&gt; definition. Consider &lt;Slab/&gt; too </dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#97b823df0769e85894bcfd831c640d60">AbstractCardiacProblem::Initialise</a> () </dt>
<dd>We can't currently instantiate the parallel mesh in 1D </dd>
</dl>
<p>
<a class="anchor" name="_todo000024"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#97b823df0769e85894bcfd831c640d60">AbstractCardiacProblem::Initialise</a> () </dt>
<dd>Should this method be rolled into the Solve() method or the PreSolveChecks()? </dd>
</dl>
<p>
<a class="anchor" name="_todo000027"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#582d389e0adb8df913d97a10e46ad931">AbstractCardiacProblem::Solve</a> () </dt>
<dd>This should go in a location set in <a class="el" href="classArchiveLocationInfo.html">ArchiveLocationInfo</a> (see LinearSystem::load_construct_data(...)) </dd>
</dl>
<p>
<a class="anchor" name="_todo000028"></a> <dl>
<dt>Member <a class="el" href="classAbstractCardiacProblem.html#3edf3f74bbf50532e0bfeb36146cb8f7">AbstractCardiacProblem::CloseFilesAndPostProcess</a> () </dt>
<dd>WriteFilesUsingMesh cannot handle <a class="el" href="classParallelTetrahedralMesh.html">ParallelTetrahedralMesh</a> objects. Abort if so. </dd>
</dl>
<p>
<a class="anchor" name="_todo000002"></a> <dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#25a3b5da1f940794918b6abb47f7fb79">AbstractConvergenceTester::Converge</a> (std::string nameOfTest) </dt>
<dd>This is a scarily long method; could do with some parts extracted? </dd>
</dl>
<p>
<a class="anchor" name="_todo000002"></a> <dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#25a3b5da1f940794918b6abb47f7fb79">AbstractConvergenceTester::Converge</a> (std::string nameOfTest) </dt>
<dd>this is a sequential mesh </dd>
</dl>
<p>
<a class="anchor" name="_todo000002"></a> <dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#25a3b5da1f940794918b6abb47f7fb79">AbstractConvergenceTester::Converge</a> (std::string nameOfTest) </dt>
<dd>Cover this </dd>
</dl>
<p>
<a class="anchor" name="_todo000005"></a> <dl>
<dt>Member <a class="el" href="classAbstractConvergenceTester.html#8ec5fb24c1e3606e72dc68a6c1ebce6f">AbstractConvergenceTester::DisplayRun</a> () </dt>
<dd>The UseAbsoluteStimulus is temporary, while we are sorting out 3D stimulus. It is to be removed later (along with StimulusConvergenceTester) </dd>
</dl>
<p>
<a class="anchor" name="_todo000096"></a> <dl>
<dt>Member <a class="el" href="classAbstractElement.html#17f2dc0959c8f4105843d59dd5f3736a">AbstractElement::GetNodeLocation</a> (unsigned localIndex) const  </dt>
<dd>this used to return a reference to a c_vector, in which case a weird error arose where it compiled, ran and passed on some machines but failed the tests (bad_size errors) on another machine. </dd>
</dl>
<p>
<a class="anchor" name="_todo000148"></a> <dl>
<dt>Member <a class="el" href="classAbstractFunctionalCalculator.html#06bc7c4c0ca64a63d5c9b4a39460d318">AbstractFunctionalCalculator::CalculateOnElement</a> (Element&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement) </dt>
<dd>Check if we are using a mesh with cached Jacobians, if so, get it from the mesh rather than calling the calculate method. </dd>
</dl>
<p>
<a class="anchor" name="_todo000152"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#3ba3f6957e2343e39d6304d4cdc2405e">AbstractIsotropicIncompressibleMaterialLaw::Get_dW_dI1</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000153"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#e377687f775dd070cdf29bd60b26efcf">AbstractIsotropicIncompressibleMaterialLaw::Get_dW_dI2</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000154"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#b560e0993f5892ec9524dc035702ba6f">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI1</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000155"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#cbcca2fcf4c5d73484dfeb4c65cb10bb">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI2</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000156"></a> <dl>
<dt>Member <a class="el" href="classAbstractIsotropicIncompressibleMaterialLaw.html#cb19d8801f5dcd6085826b2e358efe12">AbstractIsotropicIncompressibleMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2)=0 </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000172"></a> <dl>
<dt>Member <a class="el" href="classAbstractLinearAssembler.html#b33056cf28f38b03afeef6fcc1725688">AbstractLinearAssembler::Solve</a> (Vec currentSolutionOrGuess=NULL, double currentTime=0.0) </dt>
<dd>move the asserts into PrepareForSolve() </dd>
</dl>
<p>
<a class="anchor" name="_todo000097"></a> <dl>
<dt>Member <a class="el" href="classAbstractMesh.html#be215056a72c1b64d0871e37d08dd0f7">AbstractMesh::GetWidthExtremes</a> (const unsigned &amp;rDimension) const  </dt>
<dd>use NodeIterator here? </dd>
</dl>
<p>
<a class="anchor" name="_todo000173"></a> <dl>
<dt>Member <a class="el" href="classAbstractNonlinearAssembler.html#5645b3fcde13bd8802099837e535e342">AbstractNonlinearAssembler::StaticSolve</a> (Vec currentSolutionOrGuess=NULL, double currentTime=0.0, bool assembleMatrix=true) </dt>
<dd>do something sensible if assembleMatrix is false. </dd>
</dl>
<p>
<a class="anchor" name="_todo000145"></a> <dl>
<dt>Member <a class="el" href="classAbstractOdeSystem.html#639f1366dd7212922a06902a97adb210">AbstractOdeSystem::serialize</a> (Archive &amp;archive, const unsigned int version) </dt>
<dd>archive mpSystemInfo </dd>
</dl>
<p>
<a class="anchor" name="_todo000177"></a> <dl>
<dt>Member <a class="el" href="classAbstractStaticAssembler.html#2fe1f0600bdee65ce27ac191b531b1a5">AbstractStaticAssembler::ComputeTransformedBasisFunctionDerivatives</a> (const ChastePoint&lt; ELEMENT_DIM &gt; &amp;rPoint, const c_matrix&lt; double, ELEMENT_DIM, SPACE_DIM &gt; &amp;rInverseJacobian, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rReturnValue) </dt>
<dd>Template <a class="el" href="classLinearBasisFunction.html">LinearBasisFunction</a> over SPACE_DIM?<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000174"></a> <dl>
<dt>Member <a class="el" href="classAbstractStaticAssembler.html#1610b285345d21fb10fbd5e9e2cfe3fe">AbstractStaticAssembler::AssembleOnElement</a> (Element&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rElement, c_matrix&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1), PROBLEM_DIM *(ELEMENT_DIM+1) &gt; &amp;rAElem, c_vector&lt; double, PROBLEM_DIM *(ELEMENT_DIM+1)&gt; &amp;rBElem, bool assembleVector, bool assembleMatrix) </dt>
<dd>This assumes that the Jacobian is constant on an element. This is true for linear basis functions, but not for any other type of basis function. </dd>
</dl>
<p>
<a class="anchor" name="_todo000175"></a> <dl>
<dt>Member <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler::AssembleOnSurfaceElement</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;rBSurfElem) </dt>
<dd>: add interpolation of u as well </dd>
</dl>
<p>
<a class="anchor" name="_todo000175"></a> <dl>
<dt>Member <a class="el" href="classAbstractStaticAssembler.html#d900feac00b92662daaadd766f26cf78">AbstractStaticAssembler::AssembleOnSurfaceElement</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEMENT_DIM-1, SPACE_DIM &gt; &amp;rSurfaceElement, c_vector&lt; double, PROBLEM_DIM *ELEMENT_DIM &gt; &amp;rBSurfElem) </dt>
<dd>Improve efficiency of Neumann BC implementation. </dd>
</dl>
<p>
<a class="anchor" name="_todo000178"></a> <dl>
<dt>Member <a class="el" href="classAbstractStaticAssembler.html#dcdfe198e4fddcb70d344cba4e7bafa3">AbstractStaticAssembler::SetNumberOfQuadraturePointsPerDimension</a> (unsigned numQuadPoints) </dt>
<dd>: There may be a small memory leak if this occurs.)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000101"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralElement.html#ba32f8664f22c8e2989ee886991e94a8">AbstractTetrahedralElement::GetVolume</a> (double determinant) const  </dt>
<dd>make this argument const? </dd>
</dl>
<p>
<a class="anchor" name="_todo000098"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralElement.html#6140948284d291f3586e6c33f979c075">AbstractTetrahedralElement::AbstractTetrahedralElement</a> (unsigned index, const std::vector&lt; Node&lt; SPACE_DIM &gt; * &gt; &amp;rNodes) </dt>
<dd>We don't want to create new data, calculation and throw the answer away </dd>
</dl>
<p>
<a class="anchor" name="_todo000099"></a> <dl>
<dt>Class <a class="el" href="classAbstractTetrahedralElement_3_010_00_01SPACE__DIM_01_4.html">AbstractTetrahedralElement&lt; 0, SPACE_DIM &gt;</a>  </dt>
<dd>Move implementation into .cpp file? (#847) </dd>
</dl>
<p>
<a class="anchor" name="_todo000100"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralElement_3_010_00_01SPACE__DIM_01_4.html#edb646a7f2515ec29ed16eee847e8cca">AbstractTetrahedralElement&lt; 0, SPACE_DIM &gt;::AbstractTetrahedralElement</a> (unsigned index, const std::vector&lt; Node&lt; SPACE_DIM &gt; * &gt; &amp;rNodes) </dt>
<dd>We don't want to create new data, calculation and throw the answer away </dd>
</dl>
<p>
<a class="anchor" name="_todo000102"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMesh.html#e95c4b2ff7ecebbe10a26818abd8d4f2">AbstractTetrahedralMesh::save</a> (Archive &amp;archive, const unsigned int version) const  </dt>
<dd>#98 - what does this achieve? Overwrites existing mesh file or potentially rewrites mesh with a different name, would it be better just to update the name in the <a class="el" href="classArchiveLocationInfo.html">ArchiveLocationInfo</a> ?? </dd>
</dl>
<p>
<a class="anchor" name="_todo000102"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMesh.html#e95c4b2ff7ecebbe10a26818abd8d4f2">AbstractTetrahedralMesh::save</a> (Archive &amp;archive, const unsigned int version) const  </dt>
<dd>#98, you can use the line mesh_writer.WriteFilesUsingMesh(*this) from above here, but have to think about parallel meshes. </dd>
</dl>
<p>
<a class="anchor" name="_todo000104"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMesh.html#e92c8d2039dd9707c09c539eb0f79379">AbstractTetrahedralMesh::GetWeightedDirectionForBoundaryElement</a> (unsigned elementIndex, c_vector&lt; double, SPACE_DIM &gt; &amp;rWeightedDirection, double &amp;rJacobianDeterminant) const  </dt>
<dd>: this method doesn't seem to be used anywhere but in the test. Consider removing it. </dd>
</dl>
<p>
<a class="anchor" name="_todo000143"></a> <dl>
<dt>Member <a class="el" href="classAbstractTetrahedralMeshWriter.html#465a997fccf4aeca111b2e30dab69867">AbstractTetrahedralMeshWriter::WriteFilesUsingMesh</a> (const AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMesh) </dt>
<dd>This is a very smelly method which has copied code from the above method...<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000184"></a> <dl>
<dt>Member <a class="el" href="classAbstractTissue.html#fd91b72b05272ca2c53c04f1803309f2">AbstractTissue::WriteTimeAndNodeResultsToFiles</a> (std::vector&lt; unsigned &gt; &amp;rCellTypeCounter, std::vector&lt; unsigned &gt; &amp;rCellMutationStateCounter, std::vector&lt; unsigned &gt; &amp;rCellCyclePhaseCounter) </dt>
<dd>Vertex meshes output nans here if the node does not exist. </dd>
</dl>
<p>
<a class="anchor" name="_todo000030"></a> <dl>
<dt>Class <a class="el" href="classAxisymmetricConductivityTensors.html">AxisymmetricConductivityTensors&lt; SPACE_DIM &gt;</a>  </dt>
<dd>is the compatibility argument above really worthwhile? We could just inherit from AbstractConductivityTensors&lt;3&gt;. This would however require changes to the constructors of <a class="el" href="classAbstractCardiacPde.html">AbstractCardiacPde</a> and <a class="el" href="classBidomainPde.html">BidomainPde</a>. </dd>
</dl>
<p>
<a class="anchor" name="_todo000016"></a> <dl>
<dt>Member <a class="el" href="classBidomainPde.html#028a5c18867399208d260d668a14c004">BidomainPde::~BidomainPde</a> () </dt>
<dd>: #98 once the archiving constructor is creating the conductivity tensors properly we won't need this if statement </dd>
</dl>
<p>
<a class="anchor" name="_todo000054"></a> <dl>
<dt>Member <a class="el" href="classBidomainWithBathAssembler.html#10ca4cf8f3ff023005825db2c988f56d">BidomainWithBathAssembler::FinaliseLinearSystem</a> (Vec existingSolutionOrGuess, double time, bool assembleVector, bool assembleMatrix) </dt>
<dd>: assumes Vm and Phie are interleaved </dd>
</dl>
<p>
<a class="anchor" name="_todo000058"></a> <dl>
<dt>Member <a class="el" href="classBidomainWithBathMatrixBasedAssembler.html#fa18f1eb05b51d305c85834443f60fc7">BidomainWithBathMatrixBasedAssembler::mpBidomainWithBathRhsMatrixAssembler</a>  </dt>
<dd>: Once <a class="el" href="classBidomainWithBathRhsMatrixAssembler.html">BidomainWithBathRhsMatrixAssembler</a> inherits from <a class="el" href="classBidomainRhsMatrixAssembler.html">BidomainRhsMatrixAssembler</a> we'll be able to reuse the pointer in <a class="el" href="classBidomainMatrixBasedAssembler.html">BidomainMatrixBasedAssembler</a> </dd>
</dl>
<p>
<a class="anchor" name="_todo000056"></a> <dl>
<dt>Member <a class="el" href="classBidomainWithBathMatrixBasedAssembler.html#eed8b1047eb7592dd0b0aac486f03c35">BidomainWithBathMatrixBasedAssembler::BidomainWithBathMatrixBasedAssembler</a> (AbstractTetrahedralMesh&lt; ELEMENT_DIM, SPACE_DIM &gt; *pMesh, BidomainPde&lt; SPACE_DIM &gt; *pPde, BoundaryConditionsContainer&lt; ELEMENT_DIM, SPACE_DIM, 2 &gt; *pBcc, unsigned numQuadPoints=2) </dt>
<dd>: at this point we'll have a <a class="el" href="classBidomainWithBathRhsMatrixAssembler.html">BidomainWithBathRhsMatrixAssembler</a> object and a <a class="el" href="classBidomainRhsMatrixAssembler.html">BidomainRhsMatrixAssembler</a> object in memory. This is a waste of memory since both construct and store a matrix for RHS assembly. </dd>
</dl>
<p>
<a class="anchor" name="_todo000057"></a> <dl>
<dt>Class <a class="el" href="classBidomainWithBathRhsMatrixAssembler.html">BidomainWithBathRhsMatrixAssembler&lt; DIM &gt;</a>  </dt>
<dd>: make this class inherit from <a class="el" href="classBidomainRhsMatrixAssembler.html">BidomainRhsMatrixAssembler</a> </dd>
</dl>
<p>
<a class="anchor" name="_todo000149"></a> <dl>
<dt>Class <a class="el" href="classBoundaryConditionsContainer.html">BoundaryConditionsContainer&lt; ELEM_DIM, SPACE_DIM, PROBLEM_DIM &gt;</a>  </dt>
<dd>Various operations are currently very inefficient - there is certainly scope for optimisation here! </dd>
</dl>
<p>
<a class="anchor" name="_todo000150"></a> <dl>
<dt>Member <a class="el" href="classBoundaryConditionsContainer.html#05e64d47eb69c5e5143287fbadef2008">BoundaryConditionsContainer::Validate</a> (<a class="el" href="classAbstractTetrahedralMesh.html">AbstractTetrahedralMesh&lt; ELEM_DIM, SPACE_DIM &gt;</a> *pMesh) </dt>
<dd>Might we want to throw an exception specifying which node failed? What about checking for multiple conditions at a point (might be intentional)?<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000151"></a> <dl>
<dt>Member <a class="el" href="classBoundaryConditionsContainer.html#f66788db66969d879cd5109c586a88f1">BoundaryConditionsContainer::HasNeumannBoundaryCondition</a> (const <a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; ELEM_DIM-1, SPACE_DIM &gt; *pSurfaceElement, unsigned indexOfUnknown=0) </dt>
<dd>This is a horrendously inefficient fix. Perhaps have flag in element object?<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000105"></a> <dl>
<dt>Member <a class="el" href="classBoundaryElement.html#22e1b3aa2190aec6f90dcf8e67ff7e01">BoundaryElement::BoundaryElement</a> (unsigned index, std::vector&lt; Node&lt; SPACE_DIM &gt; * &gt; nodes) </dt>
<dd>make rNodes like in <a class="el" href="classAbstractTetrahedralElement.html">AbstractTetrahedralElement</a>? (#991) </dd>
</dl>
<p>
<a class="anchor" name="_todo000031"></a> <dl>
<dt>Member <a class="el" href="classCardiacElectroMechanicsProblem.html#6f060578a8380d2aec80d3f9d3c4feb9">CardiacElectroMechanicsProblem::WriteWatchedLocationData</a> (double time, Vec voltage) </dt>
<dd>Improve efficiency of this method? </dd>
</dl>
<p>
<a class="anchor" name="_todo000031"></a> <dl>
<dt>Member <a class="el" href="classCardiacElectroMechanicsProblem.html#6f060578a8380d2aec80d3f9d3c4feb9">CardiacElectroMechanicsProblem::WriteWatchedLocationData</a> (double time, Vec voltage) </dt>
<dd>: NOTE!!! HARDCODED state variable index - assumes Lr91. Metadata is currently being added to CellML models and then this will be avoided by asking for Calcium. </dd>
</dl>
<p>
<a class="anchor" name="_todo000034"></a> <dl>
<dt>Member <a class="el" href="classCardiacElectroMechanicsProblem.html#cb7593ef1872c99b1e4ebf98841c4ede">CardiacElectroMechanicsProblem::Max</a> (std::vector&lt; double &gt; &amp;vec) </dt>
<dd>Move to UblasCustomFunctions?<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000033"></a> <dl>
<dt>Member <a class="el" href="classCardiacElectroMechanicsProblem.html#3c6f80ca597e5b7a6b7a3a19a6ab24bb">CardiacElectroMechanicsProblem::CardiacElectroMechanicsProblem</a> (<a class="el" href="classTetrahedralMesh.html">TetrahedralMesh&lt; DIM, DIM &gt;</a> *pElectricsMesh, QuadraticMesh&lt; DIM &gt; *pMechanicsMesh, std::vector&lt; unsigned &gt; fixedMechanicsNodes, <a class="el" href="classAbstractCardiacCellFactory.html">AbstractCardiacCellFactory&lt; DIM &gt;</a> *pCellFactory, double endTime, unsigned numElecTimeStepsPerMechTimestep, double nhsOdeTimeStep, std::string outputDirectory) </dt>
<dd>Cover these lines </dd>
</dl>
<p>
<a class="anchor" name="_todo000017"></a> <dl>
<dt>Member <a class="el" href="classCellProperties.html#8a90b8eae0e383fd7df237da487a7859">CellProperties::CalculateActionPotentialDurations</a> (const double percentage) </dt>
<dd>linear interpolation here too? </dd>
</dl>
<p>
<a class="anchor" name="_todo000106"></a> <dl>
<dt>Member <a class="el" href="classChasteCuboid.html#544930f394d73e86e4e47e22e72b246c">ChasteCuboid::DoesContain</a> (const ChastePoint&lt; 3U &gt; &amp;rPointToCheck) </dt>
<dd>: use a templated definition of the method below </dd>
</dl>
<p>
<a class="anchor" name="_todo000144"></a> <dl>
<dt>Member <a class="el" href="classCmguiWriter.html#617bf20b853403887375403bae38c8fa">CmguiWriter::CmguiWriter</a> (const std::string &amp;rDirectory, const std::string &amp;rBaseName, const bool &amp;rCleanDirectory=true) </dt>
<dd>make this cleanDirectory to be consistent with other writers? (#991) </dd>
</dl>
<p>
<a class="anchor" name="_todo000065"></a> <dl>
<dt>Member <a class="el" href="classColumnDataReader.html#7bae0b42045724d4dfcda58315588bec">ColumnDataReader::mVariablesToColumns</a>  </dt>
<dd>Change int to unsigned? (#991) </dd>
</dl>
<p>
<a class="anchor" name="_todo000066"></a> <dl>
<dt>Member <a class="el" href="classColumnDataReader.html#bc8e2344866ad0d5a2ee9e564574dccc">ColumnDataReader::GetValues</a> (const std::string &amp;rVariableName) </dt>
<dd>This method returns a copy of <a class="el" href="classColumnDataReader.html#dc88a987e44d20fb7bd7964bee454b26">ColumnDataReader::mValues</a> - would it make more sense to change the semantics and return by reference? The only downside is that users would need to copy the result before calling <a class="el" href="classColumnDataReader.html#bc8e2344866ad0d5a2ee9e564574dccc">ColumnDataReader::GetValues</a> again, if they wanted to keep the original results, which might cause head scratching!<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000067"></a> <dl>
<dt>Member <a class="el" href="classColumnDataReader.html#14fcc05b4b8b8ce28fb1a0cb49fde6af">ColumnDataReader::GetValues</a> (const std::string &amp;rVariableName, int fixedDimension) </dt>
<dd>This method returns a copy of <a class="el" href="classColumnDataReader.html#dc88a987e44d20fb7bd7964bee454b26">ColumnDataReader::mValues</a> - would it make more sense to change the semantics and return by reference? The only downside is that users would need to copy the result before calling <a class="el" href="classColumnDataReader.html#bc8e2344866ad0d5a2ee9e564574dccc">ColumnDataReader::GetValues</a> again, if they wanted to keep the original results, which might cause head scratching!<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000068"></a> <dl>
<dt>Member <a class="el" href="classColumnDataReader.html#b1b59498545474c299adf23ebb667fdb">ColumnDataReader::GetUnlimitedDimensionValues</a> () </dt>
<dd>This method returns a copy of <a class="el" href="classColumnDataReader.html#dc88a987e44d20fb7bd7964bee454b26">ColumnDataReader::mValues</a> - would it make more sense to change the semantics and return by reference? The only downside is that users would need to copy the result before calling <a class="el" href="classColumnDataReader.html#bc8e2344866ad0d5a2ee9e564574dccc">ColumnDataReader::GetValues</a> again, if they wanted to keep the original results, which might cause head scratching! </dd>
</dl>
<p>
<a class="anchor" name="_todo000107"></a> <dl>
<dt>Member <a class="el" href="classCuboidMeshConstructor.html#83b74064bd19815b90c29fdb52978956">CuboidMeshConstructor::NumElements</a>  </dt>
<dd>Should be mNumElements and private </dd>
</dl>
<p>
<a class="anchor" name="_todo000108"></a> <dl>
<dt>Member <a class="el" href="classCuboidMeshConstructor.html#4d86c7b3c433cdec4bde143cc3659b1e">CuboidMeshConstructor::NumNodes</a>  </dt>
<dd>Should be mNumNodes and private </dd>
</dl>
<p>
<a class="anchor" name="_todo000110"></a> <dl>
<dt>Member <a class="el" href="classElement.html#2655827a1495d06094dba66849ed811a">Element::Element</a> (unsigned index, std::vector&lt; Node&lt; SPACE_DIM &gt; * &gt; nodes) </dt>
<dd>make rNodes like in <a class="el" href="classAbstractTetrahedralElement.html">AbstractTetrahedralElement</a>? (#991) </dd>
</dl>
<p>
<a class="anchor" name="_todo000111"></a> <dl>
<dt>Member <a class="el" href="classElement.html#9e1ed0f3eda5b23a2b71b312c86d9dd7">Element::Element</a> (const <a class="el" href="classElement.html">Element</a> &amp;rElement, const unsigned index) </dt>
<dd>this is rather dubious; a factory method might be better.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000109"></a> <dl>
<dt>Member <a class="el" href="classElement.html#bf5c2bc4fb4db48d8108d04625075b21">Element::CalculatePsi</a> (ChastePoint&lt; SPACE_DIM &gt; testPoint) </dt>
<dd>This method shouldn't need a new Jacobian inverse for every Psi </dd>
</dl>
<p>
<a class="anchor" name="_todo000059"></a> <dl>
<dt>Class <a class="el" href="classException.html">Exception</a>  </dt>
<dd>Might we want this class to inherit from STL exceptions? </dd>
</dl>
<p>
<a class="anchor" name="_todo000060"></a> <dl>
<dt>Member <a class="el" href="classException.html#29aca1eccd9d93297a3b01931c648f2a">Exception::Exception</a> (std::string message, std::string filename, const unsigned rLineNumber) </dt>
<dd>make this argument a reference? </dd>
</dl>
<p>
<a class="anchor" name="_todo000157"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#7fd47d973750491f5d5356143870062a">ExponentialMaterialLaw::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000158"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#4af9764dba9d79966ffc9e0c0c59a416">ExponentialMaterialLaw::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000159"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#291b4a2441a90b0605d41985269d7304">ExponentialMaterialLaw::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000160"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#c008235dc7dec5992da5b0141816e4b0">ExponentialMaterialLaw::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000161"></a> <dl>
<dt>Member <a class="el" href="classExponentialMaterialLaw.html#b881ef4671b0a67d754c2b798d8d3ce6">ExponentialMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000035"></a> <dl>
<dt>Member <a class="el" href="classGeneralPlaneStimulusCellFactory.html#48c5471140868a417054a43e07da9bc2">GeneralPlaneStimulusCellFactory::GeneralPlaneStimulusCellFactory</a> (unsigned numEleAcross, double meshWidth, bool useMeshWidthAsMag=false, double stimulusMagnitude=-1e7, double stimulusDuration=0.5) </dt>
<dd>The useMeshWidth is temporary, while we are sorting out 3D stimulus. It is to be removed later (along with StimulusConvergenceTester) scale stimulus depending on space_step of elements<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000035"></a> <dl>
<dt>Member <a class="el" href="classGeneralPlaneStimulusCellFactory.html#48c5471140868a417054a43e07da9bc2">GeneralPlaneStimulusCellFactory::GeneralPlaneStimulusCellFactory</a> (unsigned numEleAcross, double meshWidth, bool useMeshWidthAsMag=false, double stimulusMagnitude=-1e7, double stimulusDuration=0.5) </dt>
<dd>It looks like the value of the stimulus is specific to 3D<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000070"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataReader.html#afd7eea581b860ca7212b0b4c30c8969">Hdf5DataReader::MAX_DATASET_RANK</a>  </dt>
<dd>: define it once </dd>
</dl>
<p>
<a class="anchor" name="_todo000069"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataReader.html#859ef71cd53870bd08d77abc83e575b5">Hdf5DataReader::GetVariableOverNodes</a> (Vec data, const std::string &amp;rVariableName, unsigned timestep=0) </dt>
<dd>Use <a class="el" href="classDistributedVector.html">DistributedVector</a>? </dd>
</dl>
<p>
<a class="anchor" name="_todo000072"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataWriter.html#3c70b9b18ab0dec566bb5709391bc5ae">Hdf5DataWriter::DATASET_DIMS</a>  </dt>
<dd>: define it once </dd>
</dl>
<p>
<a class="anchor" name="_todo000071"></a> <dl>
<dt>Member <a class="el" href="classHdf5DataWriter.html#9fcd06f1bb1e2d6ef8a17eaec354a636">Hdf5DataWriter::PutStripedVector</a> (int firstVariableID, int secondVariableID, Vec petscVector) </dt>
<dd>Use distributed vector functionality here? </dd>
</dl>
<p>
<a class="anchor" name="_todo000037"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#b1795ab3abddcc5e8e7d98cadd70ef22">HeartConfig::GetIonicModelRegions</a> (std::vector&lt; ChasteCuboid &gt; &amp;definedRegions, std::vector&lt; ionic_models_available_type &gt; &amp;ionicModels) const  </dt>
<dd>- do we assume the vectors are initially empty? The standard vectors returned are of the same length (one entry per region)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000037"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#b1795ab3abddcc5e8e7d98cadd70ef22">HeartConfig::GetIonicModelRegions</a> (std::vector&lt; ChasteCuboid &gt; &amp;definedRegions, std::vector&lt; ionic_models_available_type &gt; &amp;ionicModels) const  </dt>
<dd>No set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000039"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#ca214e0a3a7aefaa8694e602a6346dc7">HeartConfig::GetSlabDimensions</a> (c_vector&lt; double, 3 &gt; &amp;slabDimensions) const  </dt>
<dd>IsMeshProvided and GetLoadMesh are subtly different but very similar. Can one of them go? </dd>
</dl>
<p>
<a class="anchor" name="_todo000040"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#020c41230ed9aedf95f1dfc43df7eccb">HeartConfig::GetStimuli</a> (std::vector&lt; boost::shared_ptr&lt; SimpleStimulus &gt; &gt; &amp;rStimuliApplied, std::vector&lt; ChasteCuboid &gt; &amp;rStimulatedAreas) const  </dt>
<dd>- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </dd>
</dl>
<p>
<a class="anchor" name="_todo000040"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#020c41230ed9aedf95f1dfc43df7eccb">HeartConfig::GetStimuli</a> (std::vector&lt; boost::shared_ptr&lt; SimpleStimulus &gt; &gt; &amp;rStimuliApplied, std::vector&lt; ChasteCuboid &gt; &amp;rStimulatedAreas) const  </dt>
<dd>There is no set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000042"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#583db4054be86aea6fadcf32eab30976">HeartConfig::GetCellHeterogeneities</a> (std::vector&lt; ChasteCuboid &gt; &amp;cellHeterogeneityAreas, std::vector&lt; double &gt; &amp;scaleFactorGks, std::vector&lt; double &gt; &amp;scaleFactorIto, std::vector&lt; double &gt; &amp;scaleFactorGkr) const  </dt>
<dd>- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </dd>
</dl>
<p>
<a class="anchor" name="_todo000042"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#583db4054be86aea6fadcf32eab30976">HeartConfig::GetCellHeterogeneities</a> (std::vector&lt; ChasteCuboid &gt; &amp;cellHeterogeneityAreas, std::vector&lt; double &gt; &amp;scaleFactorGks, std::vector&lt; double &gt; &amp;scaleFactorIto, std::vector&lt; double &gt; &amp;scaleFactorGkr) const  </dt>
<dd>There is no set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000044"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#9e721dab24aa4c7c18bcbc3501dce758">HeartConfig::GetConductivityHeterogeneities</a> (std::vector&lt; ChasteCuboid &gt; &amp;conductivitiesHeterogeneityAreas, std::vector&lt; c_vector&lt; double, 3 &gt; &gt; &amp;intraConductivities, std::vector&lt; c_vector&lt; double, 3 &gt; &gt; &amp;extraConductivities) const  </dt>
<dd>- do we assume the vectors are initially empty? The returned std::vectors are all of the same length </dd>
</dl>
<p>
<a class="anchor" name="_todo000045"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#a82a9d7071771f54527f2d749f428247">HeartConfig::IsPostProcessingRequested</a> () const  </dt>
<dd>- no set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000046"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#e36a91ca774983b59fe2a0eb6536a344">HeartConfig::GetUpstrokeTimeMaps</a> (std::vector&lt; double &gt; &amp;upstroke_time_maps) const  </dt>
<dd>- no set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000047"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#b8fa3c6d5dfada90205d5a6458d56d30">HeartConfig::IsMaxUpstrokeVelocityMapRequested</a> () const  </dt>
<dd>- no set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000047"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#b8fa3c6d5dfada90205d5a6458d56d30">HeartConfig::IsMaxUpstrokeVelocityMapRequested</a> () const  </dt>
<dd>- This method has "Is" in the name, others do not. </dd>
</dl>
<p>
<a class="anchor" name="_todo000049"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#b2c2828d79fd9a2fc54640182434e3bf">HeartConfig::GetConductionVelocityMaps</a> (std::vector&lt; unsigned &gt; &amp;conduction_velocity_maps) const  </dt>
<dd>- no set method </dd>
</dl>
<p>
<a class="anchor" name="_todo000050"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#dbe55473754f9711a1cc8f3c82037661">HeartConfig::SetMeshFileName</a> (std::string meshPrefix, media_type fibreDefinition=media_typeNoFibreOrientation) </dt>
<dd>There is no Get method </dd>
</dl>
<p>
<a class="anchor" name="_todo000051"></a> <dl>
<dt>Member <a class="el" href="classHeartConfig.html#994cb2f7b3edc1c45ba43fc967a98a8a">HeartConfig::SetBathConductivity</a> (double bathConductivity) </dt>
<dd>Is this used anywhere? </dd>
</dl>
<p>
<a class="anchor" name="_todo000083"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#5e6afa86b789aba62eba01d8eadeb198">LinearSystem::mOwnershipRangeLo</a>  </dt>
<dd>Verify claim that ownership range for Vec and Mat is same. This should only matter for efficiency if the claim is false. </dd>
</dl>
<p>
<a class="anchor" name="_todo000081"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#7cf2cdd65608f5cd83990c96ec8815ea">LinearSystem::Solve</a> (Vec lhsGuess=NULL) </dt>
<dd>never tested in linalg component </dd>
</dl>
<p>
<a class="anchor" name="_todo000081"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#7cf2cdd65608f5cd83990c96ec8815ea">LinearSystem::Solve</a> (Vec lhsGuess=NULL) </dt>
<dd>Should it be compulsory for the caller to supply this and manage the memory? </dd>
</dl>
<p>
<a class="anchor" name="_todo000084"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#036f171345725590d26d38dffcbf4e28">LinearSystem::SetNullBasis</a> (Vec nullbasis[], unsigned numberOfBases) </dt>
<dd>Document this method and its parameters!<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000077"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#2af90d2cac0e92fba7c098fc15a8c468">LinearSystem::LinearSystem</a> (PetscInt lhsVectorSize, MatType matType=(MatType) MATMPIAIJ) </dt>
<dd>: if we create a linear system object outside a cardiac assembler, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </dd>
</dl>
<p>
<a class="anchor" name="_todo000078"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#6af03462cb1054453f1093d9ba855035">LinearSystem::LinearSystem</a> (Vec templateVector) </dt>
<dd>: if we create a linear system object outside a cardiac assembler, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </dd>
</dl>
<p>
<a class="anchor" name="_todo000079"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#79b5a1abd9189331236113d48ffde5a9">LinearSystem::LinearSystem</a> (Vec residualVector, Mat jacobianMatrix) </dt>
<dd>: if we create a linear system object outside a cardiac assembler, these are gonna be the default solver and preconditioner. Not consitent with ChasteDefaults.xml though... </dd>
</dl>
<p>
<a class="anchor" name="_todo000080"></a> <dl>
<dt>Member <a class="el" href="classLinearSystem.html#e4aa80d347b07a6377607349eb334819">LinearSystem::~LinearSystem</a> () </dt>
<dd>Never tested in linalg component </dd>
</dl>
<p>
<a class="anchor" name="_todo000062"></a> <dl>
<dt>Member <a class="el" href="classLogFile.html#6845e69cb04b7852317c75f190d231d6">LogFile::Set</a> (unsigned level, std::string directory, std::string fileName="log.txt") </dt>
<dd>make this argument a reference? </dd>
</dl>
<p>
<a class="anchor" name="_todo000138"></a> <dl>
<dt>Member <a class="el" href="classMemfemMeshReader.html#eaeff3ce6434666beeea1a50327fa1c0">MemfemMeshReader::MemfemMeshReader</a> (const std::string &amp;rPathBaseName) </dt>
<dd>make this a reference? </dd>
</dl>
<p>
<a class="anchor" name="_todo000185"></a> <dl>
<dt>Member <a class="el" href="classMeshBasedTissue.html#6b13bb7d9ba4d50ee35ef098262f7c00">MeshBasedTissue::SetOutputTissueAreas</a> (bool writeTissueAreas) </dt>
<dd>Extend this to 3D (possibly rename to SetOutputTissueVolumes?) - see also #738<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000162"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#6d55482ffc8a243cd9fd2399d9713035">MooneyRivlinMaterialLaw::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000163"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#84b7f95aed9c199fabcdeefa282f68e5">MooneyRivlinMaterialLaw::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000164"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#16002ef8753f56e75545c07f2a079209">MooneyRivlinMaterialLaw::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000165"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#a8da1807bcbb6d337d55d0e670cdb4e1">MooneyRivlinMaterialLaw::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000166"></a> <dl>
<dt>Member <a class="el" href="classMooneyRivlinMaterialLaw.html#a6ef7d8e0134db35cf1f590358a17890">MooneyRivlinMaterialLaw::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000113"></a> <dl>
<dt>Member <a class="el" href="classMutableMesh.html#354930eefda2938e1b239ce5b7e80de9">MutableMesh::CheckVoronoi</a> (Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement, double maxPenetration) </dt>
<dd>Should use a set union operation here </dd>
</dl>
<p>
<a class="anchor" name="_todo000115"></a> <dl>
<dt>Member <a class="el" href="classMutableMesh.html#c241ad1e4d5c57f0201a22678d082d51">MutableMesh::RescaleMeshFromBoundaryNode</a> (ChastePoint&lt; 1 &gt; updatedPoint, unsigned boundaryNodeIndex) </dt>
<dd>should unsigned GetNumBoundaryNodes() be overloaded too?? </dd>
</dl>
<p>
<a class="anchor" name="_todo000112"></a> <dl>
<dt>Member <a class="el" href="classMutableMesh.html#20f735bf3837b082929ca010bb2f1a1e">MutableMesh::ReMesh</a> (<a class="el" href="classNodeMap.html">NodeMap</a> &amp;map) </dt>
<dd>communicate the length first </dd>
</dl>
<p>
<a class="anchor" name="_todo000114"></a> <dl>
<dt>Member <a class="el" href="classMutableMesh.html#74fd5ee1cd6010aa4835e18690b30dbc">MutableMesh::CheckVoronoi</a> (double maxPenetration=0.0) </dt>
<dd>use ElementIterator here? </dd>
</dl>
<p>
<a class="anchor" name="_todo000186"></a> <dl>
<dt>Member <a class="el" href="classNodeBoxCollection.html#15401f69be227828b6581768ffb2a48b">NodeBoxCollection::NodeBoxCollection</a> (double cutOffLength, c_vector&lt; double, 2 *DIM &gt; domainSize) </dt>
<dd>3d node box collection </dd>
</dl>
<p>
<a class="anchor" name="_todo000186"></a> <dl>
<dt>Member <a class="el" href="classNodeBoxCollection.html#15401f69be227828b6581768ffb2a48b">NodeBoxCollection::NodeBoxCollection</a> (double cutOffLength, c_vector&lt; double, 2 *DIM &gt; domainSize) </dt>
<dd>1d node box collection </dd>
</dl>
<p>
<a class="anchor" name="_todo000146"></a> <dl>
<dt>Member <a class="el" href="classOdeSystemInformation.html#290a58619ebad70ded740c148df3ad9d">OdeSystemInformation::mpInstance</a>  </dt>
<dd>see if using weak_ptr would work and give funkier semantics (automatically destroy the singleton when no ODE systems were using it) </dd>
</dl>
<p>
<a class="anchor" name="_todo000075"></a> <dl>
<dt>Member <a class="el" href="classParallelColumnDataWriter.html#69c9d2eea5da180544f2dd68ad0731cd">ParallelColumnDataWriter::PutVector</a> (int variableID, Vec petscVector) </dt>
<dd>Where is this implemented? (#991) </dd>
</dl>
<p>
<a class="anchor" name="_todo000076"></a> <dl>
<dt>Member <a class="el" href="classParallelColumnDataWriter.html#579406de3c0e29243d592ffdf3f6580c">ParallelColumnDataWriter::PutVectorStripe</a> (int variableId, <a class="el" href="classDistributedVector_1_1Stripe.html">DistributedVector::Stripe</a> &amp;rStripe) </dt>
<dd>allow this to be a const-reference </dd>
</dl>
<p>
<a class="anchor" name="_todo000073"></a> <dl>
<dt>Member <a class="el" href="classParallelColumnDataWriter.html#573d2b234ca208f32591fb6e31ad5185">ParallelColumnDataWriter::AdvanceAlongUnlimitedDimension</a> () </dt>
<dd>This is where the master is going to take messages from the slaves and write them. </dd>
</dl>
<p>
<a class="anchor" name="_todo000074"></a> <dl>
<dt>Member <a class="el" href="classParallelColumnDataWriter.html#ae6193983305be88a95be4f4e523493d">ParallelColumnDataWriter::Close</a> () </dt>
<dd>we may still have queued messages at this point - force their output. </dd>
</dl>
<p>
<a class="anchor" name="_todo000117"></a> <dl>
<dt>Member <a class="el" href="classParallelTetrahedralMesh.html#a8034dc77c62486189948ee613de9e4c">ParallelTetrahedralMesh::ConstructFromMeshReader</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader, bool cullInternalFaces=false) </dt>
<dd>: assert the node is not considered both owned and halo-owned. Remove continue statement few lines below then. </dd>
</dl>
<p>
<a class="anchor" name="_todo000119"></a> <dl>
<dt>Member <a class="el" href="classParallelTetrahedralMesh.html#3cb66a8d30a33a6512946785387e98d7">ParallelTetrahedralMesh::ComputeMeshPartitioning</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader, std::set&lt; unsigned &gt; &amp;rNodesOwned, std::set&lt; unsigned &gt; &amp;rHaloNodesOwned, std::set&lt; unsigned &gt; &amp;rElementsOwned, std::vector&lt; unsigned &gt; &amp;rProcessorsOffset, std::vector&lt; unsigned &gt; &amp;rNodePermutation) </dt>
<dd>Make it clear which way the permutation applies<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000116"></a> <dl>
<dt>Member <a class="el" href="classParallelTetrahedralMesh.html#3cb66a8d30a33a6512946785387e98d7">ParallelTetrahedralMesh::ComputeMeshPartitioning</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader, std::set&lt; unsigned &gt; &amp;rNodesOwned, std::set&lt; unsigned &gt; &amp;rHaloNodesOwned, std::set&lt; unsigned &gt; &amp;rElementsOwned, std::vector&lt; unsigned &gt; &amp;rProcessorsOffset, std::vector&lt; unsigned &gt; &amp;rNodePermutation) </dt>
<dd>: add a timing event for the partitioning </dd>
</dl>
<p>
<a class="anchor" name="_todo000118"></a> <dl>
<dt>Member <a class="el" href="classParallelTetrahedralMesh.html#59fe6208a095538cbbde27a9772afb7c">ParallelTetrahedralMesh::DumbNodePartitioning</a> (AbstractMeshReader&lt; ELEMENT_DIM, SPACE_DIM &gt; &amp;rMeshReader, std::set&lt; unsigned &gt; &amp;rNodesOwned) </dt>
<dd>: to be removed </dd>
</dl>
<p>
<a class="anchor" name="_todo000087"></a> <dl>
<dt>Member <a class="el" href="structPCBlockDiagonal_1_1PCBlockDiagonalContext.html#00d0bde63d57499a3be7615afee22e0b">PCBlockDiagonal::PCBlockDiagonalContext::A11_matrix_subblock</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p>
<a class="anchor" name="_todo000088"></a> <dl>
<dt>Member <a class="el" href="structPCBlockDiagonal_1_1PCBlockDiagonalContext.html#6efafce9e8e1d3f941a1e91094ed61e4">PCBlockDiagonal::PCBlockDiagonalContext::A22_matrix_subblock</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p>
<a class="anchor" name="_todo000089"></a> <dl>
<dt>Member <a class="el" href="structPCBlockDiagonal_1_1PCBlockDiagonalContext.html#b30e41636edc4227f32664e633811735">PCBlockDiagonal::PCBlockDiagonalContext::PC_amg_A11</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p>
<a class="anchor" name="_todo000090"></a> <dl>
<dt>Member <a class="el" href="structPCBlockDiagonal_1_1PCBlockDiagonalContext.html#6004045452c8c19a26aedce6e95743dd">PCBlockDiagonal::PCBlockDiagonalContext::PC_amg_A22</a>  </dt>
<dd>- don't create this every iteration but save it first time is needed. </dd>
</dl>
<p>
<a class="anchor" name="_todo000063"></a> <dl>
<dt>Member <a class="el" href="classPetscTools.html#1fdfbb8eb4f7fb3d15e148a9b4599ef8">PetscTools::DumpPetscObject</a> (const Mat &amp;rMat, const std::string &amp;rOutputFileFullPath) </dt>
<dd>Think if there is an efficient compromise between this method and the full weight of <a class="el" href="classReplicatableVector.html">ReplicatableVector</a> (broadcast single values to all processors). How do you know who has the value?<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000167"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#8924263fd2f64b16d5c9074d40142669">PolynomialMaterialLaw3d::Get_dW_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000168"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#1aabede19af92507752a4ddcb58311ff">PolynomialMaterialLaw3d::Get_dW_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000169"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#144746018624f7de4def2a1b669100fb">PolynomialMaterialLaw3d::Get_d2W_dI1</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000170"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#f877b2e196146b36438bfcee79552f87">PolynomialMaterialLaw3d::Get_d2W_dI2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000171"></a> <dl>
<dt>Member <a class="el" href="classPolynomialMaterialLaw3d.html#b8707e90ba8823d0b34ee7aaa9f7b987">PolynomialMaterialLaw3d::Get_d2W_dI1I2</a> (double I1, double I2) </dt>
<dd>The name of this method should not include underscores.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000020"></a> <dl>
<dt>Class <a class="el" href="classPostProcessingWriter.html">PostProcessingWriter</a>  </dt>
<dd>- Needs to deal with the case where no upstroke is found. </dd>
</dl>
<p>
<a class="anchor" name="_todo000021"></a> <dl>
<dt>Member <a class="el" href="classPostProcessingWriter.html#32d844637717e9efe0e939f09902f0e2">PostProcessingWriter::WriteUpstrokeTimeMap</a> (double threshold) </dt>
<dd>Allow this (see class description)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000018"></a> <dl>
<dt>Member <a class="el" href="classPostProcessingWriter.html#32d844637717e9efe0e939f09902f0e2">PostProcessingWriter::WriteUpstrokeTimeMap</a> (double threshold) </dt>
<dd>Allow this (see class description) </dd>
</dl>
<p>
<a class="anchor" name="_todo000022"></a> <dl>
<dt>Member <a class="el" href="classPostProcessingWriter.html#ee21005fa5c355bb9b4fd88e5d8c5667">PostProcessingWriter::WriteMaxUpstrokeVelocityMap</a> (double threshold) </dt>
<dd>Allow this (see class description)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000019"></a> <dl>
<dt>Member <a class="el" href="classPostProcessingWriter.html#ee21005fa5c355bb9b4fd88e5d8c5667">PostProcessingWriter::WriteMaxUpstrokeVelocityMap</a> (double threshold) </dt>
<dd>Allow this (see class description) </dd>
</dl>
<p>
<a class="anchor" name="_todo000023"></a> <dl>
<dt>Member <a class="el" href="classPropagationPropertiesCalculator.html#1d836c5b94e91c75473384ca54ef52d6">PropagationPropertiesCalculator::CalculateMaximumUpstrokeVelocity</a> (unsigned globalNodeIndex) </dt>
<dd>the following helper method, when used, causes seg faults. Mend it and use to reduce repeated code. </dd>
</dl>
<p>
<a class="anchor" name="_todo000122"></a> <dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#381423743a648ba7e155c20d09b3c717">QuadraticMesh::HelperMethod1</a> (unsigned boundaryElemNode0, unsigned boundaryElemNode1, Element&lt; DIM, DIM &gt; *pElement, unsigned node0, unsigned node1, unsigned node2, unsigned &amp;rOffset, bool &amp;rReverse) </dt>
<dd>document these parameters<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000123"></a> <dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#3ef05dfe611ac8d2f84a7d9dc9de2164">QuadraticMesh::HelperMethod2</a> (<a class="el" href="classBoundaryElement.html">BoundaryElement</a>&lt; DIM-1, DIM &gt; *pBoundaryElement, Element&lt; DIM, DIM &gt; *pElement, unsigned internalNode0, unsigned internalNode1, unsigned internalNode2, unsigned offset, bool reverse) </dt>
<dd>document these parameters<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000124"></a> <dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#994fe7d9ec5250fdfdbaa7659cc7dc67">QuadraticMesh::RunMesherAndReadMesh</a> (std::string binary, std::string outputDir, std::string fileStem) </dt>
<dd>document these parameters (also shouldn't they be references?)<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000125"></a> <dl>
<dt>Member <a class="el" href="classQuadraticMesh.html#289421503d4d7f916f627b82bdf9bf72">QuadraticMesh::QuadraticMesh</a> (double xEnd, double yEnd, unsigned numElemX, unsigned numElemY) </dt>
<dd>1d constructor </dd>
</dl>
<p>
<a class="anchor" name="_todo000001"></a> <dl>
<dt>Member <a class="el" href="classQuarterStimulusCellFactory.html#1a0a648badac1a8e5a9f1a062c5bfed6">QuarterStimulusCellFactory::CreateCardiacCellForTissueNode</a> (unsigned node) </dt>
<dd>- I thought that the concept here was to ramp the stimulus down over the first quarter, in order to make sure that there is no interface between stimulated region and un-stimulated region where the FEM linear interpolation makes the stimulus mesh-dependant.<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000179"></a> <dl>
<dt>Member <a class="el" href="classSimpleDg0ParabolicAssembler.html#61e21fe8c637a5a2a7d0360b5cb18ab5">SimpleDg0ParabolicAssembler::ComputeMatrixTerm</a> (c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, 1 &gt; &amp;rU, c_matrix&lt; double, 1, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement) </dt>
<dd>should this be rU? </dd>
</dl>
<p>
<a class="anchor" name="_todo000180"></a> <dl>
<dt>Member <a class="el" href="classSimpleLinearEllipticAssembler.html#e21176246b48368fe9bb442461687c7b">SimpleLinearEllipticAssembler::ComputeMatrixTerm</a> (c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, SPACE_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, 1 &gt; &amp;rU, c_matrix&lt; double, 1, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement) </dt>
<dd>should this be rU? </dd>
</dl>
<p>
<a class="anchor" name="_todo000181"></a> <dl>
<dt>Class <a class="el" href="classSimpleNonlinearEllipticAssembler.html">SimpleNonlinearEllipticAssembler&lt; ELEMENT_DIM, SPACE_DIM &gt;</a>  </dt>
<dd>[old todo, maybe not true anymore after refactor(?)] This class could do with some tidying. More (3D) tests are also needed. It probably needs re-writing to take advantage of parallel machines. </dd>
</dl>
<p>
<a class="anchor" name="_todo000182"></a> <dl>
<dt>Member <a class="el" href="classSimpleNonlinearEllipticAssembler.html#2e0f5e27017e0a406a49e66c3ab47939">SimpleNonlinearEllipticAssembler::ComputeMatrixTerm</a> (c_vector&lt; double, ELEMENT_DIM+1 &gt; &amp;rPhi, c_matrix&lt; double, ELEMENT_DIM, ELEMENT_DIM+1 &gt; &amp;rGradPhi, ChastePoint&lt; SPACE_DIM &gt; &amp;rX, c_vector&lt; double, 1 &gt; &amp;rU, c_matrix&lt; double, 1, SPACE_DIM &gt; &amp;rGradU, Element&lt; ELEMENT_DIM, SPACE_DIM &gt; *pElement) </dt>
<dd>should this be rU? </dd>
</dl>
<p>
<a class="anchor" name="_todo000052"></a> <dl>
<dt>Member <a class="el" href="classStreeterFibreGenerator.html#e80db1583cdf268cec04c5e1c2b2e5d1">StreeterFibreGenerator::GetAveragedThickness</a> (const unsigned nodeIndex, const std::vector&lt; double &gt; &amp;wallThickness) const  </dt>
<dd>The following nested loops appear in <a class="el" href="classDistanceMapCalculator.html">DistanceMapCalculator</a> as well, refactor it. Idea: create an iterator over the neighbour nodes in class <a class="el" href="classNode.html">Node</a> </dd>
</dl>
<p>
<a class="anchor" name="_todo000053"></a> <dl>
<dt>Member <a class="el" href="classStreeterFibreGenerator.html#e3118e7224f50977007cdab4fe6db468">StreeterFibreGenerator::GenerateOrthotropicFibreOrientation</a> (std::string outputDirectory, std::string fibreOrientationFile, bool logInfo=false) </dt>
<dd>basis_functions matrix is 3D specific, work out the generic expression </dd>
</dl>
<p>
<a class="anchor" name="_todo000134"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#b13b8b5ab87341128605d95f4fe99e46">TetrahedralMesh::Translate</a> (c_vector&lt; double, SPACE_DIM &gt; displacement) </dt>
<dd>pass by const reference? </dd>
</dl>
<p>
<a class="anchor" name="_todo000126"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#05ea40a52d6bae9b81f9ec67b3566ea1">TetrahedralMesh::GetContainingElementIndex</a> (ChastePoint&lt; SPACE_DIM &gt; testPoint, bool strict=false, std::set&lt; unsigned &gt; testElements=stdset&lt; unsigned &gt;()) </dt>
<dd>What if the element is deleted? </dd>
</dl>
<p>
<a class="anchor" name="_todo000126"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#05ea40a52d6bae9b81f9ec67b3566ea1">TetrahedralMesh::GetContainingElementIndex</a> (ChastePoint&lt; SPACE_DIM &gt; testPoint, bool strict=false, std::set&lt; unsigned &gt; testElements=stdset&lt; unsigned &gt;()) </dt>
<dd>This ought to return a set of all elements that contain the point (if the point is a node in the mesh then it's contained in multiple elements) </dd>
</dl>
<p>
<a class="anchor" name="_todo000126"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#05ea40a52d6bae9b81f9ec67b3566ea1">TetrahedralMesh::GetContainingElementIndex</a> (ChastePoint&lt; SPACE_DIM &gt; testPoint, bool strict=false, std::set&lt; unsigned &gt; testElements=stdset&lt; unsigned &gt;()) </dt>
<dd>Polling every element is unnecessary. We ought to start from a likely place and hill climb </dd>
</dl>
<p>
<a class="anchor" name="_todo000130"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#c4d26bb52e22df8148267eb1f762b30e">TetrahedralMesh::GetNearestElementIndex</a> (ChastePoint&lt; SPACE_DIM &gt; testPoint) </dt>
<dd>This ought to return a set of all elements that contain the point (if the point is a node in the mesh then it's contained in multiple elements) </dd>
</dl>
<p>
<a class="anchor" name="_todo000130"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#c4d26bb52e22df8148267eb1f762b30e">TetrahedralMesh::GetNearestElementIndex</a> (ChastePoint&lt; SPACE_DIM &gt; testPoint) </dt>
<dd>Polling every element is unnecessary. We ought to start from a likely place and hill climb </dd>
</dl>
<p>
<a class="anchor" name="_todo000130"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#c4d26bb52e22df8148267eb1f762b30e">TetrahedralMesh::GetNearestElementIndex</a> (ChastePoint&lt; SPACE_DIM &gt; testPoint) </dt>
<dd>What if the element is deleted? </dd>
</dl>
<p>
<a class="anchor" name="_todo000133"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#cd338a5d9350f042df2d7bc369b9e9f2">TetrahedralMesh::GetContainingElementIndices</a> (ChastePoint&lt; SPACE_DIM &gt; testPoint) </dt>
<dd>What if the element is deleted? </dd>
</dl>
<p>
<a class="anchor" name="_todo000135"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh.html#762bc1c77d385084436adfab74824d41">TetrahedralMesh::FlagElementsNotContainingNodes</a> (std::set&lt; unsigned &gt; nodes) </dt>
<dd>pass by const reference? </dd>
</dl>
<p>
<a class="anchor" name="_todo000136"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh_1_1EdgeIterator.html#ad32ecc0136c78f97a8903feca942cda">TetrahedralMesh::EdgeIterator::mCellIndex</a>  </dt>
<dd>This doesn't appear to be used anywhere - remove it? </dd>
</dl>
<p>
<a class="anchor" name="_todo000137"></a> <dl>
<dt>Member <a class="el" href="classTetrahedralMesh_1_1EdgeIterator.html#257b65803576ac7a0a5ec0ffca12a95a">TetrahedralMesh::EdgeIterator::mNodeIndex</a>  </dt>
<dd>This doesn't appear to be used anywhere - remove it? </dd>
</dl>
<p>
<a class="anchor" name="_todo000064"></a> <dl>
<dt>Member <a class="el" href="classTimeStepper.html#3c5c0495273845abb83189c48824eb8d">TimeStepper::TimeStepper</a> (double startTime, double endTime, double dt, bool enforceConstantTimeStep=false) </dt>
<dd>This assertion breaks several tests<p>
</dd>
</dl>
<p>
<a class="anchor" name="_todo000183"></a> <dl>
<dt>Member <a class="el" href="classTissueSimulation.html#cd41a7be08785b4520ef0dcd444e49b6">TissueSimulation::DoCellBirth</a> () </dt>
<dd>This is specific to cell-centre based models, the location isn't used in a vertex simulation, move it down to <a class="el" href="classAbstractCellCentreBasedTissue.html">AbstractCellCentreBasedTissue</a>?? </dd>
</dl>
<p>
<a class="anchor" name="_todo000141"></a> <dl>
<dt>Member <a class="el" href="classTrianglesMeshReader.html#869d21887156901cb08629673b3d2123">TrianglesMeshReader::OpenNodeFile</a> () </dt>
<dd>Change name to OpenNodesFile for consistency with OpenElementsFile and OpenFacesFile? (#991) </dd>
</dl>
<p>
<a class="anchor" name="_todo000139"></a> <dl>
<dt>Member <a class="el" href="classTrianglesMeshReader.html#05c0149482763c581bee26d227069d27">TrianglesMeshReader::ReadHeaders</a> () </dt>
<dd>: rename std::stringstream variables </dd>
</dl>
<p>
<a class="anchor" name="_todo000140"></a> <dl>
<dt>Member <a class="el" href="classTrianglesMeshReader.html#6e11ccad8feae3c21ccc4fc02f476aa4">TrianglesMeshReader::GetNextLineFromStream</a> (std::ifstream &amp;fileStream, std::string &amp;rRawLine) </dt>
<dd>: improve this error message </dd>
</dl>
<p>
<a class="anchor" name="_todo000142"></a> <dl>
<dt>Class <a class="el" href="classVertexAndAngle.html">VertexAndAngle&lt; DIM &gt;</a>  </dt>
<dd>does this really need to be templated? </dd>
</dl>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Aug 4 16:10:27 2009 for Chaste by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
